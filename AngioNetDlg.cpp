CAngioNetApp
//--------------------------------------
// AngioNetDlg.cpp : implementation file
//--------------------------------------

#include "stdafx.h"
#include "AngioNet.h"
#include "AngioNetDlg.h"


#include <iostream>
using namespace std;
#include <stdlib.h>
#include <math.h>

#include "PressureSolverSOR.h"
#include <fstream>
#include ".\angionetdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


const double	PI=3.141592654;

bool  b_venousIncluded;
//*****************************************************

//----------------output file for debugging------------

	ofstream outfileReplayout("ReplayOut.txt");	
	//NB OK if replayed immediately else need to copy this into another 
	//file (if prog is killed, then a new blank output file is created

	ifstream infileReplayin("Input1.txt");

	ofstream outfileConc("DebugOutputFiles/concentrations.txt");
	ofstream pressurefile("pressures.xls");

	ofstream outfileUV("DebugOutputFiles/debugUpdateVar.txt");
	ofstream outfileCellConserv("DebugOutputFiles/debugCellConserv.xls");
	ofstream outfileGrowth("DebugOutputFiles/debugGrowth.txt");
	ofstream outfileProb("DebugOutputFiles/debugProb.txt");
	ofstream outfileGrowVasc("DebugOutputFiles/debugGrowVasc.txt");
	ofstream outfileSprouts("DebugOutputFiles/debugSprouts.txt");
	

//----------------output Results files-------------------

	ofstream outfileTot("TotMassInVasc.xls");//used in WriteAwayMasses()
	ofstream outfileUptake("Uptake.xls");//used in TumourUptake()
	ofstream outfileConnect("Results/Connectivity.xls");//used in calculateConnectivity()
	ofstream outfileConnect2("Results/Connectivity2.xls");//used in calculateConnectivity2()
	ofstream outfileFlow("Results/Flow.xls");//used in CycleAndGraphics()
	ofstream outfileViscosity("Results/Viscosity.xls");//used in UpdateViscosity()
	ofstream outfileWallShearStress("Results/WallShearStress.xls");//used in CalculateWallShearStress()
	ofstream outfileRadius("Results/Radius.xls");//used in UpdateRadii2()	
	ofstream outfileMinMaxMean("Results/MinMaxMean.xls");//used in CalculateMinMaxMean()
	ofstream outfileVesselPressure("Results/vesselPressure.xls");//used in CalculatePressureInVessel()
	ofstream outfileNodalPressure("Results/nodalPressure.xls");//used in CalculatePressureInVessel()
	ofstream outfileTauE("Results/TauE.xls");//used in CalculateTauE()

	ofstream outfileIteration("Results/Iterations.txt");//used in AdaptVasculature()
	ofstream outfileFlowConvergence("Results/FlowConvergence.xls");
	ofstream outfiletest("Results/test.xls");
	ofstream outfiletest2("Results/test2.xls");
	ofstream outfiletestxt("Results/test.txt");

	ofstream outfileHem("Results/Hematocrit.xls");
	ofstream outfileDebugNodeFlows("NodeFlows2.txt");
	ofstream outfileDebugNodeRadii("NodeRadii2.txt");
	ofstream outfileDebugFQB("FQB2.txt");
	ofstream outfileDebugInOut("FlowsIn&Out2.txt");
	ofstream outfileDebugAdjust("Adjust2.txt");
	ofstream outfileDebugFQE("FQE2.txt");
	ofstream outfileDebugHem("Hem2.xls");
	ofstream outfileDebugOxyTracer("DebugVessOxyConc.txt");
	ofstream outfileDebugOxyGraphics("OxyGraphics.txt");

	ofstream outfileVesselCond("Results/VesselCond.xls");
	ofstream outfileDebugNetwork("NewNetwork.txt");
	ofstream outfileDebugNodes("NodePositions.txt");
	ofstream outfileDebugConStim("ConStim.txt");
	ofstream outfileDebugStimuli("Stimuli(TumourPV12NewFastDecay).txt");
	ofstream outfileDebugConvectedStim("Convected.txt");
	ofstream outfileDebugConvectedStim2("ConvectedBondStimsRetConStims1.txt");
	ofstream outfileDebugConductedStim("Conducted.txt");
	ofstream outfileDebugConductedStim2("ConductedBondStimsRetConStims1.txt");
	ofstream outfileConvected2("Convected2.txt");
	ofstream outfileConducted2("Conducted2.txt");
	ofstream outfileLocalNutrient("LocalNutrient.txt");
	ofstream outfileWSSMatrix("WSSMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfilePressMatrix("PressMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfileConvectMatrix("ConvectMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfileConductMatrix("ConductMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfileFlowMatrix("FlowMatrix(TumourPV12NewFastDecay).txt");
    ofstream outfileRadMatrix("RadMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfileTotalStimMatrix("TotalStimMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfileNutrientMatrix("NutrientMatrix(TumourPV12NewFastDecay).txt");
	ofstream outfileHemMatrix("HemMatrix(TumourPV12NewFastDecay).txt");
	ifstream infileRetinaXBonds("Retina X-bonds.txt");
	ifstream infileRetinaYBonds("Retina Y-bonds.txt");
	ofstream outfileDebugBone("DebugBone.txt");
			
	ofstream outfileWoundOxygen("TotalOxygenInWound(Seed 60 Post-Wound Thesis).txt");
	ofstream outfileWoundArea("WoundArea(TumourPV12NewFastDecay).txt");
	ofstream outfileWoundArea2("WoundArea2(TumourPV12NewFastDecay).txt");
	ofstream outfileWoundArea3("WoundArea3(TumourPV12NewFastDecay).txt");
	ofstream outfileFalseFlowTest("FalseFlowTest.txt");
	ofstream outfileFlows("Flows.txt");
	ofstream outfileOxygen("Debug Grow,Flow,Oxy.txt");
	
	ofstream outfile5("tracerDebug.xls");
	ofstream outfileVasc("Adaptvasc.xls");

	ofstream outfileSaveVasc("SaveVasc(InsertNameHere).txt");
	ifstream inputfileSaveVasc("ReadInVasc(Seed 617 Oxy Tracer).txt");

	ofstream outfileSaveVascRad("SaveRadii(InsertNameHere).txt");
	ifstream inputfileSaveVascRad("ReadInRadii(Seed 617 Oxy Tracer).txt");

	ofstream outfileSavePericyte("SavePericytesTestNoPS.txt");
	ifstream inputfileSavePericytes("ReadInPericytesTestNoPS.txt");

	ifstream PreFormedVasc("InputVasc(8PVs 0.32Bone).txt");			//Remember to enter
	ifstream PreFormedRad("InputRadii(8PVs 0.32Bone).txt");			//correct seed in
	ifstream PreFormedHem("InputHem(8PVs 0.32Bone).xls");			//dialogue box so
	ifstream PreFormedFlow("InputFlow(8PVs 0.32Bone).txt");			//setRadiiAndLengths
	ifstream PreFormedFalseFlow("InputFalseFlow(8PVs 0.32Bone).txt");//inputs consistent
	ifstream PreFormedFQE("InputFQE(8PVs 0.32Bone).txt");			//XBL,YBL,ZBL values
	ifstream PreFormedbFlowIn("InputbFlowIn(8PVs 0.32Bone).txt");
	ifstream PreFormedbFlowOut("InputbFlowOut(8PVs 0.32Bone).txt");

	ofstream outfileTime("deltaT.txt");//used in WriteAwayMasses()
	ifstream infileTime("InDeltaT.txt");//used in WriteAwayMasses()

	ofstream outfileSaveMDE("SaveMDETestNoPS.txt");
	ifstream infileMDE("ReadInMDETestNoPS.txt");

	ofstream outfileSaveVascLast("FinalVasc.txt");
	ofstream outfileSaveRadLast("FinalRad.txt");
	ofstream outfileSaveHemLast("FinalHem.xls");

	ofstream outfileDebugTime("DebugTimes(Seed 60 Post-Wound Thesis).txt");

	ofstream outfileFlowTimes("Mike's Results/TumNewPriesSkimPV12FastDecay/SaveTimeSteps(TumourPV12NewFastDecay).txt");
	ifstream infileReadInFlowTimes("ReadInTimeSteps(TumourPV12Old).txt");

	ofstream outfile4x("DebugOutputFiles/xflows.xls");
	ofstream outfile4y("DebugOutputFiles/yflows.xls");

	ofstream probsOut("probsPC.xls");
	ofstream PCsAttached("Pericyte_Attachment.xls");

	ofstream outfileSaveDiscretePCs("SaveDiscretePCsSeed1639.txt");
	ifstream infileDiscretePCs("ReadInDiscretePCsSeed1639.txt");

	ofstream outfileSaveNutrient("SaveNutrient(Seed 60 Post-Wound Thesis).txt");
	ifstream infileNut("ReadInNutrient(2.0e-3,2.0e-9,5.0e-6 8PVs 2400 0.32BoneRemoved).txt");
	ofstream NutrientOutFile("CheckNutrient2008.txt");
	ofstream outfileNutConverge("NutrientConvergence(InsertNameHere).txt");
	ofstream outfileSaveVascNut("SaveVesselNutrient(Seed 60 Post-Wound Thesis).txt");

	ofstream outfileSaveFlow("SaveFlow(InsertNameHere).txt");	//Mike 12/08
	ifstream infileSaveFlow("ReadInFlowSeed1639.txt");			//Mike 12/08

	ofstream outfileSaveFalseFlow("SaveFalseFlow(InsertNameHere).txt");				
	ifstream infileSaveFalseFlow("ReadInFalseFlowSeed1639.txt");			

	ofstream outfileSaveFQE("SaveFQE(InsertNameHere).txt");				
	ifstream infileSaveFQE("ReadInFQESeed1639.txt");

	ofstream outfileSavebFlowIn("SavebFlowIn(InsertNameHere).txt");				
	ifstream infileSavebFlowIn("ReadInbFlowInSeed1639.txt");	

	ofstream outfileSavebFlowOut("SavebFlowOut(InsertNameHere).txt");				
	ifstream infileSavebFlowOut("ReadInbFlowOutSeed1639.txt");	

	ofstream outfileSaveAge("SaveAgeVesselsSeed1639.xls");			//Mike 12/08
	ifstream infileSaveAge("ReadInAgeVesselsSeed2863.xls");		//Mike 12/08

	ofstream outfileSaveHem("SaveHem(InsertNameHere).xls");		//Mike 06/09
	ifstream infileSaveHem("ReadInHem(Seed 617 Oxy Tracer).xls");		//Mike 06/09

	ofstream outfileSaveWoundArea("SaveWoundArea(TumourPV12NewFastDecay).txt");		//Mike 06/09
	ifstream infileSaveWoundArea("ReadInWoundArea(Seed 2544  2.6 0.45).txt");		//Mike 06/09

	ofstream outfileVesselDensity("WoundVesselDensity(TumourPV12NewFastDecay).txt");	//Mike 09/08, used in WoundVesselCount

	ofstream outfileWoundConnect0("WoundConnectivity0TestNoPS.txt");	//Mike 10/08, used in WoundConnectivity 
	ofstream outfileWoundConnect1("WoundConnectivity1TestNoPS.txt");	//Mike 10/08,	"	"	"	"	"
	ofstream outfileWoundConnect2("WoundConnectivity2TestNoPS.txt");	//Mike 10/08,	"	"	"	"	"
	ofstream outfileWoundConnect3("WoundConnectivity3TestNoPS.txt");	//Mike 10/08,	"	"	"	"	"
	ofstream outfileWoundConnect4("WoundConnectivity4TestNoPS.txt");	//Mike 10/08,	"	"	"	"	"

	ofstream outfileVesselDiameter("WoundVesselDiameter(TumourPV12NewFastDecay).txt");	//Mike 10/08, used in WoundVesselRadius

	ofstream outfileBranchPoints("WoundBranchPoints(TumourPV12NewFastDecay).txt");		//Mike 10/08, used in WoundBranchPoints

	ofstream outfileRemodelling("Remodelling.txt");				//Mike 10/08, used in WoundRemodelling

	ofstream outfileVesselArea("TotalVesselAreas(TumourPV12NewFastDecay).txt");			//Mike 11/08, used in WoundVesselCount
	ofstream outfileVesselAreaDensity("VesselAreaDensity(TumourPV12NewFastDecay).txt");	//Mike 11/08,	"	"	"	"	"
	ofstream outfileWoundResults("WholeWoundResults(TumourPV12NewFastDecay).txt");		//Mike 11/08,	"	"	"	"	"
	ofstream outfileVesselVolume("TotalVesselVolume(TumourPV12NewFastDecay).txt");		//Mike 11/08,	"	"	"	"	"
	ofstream outfileFlow2("FlowTimestep.txt");

	ofstream outfileRegionOxygen("RegionOxygen(Seed 60 Post-Wound Thesis).txt");

	ofstream outfileBoneTissue("SaveScaffold().txt");
	ifstream infileBoneTissue("ReadInScaffold(60x60x60 37%).txt");
		
//*****************************************************

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//*****************************************************

/////////////////////////////////////////////////////////////////////////////
// CAngioNetDlg dialog

CAngioNetDlg::CAngioNetDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAngioNetDlg::IDD, pParent)
	, pArterialVenousID(NULL)
	, bDiscretePericyte(NULL)
	, pPCXCoord(NULL)
	, pPCYCoord(NULL)
	, pPCZCoord(NULL)
	, nPericytes(0)
	, pPCOrientationID(NULL)
	, PC_StillActive(NULL)
	, nPericytesAttached(0)
	, b_UU_wound_Model(false)
	, iWoundRadius(0)
	, jCentre(0)
	, iCentre(0)
	, nAdditionalCentralPVs(0)
	, b_IncludeDiscretePericytes(false)
	, UU_PV_AdditionalRadius(0)
	, TAF_Trigger(0)
	, D_TAF_Scaling(0)
{
	//{{AFX_DATA_INIT(CAngioNetDlg)
	m_diffCoeff = 0.00035;//0.0003;//0.00003; //0.000028; Mike 05/09
	m_alpha = 0.6;//0.21; //0.5; Mike 05/09		0.76
	m_chi = 0.38;//0.091; //0.0915; Mike 05/09
	m_z = 6.0;
	m_rho = 0.28;//0.16;//0.3; //0.25; Mike 05/09
	m_nz = 60;//1;//50;//
	m_ny = 60;//180;//50;//100;//
	m_nx = 60;//180;//50;//100;//
	m_distort = 0.0;//0.3;//
	m_graphicsView = 0;
	m_presetNetwork = FALSE;
	m_slug = FALSE;
	m_tracerOn = FALSE;
	m_circTumour = FALSE;
	m_angiotimeMax = 4.05;//3.0;//12.5;//6.25;//4.32;//4.13;//1000.0;
	m_replayTick = FALSE;
	m_nReplayLoops = 10;
	m_CentralTumour = FALSE;
	m_FractOut = 0.0;
	m_TumRadius = 22;
	m_WoundOption = FALSE;
	m_Nutrients = FALSE;//TRUE;//
	m_adaptVasculature = FALSE;//TRUE;//
	m_GrowthInterval = 0.48;//0.375;//3.8;
	m_seedFromDialog = 60;
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
//------------------------------------
//----Flag used to see if RUN button pressed
	running=FALSE;
//Initialise variables here--
//	InitialiseVariables();
//-------------------------------
}


//*****************************************************

void CAngioNetDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAngioNetDlg)
	DDX_Text(pDX, IDC_DIFFCOEFF, m_diffCoeff);
	DDX_Text(pDX, IDC_ALPHA, m_alpha);
	DDX_Text(pDX, IDC_CHI, m_chi);
	DDX_Text(pDX, IDC_Z, m_z);
	DDX_Text(pDX, IDC_RHO, m_rho);
	DDX_Text(pDX, IDC_NZ, m_nz);
	DDX_Text(pDX, IDC_NY, m_ny);
	DDX_Text(pDX, IDC_NX, m_nx);
	DDX_Text(pDX, IDC_DISTORT, m_distort);
	DDX_Radio(pDX, IDC_RADIO1, m_graphicsView);
	DDX_Check(pDX, IDC_CHECK1, m_presetNetwork);
	DDX_Check(pDX, IDC_TRACER2, m_slug);
	DDX_Check(pDX, IDC_TRACER1, m_tracerOn);
	DDX_Check(pDX, IDC_CIRCTUM, m_circTumour);
	DDX_Text(pDX, IDC_TMAX, m_angiotimeMax);
	DDV_MinMaxDouble(pDX, m_angiotimeMax, 0., 100000.);
	DDX_Check(pDX, IDC_REPLAYTICK, m_replayTick);
	DDX_Text(pDX, IDC_REPLAYLOOPS, m_nReplayLoops);
	DDX_Check(pDX, IDC_CENTRAL_TUM, m_CentralTumour);
	DDX_Text(pDX, IDC_FractRemoved, m_FractOut);
	DDV_MinMaxDouble(pDX, m_FractOut, 0., 0.5);
	DDX_Text(pDX, IDC_TUMRADIUS, m_TumRadius);
	DDV_MinMaxInt(pDX, m_TumRadius, 0, 50);
	DDX_Check(pDX, IDC_WOUNDCHECK, m_WoundOption);
	DDX_Check(pDX, IDC_NUTRIENTCHECK, m_Nutrients);
	DDX_Check(pDX, IDC_ADAPT_VASC, m_adaptVasculature);
	DDX_Text(pDX, IDC_GROWINTRVAL, m_GrowthInterval);
	DDV_MinMaxDouble(pDX, m_GrowthInterval, 0., 100.);
	DDX_Text(pDX, IDC_SEED, m_seedFromDialog);
	DDV_MinMaxInt(pDX, m_seedFromDialog, 1, 3000);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAngioNetDlg, CDialog)
	//{{AFX_MSG_MAP(CAngioNetDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_TRACER1, OnTracer1)
	ON_BN_CLICKED(IDC_TRACER2, OnTracer2)
	ON_BN_CLICKED(IDC_RUN, OnRun)
	ON_BN_CLICKED(IDEXIT, OnExit)
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_CHECK1, OnLinTum)
	ON_BN_CLICKED(IDC_CIRCTUM, OnCirctum)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_REPLAYTICK, OnReplaytick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//*****************************************************

/////////////////////////////////////////////////////////////////////////////
// CAngioNetDlg message handlers

BOOL CAngioNetDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	// TODO: Add extra initialization here
	//----------------------------------------------
	//Get Pointer to canvas
	CWnd* pCanvas=GetDlgItem(IDC_PICFRAME);
	//find its location
	pCanvas->GetWindowRect(&m_Canvas);
	//Store client coords - we can draw using these now
	ScreenToClient(&m_Canvas);
//	m_Canvas.DeflateRect(2,2,1,1);

//	SetTimer(1,55,NULL);
	return TRUE;  // return TRUE  unless you set the focus to a control
}


//*****************************************************

//======================================================
void CAngioNetDlg::OnSysCommand(UINT nID, LPARAM lParam)
//======================================================
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);

	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.


//*****************************************************

//==========================
void CAngioNetDlg::OnPaint()
//========================== 
{

		CDialog::OnPaint();

//Redraw the network if window is covered (doesn't seem necessary now but keep)
		DrawBackground();
		if(running)
		{OnDrawIt2();}
}


//*****************************************************

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CAngioNetDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


//*****************************************************

//============================
void CAngioNetDlg::OnTracer1()
//============================ 
{
	// TODO: Add your control notification handler code here

	//get pointers to the 2 check boxes 
	CButton* pTracer=(CButton*)GetDlgItem(IDC_TRACER1);
	CButton* pSlug=(CButton*)GetDlgItem(IDC_TRACER2);

	//if slug is selected, tracer must also be checked
	if (pSlug->GetCheck())
	{
		pTracer->SetCheck(1);
	}
}


//*****************************************************

//============================
void CAngioNetDlg::OnTracer2()
//============================ 
{
	// TODO: Add your control notification handler code here

	//get pointers to the 2 check boxes 
	CButton* pTracer=(CButton*)GetDlgItem(IDC_TRACER1);
	CButton* pSlug=(CButton*)GetDlgItem(IDC_TRACER2);

	//if slug is selected, tracer must also be checked

	if (pSlug->GetCheck())
	{
		pTracer->SetCheck(1);
	}
}


//*****************************************************

//========================
void CAngioNetDlg::OnRun()
//======================== 
{
	//ofstream outfileOnRun("DebugOutputFiles/DebugOnRun.txt");
	//Only open this if not replaying - otherwise it will overwrite blank




	running=TRUE; 
	//the program is running and OnDrawIt will do something now

	//Draw the background for window
	DrawBackground();

	//------------------------------------------------------
	//(1)Read in data from dialog box
    UpdateData();

	//------------------------------------------------------
	//(2)data initialisations here (declared in header file)
	InitialiseVariables();	//includes sealed boundary

	NodalPositions();
	setRadiiAndLengths();

//	assignConductivities(); //all else filled with fluid 0//NB need to 
							//set pFluid!=10 bonds to 0.0
    //calculatePressuresAndFlows(0);

	//------------------------------------------------------
	//(2a)Construct the underlying network
	//SetUp();  //Put in arteriole,initialise TAF,FN,ECD,sprouts
 	//SetUp2(); // MODIF A.S.
	
	  SetUp3(); // MODIF A.S.
	


//SMcD2004-------------------
//	Shunt();		  //put in shunt to check tracer
//---------------------------


	if (m_presetNetwork || m_circTumour) 
	{   
		//ReadInVasculatureWound();	//SMcD 10/2004 Wound
		//ReadInVasculature();
		//ReadInVasculature2();
		ReadInPreFormedVasc();
//		SetInitialTissueNutrientConc();
//		exit(1);
		////ReadInPreFormedVascAllRad6();
////June2005			angiotime=0.0;	//reset after vasc read in (as angiotime is read in here)
		//ReadInPreFormedVascAllRad6();
	    //ConnectToTumour();
		//RemoveBonds();
		CalculateVasculatureVolume();
		calculateConnectivity();
		calculateConnectivity2();
		//if (m_Nutrients)	{LocaliseVesselNutrients();}
	}  //read in net if preset tick
	
	if (m_WoundOption) 
	{   
		ReadInVasculatureWound();
		CalculateVasculatureVolume();
		calculateConnectivity();
		calculateConnectivity2();
		if (m_Nutrients)	{LocaliseVesselNutrients();}
	}
	//-------------------------------------------------------
//	if (m_Nutrients)	{LocaliseVesselNutrients();}	//This ALWAYS puts nutrients into vessels (DYN sim)
    //------------------------------------------------------
	
	
	
	//If we only want to replay, then just read in data file and return at end
	if (m_replayTick)		//just read in the concentrations for replay
	{
		while (replayloop<=m_nReplayLoops)//replayloopMax)
		{
			ReadInNutrient();
//			ReadInVasculature2();
//			ReadVasculatureRadii();
//			ReadInMDE();
//			ReadInPericytes();
//			ReadInDiscretePCs();
//			ReadInFlow();			//Mike 12/08
//			ReadInAge();			//Mike 12/08
//			ReadInHematocrit();		//Mike 06/09
//			ReadInWoundArea();		//Mike 07/10
						
///			ReadInSavedConcs();
			//OnDrawIt2();
//			OnDrawIt3();
			ProcessMessageLoop();
			UpdateData();
			OnDrawIt3();

			replayloop+=1;
		}

		
//SMcD2005
///			SaveVasculature();//save last picture data
///			SaveVasculatureRadii();


//		return;
	}

	//---More initialisation and initial pressure solve-------
	if ((m_tracerOn || m_adaptVasculature) && !m_replayTick) //Initialise tracer and Hd etc if flowing
	{
		SetInitialTracer();	//initialise tracer concentrations
		SetInitialAngioDrugTracer(); //for antiangiogenic therapy
		
		SetInitialViscosity();	//SMcD 10/2004 uncommented this
		SetInitialHematocrit();
		if	(m_Nutrients)	
		{
			SetInitialVesselNutConc();
			SetInitialTissueNutrientConc();
		}
//		assignConductivities();	//SMcD 10/2004 commented this
		assignConductivities2();
		VesselConductivities();	//assigns conductances to vessels only
		calculatePressuresAndFlows(10);
		CalculatePressureInVessel();

		CalculateMinMaxMean(Xmu,Ymu,Zmu);
		outfileViscosity << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

		CalculateMinMaxMean(pXHem,pYHem,pZHem);
		outfileHem << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

		//CalculateMinMaxMean(XCond,YCond,ZCond);
		//outfiletest << "Conductivity0" << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

		//CalculateMinMaxMean(vesselXCond,vesselYCond,vesselZCond);
		//outfileVesselCond << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

		CalculateMinMaxMean(XFlow,YFlow,ZFlow);
		outfileFlow << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

/*		//---- START MODIF A.S. -------------------
		PerturbationOnRadii(); //slight random modification of the radii to initiate the simulation
		assignConductivities(); //calculation of the conductivities with the new radii
		VesselConductivities(); //assigns conductances to vessels only
*/		//---- END MODIF A.S. ---------------------
	}

	//=====================
	  //AdaptVasculature();
	//=====================

	//-----------------------------------------------------------
	//(3)Cycle through simulation and update graphics

	
	while	((angiotime < m_angiotimeMax) && !m_replayTick) //1000) //16800.0)
	{
	//	VesselConductivities();	//assigns conductances to vessels only
	//	calculatePressuresAndFlows(10);//need to do this for DYNAMIC growth
//outfileDebugNetwork << "got here" << endl;
		CycleAndGraphics();	//concs etc written away here


		OnDrawIt3();
//outfileDebugNetwork << "got here" << endl;

		ProcessMessageLoop();
		UpdateData();
	}

//=============================================================

	while(1)
	{
			OnDrawIt3();	//KEEP GRAPHICS ALIVE AFTER LAST LOOP IN REPLAY
			ProcessMessageLoop();
			UpdateData();

	}

}

//==============================================================
//*****************************************************

//============================
void CAngioNetDlg::OnDrawIt2()
//============================
{
//Set window parameters
//	int xMin=209,xMax=662,yMin=13,yMax=379;
//	int networkWidth=300;
//	double deltaX= (xMax-xMin-networkWidth)/2.0;
//	double deltaY= (yMax-yMin-networkWidth)/2.0;

	int xMin=m_Canvas.left,xMax=m_Canvas.right,
		yMin=m_Canvas.top,yMax=m_Canvas.bottom;
	int borderx=(xMax-xMin)/6;
	int bordery=(yMax-yMin)/12;
	int networkWidth=(xMax-xMin)-2*borderx;
	double deltaX= (double)borderx;//(xMax-xMin-networkWidth)/2.0;
	double deltaY= (double)bordery;//(yMax-yMin-networkWidth)/2.0;


//Select graphics routine depending upon the radio button pressed
//the radio buttons are numbered 0 1 2 3 
	if(running)
	{

	switch (m_graphicsView)
	{

	case 0: ECDensityGraphics2(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY); 
			break;

	case 1: TracerGraphics2(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY);
			break;

	case 2:	VesselGraphics2(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY);
			break;

	case 3:	RadiiGraphics(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY);
			//RadiiGraphicsBW(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			break;
	}}
}


//*****************************************************

//============================
void CAngioNetDlg::OnDrawIt3()
//============================
{
	int xMin=m_Canvas.left,xMax=m_Canvas.right,
		yMin=m_Canvas.top,yMax=m_Canvas.bottom;
	int borderx=(xMax-xMin)/6;
	int bordery=(yMax-yMin)/12;
	int networkWidth=(xMax-xMin)-2*borderx;
	double deltaX= (double)borderx;
	double deltaY= (double)bordery;

	if(running)
	{
	switch (m_graphicsView)
	{

	case 0: //TracerAngioDrugGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY); 
//			MDFConcGraphics2(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
//			WoundAreaGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY); 
//			MDFConcGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY); 
			//HematocritGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//FlowStatGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
//			TransMuralGraphics(xMin,xMax,yMin,yMax,networkWidth,
//								deltaX,deltaY);
//			PericytesGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
//			FlowingGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
			TAFConcGraphics(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY);
//			TransmuralVesselGraphics(xMin,xMax,yMin,yMax,networkWidth,
//								deltaX,deltaY);

			break;

	case 1: //TracerGraphics2(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//WSSGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
//			FNConcGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
//			HematocritGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
//			ArtVenGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
//			TAFConcGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
			FlowStatGraphics(xMin,xMax,yMin,yMax,networkWidth,	//TAF
						  deltaX,deltaY);
//			TransMuralGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							deltaX,deltaY);
			break;

	case 2:	//WSSGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//VesselGraphics2(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//VesselGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//AgeVesselGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			RadiiGraphics(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY);
//			TAFConcGraphics2(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
//			FNConcGraphics(xMin,xMax,yMin,yMax,networkWidth,
//							  deltaX,deltaY);
			//HematocritGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//TracerGraphics2(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			break;

	case 3:	//PericytesGraphics(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//PericyteGraphicsDiscrete(xMin,xMax,yMin,yMax,networkWidth,
			//				  deltaX,deltaY);
			//AgeVesselGraphics(xMin,xMax,yMin,yMax,networkWidth,		//PCs
			//				  deltaX,deltaY);
			HematocritGraphics(xMin,xMax,yMin,yMax,networkWidth,
							  deltaX,deltaY);
			break;
	}}
}


//*****************************************************

//=========================
void CAngioNetDlg::SetUp2()
//=========================
{
	PutInArteriole();
	SetInitialFNConcs2();
	SetInitialTAFConcs2();
	SetInitialECDensity2();
	AssignInitialSprouts2();  //(removed for the reading of the 3D network)
}


//*****************************************************

//=========================
void CAngioNetDlg::SetUp3()
//=========================
{
	if	(!b_TestNetwork && !b_Bone_model)	{PutInArteriole();}
outfileDebugBone<<"got past art"<<endl;
	if (b_UU_wound_Model && !b_TestNetwork) {PutInAdditionalArterioles();}	//UU wound model only

	if	(b_TestNetwork)	{PutInTestNetwork();}

	if	(b_Bone_model)	{
							InitialiseBoneTissue();	
							PutInArterioles_Bone();	
							AssignInitialSprouts_Bone();
						}

outfileDebugBone<<"got past bone"<<endl;
	SetInitialFNConcs2();
//	SetInitialTAFConcs2();

//outfileDebugBone<<"got to solve TAF"<<endl;
	if (!m_presetNetwork && !m_replayTick) {SolveInitialTAFConc();}
outfileDebugBone<<"got past solve TAF"<<endl;

//	AssignInitialSprouts2();	//10 tips

	if	(!b_TestNetwork && !b_Bone_model)
	{
		if	(b_UU_wound_Model) //UU wound model only
		{
			//AssignInitialSprouts_UU_Wound();
		}
		else
		{
			//AssignInitialSprouts();	//5 tips
			AssignInitialSprouts2();	//10 tips
		}
	}

	
	//--SMcD 10/2004  Tumour Cells-----
	SetInitialMDFConcs_TumModel();
	AssignInitialTumCells();	//Does nothing at present but example given in routine
	//-------------------


	//Initialise Discrete Pericytes
	if (b_IncludeDiscretePericytes)
	{
	InitialisePericytes();
	}
	//-------------------------

	//AssignInitialSprouts2();  //(removed for the reading of the 3D network)
	// ECDensity and MDFConc are set to 0 in InitialiseVariables()
//outfileDebugNetwork << "got here" << endl;

}

//***********************************************
//=====================================
void CAngioNetDlg::PutInArteriole()
//=====================================
{
	int i,j,k,nbx;
	j=1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/10); }//5; }//int(m_nz/2)+1; }

	for (i=1;i<=m_nx+1;i++)
//	for (i=1;i<=m_nx-1;i++)
	{
		nbx=LabX(i,j,k);
		pFluid[nbx-1]=10;
		pPericyteDensity[nbx-1]=1.0;
		pArterialVenousID[nbx-1]=1;
		XBR[i-1][j-1][k-1]=3.0e-6;
	}

//-----------------------------------------------
	if (b_venousIncluded)
	{//Venous PV included if requested
		j=m_ny-1;

		if (m_nz==1) { k=1; } else { k=int(9*m_nz/10); }//45; }//int(m_nz/2)+1; }

		for (i=1;i<=m_nx+1;i++)
//		for (i=2;i<=m_nx+1;i++)
		{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=-1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}

	}//////////////

//-----------------------------------------------
	int nby;
	i=1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/10); }//5; }//int(m_nz/2)+1; }

	for (j=1;j<=m_ny;j++)
	{
		nby=LabY(i,j,k);
		pFluid[nby-1]=10;
		pPericyteDensity[nby-1]=1.0;
		pArterialVenousID[nby-1]=1;
		YBR[i-1][j-1][k-1]=3.0e-6;
	}

//-----------------------------------------------
	i=m_nx-1;//m_nx;//

	if (m_nz==1) { k=1; } else { k=int(9*m_nz/10); }//45; }//int(m_nz/2)+1; }

	for (j=1;j<=m_ny;j++)
	{
		nby=LabY(i,j,k);
		pFluid[nby-1]=10;
		pPericyteDensity[nby-1]=1.0;
		pArterialVenousID[nby-1]=-1;
		YBR[i-1][j-1][k-1]=3.0e-6;
	}

//-----------------------------------------------
/*	for (int PVLoop=1;PVLoop<=8;PVLoop++)
	{
		if (PVLoop==1){k=4;}
		else if (PVLoop==2){k=10;}
		else if (PVLoop==3){k=16;}
		else if (PVLoop==4){k=22;}
		else if (PVLoop==5){k=29;}
		else if (PVLoop==6){k=35;}
		else if (PVLoop==7){k=41;}
		else {k=47;}

		j=1;

		for (i=1;i<=m_nx-1;i++)
		{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
		}

		j=m_ny-1;

		for (i=2;i<=m_nx+1;i++)
		{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=-1;
		}

	}*/
//-------------------------------------------------

//------ MODIF A.S. ----------------------
// connection of the parent vessel to the 
// 3d-linear-30-2.txt network
/*	
	int i,j,k,nbx,nbz;
	j=1;

	for (i=1;i<=7;i=i++)
	{	
		k=15;
		nbx=LabX(i,j,k);
		pFluid[nbx-1]=10;
	}
	for (k=16;k<=21;k++)
	{	
		i=7;
		nbz=LabZ(i,j,k);
		pFluid[nbz-1]=10;
	}
	for (i=8;i<=m_nx+1;i++)
	{
		k=21;
		nbx=LabX(i,j,k);
		pFluid[nbx-1]=10;
	}
*/

	//**************CURLY 3D VESSEL  BROKEN!!!**********************
/*	int i,j,k,nbxL,nbxR,nbzI,nbzO;
	j=1;

//	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }


//1st quadrant
	for (i=1;i<=m_nx+2;i++)
	{

		k=int(m_nz/2.0+pow(    (m_nz/2.0)*(m_nz/2.0) -  (i*i) ,0.5 )   ) ;

			nbxL=LabX(i,j,k);
			pFluid[nbxL-1]=10;
			pPericyteDensity[nbxL-1]=1.0;

	}
	
	for (i=1;i<=m_nx+2;i++)
	{

		k=int(m_nz/2.0+pow(    (m_nz/2.0)*(m_nz/2.0) -  (i*i) ,0.5 )   ) ;

			nbxR=LabX(i+1,j,k);
			pFluid[nbxR-1]=10;
			pPericyteDensity[nbxR-1]=1.0;

	}

	for (i=1;i<=m_nx+2;i++)
	{

		k=int(m_nz/2.0+pow(    (m_nz/2.0)*(m_nz/2.0) -  (i*i) ,0.5 )   ) ;

			nbzI=LabZ(i,j,k);
			pFluid[nbzI-1]=10;
			pPericyteDensity[nbzI-1]=1.0;

	}
	
	for (i=1;i<=m_nx+2;i++)
	{

		k=int(m_nz/2.0+pow(    (m_nz/2.0)*(m_nz/2.0) -  (i*i) ,0.5 )   ) ;

			nbzO=LabZ(i,j,k+1);
			pFluid[nbzO-1]=10;
			pPericyteDensity[nbzO-1]=1.0;

	}

	//2nd quadrant

	for (i=1;i<=m_nx+2 ;i++)
	{

		k=int(m_nz/2.0-pow(    (m_nz/2.0)*(m_nz/2.0) -  (i-m_nx)*(i-m_nx) ,0.5 )    );

			nbxL=LabX(i,j,k);
			pFluid[nbxL-1]=10;
			pPericyteDensity[nbxL-1]=1.0;
	}


	for (i=1;i<=m_nx+2 ;i++)
	{

		k=int(m_nz/2.0-pow(    (m_nz/2.0)*(m_nz/2.0) -  (i-m_nx)*(i-m_nx) ,0.5 )    );

			nbxR=LabX(i+1,j,k);
			pFluid[nbxR-1]=10;
			pPericyteDensity[nbxR-1]=1.0;
	}


	//******************END CURLY*****************
*/	
//-----------------------------------------
}

//***********************************************
//===========================
void CAngioNetDlg::OnExit()
//=========================== 
{
	// TODO: Add your control notification handler code here

	OnDestroy();
	CDialog::OnOK();
	
}


//*****************************************************

//-----------------------------------------
int CAngioNetDlg::LabX(int i, int j, int k)
//-----------------------------------------
{
	int n1=(m_nx+1)*(j-1);
	if (j==m_ny+1) {n1=0;}

	int n2=m_ny*(m_nx+1)*(k-1);
	if (k==m_nz+1) {n2=0;}

	return i + n1 + n2;
}


//*****************************************************

//-----------------------------------------
int CAngioNetDlg::LabY(int i, int j, int k)
//-----------------------------------------
{
	int n1=(m_nx)*(j-1);
	if (j==m_ny+1) {n1=0;}

	int n2=m_ny*(m_nx)*(k-1);
	if (k==m_nz+1) {n2=0;}

	return i + n1 + n2 + (m_nx+1)*m_ny*m_nz;
}


//*****************************************************

//-----------------------------------------
int CAngioNetDlg::LabZ(int i, int j, int k)
//-----------------------------------------
{
	int n1=m_nx*(j-1);
	if (j==m_ny+1) {n1=0;}

	int n2=m_ny*m_nx*(k-1);
	if (k==m_nz+1) {n2=0;}

	return i + n1 + n2 + (m_nx+1)*m_ny*m_nz + m_nx*m_ny*m_nz;
}


//*****************************************************

//======================================
void CAngioNetDlg::InitialiseVariables()
//======================================
{

	//--------------- Results ----------------------------
	  outfileTot << "Time" << "\t" << "TotalMass" << endl;
	  outfileUptake << "Time" << "\t" << "Uptake" << endl;
	  outfileViscosity << "Time" << "\t" << "mu_min" << "\t" << "mu_max" << "\t" << "mu_mean" << endl;
	  outfileWallShearStress << "Time" << "\t" << "TauW_min" << "\t" << "TauW_max" << "\t" << "TauW_mean" << endl;
	  outfileRadius << "Time" << "\t" << "Rad_min" << "\t" << "Rad_max" << "\t" << "Rad_mean" << endl;
	  outfileMinMaxMean << "Time" << "\t" << "MinValue" << "\t" << "MaxValue" << "\t" << "MeanValue" << endl;
	  outfileHem << "Time" << "\t" << "MinValue" << "\t" << "MaxValue" << "\t" << "MeanValue" << endl;
	  outfileVesselCond << "Time" << "\t" << "MinValue" << "\t" << "MaxValue" << "\t" << "MeanValue" << endl;
	  outfileFlow << "Time" << "\t" << "MinValue" << "\t" << "MaxValue" << "\t" << "MeanValue" << endl;
	  outfileVesselPressure << "Time" << "\t" << "Pmin" << "\t" << "Pmax" << "\t" << "Pmean" << endl;
	  outfileNodalPressure << "Time" << "\t" << "Pmin" << "\t" << "Pmax" << "\t" << "Pmean" << endl;
	  outfileTauE << "Time " << "\t" << "TauE_min" << "\t" << "TauE_max" << "\t" << "TauE_mean" << endl;
	  outfileWoundResults << "time" << "\t" << "vessels" << "\t" << "\t" << "area" << "\t" << 
							"length" << "\t" << "density" << "\t" << "ves area" << 
							"  area dens" << "\t" << "ves volume" << "  bp" << "  diam" << endl;
	  outfileWoundArea << "time" << "\t" << "rad 1" << "\t" << "rad 2" << "\t" << "rad 3" << "\t" << "rad 4" << "\t" <<
							"average" << "\t" << "area" << endl;
	//----------------------------------------------------

	dStore=1.0;	//used for writing data away
	nGrowthInterval=1;	//initialise the growth period for full ATIA
	growthDuration=4.0;//7.5;//4.0;//3.1;//m_GrowthInterval;//1.75;//1.0;// 4.0 used in JTB paper;     //0.0;// for a posteriori remodelling //30.1;//4.0;//4.0;       //3.3;//dimensionless time
	flowDuration=0.25;//25.0;//50.0;//100.0;//40.0;//20.0;//15.0;//215.0;//15.0;//20.0;//5.0 (changed by Mike 10/08 for wound model)	
	//prior to July 2008//35.0*2;//10.0;//for venous system use 5.0;//for a posteriori remodelling //35.0;//*5.0;//80.0;//35.0;  //  *2.0; //140.0;  ///35.0;///   //25.0;//25.0;//dimensionless time
	bGrowing=true; //bool to say if we are in a growing phase or a flowing phase??
	flowDeltaT=0.0;
	flowTime=0.0;
	oxyDeltaT=0.0;
	oxyTime=0.0;
	bSkimming=true;//false;//

	b_justFinishedFlowPeriod=false;	//used for updating oxygen during grow+flow
	b_NewPries=true;//false;//

	//Variables are declared in header file of dialog
	//initialisations occur here - after Updatedata has
	//been called from OnRun()

	Nbond=3*m_nx * m_ny * m_nz + m_ny * m_nz; //Total bonds

	loop=0;

//-----------------------------------------

	//--- MODIF A.S. -----------------
	pVesselPressure=NULL;
	pVesselPressure=new double[Nbond];
	//--------------------------------

	pFluid=NULL;
	pFluid=new int[Nbond];	//dynamic array of fluid labels

	int i,j,k,nbx,nby,nbz;

	for (k=1;k<=m_nz;k++)
	{
	   for (j=1;j<=m_ny;j++)
	   {
	      for (i=1;i<=m_nx;i++)
		  {
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);	

			  pFluid[nbx-1]=0;
			  pFluid[nby-1]=0;

			  if (m_nz==1) { pFluid[nbz-1]=66;}
			     else      { pFluid[nbz-1]=0; }
//******************************************************
//******************************************************
		  }
			  i=m_nx+1;
			  nbx=LabX(i,j,k);
			  pFluid[nbx-1]=0;
	  }}
	  
	
//-----------------------------------------
	//Seal the upper boundary
	j=1;
	for (k=1;k<=m_nz;k++)
	{
		for (i=1;i<=m_nx;i++)
		{
			nby=LabY(i,j,k);
            pFluid[nby-1]=66;
		}
	}
//-------------------------------------------



//------ START MODIF A.S. (version 2.0)------------------------------
	double Original_TAF_Diffcoeff=2.9e-7;
	double New_TAF_Diffcoeff=2.9e-7;//1e-6; //in Sherratt range now
	D_TAF_Scaling=Original_TAF_Diffcoeff/New_TAF_Diffcoeff; //used to rescale 
															//all equations
//-------------------------------------------------------------------
    vFibronectinConc=vTAFConc=vEndoCellDensity=vMDFConc=NULL;
	vOldFibronectinConc=vOldTAFConc=vOldEndoCellDensity=vOldMDFConc=NULL;
	vSproutsTips=NULL;
	bBoneTissue=NULL;

	vFibronectinConc=new double** [m_nx+1]; // indice from 0 to m_nx
	vTAFConc=new double** [m_nx+1];
	vEndoCellDensity=new double** [m_nx+1];
	vSproutsTips=new int** [m_nx+1];
	vMDFConc= new double** [m_nx+1];
	vOldFibronectinConc=new double** [m_nx+1];
	vOldTAFConc=new double** [m_nx+1];
	vOldEndoCellDensity=new double** [m_nx+1];
	vOldMDFConc=new double** [m_nx+1];
	bBoneTissue=new bool** [m_nx+1];

	for (i=0;i<=m_nx;i++) 
	{    vFibronectinConc[i]=new double* [m_ny]; 
         vTAFConc[i]=new double* [m_ny];
	     vEndoCellDensity[i]=new double* [m_ny];
		 vSproutsTips[i]=new int* [m_ny];
		 vMDFConc[i]=new double* [m_ny];
         vOldFibronectinConc[i]=new double* [m_ny];
	     vOldTAFConc[i]=new double* [m_ny];
	     vOldEndoCellDensity[i]=new double* [m_ny];
		 vOldMDFConc[i]=new double* [m_ny];
		 bBoneTissue[i]=new bool* [m_ny];
	}

	for (i=0;i<=m_nx;i++)
	{    for (j=0;j<=m_ny-1;j++)
		{     vFibronectinConc[i][j]=new double [m_nz];
	          vTAFConc[i][j]=new double [m_nz];
			  vEndoCellDensity[i][j]=new double [m_nz];
			  vSproutsTips[i][j]=new int [m_nz];
			  vMDFConc[i][j]=new double [m_nz];
			  vOldFibronectinConc[i][j]=new double [m_nz];
			  vOldTAFConc[i][j]=new double [m_nz];
			  vOldEndoCellDensity[i][j]=new double [m_nz];
			  vOldMDFConc[i][j]=new double [m_nz];
			  bBoneTissue[i][j]=new bool [m_nz];
	}}

	for (i=0;i<=m_nx;i++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			  vFibronectinConc[i][j][k]=0.0;
	          vTAFConc[i][j][k]=0.0;
			  vEndoCellDensity[i][j][k]=0.0;
			  vSproutsTips[i][j][k]=0;
			  vMDFConc[i][j][k]=0.0;
			  vOldFibronectinConc[i][j][k]=0.0;
			  vOldTAFConc[i][j][k]=0.0;
			  vOldEndoCellDensity[i][j][k]=0.0;
			  vOldMDFConc[i][j][k]=0.0;
			  bBoneTissue[i][j][k]=FALSE;
	}}}
//------ END MODIF A.S. ---------------------------------------


	pSprout=NULL;
	pSprout=new int[Nbond];	//dynamic array of sprout labels

	for (int n=1;n<=Nbond;n++) { pSprout[n-1]=0; }



//------ START MODIF A.S.(version 2.0)-------------------------
	poleSprout=NULL;
	poleSprout=new bool[Nbond];

	for (int n=1;n<=Nbond;n++) { poleSprout[n-1]=true; }

	//------------------------

	probP0=NULL;
	probP1=NULL;
	probP2=NULL;
	probP3=NULL;
	probP4=NULL;
	probP5=NULL;
	probP6=NULL;

	probP0=new double** [m_nx+1]; // indice from 0 to m_nx
	probP1=new double** [m_nx+1];
    probP2=new double** [m_nx+1];
	probP3=new double** [m_nx+1];
    probP4=new double** [m_nx+1];
	probP5=new double** [m_nx+1];
    probP6=new double** [m_nx+1];

	for (i=0;i<=m_nx;i++)
	{    probP0[i]=new double* [m_ny];
	     probP1[i]=new double* [m_ny];
	     probP2[i]=new double* [m_ny];
	     probP3[i]=new double* [m_ny];
	     probP4[i]=new double* [m_ny];
	 	 probP5[i]=new double* [m_ny];
		 probP6[i]=new double* [m_ny];
	}
	for (i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	 probP0[i][j]=new double [m_nz];
			 probP1[i][j]=new double [m_nz];
			 probP2[i][j]=new double [m_nz];
			 probP3[i][j]=new double [m_nz];
			 probP4[i][j]=new double [m_nz];
			 probP5[i][j]=new double [m_nz];
			 probP6[i][j]=new double [m_nz];
	}}

	//-------------------

	R0inf=R0sup=R1inf=R1sup=R2inf=R2sup=R3inf=R3sup=NULL;
	R4inf=R4sup=R5inf=R5sup=R6inf=R6sup=NULL;

	R0inf=new double** [m_nx+1];
	R1inf=new double** [m_nx+1];
	R2inf=new double** [m_nx+1];
	R3inf=new double** [m_nx+1];
	R4inf=new double** [m_nx+1];
	R5inf=new double** [m_nx+1];
	R6inf=new double** [m_nx+1];
	R0sup=new double** [m_nx+1];
	R1sup=new double** [m_nx+1];
	R2sup=new double** [m_nx+1];
	R3sup=new double** [m_nx+1];
	R4sup=new double** [m_nx+1];
	R5sup=new double** [m_nx+1];
	R6sup=new double** [m_nx+1];

	for (i=0;i<=m_nx;i++)
	{    R0inf[i]=new double* [m_ny];
	     R1inf[i]=new double* [m_ny];
	     R2inf[i]=new double* [m_ny];
	     R3inf[i]=new double* [m_ny];
	     R4inf[i]=new double* [m_ny];
	 	 R5inf[i]=new double* [m_ny];
		 R6inf[i]=new double* [m_ny];
		 R0sup[i]=new double* [m_ny];
	     R1sup[i]=new double* [m_ny];
	     R2sup[i]=new double* [m_ny];
	     R3sup[i]=new double* [m_ny];
	     R4sup[i]=new double* [m_ny];
	 	 R5sup[i]=new double* [m_ny];
		 R6sup[i]=new double* [m_ny];
	}
	for (i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	 R0inf[i][j]=new double [m_nz];
			 R1inf[i][j]=new double [m_nz];
			 R2inf[i][j]=new double [m_nz];
			 R3inf[i][j]=new double [m_nz];
			 R4inf[i][j]=new double [m_nz];
			 R5inf[i][j]=new double [m_nz];
			 R6inf[i][j]=new double [m_nz];
			 R0sup[i][j]=new double [m_nz];
			 R1sup[i][j]=new double [m_nz];
			 R2sup[i][j]=new double [m_nz];
			 R3sup[i][j]=new double [m_nz];
			 R4sup[i][j]=new double [m_nz];
			 R5sup[i][j]=new double [m_nz];
			 R6sup[i][j]=new double [m_nz];
	}}

//------------- END MODIF A.S. ---------------------------------



//---------------------------------------------------
//	pIclus=NULL;
//	pIclus=new int[Nbond];	//dynamic array of cluster labels
	pIwork=NULL;
	pIwork=new int[10];	//dynamic array of neighbour labels
	pNwork=NULL;
	pNwork=new int[10];	//dynamic array of neighbour clusters 

///	for (n=1;n<=Nbond;n++)
//	{
//		*(pIclus+(n-1))=0;
//		pIclus[n-1]=0;
//	}

	for (int n=1;n<=10;n++)
	{
		pIwork[n-1]=0;
		pNwork[n-1]=0;
	}
//---------------------------------------------------

	angiotime=0.0;
	
	//--SMcD 10/2004--------

	TimeFactor=1.0;	//This is the normalisation time Tau

	if (m_presetNetwork==TRUE || m_circTumour==TRUE || m_WoundOption==TRUE)
	{
	TimeFactor=1.0;//1.0;//1.37*10.0e5;	//1.0; FOR ORIGINAL RESULTS 									//USE 1 for a posteriori tracer
	}
	//----------------------
	angioDeltaT=0.005/TimeFactor;//0.00000005;//0.005THIS IS THE ONE TO USE GENERALLY; // MODIF A.S. (initial value = 0.0005)
								//If a tracer is being used, then the timestep could be chaged
								//in UpdateTracer() to conserve mass
	angioSystemLength=1.0;

	// start modif A.S. ---------------
	angioDeltaX=angioSystemLength/m_nx;
	angioDeltaY=angioSystemLength/m_ny;
	//angioDeltaZ=angioSystemLength/m_nz;
	if (m_nz==1) { angioDeltaZ=0.0; } // necessary condition for the initial code
			else { angioDeltaZ=angioSystemLength/m_nz; }
	// end modif A.S. -----------------

	//angioBondLength=angioSystemLength/m_nx;
	//angioDeltaX=angioBondLength;
	//angioDeltaY=angioBondLength;
	//angioDeltaZ=(m_nz==1)? 0.0 : angioBondLength;
	  thresholdAge=0.5;	//0.5 used earlier (else 0.05)  

//--Set Rand No Seed-----------------
		//srand(8);	//gives a reproducible set of Rand. Nos.
		////Feb2007  srand(21); //changed on the 18/10/02
		//srand(35); //Used for all Feb2005 runs ecxept 1cP blood 
		//srand(34); //used in the Feb 2005 run for the 1cP blood study
		//33 not bad
	      srand(m_seedFromDialog);
//--------------------------------------


//---------------------------------------------------
	runningEndoCellMAX=0.0;
	runningMDFConcMAX=0.0;
	runningTAFConcMAX=0.0;
//----------------------------------------------------


	pAgeOfSprout=NULL;
	pAgeOfSprout=new double[Nbond];	//dynamic array of sprout labels

	pAgeOfVessel=NULL;
	pAgeOfVessel=new double[Nbond];

	for (int n=1;n<=Nbond;n++)
	{
		pAgeOfSprout[n-1]=0.0;
		pAgeOfVessel[n-1]=0.0;
	}


//----------- Larger system -------------
//	Rmin=14.5e-6;
//	Rmax=15.0e-6;
//	artRad=30.0e-6;
//	bondLength=10.0/(double)m_nx*1.0e-3;
//---------------------------------------

//---Capillary radii------------
	Rmin=3.00e-6;//6.00e-6;//4.00e-6;// (changed by Mike 10/08 for wound model)	//1.98e-6;//(need 1.98, 1.99 for pericyte work or new sprouts recruit PCs unphysically)	//was 6 microns in all earlier work
	Rmax=3.01e-6;//6.01e-6;//4.01e-6;// (changed by Mike 10/08 for wound model)	//1.99e-6;	//6.01e-6; //
	artRad=12.0e-6;//6.0e-6;//14.0e-6;//13.5e-6;// (changed by Mike 07/09 - speeds up flow by 10%)
	//use 12 for m_distort=0.3 & 13.5 otherwise - increases timestep (still <angioDeltaT) to compensate 
	//for reduction induced by using distortion, all other aspects of simulation unaffected
	UU_PV_AdditionalRadius=4.0e-6;	//artRad/4.0;
	bondLength=20.0e-6;//2.0/(double)m_nx*1.0e-3;//3.92/(double)m_nx*1.0e-3;//	//basic length unit 2mm = systemlength
//----------------------------------

//-------------------
	mu_blood=4.0e-3;	//SMcD Feb2005// 4.0e-3 Pa.s = 4 cp (is typical)
	mu_plasma=1.2e-3;   // (Pa.s)
//-------------------

	ConMin=0.0;
	ConMax=1.0;
	flushtime=150.0;	//1200.0;
	adsorbedmass=0.0;

	//--- MODIF A.S. ---
	  AngioDrugMin=0.0;
	  AngioDrugMax=10.0;
	  MinHt=0.0;
	  MaxHt=1.0;
	  AverageHt=0.45;//0.45;
	//------------------

//--------------------------------------------------------------

	XBR=NULL;YBR=NULL;ZBR=NULL;XBL=NULL;YBL=NULL;ZBL=NULL;
	XBROld=NULL;YBROld=NULL;ZBROld=NULL;
	XCond=NULL;YCond=NULL;ZCond=NULL;
	vesselXCond=NULL;vesselYCond=NULL;vesselZCond=NULL;
	pXCON=NULL;pYCON=NULL;pZCON=NULL;
	XFlow=NULL;YFlow=NULL;ZFlow=NULL;
	XOldFlow=NULL;YOldFlow=NULL;ZOldFlow=NULL;
	Xmu=NULL;Ymu=NULL;Zmu=NULL;
	XOldmu=NULL;YOldmu=NULL;ZOldmu=NULL;
	XTauW=NULL;YTauW=NULL;ZTauW=NULL;
	XTauE=NULL;YTauE=NULL;ZTauE=NULL;
	pXHem=NULL;pYHem=NULL;pZHem=NULL;

	XBR=new double**[m_nx+1];
	YBR=new double**[m_nx];
	ZBR=new double**[m_nx];

	XBROld=new double**[m_nx+1];
	YBROld=new double**[m_nx];
	ZBROld=new double**[m_nx];

	XBL=new double**[m_nx+1];
	YBL=new double**[m_nx];
	ZBL=new double**[m_nx];

	XCond=new double**[m_nx+1];
	YCond=new double**[m_nx];
	ZCond=new double**[m_nx];

	vesselXCond=new double**[m_nx+1];
	vesselYCond=new double**[m_nx];
	vesselZCond=new double**[m_nx];

	pXCON=new double**[m_nx+1];
	pYCON=new double**[m_nx];
	pZCON=new double**[m_nx];

	XFlow=new double**[m_nx+1];
	YFlow=new double**[m_nx];
	ZFlow=new double**[m_nx];


	//--- MODIF A.S.-------------
	XOldFlow=new double**[m_nx+1];
	YOldFlow=new double**[m_nx];
	ZOldFlow=new double**[m_nx];
	Xmu=new double**[m_nx+1];
	Ymu=new double**[m_nx];
	Zmu=new double**[m_nx];
	XOldmu=new double**[m_nx+1];
	YOldmu=new double**[m_nx];
	ZOldmu=new double**[m_nx];	
	XTauW=new double**[m_nx+1];
	YTauW=new double**[m_nx];
	ZTauW=new double**[m_nx];
	XTauE=new double**[m_nx+1];
	YTauE=new double**[m_nx];
	ZTauE=new double**[m_nx];
	pXHem=new double**[m_nx+1];
	pYHem=new double**[m_nx];
	pZHem=new double**[m_nx];
	pXAngioDrug=new double**[m_nx+1];
	pYAngioDrug=new double**[m_nx];
	pZAngioDrug=new double**[m_nx];

	//----------------------------

//-----
	for (i=0;i<m_nx+1;i++)
	{
		XBR[i]=new double* [m_ny];
		XBROld[i]=new double* [m_ny];
		XBL[i]=new double* [m_ny];
		XCond[i]=new double* [m_ny];
		vesselXCond[i]=new double* [m_ny];
		pXCON[i]=new double* [m_ny];
		XFlow[i]=new double* [m_ny];
		XOldFlow[i]=new double* [m_ny];
		Xmu[i]=new double* [m_ny];
		XOldmu[i]=new double* [m_ny];
		XTauW[i]=new double* [m_ny];
		XTauE[i]=new double* [m_ny];
		pXHem[i]=new double* [m_ny];
		pXAngioDrug[i]=new double* [m_ny];
	}

	for (i=0;i<m_nx;i++)
	{
		YBR[i]=new double* [m_ny];
		YBROld[i]=new double* [m_ny];
		ZBR[i]=new double* [m_ny];
		ZBROld[i]=new double* [m_ny];
		YBL[i]=new double* [m_ny];
		ZBL[i]=new double* [m_ny];
		YCond[i]=new double* [m_ny];
		ZCond[i]=new double* [m_ny];
		vesselYCond[i]=new double* [m_ny];
		vesselZCond[i]=new double* [m_ny];
		pYCON[i]=new double* [m_ny];
		pZCON[i]=new double* [m_ny];
		YFlow[i]=new double* [m_ny];
		ZFlow[i]=new double* [m_ny];
		YOldFlow[i]=new double* [m_ny];
		ZOldFlow[i]=new double* [m_ny];
		Ymu[i]=new double* [m_ny];
		Zmu[i]=new double* [m_ny];
		YOldmu[i]=new double* [m_ny];
		ZOldmu[i]=new double* [m_ny];
		YTauW[i]=new double* [m_ny];
		ZTauW[i]=new double* [m_ny];
		YTauE[i]=new double* [m_ny];
		ZTauE[i]=new double* [m_ny];
		pYHem[i]=new double* [m_ny];
		pZHem[i]=new double* [m_ny];
		pYAngioDrug[i]=new double* [m_ny];
		pZAngioDrug[i]=new double* [m_ny];
	}

	for (i=0;i<m_nx+1;i++)
	{	for (int j=0;j<m_ny;j++)
		{
		  XBR[i][j]=new double [m_nz];
		  XBROld[i][j]=new double [m_nz];
		  XBL[i][j]=new double [m_nz];
		  XCond[i][j]=new double [m_nz];
		  vesselXCond[i][j]=new double [m_nz];
		  pXCON[i][j]=new double [m_nz];
		  XFlow[i][j]=new double [m_nz];
		  XOldFlow[i][j]=new double [m_nz];
		  Xmu[i][j]=new double [m_nz];
		  XOldmu[i][j]=new double [m_nz];
		  XTauW[i][j]=new double [m_nz];
		  XTauE[i][j]=new double [m_nz];
		  pXHem[i][j]=new double [m_nz];
		  pXAngioDrug[i][j]=new double [m_nz];
	}}

	for (i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
		  YBR[i][j]=new double [m_nz];
		  ZBR[i][j]=new double [m_nz];
		  YBROld[i][j]=new double [m_nz];
		  ZBROld[i][j]=new double [m_nz];
		  YBL[i][j]=new double [m_nz];
		  ZBL[i][j]=new double [m_nz];
		  YCond[i][j]=new double [m_nz];
		  ZCond[i][j]=new double [m_nz];
		  vesselYCond[i][j]=new double [m_nz];
		  vesselZCond[i][j]=new double [m_nz];
		  pYCON[i][j]=new double [m_nz];
		  pZCON[i][j]=new double [m_nz];
		  YFlow[i][j]=new double [m_nz];
		  ZFlow[i][j]=new double [m_nz];
		  YOldFlow[i][j]=new double [m_nz];
		  ZOldFlow[i][j]=new double [m_nz];
		  Ymu[i][j]=new double [m_nz];
		  Zmu[i][j]=new double [m_nz];
		  YOldmu[i][j]=new double [m_nz];
		  ZOldmu[i][j]=new double [m_nz];
		  YTauW[i][j]=new double [m_nz];
		  ZTauW[i][j]=new double [m_nz];
		  YTauE[i][j]=new double [m_nz];
		  ZTauE[i][j]=new double [m_nz];
		  pYHem[i][j]=new double [m_nz];
		  pZHem[i][j]=new double [m_nz];
		  pYAngioDrug[i][j]=new double [m_nz];
		  pZAngioDrug[i][j]=new double [m_nz];
	}}

	for (k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for ( i=0;i<=m_nx-1;i++)
			{
				Xmu[i][j][k]=0.0; //mu_blood;
				Ymu[i][j][k]=0.0; //mu_blood;
				Zmu[i][j][k]=0.0; //mu_blood;
				XTauW[i][j][k]=0.0;
				YTauW[i][j][k]=0.0;
				ZTauW[i][j][k]=0.0;
			}	
			 i=m_nx;
				Xmu[i][j][k]=0.0; //mu_blood;
				XTauW[i][j][k]=0.0;
	}}


	//------------------------------------------------------
	XPOS=NULL;	//nodal positions - the inlet and outlet nodes are kept fixed
	YPOS=NULL;
	ZPOS=NULL;

	XPOS=new double**[m_nx+2];	//need layer before and after network
	YPOS=new double**[m_nx+2];	//i range goes from 0 to nx+1
	ZPOS=new double**[m_nx+2];	//do not decrement arrays by 1 each time now
								//as we really need 0 to nx+1

	for (i=0;i<m_nx+2;i++)
	{
		XPOS[i]=new double* [m_ny+1];	//y range goes from 0 to ny but 
		YPOS[i]=new double* [m_ny+1];	//ignore 0 subscript, we want 1 to ny only
		ZPOS[i]=new double* [m_ny+1];
	}

	for (i=0;i<m_nx+2;i++)
	{
		for (int j=0;j<m_ny+1;j++)
		{
		XPOS[i][j]=new double[m_nz+1];	//same as for y-range, we want 1 to nz
		YPOS[i][j]=new double[m_nz+1];	
		ZPOS[i][j]=new double[m_nz+1];
		}
	}
//-----------------------------------------------------------------

		NodalPressures=NULL;ConsecPressures=NULL;

		ConsecPressures=new double[m_nx*m_ny*m_nz];

		NodalPressures=new double**[m_nx];
		for (i=0;i<m_nx;i++){ NodalPressures[i]=new double* [m_ny]; }
		for (i=0;i<m_nx;i++)
		{	for (int j=0;j<m_ny;j++) 
							{ NodalPressures[i][j]=new double [m_nz]; }
		}

//-----------------------------------------------------------------
		//Pin=30000.0; //large system
		  Pin=3020;//3260;//3860;//2960;//3836;//2910;//   //1200.0;	//use for growth with WSS
		  Pout=2300;//2060;//1460;//2360;//1484;//2410;//   //0.0;
		
		//--- Used for remodelling of a static network -----
		// together with capillary data for Rmin, Rmax, artRad
			//Pin=8000;   
			//Pout=0.0;	//Pa
		//-----------------------

		for (k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (pFluid[LabX(i,j,k)-1]==10)
					{
					NodalPressures[i-1][j-1][k-1]=//0.0;//-(Pin-Pout)*(i)/(m_nx+1)
												  //+Pin;
												  -(Pin-Pout)*(i)/(m_nx+1)
												  +Pin;
					}
					else
					{
					NodalPressures[i-1][j-1][k-1]=//0.0;//used to check solve
													//-(Pin-Pout)*(i)/(m_nx+1)
													//+Pin;
													-(Pin-Pout)*(i)/(m_nx+1)
													+Pin;
					}

//			if (i==1 && j==m_ny-2) 
//						NodalPressures[i-1][j-1][k-1]=
//												  -(Pin/1.2-Pout/1.2)*(i)/(m_nx+1)
//												  +Pin/1.;
//			if (i==m_nx && j==m_ny-2) 
//						NodalPressures[i-1][j-1][k-1]=
///												  -(Pin/1.2-Pout/1.2)*(i)/(m_nx+1)
//												  +Pin/1.;

		}}}
//------------------------------------------------------------------
	
	for (i=1;i<=m_nx;i++)
	{
		double pres=(double)(m_nx+1-i)/(double)(m_nx+1)*
										(Pin-Pout)+Pout;
		for (int j=1;j<=m_ny;j++)
		{	for (int k=1;k<=m_nz;k++)
			{
			  if (pFluid[LabX(i,j,k)-1]==10)
				{ ConsecPressures[i+(j-1)*m_nx+(k-1)*m_nx*m_ny - 1]=0.0;}
			  else
				{ ConsecPressures[i+(j-1)*m_nx+(k-1)*m_nx*m_ny - 1]=0.0;}		
	}}}

//---------------------------------------------------------------
	MySolver.initialisePressures(m_nx,m_ny,m_nz, 
					NodalPressures,ConsecPressures,Pin, Pout);
//---------------------------------------------------------------

	pIclusO=NULL;
	pIclusW=NULL;
	pIclusO=new int[Nbond];	//dynamic array of cluster labels
	pIclusW=new int[Nbond];	//dynamic array of cluster labels

	for (int n=1;n<=Nbond;n++)
	{
		pIclusO[n-1]=0;
		pIclusW[n-1]=0;
	}

	pIclusBone=NULL;
	pIclusBone=new int[(m_nx+1)*m_ny*m_nz];

	for (int n=1;n<=(m_nx+1)*m_ny*m_nz;n++)
	{
		pIclusBone[n-1]=0;
	}

//---------------------------------------------------
	vesselTrappedSat=0.0;
	nVesselTrapped=0;
//---------------------------------------------------
	pVesselTrapped=NULL;
	pVesselTrapped=new bool[Nbond];

	for (int n=1;n<=Nbond;n++)
	{
		pVesselTrapped[n-1]=FALSE;	//all pores trapped initially
	}
//--------------------------------------------------------------
	replayloop=1;
	replayStore=1.0;	//this variable counts how many replay loops have been written 
						//away to file for later read in.
//	replayloopMax=10;

//------ Nutrient Concentrations-------------------------
	pVesselNutrientConc=NULL;
	pVesselNutrientConc=new double[Nbond];
	pOldVesselNutrientConc=NULL;
	pOldVesselNutrientConc=new double[Nbond];
	D_Transmural=NULL;
	D_Transmural=new double[Nbond];
	Perm_Vessel=NULL;
	Perm_Vessel=new double[Nbond];
	DimPerm_Vessel=NULL;
	DimPerm_Vessel=new double[Nbond];
	pConcDecrement=NULL;
	pConcDecrement=new double[Nbond];	//dynamic array of vessel conc decrements
	bAllowNutrientTransport=NULL;
	bAllowNutrientTransport=new bool[Nbond];

	for (int n=1;n<=Nbond;n++) 
	{ 
		pVesselNutrientConc[n-1]=0.0;
		pOldVesselNutrientConc[n-1]=0.0;
		D_Transmural[n-1]=0.0;
		DimPerm_Vessel[n-1]=0.0;
		Perm_Vessel[n-1]=0.0;
		pConcDecrement[n-1]=0.0;
		bAllowNutrientTransport[n-1]=false;
	}

	//------------------------

	pTissueNutrientConc=NULL;
	pOldTissueNutrientConc=NULL;

	pTissueNutrientConc=new double** [m_nx+1]; //m_nx+1 tissue blocks
	pOldTissueNutrientConc=new double** [m_nx+1]; //m_nx+1 tissue blocks

	for (i=0;i<=m_nx;i++)
	{    
		pTissueNutrientConc[i]=new double* [m_ny];
		pOldTissueNutrientConc[i]=new double* [m_ny];
	}

	for (i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	 
			pTissueNutrientConc[i][j]=new double [m_nz];
			pOldTissueNutrientConc[i][j]=new double [m_nz];
		}
	}

//-----------------------------------------
	for (k=1;k<=m_nz;k++)
	{	
		for (int j=1;j<=m_ny;j++)
		{	
			for (int i=1;i<=m_nx+1;i++)
			{
				pTissueNutrientConc[i-1][j-1][k-1]=0.0;
				pOldTissueNutrientConc[i-1][j-1][k-1]=0.0;
			}
		}
	}
//-----------------------------------------

	CharTime=1.0;//s
	CharLength=0.001;//0.002;//0.00392;//m
	DimSigma_Nutrient=0.002;//0.005;//0.000167;//0.025;//0.0008;//0.07;//0.00015;//per second
	sigma_Nutrient=DimSigma_Nutrient*CharTime;
	DimDiffCoeffNutrient=2.0e-9;//2.5e-10;//2.41e-9;//m^2/s
	diffCoeffNutrient=DimDiffCoeffNutrient*CharTime/pow(CharLength,2);
	DimVesselPerm=0.000005;//0.00025;//0.0007;//0.0005;//0.001//m/s
	vesselPerm=DimVesselPerm*CharTime/CharLength;
	InputNutConc=0.45;
	Rmaximum=12.0e-6;
	RateNutChangeMAX=0.0;
//-----------------------------------------------

	NormFractRBCFlowX=NULL;
	NormFractRBCFlowY=NULL;
	NormFractRBCFlowZ=NULL;
	bFlowIn=NULL;
	bFlowOut=NULL;
	
	NormFractRBCFlowX=new double**[m_nx+1];
	NormFractRBCFlowY=new double**[m_nx];
	NormFractRBCFlowZ=new double**[m_nx];
	bFlowIn=new bool[Nbond];
	bFlowOut=new bool[Nbond];
	
	for (i=0;i<m_nx;i++)
	{
		NormFractRBCFlowY[i]=new double*[m_ny];
		NormFractRBCFlowZ[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			NormFractRBCFlowY[i][j]=new double[m_nz];
			NormFractRBCFlowZ[i][j]=new double[m_nz];
		}}

	for (i=0;i<m_nx+1;i++)
	{
		NormFractRBCFlowX[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx+1;i++)
	{	for (j=0;j<m_ny;j++)
		{
			NormFractRBCFlowX[i][j]=new double[m_nz];
	}}

	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				NormFractRBCFlowX[i-1][j-1][k-1]=0.0;	
				NormFractRBCFlowY[i-1][j-1][k-1]=0.0;	
				NormFractRBCFlowZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;
			NormFractRBCFlowX[i-1][j-1][k-1]=0.0;
		}}

	for (int n=1;n<=Nbond;n++)	{bFlowIn[n-1]=false;	bFlowOut[n-1]=false;}


	TotalFlowsOut=NULL;
	TotalFlowsIn=NULL;
	TotalMassesIn=NULL;
	
	TotalFlowsOut=new double**[m_nx];
	TotalFlowsIn=new double**[m_nx];
	TotalMassesIn=new double**[m_nx];

	for (i=0;i<m_nx;i++)
	{
		TotalFlowsOut[i]=new double* [m_ny];
		TotalFlowsIn[i]=new double* [m_ny];
		TotalMassesIn[i]=new double* [m_ny];
	}
	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			TotalFlowsOut[i][j]=new double [m_nz];
			TotalFlowsIn[i][j]=new double [m_nz];
			TotalMassesIn[i][j]=new double [m_nz];
	}}

	for ( k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				TotalFlowsIn[i-1][j-1][k-1]=0.0;
				TotalFlowsOut[i-1][j-1][k-1]=0.0;
				TotalMassesIn[i-1][j-1][k-1]=0.0;
	}}}


//===========================================================
//-------------------------------------------
//---------Tumour Model initialisation - SMcD 10/2004
	//Place initial Tumour Cell population in domain---
	int nTumCells=1000;

 	pXCoord_TumCell=NULL;
	pXCoord_TumCell=new int[nTumCells];
	pYCoord_TumCell=NULL;
	pYCoord_TumCell=new int[nTumCells];
	pZCoord_TumCell=NULL;
	pZCoord_TumCell=new int[nTumCells];
	pPhenoType=NULL;
	pPhenoType=new int[nTumCells];

	for (int n=1;n<=nTumCells;n++)
	{
		pXCoord_TumCell[n-1]=0;
		pYCoord_TumCell[n-1]=0;
		pZCoord_TumCell[n-1]=0;

		pPhenoType[n-1]=0;
	}
	//-----------------------------------------

//------ START MODIF A.S. (version 2.0)------------------------------
    pTumCellPresent=NULL;

	pTumCellPresent=new bool** [m_nx+1];

	for (i=0;i<=m_nx;i++) 
	{    
		pTumCellPresent[i]=new bool* [m_ny]; 
	}

	for (i=0;i<=m_nx;i++)
	{    for (j=0;j<=m_ny-1;j++)
		{     
		pTumCellPresent[i][j]=new bool [m_nz];
	    }
	}

	for (i=0;i<=m_nx;i++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			  pTumCellPresent[i][j][k]=false;
			}
		}
	}
//--------------------------------------------------



//---Boolean variable to indicate whether lower venous vessel present-------------------------------------
	b_venousIncluded=true;//false;//		//NOT present as default

//---Ulster Wound Parameters
	b_UU_wound_Model=false;//true;//	//University of Ulster model
	iWoundRadius=34;//68*m_nx/100/2;//3*m_nx/5/2;	//radius of wound as a fraction of the system length
								//Mike 08/09, defines radius within which PVs ablated

	iDamagedRadius=iWoundRadius+2;	//Mike 08/09, defines radius at which PVs experienced damage (ie can remodel/regress)
									//This will probably never be used

	i_UU_WoundRad=30;//3*m_nx/5/2;	//Mike 08/09, defines radius of actual wounds in UU experiment
								//leave fixed for numerical output (ie defines annular regions; total oxygen in wound etc)  & graphics

	jCentre=m_ny/2,iCentre=m_nx/2;	//centre of circular wound
	nAdditionalCentralPVs=40;//48;//24;//20;//35; (changed by Mike 10/08)	//7;
//----------------------------------------

//---Bone Model (Mike 01/13)
	b_Bone_model=true;

//---Test Network (Mike 08/09)----
	b_TestNetwork=false;//true;
	if	(b_TestNetwork==true)	{b_UU_wound_Model=b_venousIncluded=false;}

//---Hexagonal Vasculature (Mike 09/09)----
	b_HexNetwork=false;//true;
	b_StraightPVs=false;//true;

//---Wound Area (global for graphics)---
	NumBondsRadius=0;

	bCountBlock=NULL;
	bCountBlock=new bool[m_nx*m_ny*m_nz];

	for	(int n=1;n<=m_nx*m_ny*m_nz;n++)
	{
		bCountBlock[n-1]=false;
	}


//---CONTINUOUS Pericytes included-----------
	PericyteDensityInit=0.0001;	//Initial density assigned to sprout tips position
								//which obviously varies in time and space as capillaries grow
								//See AssignInitialSprouts(), AssignInitialSprouts2()
								// and GrowVasculatureMDF()
	pPericyteDensity=NULL;
	pPericyteDensity=new double[Nbond];	


	for (k=1;k<=m_nz;k++)
	{
	   for (j=1;j<=m_ny;j++)
	   {
	      for (i=1;i<=m_nx;i++)
		  {
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);	

			  pPericyteDensity[nbx-1]=0;
			  pPericyteDensity[nby-1]=0;
			  pPericyteDensity[nbz-1]=0;

		  }
			  i=m_nx+1;
			  nbx=LabX(i,j,k);
			  pPericyteDensity[nbx-1]=0;
	  }}
	  
	RadiusPericyte=20.0e-6;	//m
	PC_Carrying_Capacity_Max=2.0*artRad*angioDeltaX/pow(RadiusPericyte,2);
//-----------------------------------------




//----DISCRETE PC initialisation - these move along the underlying network grid
//----just like the ECs---------------------------
	b_IncludeDiscretePericytes=false;//true;
	bDiscretePericyte=NULL;	//array that detremines whether PC is present or not
	bDiscretePericyte=new bool[Nbond];	
	for (int n=1;n<=Nbond;n++) { bDiscretePericyte[n-1]=false; }
//---------------------------------------------------

//----Populate tissue with pericytes (randomly in domain)
	int nPVs=1;
	if (b_venousIncluded) {nPVs++;}
	if (b_UU_wound_Model) {nPVs+=nAdditionalCentralPVs;}	//additional PVs
		
	int PV_PericyteNumber=nPVs*(m_nx+1);	//these are the PCs covering PVs

	nPericytes=500 + PV_PericyteNumber;  //free pericytes + PV pericytes

	//----Positions of Pericytes in 3D (i,j,k) same meaning as network model----------
	pPCXCoord=NULL;
	pPCXCoord=new int[nPericytes];	//dynamic array (0,nPericytes-1)
	pPCYCoord=NULL;
	pPCYCoord=new int[nPericytes];	//dynamic array
	pPCZCoord=NULL;
	pPCZCoord=new int[nPericytes];	//dynamic array

	pPCOrientationID=NULL;
	pPCOrientationID=new int[nPericytes];	//1=xAligned,2=yAligned,3=zAligned

	PC_StillActive=NULL;
	PC_StillActive=new bool[Nbond];	//dynamic array of active labels
									//NB this array is nBond in size, i.e. 
									//the value says whether any bond currently
									//HOSTS an active PC or not
	for (int n=1;n<=Nbond;n++) { PC_StillActive[n-1]=false; }

	nPericytesAttached=0;	//no. of pericytes attached to vessels
//=============================================================



//Use an array to track flowing vessel segments (used for PC recruitment---

	bFlowingVessel=NULL;
	bFlowingVessel=new bool[Nbond];	//dynamic array of sprout labels

	for (int n=1;n<=Nbond;n++) { bFlowingVessel[n-1]=false; }

//===========================================================


//======================================================

	pArterialVenousID=NULL;
	pArterialVenousID=new int[Nbond];	//dynamic array of fluid labels
	for (int n=1;n<=Nbond;n++) { pArterialVenousID[n-1]=0; }

//------ END MODIF A.S. ---------------------------------------
//------ End Tumour Model initialisation ---------------------------------------
//===========================================================================

//---Vessel Pruning Initialisation-----

	Prune_AgeX=NULL;
	Prune_AgeY=NULL;
	Prune_AgeZ=NULL;

	Prune_AgeX=new double**[m_nx+1];
	Prune_AgeY=new double**[m_nx];
	Prune_AgeZ=new double**[m_nx];

	for (i=0;i<m_nx;i++)
	{
		Prune_AgeY[i]=new double*[m_ny];
		Prune_AgeZ[i]=new double*[m_ny];
	}
	
	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			Prune_AgeY[i][j]=new double[m_nz];
			Prune_AgeZ[i][j]=new double[m_nz];
		}
	}

	for (i=0;i<m_nx+1;i++)
	{
		Prune_AgeX[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx+1;i++)
	{	for (j=0;j<m_ny;j++)
		{
			Prune_AgeX[i][j]=new double[m_nz];
		}
	}
			
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				Prune_AgeX[i-1][j-1][k-1]=0.0;
				Prune_AgeY[i-1][j-1][k-1]=0.0;
				Prune_AgeZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			Prune_AgeX[i-1][j-1][k-1]=0.0;

		}
	}

//---Conducted & Convected Stim Initialisation---

	ConductedStimX=NULL;
	ConductedStimY=NULL;
	ConductedStimZ=NULL;
	ConvectedStimX=NULL;
	ConvectedStimY=NULL;
	ConvectedStimZ=NULL;

	ConductedStimX=new double**[m_nx+1];
	ConductedStimY=new double**[m_nx];
	ConductedStimZ=new double**[m_nx];
	ConvectedStimX=new double**[m_nx+1];
	ConvectedStimY=new double**[m_nx];
	ConvectedStimZ=new double**[m_nx];

	for (i=0;i<m_nx;i++)
	{
		ConductedStimY[i]=new double*[m_ny];
		ConductedStimZ[i]=new double*[m_ny];
		ConvectedStimY[i]=new double*[m_ny];
		ConvectedStimZ[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			ConductedStimY[i][j]=new double[m_nz];
			ConductedStimZ[i][j]=new double[m_nz];
			ConvectedStimY[i][j]=new double[m_nz];
			ConvectedStimZ[i][j]=new double[m_nz];
		}
	}

	for (i=0;i<m_nx+1;i++)
	{
		ConductedStimX[i]=new double*[m_ny];
		ConvectedStimX[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx+1;i++)
	{	for (j=0;j<m_ny;j++)
		{
			ConductedStimX[i][j]=new double[m_nz];
			ConvectedStimX[i][j]=new double[m_nz];
		}
	}
			
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				ConductedStimX[i-1][j-1][k-1]=0.0;
				ConductedStimY[i-1][j-1][k-1]=0.0;
				ConductedStimZ[i-1][j-1][k-1]=0.0;
				ConvectedStimX[i-1][j-1][k-1]=0.0;
				ConvectedStimY[i-1][j-1][k-1]=0.0;
				ConvectedStimZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			ConductedStimX[i-1][j-1][k-1]=0.0;
			ConvectedStimX[i-1][j-1][k-1]=0.0;
		}
	}

	FalseFlow=NULL;
	FalseFlow=new bool[Nbond];	

	for (int n=1;n<=Nbond;n++) { FalseFlow[n-1]=0; }

//-----------------------------------------------
//-----------------------------------------------

	
//=================================================================================================
}

//***********************************************
//=====================================
void CAngioNetDlg::SetInitialFNConcs2()
//=====================================
{

	//--- output file for debugging ------------------
      //ofstream outfileInitFN2 ("DebugSetInitFN2.txt");
	//------------------------------------------------
//==ORIGINAL PROFILE

	double constant=0.75,eps2=0.45;
	int i,j,k;

	fibronectinConcMAX=constant;

//-------If venule present in domain
	if(b_venousIncluded)  //venule or central wound present
	{
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)
			{	for (i=1;i<=m_nx+1;i++)
				{
			 vFibronectinConc[i-1][j-1][k-1]=//0.0;
				 constant-constant*exp(-(pow( ( (double)(j-1) - (double)(m_ny/2.0)  )
				 /m_ny,2.0)/eps2)); // (j-1)/(m_ny-1) ...
		}}}

	}
	else	//only a single arteriole
	{
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)
			{	for (i=1;i<=m_nx+1;i++)
				{
					vFibronectinConc[i-1][j-1][k-1]=
						constant*exp(-(pow((double)(j-1)/m_ny,2.0)/eps2)); // (j-1)/(m_ny-1) ...

					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)	{vFibronectinConc[i-1][j-1][k-1]=0.0;}
		}}}

	}
//------------------------------------------
//	if (b_UU_wound_Model)	//overwrite to constant if wound heal
//	{

		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)
			{	for (i=1;i<=m_nx+1;i++)
				{
			 vFibronectinConc[i-1][j-1][k-1]=fibronectinConcMAX*
								0.5*(1+exp(-1/eps2));	//average value
		}}}


//	}
//---------------------------------------------------
/*  ??????????????????
	//------ CIRCULAR TUMOUR IN CENTRE--------------
	double r;
	double constant=0.75,eps2=0.45;
	int i,j,k;

	fibronectinConcMAX=constant;

	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 //r=sqrt(pow(((double)i/m_nx)-0.5,2)+pow(((double)j/(m_ny-1))-1.0,2));
			 r=0.5*sqrt(pow(0.5-(double)i/m_nx,2)+pow(0.5-(double)j/m_ny,2));

			 //if (r<0.1)  { vTAFConc[i][j][k]=1.0; }
			 //if (r>=0.1) { vTAFConc[i][j][k]=pow(nu-r,2)/(nu-0.1); }
			 //if (r>=0.1) { vTAFConc[i][j][k]=exp(-(pow(r,2.0)/eps1)); }

	    vFibronectinConc[i][j][k]=fibronectinConcMAX-exp(-(pow(r,2)/0.45)); //test2
			 //vTAFConc[i][j][k]=4.0*exp(-(pow(r,2)/0.25)); //test1
	}}}
*///?????????????????????????


	//-------------------------------------
/*	for (i=0;i<=m_nx;i++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (k=0;k<=m_nz-1;k++)
			{			
			 outfileInitFN2 << i << "\t" << j << "\t" << vFibronectinConc[i][j][k] << endl;
	}}}
*/


/*	// Set FN to zero if fluid label is 66
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]==66) { vFibronectinConc[i-1][j-1][k-1]=0.0; }
			 if (pFluid[nby-1]==66) { vFibronectinConc[i-1][j-1][k-1]=0.0; }
			 if (pFluid[nbz-1]==66) { vFibronectinConc[i-1][j-1][k-1]=0.0; }
			 }
			 
			 nbx=LabX(m_nx+1,j,k);

			 if (pFluid[nbx-1]==66) { vFibronectinConc[i-1][j-1][k-1]=0.0; }
	}}
*/

	// Now set Old values to new values (initialisation only)
    for (i=0;i<=m_nx;i++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (k=0;k<=m_nz-1;k++)
			{
			 vOldFibronectinConc[i][j][k]=vFibronectinConc[i][j][k];
			 //outfileInitFN2 << i << "\t" << j << "\t" << vFibronectinConc[i][j][k] << endl;
	}}}

}


//*****************************************************

//======================================
void CAngioNetDlg::SetInitialTAFConcs2()
//======================================
{

	//--- output file for debugging ------------------
      //ofstream outfileInitTAF2 ("DebugSetInitTAF2.txt");
	//------------------------------------------------
//   SMcD 07.11.06
	double constant=1.0,eps1=0.45;    //0.45 used in ALL pre-UUC work
	int i,j,k;

	TAFConcMAX=constant;


	//------ LINEAR TUMOUR --------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx+1;i++)
			{   
				vTAFConc[i-1][j-1][k-1]=exp(-(pow(1-(double)j/m_ny,2.0)/eps1)); // (j-1)/(m_ny-1)

				if	(bBoneTissue[i-1][j-1][k-1]==TRUE)	{vTAFConc[i-1][j-1][k-1]=0.0;}
	}}}



	//-------------------------------------
/*
	//------ CIRCULAR TUMOUR AT Lower Boundary--------------
	double r;
	for (k=0;k<=m_nz-1;k++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (i=0;i<=m_nx;i++)
			{
			 //r=sqrt(pow(((double)i/m_nx)-0.5,2)+pow(((double)j/(m_ny-1))-1.0,2));
			 r=sqrt(pow(0.5-(double)i/m_nx,2)+pow(1.0-(double)j/m_ny,2));

			 //if (r<0.1)  { vTAFConc[i][j][k]=1.0; }
			 //if (r>=0.1) { vTAFConc[i][j][k]=pow(nu-r,2)/(nu-0.1); }
			 //if (r>=0.1) { vTAFConc[i][j][k]=exp(-(pow(r,2.0)/eps1)); }

			   vTAFConc[i][j][k]=exp(-(pow(r,2)/0.45)); //test2
			 //vTAFConc[i][j][k]=4.0*exp(-(pow(r,2)/0.25)); //test1
	}}}
	//-------------------------------------
*/


//Change TAF conc if venule present----------
//	if(b_venousIncluded || b_UU_wound_Model)	//circular wound needs circular TAF too
//	{
	//------ CIRCULAR TUMOUR IN CENTRE--------------
	double r;
	double eps_UU=0.91;//0.9; // changed by Mike 05/09 //0.85;//1.25; (changed by Mike 10/08 for wound model)	//0.75 used earlier
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 //r=sqrt(pow(((double)i/m_nx)-0.5,2)+pow(((double)j/(m_ny-1))-1.0,2));
			 r=2*sqrt(	
						pow(0.5-(double)i/m_nx,2)
							+pow(0.5-(double)j/m_ny,2)
								//+pow(0.5-(double)k/m_nz,2)
					);

			 //if (r<0.1)  { vTAFConc[i][j][k]=1.0; }
			 //if (r>=0.1) { vTAFConc[i][j][k]=pow(nu-r,2)/(nu-0.1); }
			 //if (r>=0.1) { vTAFConc[i][j][k]=exp(-(pow(r,2.0)/eps1)); }

//			   vTAFConc[i][j][k]=exp(-(pow(r,2)/0.45)); //test2//Circular
			   vTAFConc[i][j][k]=exp(-(pow(r,1.5)/eps_UU)); //2 - changed by Mike 05/09 (steeper grad near centre)//test2//Circular
			   if	(bBoneTissue[i][j][k]==TRUE)	{vTAFConc[i][j][k]=0.0;}
//			   vTAFConc[i][j][k]=0.85*exp(-(pow(r,2.5)/eps_UU));//TNP-470

//			   vTAFConc[i][j][k]=exp(-(pow((double)j-(double)m_ny/2.0,2)/1500.0)); //test2//Slope from centre



//			 vTAFConc[i][j][k]=4.0*exp(-(pow(r,2)/0.25)); //test1
	}}}
	//-------------------------------------

	
//	}

//--------------------------------------------------------



/*
	//--------- INDIVIDUAL SOURCE OF TAF RESPONDING TO O2 CONCENTRATION ---------
	double r1,r2,r3;
	for (k=0;k<=m_nz-1;k++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (i=0;i<=m_nx;i++)
			{
			  r1=sqrt(pow(0.4-(double)i/m_nx,2)+pow(1.0-(double)j/m_ny,2));
			  r2=sqrt(pow(0.5-(double)i/m_nx,2)+pow(1.0-(double)j/m_ny,2));
			  r3=sqrt(pow(0.6-(double)i/m_nx,2)+pow(1.0-(double)j/m_ny,2));

			  vTAFConc[i][j][k]=0.3*(exp(-(pow(r1,2)/0.45))+exp(-(pow(r2,2)/0.45))+exp(-(pow(r3,2)/0.45))); 
	}}}	
	//---------------------------------------------------------------------------
*/


/*	// Set FN to zero if fluid label is 66
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);
			 
			 if (pFluid[nbx-1]==66) { vTAFConc[i-1][j-1][k-1]=0.0; }
			 if (pFluid[nby-1]==66) { vTAFConc[i-1][j-1][k-1]=0.0; }
			 if (pFluid[nbz-1]==66) { vTAFConc[i-1][j-1][k-1]=0.0; }
			 }
			 nbx=LabX(m_nx+1,j,k);

			 if (pFluid[nbx-1]==66) { vTAFConc[i-1][j-1][k-1]=0.0; }
	}}
*/


	// Now set Old values to new values (initialisation only)
    for ( i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 vOldTAFConc[i][j][k]=vTAFConc[i][j][k];
			 //outfileInitTAF2 << i << "\t" << j << "\t" << vTAFConc[i][j][k] << endl;
	}}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::SetInitialECDensity2()
//=======================================
{
	//--- output file for debugging ------------------
      //ofstream outfileInitEC2 ("DebugOutputFiles/DebugSetInitEC2.txt");
	//------------------------------------------------

	double eps3=0.001,Pi=3.141592654;
	int i,j,k;

	EndoCellDensityMAX=1.0;  //36.0; MODIF A.S. (original value =36.0)


	// Initialise to zero first
   for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx+1;i++)
			{
	         vEndoCellDensity[i-1][j-1][k-1]=0.0;
   }}}


   // Next, put in spikes of initial density

   // First Spike
   //-------------
	int lowerBound=(int) floor(0.5 + (m_nx+1)/12.0 ) + 1; //NINT 
	int upperBound=(int) floor(0.5 + 3*(m_nx+1)/12.0 ); //NINT 

	for (k=1;k<=m_nz;k++)
	{
	   for (j=1;j<=m_ny;j++)
	   {
	      for (i=lowerBound;i<=upperBound;i++)
		  {
		   vEndoCellDensity[i-1][j-1][k-1]=EndoCellDensityMAX*
			exp( - ( pow((double)(j-1),2.0)/eps3  )    )*
			pow( sin(6.0*Pi*((double)i/m_nx-1/12.0-1.0/m_nx)),2.0 );
	}}}

   // Second Spike
   //--------------
	lowerBound=(int) floor(0.5 + 5*(m_nx+1)/12.0 ) + 1; //NINT 
	upperBound=(int) floor(0.5 + 7*(m_nx+1)/12.0 ); //NINT 

	for (k=1;k<=m_nz;k++)
	{
	   for (j=1;j<=m_ny;j++)
	   {
	      for (i=lowerBound;i<=upperBound;i++)
		  {
		   vEndoCellDensity[i-1][j-1][k-1]=EndoCellDensityMAX*
			exp( - ( pow((double)(j-1),2.0)/eps3  )    )*
			pow( sin(6.0*Pi*((double)i/m_nx-1/12.0-1.0/m_nx)),2.0 );
	}}}

   // Third Spike
   //-------------
	lowerBound=(int) floor(0.5 + 9*(m_nx+1)/12.0 ) + 1; //NINT 
	upperBound=(int) floor(0.5 + 11*(m_nx+1)/12.0 ); //NINT 

	for (k=1;k<=m_nz;k++)
	{
	   for (j=1;j<=m_ny;j++)
	   {
	      for (i=lowerBound;i<=upperBound;i++)
			{
		    vEndoCellDensity[i-1][j-1][k-1]=EndoCellDensityMAX*
			exp( - ( pow((double)(j-1),2.0)/eps3  )    )*
			pow( sin(6.0*Pi*((double)i/m_nx-1/12.0-1.0/m_nx)),2.0 );
	}}}


/*	// Set FN to zero if fluid label is 66
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);
			 
			 if (pFluid[nbx-1]==66) { vEndoCellDensity[i-1][j-1][k-1]=0.0; }
			 if (pFluid[nby-1]==66) { vEndoCellDensity[i-1][j-1][k-1]=0.0; }
			 if (pFluid[nbz-1]==66) { vEndoCellDensity[i-1][j-1][k-1]=0.0; }
			 }
			 nbx=LabX(m_nx+1,j,k);

			 if (pFluid[nbx-1]==66) { vEndoCellDensity[i-1][j-1][k-1]=0.0; }
	}}
*/

	
	// Calculate a running maximum for graphics output
	runningEndoCellMAX=0.0; //used for graphics

	for (k=0;k<=m_nz-1;k++)
	{	for (j=0;j<=m_ny-1;j++)
		{	for (i=0;i<=m_nx;i++)
			{

			//outfileInitEC << i << "\t" << j << "\t" << vEndoCellDensity[i][j][k] << endl;
			
			 if (vEndoCellDensity[i][j][k]>runningEndoCellMAX) 
				{ runningEndoCellMAX=vEndoCellDensity[i][j][k]; }
		
	}}}


	// Now set Old values to new values (initialisation only)
    for (j=0;j<=m_ny-1;j++)
	{	for (i=0;i<=m_nx;i++)
		{	for (k=0;k<=m_nz-1;k++)
			{
			 vOldEndoCellDensity[i][j][k]=vEndoCellDensity[i][j][k];
			 //outfileInitEC2 << j << "\t" << i << "\t" << vEndoCellDensity[i][j][k] << endl;
	}}}

}


//*****************************************************

//=======================================
void CAngioNetDlg::AssignInitialSprouts()
//=======================================
{

//----------No sprouts initially---------------
	for (int nn=1;nn<=Nbond;nn++) { pSprout[nn-1]=0; }

//--------Now assign sprout tips----------------
	int zpos;
	if (m_nz==1) { zpos=1; } else { zpos=int(m_nz/10); }//5; }//int(m_nz/2); }

	int iSprout1=(int)floor(1.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout2=(int)floor(2.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout3=(int)floor(3.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout4=(int)floor(4.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout5=(int)floor(5.0*(m_nx+1)/6.0+0.5);	//NINT

	if	(b_HexNetwork)	{iSprout1=(int)floor(1.0*(m_nx+1)/6.0+0.5)+1;}	//correction so that sprout does not
																		//lie on pFluid=66 bond

	if	(b_HexNetwork && m_nx==52)	{iSprout1=(int)floor(1.0*(m_nx+1)/6.0+0.5);
									iSprout2=(int)floor(2.0*(m_nx+1)/6.0+0.5)+1;
									iSprout4=(int)floor(4.0*(m_nx+1)/6.0+0.5)-1;
									iSprout5=(int)floor(5.0*(m_nx+1)/6.0+0.5)+1;}

	pFluid[LabY(iSprout1,2,zpos)-1]=10;
	pFluid[LabY(iSprout2,2,zpos)-1]=10;
	pFluid[LabY(iSprout3,2,zpos)-1]=10;
	pFluid[LabY(iSprout4,2,zpos)-1]=10;
	pFluid[LabY(iSprout5,2,zpos)-1]=10;

	pSprout[LabY(iSprout1,2,zpos)-1]=1;
	pSprout[LabY(iSprout2,2,zpos)-1]=1;
	pSprout[LabY(iSprout3,2,zpos)-1]=1;
	pSprout[LabY(iSprout4,2,zpos)-1]=1;
	pSprout[LabY(iSprout5,2,zpos)-1]=1;

	poleSprout[LabY(iSprout1,2,zpos)-1]=true;
	poleSprout[LabY(iSprout2,2,zpos)-1]=true;
	poleSprout[LabY(iSprout3,2,zpos)-1]=true;
	poleSprout[LabY(iSprout4,2,zpos)-1]=true;
	poleSprout[LabY(iSprout5,2,zpos)-1]=true;

	pPericyteDensity[LabY(iSprout1,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout2,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout3,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout4,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout5,2,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabY(iSprout1,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout2,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout3,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout4,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout5,2,zpos)-1]=1;

	YBR[iSprout1-1][2-1][zpos-1]=3.0e-6;
	YBR[iSprout2-1][2-1][zpos-1]=3.0e-6;
	YBR[iSprout3-1][2-1][zpos-1]=3.0e-6;
	YBR[iSprout4-1][2-1][zpos-1]=3.0e-6;
	YBR[iSprout5-1][2-1][zpos-1]=3.0e-6;

/*	for (int PVLoop=1;PVLoop<=8;PVLoop++)
	{
		if (PVLoop==1){zpos=4;}
		else if (PVLoop==2){zpos=10;}
		else if (PVLoop==3){zpos=16;}
		else if (PVLoop==4){zpos=22;}
		else if (PVLoop==5){zpos=29;}
		else if (PVLoop==6){zpos=35;}
		else if (PVLoop==7){zpos=41;}
		else {zpos=47;}

	pFluid[LabY(iSprout1,2,zpos)-1]=10;
	pFluid[LabY(iSprout2,2,zpos)-1]=10;
	pFluid[LabY(iSprout3,2,zpos)-1]=10;
	pFluid[LabY(iSprout4,2,zpos)-1]=10;
	pFluid[LabY(iSprout5,2,zpos)-1]=10;

	pSprout[LabY(iSprout1,2,zpos)-1]=1;
	pSprout[LabY(iSprout2,2,zpos)-1]=1;
	pSprout[LabY(iSprout3,2,zpos)-1]=1;
	pSprout[LabY(iSprout4,2,zpos)-1]=1;
	pSprout[LabY(iSprout5,2,zpos)-1]=1;

	poleSprout[LabY(iSprout1,2,zpos)-1]=true;
	poleSprout[LabY(iSprout2,2,zpos)-1]=true;
	poleSprout[LabY(iSprout3,2,zpos)-1]=true;
	poleSprout[LabY(iSprout4,2,zpos)-1]=true;
	poleSprout[LabY(iSprout5,2,zpos)-1]=true;

	pPericyteDensity[LabY(iSprout1,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout2,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout3,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout4,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout5,2,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabY(iSprout1,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout2,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout3,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout4,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout5,2,zpos)-1]=1;
	}
*/	
//===================================================================

	//2nd vessel

	if	(b_venousIncluded)
	{
		if (m_nz==1) { zpos=1; } else { zpos=int(9*m_nz/10); }//45; }//int(m_nz/2); }

		int iSprout1a=(int)floor(1.0*(m_nx+1)/6.0+0.5);	//NINT
		int iSprout2a=(int)floor(2.0*(m_nx+1)/6.0+0.5);	//NINT
		int iSprout3a=(int)floor(3.0*(m_nx+1)/6.0+0.5);	//NINT
		int iSprout4a=(int)floor(4.0*(m_nx+1)/6.0+0.5);	//NINT
		int iSprout5a=(int)floor(5.0*(m_nx+1)/6.0+0.5);	//NINT

		if	(b_HexNetwork)	{iSprout1a=(int)floor(1.0*(m_nx+1)/6.0+0.5)+1;}	//correction so that sprout does not
																			//lie on pFluid=66 bond

		pFluid[LabY(iSprout1a,m_ny-1,zpos)-1]=10;
		pFluid[LabY(iSprout2a,m_ny-1,zpos)-1]=10;
		pFluid[LabY(iSprout3a,m_ny-1,zpos)-1]=10;
		pFluid[LabY(iSprout4a,m_ny-1,zpos)-1]=10;
		pFluid[LabY(iSprout5a,m_ny-1,zpos)-1]=10;

		pSprout[LabY(iSprout1a,m_ny-1,zpos)-1]=1;
		pSprout[LabY(iSprout2a,m_ny-1,zpos)-1]=1;
		pSprout[LabY(iSprout3a,m_ny-1,zpos)-1]=1;
		pSprout[LabY(iSprout4a,m_ny-1,zpos)-1]=1;
		pSprout[LabY(iSprout5a,m_ny-1,zpos)-1]=1;

		poleSprout[LabY(iSprout1a,m_ny-1,zpos)-1]=false;	//direction of these sprouts is away from lower boundary
		poleSprout[LabY(iSprout2a,m_ny-1,zpos)-1]=false;
		poleSprout[LabY(iSprout3a,m_ny-1,zpos)-1]=false;
		poleSprout[LabY(iSprout4a,m_ny-1,zpos)-1]=false;
		poleSprout[LabY(iSprout5a,m_ny-1,zpos)-1]=false;

		pPericyteDensity[LabY(iSprout1a,m_ny-1,zpos)-1]=PericyteDensityInit;
		pPericyteDensity[LabY(iSprout2a,m_ny-1,zpos)-1]=PericyteDensityInit;
		pPericyteDensity[LabY(iSprout3a,m_ny-1,zpos)-1]=PericyteDensityInit;
		pPericyteDensity[LabY(iSprout4a,m_ny-1,zpos)-1]=PericyteDensityInit;
		pPericyteDensity[LabY(iSprout5a,m_ny-1,zpos)-1]=PericyteDensityInit;

		pArterialVenousID[LabY(iSprout1a,m_ny-1,zpos)-1]=-1;
		pArterialVenousID[LabY(iSprout2a,m_ny-1,zpos)-1]=-1;
		pArterialVenousID[LabY(iSprout3a,m_ny-1,zpos)-1]=-1;
		pArterialVenousID[LabY(iSprout4a,m_ny-1,zpos)-1]=-1;
		pArterialVenousID[LabY(iSprout5a,m_ny-1,zpos)-1]=-1;

		YBR[iSprout1a-1][m_ny-1-1][zpos-1]=3.0e-6;
		YBR[iSprout2a-1][m_ny-1-1][zpos-1]=3.0e-6;
		YBR[iSprout3a-1][m_ny-1-1][zpos-1]=3.0e-6;
		YBR[iSprout4a-1][m_ny-1-1][zpos-1]=3.0e-6;
		YBR[iSprout5a-1][m_ny-1-1][zpos-1]=3.0e-6;

/*		for (int PVLoop=1;PVLoop<=8;PVLoop++)
		{
			if (PVLoop==1){zpos=4;}
			else if (PVLoop==2){zpos=10;}
			else if (PVLoop==3){zpos=16;}
			else if (PVLoop==4){zpos=22;}
			else if (PVLoop==5){zpos=29;}
			else if (PVLoop==6){zpos=35;}
			else if (PVLoop==7){zpos=41;}
			else {zpos=47;}

			pFluid[LabY(iSprout1a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout2a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout3a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout4a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout5a,m_ny-1,zpos)-1]=10;

			pSprout[LabY(iSprout1a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout2a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout3a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout4a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout5a,m_ny-1,zpos)-1]=1;

			poleSprout[LabY(iSprout1a,m_ny-1,zpos)-1]=false;	//direction of these sprouts is away from lower boundary
			poleSprout[LabY(iSprout2a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout3a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout4a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout5a,m_ny-1,zpos)-1]=false;

			pPericyteDensity[LabY(iSprout1a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout2a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout3a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout4a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout5a,m_ny-1,zpos)-1]=PericyteDensityInit;

			pArterialVenousID[LabY(iSprout1a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout2a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout3a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout4a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout5a,m_ny-1,zpos)-1]=-1;
		}
*/	}
//-----------------------------------------------

	if (m_nz==1) { zpos=1; } else { zpos=int(m_nz/10); }//5; }//int(m_nz/2); }

	int jSprout1=(int)floor(1.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout2=(int)floor(2.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout3=(int)floor(3.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout4=(int)floor(4.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout5=(int)floor(5.0*(m_ny)/6.0+0.5);	//NINT

	pFluid[LabX(2,jSprout1,zpos)-1]=10;
	pFluid[LabX(2,jSprout2,zpos)-1]=10;
	pFluid[LabX(2,jSprout3,zpos)-1]=10;
	pFluid[LabX(2,jSprout4,zpos)-1]=10;
	pFluid[LabX(2,jSprout5,zpos)-1]=10;

	pSprout[LabX(2,jSprout1,zpos)-1]=1;
	pSprout[LabX(2,jSprout2,zpos)-1]=1;
	pSprout[LabX(2,jSprout3,zpos)-1]=1;
	pSprout[LabX(2,jSprout4,zpos)-1]=1;
	pSprout[LabX(2,jSprout5,zpos)-1]=1;

	poleSprout[LabX(2,jSprout1,zpos)-1]=true;
	poleSprout[LabX(2,jSprout2,zpos)-1]=true;
	poleSprout[LabX(2,jSprout3,zpos)-1]=true;
	poleSprout[LabX(2,jSprout4,zpos)-1]=true;
	poleSprout[LabX(2,jSprout5,zpos)-1]=true;

	pPericyteDensity[LabX(2,jSprout1,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout3,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout4,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout5,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabX(2,jSprout1,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout2,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout3,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout4,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout5,zpos)-1]=1;

	XBR[2-1][jSprout1-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout2-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout3-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout4-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout5-1][zpos-1]=3.0e-6;

//-----------------------------------------------
	if (m_nz==1) { zpos=1; } else { zpos=int(m_nz/10); }//5; }//int(m_nz/2); }

	int jSprout1a=(int)floor(1.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout2a=(int)floor(2.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout3a=(int)floor(3.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout4a=(int)floor(4.0*(m_ny)/6.0+0.5);	//NINT
	int jSprout5a=(int)floor(5.0*(m_ny)/6.0+0.5);	//NINT

	pFluid[LabX(m_nx-1,jSprout1a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout2a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout3a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout4a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout5a,zpos)-1]=10;

	pSprout[LabX(m_nx-1,jSprout1a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout2a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout3a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout4a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout5a,zpos)-1]=1;

	poleSprout[LabX(m_nx-1,jSprout1a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout2a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout3a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout4a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout5a,zpos)-1]=false;

	pPericyteDensity[LabX(m_nx-1,jSprout1a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout2a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout3a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout4a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout5a,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabX(m_nx-1,jSprout1a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout2a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout3a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout4a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout5a,zpos)-1]=-1;

	XBR[m_nx-1-1][jSprout1a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout2a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout3a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout4a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout5a-1][zpos-1]=3.0e-6;

//-----------------------------------------------
/*	int k=m_nz;
	int j=2;

	for	(int i=1;i<=46;i++)
	{
		int nbx=LabX(i,j,k);
		pFluid[nbx-1]=10;
	}

	for	(int i=55;i<=m_nx+1;i++)
	{
		int nbx=LabX(i,j,k);
		pFluid[nbx-1]=10;
	}

	int iSprout1=46;	//NINT
	int iSprout2=54;	//NINT

	pFluid[LabY(iSprout1,j+1,k)-1]=10;
	pFluid[LabY(iSprout2,j+1,k)-1]=10;
	
	pSprout[LabY(iSprout1,j+1,k)-1]=1;
	pSprout[LabY(iSprout2,j+1,k)-1]=1;
	
	poleSprout[LabY(iSprout1,j+1,k)-1]=true;
	poleSprout[LabY(iSprout2,j+1,k)-1]=true;
*/	
//====================================================================
}

//***********************************************
//==========================================
void CAngioNetDlg::AssignInitialSprouts2()
//==========================================
{

//----------No sprouts initially---------------
	for (int nn=1;nn<=Nbond;nn++) { pSprout[nn-1]=0; }

	int zpos;
	if (m_nz==1) { zpos=1; } else {zpos=int(m_nz/2); }

//--------Now assign sprout tips----------------
	//int iSprout1=(int)floor(1.0*(m_nx+1)/6.0+0.5);	//NINT
	//int iSprout2=(int)floor(2.0*(m_nx+1)/6.0+0.5);
	//int iSprout3=(int)floor(3.0*(m_nx+1)/6.0+0.5);
	//int iSprout4=(int)floor(4.0*(m_nx+1)/6.0+0.5);
	//int iSprout5=(int)floor(5.0*(m_nx+1)/6.0+0.5);

	int iSprout1=(int)floor(1.0*(m_nx+1)/11.0+0.5);	//NINT
	int iSprout2=(int)floor(2.0*(m_nx+1)/11.0+0.5);	//NINT
	int iSprout3=(int)floor(3.0*(m_nx+1)/11.0+0.5);	//NINT
	int iSprout4=(int)floor(4.0*(m_nx+1)/11.0+0.5);	//NINT
	int iSprout5=(int)floor(5.0*(m_nx+1)/11.0+0.5);	//NINT
	int iSprout6=(int)floor(6.0*(m_nx+1)/11.0+0.5);
	int iSprout7=(int)floor(7.0*(m_nx+1)/11.0+0.5);
	int iSprout8=(int)floor(8.0*(m_nx+1)/11.0+0.5);
	int iSprout9=(int)floor(9.0*(m_nx+1)/11.0+0.5);
	int iSprout10=(int)floor(10.0*(m_nx+1)/11.0+0.5);

	if	(b_HexNetwork)	{
							iSprout2=(int)floor(2.0*(m_nx+1)/11.0+0.5)+1;	//corrections so that
							iSprout3=(int)floor(3.0*(m_nx+1)/11.0+0.5)-1;	//sprouts do not lie
							iSprout5=(int)floor(5.0*(m_nx+1)/11.0+0.5)-1;	//on pFluid=66 bonds,
							iSprout7=(int)floor(7.0*(m_nx+1)/11.0+0.5)-1;	//and also alternate
							iSprout9=(int)floor(9.0*(m_nx+1)/11.0+0.5)+1;	//direction
							iSprout10=(int)floor(10.0*(m_nx+1)/11.0+0.5)-1;
						}	
	
	pFluid[LabY(iSprout1,2,zpos)-1]=10;
	pFluid[LabY(iSprout2,2,zpos)-1]=10;
	pFluid[LabY(iSprout3,2,zpos)-1]=10;
	pFluid[LabY(iSprout4,2,zpos)-1]=10;
	pFluid[LabY(iSprout5,2,zpos)-1]=10;
	pFluid[LabY(iSprout6,2,zpos)-1]=10;
	pFluid[LabY(iSprout7,2,zpos)-1]=10;
	pFluid[LabY(iSprout8,2,zpos)-1]=10;
	pFluid[LabY(iSprout9,2,zpos)-1]=10;
	pFluid[LabY(iSprout10,2,zpos)-1]=10;

	pSprout[LabY(iSprout1,2,zpos)-1]=1;
	pSprout[LabY(iSprout2,2,zpos)-1]=1;
	pSprout[LabY(iSprout3,2,zpos)-1]=1;
	pSprout[LabY(iSprout4,2,zpos)-1]=1;
	pSprout[LabY(iSprout5,2,zpos)-1]=1;
	pSprout[LabY(iSprout6,2,zpos)-1]=1;
	pSprout[LabY(iSprout7,2,zpos)-1]=1;
	pSprout[LabY(iSprout8,2,zpos)-1]=1;
	pSprout[LabY(iSprout9,2,zpos)-1]=1;
	pSprout[LabY(iSprout10,2,zpos)-1]=1;

	poleSprout[LabY(iSprout1,2,zpos)-1]=true;
	poleSprout[LabY(iSprout2,2,zpos)-1]=true;
	poleSprout[LabY(iSprout3,2,zpos)-1]=true;
	poleSprout[LabY(iSprout4,2,zpos)-1]=true;
	poleSprout[LabY(iSprout5,2,zpos)-1]=true;
	poleSprout[LabY(iSprout6,2,zpos)-1]=true;
	poleSprout[LabY(iSprout7,2,zpos)-1]=true;
	poleSprout[LabY(iSprout8,2,zpos)-1]=true;
	poleSprout[LabY(iSprout9,2,zpos)-1]=true;
	poleSprout[LabY(iSprout10,2,zpos)-1]=true;

	pPericyteDensity[LabY(iSprout1,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout2,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout3,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout4,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout5,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout6,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout7,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout8,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout9,2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabY(iSprout10,2,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabY(iSprout1,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout2,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout3,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout4,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout5,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout6,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout7,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout8,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout9,2,zpos)-1]=1;
	pArterialVenousID[LabY(iSprout10,2,zpos)-1]=1;

	YBR[2-1][iSprout1-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout2-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout3-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout4-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout5-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout6-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout7-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout8-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout9-1][zpos-1]=3.0e-6;
	YBR[2-1][iSprout10-1][zpos-1]=3.0e-6;
//--------------------------------------------------

	//2nd arteriole=============
	if	(b_venousIncluded)
		{
			int iSprout1a=(int)floor(1.0*(m_nx+1)/11.0+0.5);	//NINT
			int iSprout2a=(int)floor(2.0*(m_nx+1)/11.0+0.5);	//NINT
			int iSprout3a=(int)floor(3.0*(m_nx+1)/11.0+0.5);	//NINT
			int iSprout4a=(int)floor(4.0*(m_nx+1)/11.0+0.5);	//NINT
			int iSprout5a=(int)floor(5.0*(m_nx+1)/11.0+0.5);	//NINT
			int iSprout6a=(int)floor(6.0*(m_nx+1)/11.0+0.5);
			int iSprout7a=(int)floor(7.0*(m_nx+1)/11.0+0.5);
			int iSprout8a=(int)floor(8.0*(m_nx+1)/11.0+0.5);
			int iSprout9a=(int)floor(9.0*(m_nx+1)/11.0+0.5);
			int iSprout10a=(int)floor(10.0*(m_nx+1)/11.0+0.5);

			if	(b_HexNetwork)	{
									iSprout2a=(int)floor(2.0*(m_nx+1)/11.0+0.5)+1;	//corrections so that
									iSprout3a=(int)floor(3.0*(m_nx+1)/11.0+0.5)-1;	//sprouts do not lie
									iSprout5a=(int)floor(5.0*(m_nx+1)/11.0+0.5)-1;	//on pFluid=66 bonds,
									iSprout7a=(int)floor(7.0*(m_nx+1)/11.0+0.5)-1;	//and also alternate
									iSprout9a=(int)floor(9.0*(m_nx+1)/11.0+0.5)+1;	//direction
									iSprout10a=(int)floor(10.0*(m_nx+1)/11.0+0.5)-1;
								}	

			pFluid[LabY(iSprout1a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout2a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout3a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout4a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout5a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout6a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout7a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout8a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout9a,m_ny-1,zpos)-1]=10;
			pFluid[LabY(iSprout10a,m_ny-1,zpos)-1]=10;

			pSprout[LabY(iSprout1a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout2a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout3a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout4a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout5a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout6a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout7a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout8a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout9a,m_ny-1,zpos)-1]=1;
			pSprout[LabY(iSprout10a,m_ny-1,zpos)-1]=1;

			poleSprout[LabY(iSprout1a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout2a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout3a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout4a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout5a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout6a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout7a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout8a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout9a,m_ny-1,zpos)-1]=false;
			poleSprout[LabY(iSprout10a,m_ny-1,zpos)-1]=false;

			pPericyteDensity[LabY(iSprout1a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout2a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout3a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout4a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout5a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout6a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout7a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout8a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout9a,m_ny-1,zpos)-1]=PericyteDensityInit;
			pPericyteDensity[LabY(iSprout10a,m_ny-1,zpos)-1]=PericyteDensityInit;

			pArterialVenousID[LabY(iSprout1a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout2a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout3a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout4a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout5a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout6a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout7a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout8a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout9a,m_ny-1,zpos)-1]=-1;
			pArterialVenousID[LabY(iSprout10a,m_ny-1,zpos)-1]=-1;

			YBR[m_ny-1-1][iSprout1a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout2a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout3a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout4a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout5a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout6a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout7a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout8a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout9a-1][zpos-1]=3.0e-6;
			YBR[m_ny-1-1][iSprout10a-1][zpos-1]=3.0e-6;
		}
	//=======================================

	if (m_nz==1) { zpos=1; } else { zpos=int(m_nz/10); }//5; }//int(m_nz/2); }

	int jSprout1=(int)floor(1.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout2=(int)floor(2.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout3=(int)floor(3.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout4=(int)floor(4.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout5=(int)floor(5.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout6=(int)floor(6.0*(m_nx+1)/11.0+0.5);
	int jSprout7=(int)floor(7.0*(m_nx+1)/11.0+0.5);
	int jSprout8=(int)floor(8.0*(m_nx+1)/11.0+0.5);
	int jSprout9=(int)floor(9.0*(m_nx+1)/11.0+0.5);
	int jSprout10=(int)floor(10.0*(m_nx+1)/11.0+0.5);

	pFluid[LabX(2,jSprout1,zpos)-1]=10;
	pFluid[LabX(2,jSprout2,zpos)-1]=10;
	pFluid[LabX(2,jSprout3,zpos)-1]=10;
	pFluid[LabX(2,jSprout4,zpos)-1]=10;
	pFluid[LabX(2,jSprout5,zpos)-1]=10;
	pFluid[LabX(2,jSprout6,zpos)-1]=10;
	pFluid[LabX(2,jSprout7,zpos)-1]=10;
	pFluid[LabX(2,jSprout8,zpos)-1]=10;
	pFluid[LabX(2,jSprout9,zpos)-1]=10;
	pFluid[LabX(2,jSprout10,zpos)-1]=10;

	pSprout[LabX(2,jSprout1,zpos)-1]=1;
	pSprout[LabX(2,jSprout2,zpos)-1]=1;
	pSprout[LabX(2,jSprout3,zpos)-1]=1;
	pSprout[LabX(2,jSprout4,zpos)-1]=1;
	pSprout[LabX(2,jSprout5,zpos)-1]=1;
	pSprout[LabX(2,jSprout6,zpos)-1]=1;
	pSprout[LabX(2,jSprout7,zpos)-1]=1;
	pSprout[LabX(2,jSprout8,zpos)-1]=1;
	pSprout[LabX(2,jSprout9,zpos)-1]=1;
	pSprout[LabX(2,jSprout10,zpos)-1]=1;

	poleSprout[LabX(2,jSprout1,zpos)-1]=true;
	poleSprout[LabX(2,jSprout2,zpos)-1]=true;
	poleSprout[LabX(2,jSprout3,zpos)-1]=true;
	poleSprout[LabX(2,jSprout4,zpos)-1]=true;
	poleSprout[LabX(2,jSprout5,zpos)-1]=true;
	poleSprout[LabX(2,jSprout6,zpos)-1]=true;
	poleSprout[LabX(2,jSprout7,zpos)-1]=true;
	poleSprout[LabX(2,jSprout8,zpos)-1]=true;
	poleSprout[LabX(2,jSprout9,zpos)-1]=true;
	poleSprout[LabX(2,jSprout10,zpos)-1]=true;

	pPericyteDensity[LabX(2,jSprout1,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout2,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout3,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout4,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout5,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout6,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout7,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout8,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout9,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(2,jSprout10,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabX(2,jSprout1,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout2,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout3,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout4,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout5,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout6,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout7,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout8,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout9,zpos)-1]=1;
	pArterialVenousID[LabX(2,jSprout10,zpos)-1]=1;

	XBR[2-1][jSprout1-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout2-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout3-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout4-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout5-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout6-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout7-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout8-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout9-1][zpos-1]=3.0e-6;
	XBR[2-1][jSprout10-1][zpos-1]=3.0e-6;

//-----------------------------------------------
	if (m_nz==1) { zpos=1; } else { zpos=int(m_nz/10); }//5; }//int(m_nz/2); }

	int jSprout1a=(int)floor(1.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout2a=(int)floor(2.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout3a=(int)floor(3.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout4a=(int)floor(4.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout5a=(int)floor(5.0*(m_nx+1)/11.0+0.5);	//NINT
	int jSprout6a=(int)floor(6.0*(m_nx+1)/11.0+0.5);
	int jSprout7a=(int)floor(7.0*(m_nx+1)/11.0+0.5);
	int jSprout8a=(int)floor(8.0*(m_nx+1)/11.0+0.5);
	int jSprout9a=(int)floor(9.0*(m_nx+1)/11.0+0.5);
	int jSprout10a=(int)floor(10.0*(m_nx+1)/11.0+0.5);

	pFluid[LabX(m_nx-1,jSprout1a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout2a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout3a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout4a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout5a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout6a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout7a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout8a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout9a,zpos)-1]=10;
	pFluid[LabX(m_nx-1,jSprout10a,zpos)-1]=10;

	pSprout[LabX(m_nx-1,jSprout1a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout2a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout3a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout4a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout5a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout6a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout7a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout8a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout9a,zpos)-1]=1;
	pSprout[LabX(m_nx-1,jSprout10a,zpos)-1]=1;

	poleSprout[LabX(m_nx-1,jSprout1a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout2a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout3a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout4a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout5a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout6a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout7a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout8a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout9a,zpos)-1]=false;
	poleSprout[LabX(m_nx-1,jSprout10a,zpos)-1]=false;

	pPericyteDensity[LabX(m_nx-1,jSprout1a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout2a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout3a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout4a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout5a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout6a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout7a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout8a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout9a,zpos)-1]=PericyteDensityInit;
	pPericyteDensity[LabX(m_nx-1,jSprout10a,zpos)-1]=PericyteDensityInit;

	pArterialVenousID[LabX(m_nx-1,jSprout1a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout2a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout3a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout4a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout5a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout6a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout7a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout8a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout9a,zpos)-1]=-1;
	pArterialVenousID[LabX(m_nx-1,jSprout10a,zpos)-1]=-1;

	XBR[m_nx-1-1][jSprout1a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout2a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout3a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout4a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout5a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout6a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout7a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout8a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout9a-1][zpos-1]=3.0e-6;
	XBR[m_nx-1-1][jSprout10a-1][zpos-1]=3.0e-6;

}

//***********************************************
//=====================================
void CAngioNetDlg::DrawBackground()
//=====================================
{
/*
//Get a device context first
	CClientDC dlgDC(this);

//Get a white brush for network window (changed to black??)
	CBrush brushWhite(RGB(0,0,0));
	CBrush *pOldBrush=NULL;
	pOldBrush=dlgDC.SelectObject(&brushWhite);

//Set window parameters
	int xMin=209,xMax=662,yMin=13,yMax=379;

//Draw the white background
	dlgDC.Rectangle(xMin,yMin,xMax,yMax);
*/

//Get a device context first
	CClientDC dlgDC(this);

//Get a black brush for network window (changed to black??)
//	CBrush brushBlack(RGB(0,0,0));
//	CBrush *pOldBrush=NULL;
//	pOldBrush=dlgDC.SelectObject(&brushBlack);

//Set window parameters
//	int xMin=242,xMax=690,yMin=13,yMax=352;

//Draw the white background
//	dlgDC.Rectangle(xMin,yMin,xMax,yMax);

	dlgDC.SelectStockObject(BLACK_BRUSH);
	dlgDC.Rectangle(m_Canvas);
	
}


//***********************************************************

//=================================================================
void CAngioNetDlg::MDFConcGraphics(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//=================================================================
 {
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,150,150),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	//COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penColour(PS_SOLID,1,colour);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("FLOW TIME %f",flowTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//-----Draw Wound Margin if applicable-----------
	memDC.SelectObject(&penGrey1);
 	CBrush brGrey(RGB(50,50,50));

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------

//-------------------------
  runningMDFConcMAX=1.0e-7;
//-------------------------

//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	memDC.SelectObject(&penBlack);

	if		(vMDFConc[i-1][j-1][k-1]> 0.2*runningMDFConcMAX &&  
			 vMDFConc[i-1][j-1][k-1]<=0.4*runningMDFConcMAX) {memDC.SelectObject(&penDarkBlue);}
	else if (vMDFConc[i-1][j-1][k-1]> 0.4*runningMDFConcMAX &&
			 vMDFConc[i-1][j-1][k-1]<=0.6*runningMDFConcMAX) {memDC.SelectObject(&penLightBlue);}
	else if (vMDFConc[i-1][j-1][k-1]> 0.6*runningMDFConcMAX &&
			 vMDFConc[i-1][j-1][k-1]<=0.8*runningMDFConcMAX) {memDC.SelectObject(&penWhite);}
	else if (vMDFConc[i-1][j-1][k-1]> 0.8*runningMDFConcMAX &&
			 vMDFConc[i-1][j-1][k-1]<=0.9*runningMDFConcMAX) {memDC.SelectObject(&penPink);}
	else if (vMDFConc[i-1][j-1][k-1]> 0.9*runningMDFConcMAX) {memDC.SelectObject(&penRed);}

/*
//-----------------------------
  //if		(vMDFConc[i-1][j-1][k-1] <=0.25*runningMDFCellMAX) {memDC.SelectObject(&penDarkBlue);}
	if      (vMDFConc[i-1][j-1][k-1] > 0.25*runningMDFConcMAX &&
		     vMDFConc[i-1][j-1][k-1] <= 0.5*runningMDFConcMAX)  {memDC.SelectObject(&penLightBlue);}
	else if (vMDFConc[i-1][j-1][k-1] > 0.5*runningMDFConcMAX &&
		     vMDFConc[i-1][j-1][k-1] <= 0.9*runningMDFConcMAX)  {memDC.SelectObject(&penWhite);}
	else if (vMDFConc[i-1][j-1][k-1] > 0.9*runningMDFConcMAX)   {memDC.SelectObject(&penPink);}
//-------------------------------
*/
	//if (pFluid[nbx-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nby-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nbz-1]==66) { graphicsDC.SelectObject(&penBlack); }

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

//---------------------------======
	if		(vMDFConc[i-1][j-1][k-1]> 0.2*runningMDFConcMAX)
	{
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the z-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
		
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}
	//----------------------------======
	
	}}}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//***********************************************************

//=================================================================
void CAngioNetDlg::MDFConcGraphics2(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//=================================================================
 {
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,150,150),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penGrey1(PS_SOLID,1,Grey1);

//Select the pen into the DC (Device Context)
//	CPen *pOldPen=NULL;
//	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("FLOW TIME %f",flowTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//-----Draw Wound Margin if applicable-----------
	memDC.SelectObject(&penGrey1);
 	CBrush brGrey(RGB(50,50,50));

/*	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}
*/
//---------------------------------------
	int x1,x2,y1,y2;

//-------------------------
//  runningMDFConcMAX=1.0e-7;
//-------------------------

	if (m_nz==1)
	{
		//Draw the network
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
			
					//memDC.SelectObject(&penBlack);
					choiceColour=Black;

					if		(vMDFConc[i-1][j-1][k-1]> 0.2*runningMDFConcMAX &&  
								vMDFConc[i-1][j-1][k-1]<=0.4*runningMDFConcMAX) {choiceColour=DarkBlue;}
					else if (vMDFConc[i-1][j-1][k-1]> 0.4*runningMDFConcMAX &&
								vMDFConc[i-1][j-1][k-1]<=0.6*runningMDFConcMAX) {choiceColour=LightBlue;}
					else if (vMDFConc[i-1][j-1][k-1]> 0.6*runningMDFConcMAX &&
								vMDFConc[i-1][j-1][k-1]<=0.8*runningMDFConcMAX) {choiceColour=White;}
					else if (vMDFConc[i-1][j-1][k-1]> 0.8*runningMDFConcMAX &&
								vMDFConc[i-1][j-1][k-1]<=0.9*runningMDFConcMAX) {choiceColour=pink;}
					else if (vMDFConc[i-1][j-1][k-1]> 0.9*runningMDFConcMAX) {choiceColour=red;}
					
					x1=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)((XPOS[i][j][k]-1)*networkWidth/m_nx);
					y1=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny);
					x2=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)(XPOS[i][j][k]*networkWidth/m_nx);
					y2=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)((YPOS[i][j][k]-1)*networkWidth/m_ny);

					memDC.FillSolidRect((int)x1,(int)y1,(int)( fabs(double(x1-x2)) ),(int)( fabs(double(y1-y2)+1) ),choiceColour);

//I've added the +1 just to stop black lines on graphics
	/*
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	*/
		}}}
	}

	else
	{
		//Draw the network
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (vMDFConc[i-1][j-1][k-1]>0.2*runningMDFConcMAX)
					{
						if		(vMDFConc[i-1][j-1][k-1]> 0.2*runningMDFConcMAX &&  
									vMDFConc[i-1][j-1][k-1]<=0.4*runningMDFConcMAX) {choiceColour=DarkBlue;}
						else if (vMDFConc[i-1][j-1][k-1]> 0.4*runningMDFConcMAX &&
									vMDFConc[i-1][j-1][k-1]<=0.6*runningMDFConcMAX) {choiceColour=LightBlue;}
						else if (vMDFConc[i-1][j-1][k-1]> 0.6*runningMDFConcMAX &&
									vMDFConc[i-1][j-1][k-1]<=0.8*runningMDFConcMAX) {choiceColour=White;}
						else if (vMDFConc[i-1][j-1][k-1]> 0.8*runningMDFConcMAX &&
									vMDFConc[i-1][j-1][k-1]<=0.9*runningMDFConcMAX) {choiceColour=pink;}
						else if (vMDFConc[i-1][j-1][k-1]> 0.9*runningMDFConcMAX) {choiceColour=red;}

						CBrush brushChoiceColour(choiceColour);
						memDC.SelectObject(&brushChoiceColour);

//-----------------------------------------------

						CPoint cubePts[5];	

						//---Top Face------------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Side Face-----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Front Face----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();
					}
		}}}
	}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

 //---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
//	memDC.SelectObject(pOldPen);
}


//***********************************************************

//=================================================================
void CAngioNetDlg::TAFConcGraphics(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//=================================================================
 {
//Get a device context first
/*	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	//COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_DASH,2,RGB(150,150,150));
	CPen penColour(PS_SOLID,1,colour);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penGrey2);

//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(150,150,150));

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------

	pOldPen=memDC.SelectObject(&penRed);

//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	//int nbx=LabX(i,j,k);
	//int nby=LabY(i,j,k);
	//int nbz=LabZ(i,j,k);

	memDC.SelectObject(&penBlack);

	if (vTAFConc[i-1][j-1][k-1] <= 0.3*runningTAFConcMAX)      {memDC.SelectObject(&penDarkBlue);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.3*runningTAFConcMAX &&
			 vTAFConc[i-1][j-1][k-1] <= 0.5*runningTAFConcMAX) {memDC.SelectObject(&penLightBlue);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.5*runningTAFConcMAX &&
			 vTAFConc[i-1][j-1][k-1] <= 0.7*runningTAFConcMAX) {memDC.SelectObject(&penWhite);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.7*runningTAFConcMAX &&
			 vTAFConc[i-1][j-1][k-1] <= 0.8*runningTAFConcMAX) {memDC.SelectObject(&penPink);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.8*runningTAFConcMAX)  {memDC.SelectObject(&penRed);}
	

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	// draw colour segment in the y-direction
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	// draw colour segment in the z-direction
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}}}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
*/
	//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penGrey1(PS_SOLID,1,Grey1);

//Select the pen into the DC (Device Context)
//	CPen *pOldPen=NULL;
//	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("FLOW TIME %f",flowTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)((networkWidth/max(1.0+0.7*cos(dAngle),1.0+0.7*sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=max(int(0.7*networkWidth/(max(max(m_nx, m_ny),m_nz))),1);}//

//-----Draw Wound Margin if applicable-----------
	memDC.SelectObject(&penGrey1);
 	CBrush brGrey(RGB(50,50,50));

/*	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}
*/
//---------------------------------------
	int x1,x2,y1,y2;

//-------------------------
//  runningMDFConcMAX=1.0e-7;
//-------------------------

	if (m_nz==1)
	{
		//Draw the network
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
			
					//memDC.SelectObject(&penBlack);
					choiceColour=Black;

/*					if		(vTAFConc[i-1][j-1][k-1]> 0.001*runningTAFConcMAX &&  
								vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX) {choiceColour=DarkBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&
								vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX) {choiceColour=LightBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&
								vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX) {choiceColour=White;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&
								vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {choiceColour=pink;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX) {choiceColour=red;}
*/
					if		(vTAFConc[i-1][j-1][k-1]> 0.001 &&  
								vTAFConc[i-1][j-1][k-1]<=0.2) {choiceColour=DarkBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.2 &&
								vTAFConc[i-1][j-1][k-1]<=0.4) {choiceColour=LightBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.4 &&
								vTAFConc[i-1][j-1][k-1]<=0.6) {choiceColour=White;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
								vTAFConc[i-1][j-1][k-1]<=0.8) {choiceColour=pink;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.8) {choiceColour=red;}
					
					x1=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)((XPOS[i][j][k]-1)*networkWidth/m_nx);
					y1=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny);
					x2=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)(XPOS[i][j][k]*networkWidth/m_nx);
					y2=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)((YPOS[i][j][k]-1)*networkWidth/m_ny);

					memDC.FillSolidRect((int)x1,(int)y1,(int)( fabs(double(x1-x2)) ),(int)( fabs(double(y1-y2)+1) ),choiceColour);

//I've added the +1 just to stop black lines on graphics
	/*
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	*/
		}}}
	}

	else
	{
		//Draw the network
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (i==m_nx/2 || j==m_ny/2 || k==m_nz/2)
					{
					if (vTAFConc[i-1][j-1][k-1]>0.001*runningTAFConcMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]> 0.001*runningTAFConcMAX &&  
									vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX) {choiceColour=DarkBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX) {choiceColour=LightBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX) {choiceColour=White;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {choiceColour=pink;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX) {choiceColour=red;}

						if		(vTAFConc[i-1][j-1][k-1]> 0.001 &&  
									vTAFConc[i-1][j-1][k-1]<=0.2) {choiceColour=DarkBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.2 &&
									vTAFConc[i-1][j-1][k-1]<=0.4) {choiceColour=LightBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.4 &&
									vTAFConc[i-1][j-1][k-1]<=0.6) {choiceColour=White;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
									vTAFConc[i-1][j-1][k-1]<=0.8) {choiceColour=pink;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.8) {choiceColour=red;}

						CBrush brushChoiceColour(choiceColour);
						memDC.SelectObject(&brushChoiceColour);

//-----------------------------------------------

						CPoint cubePts[5];	

						//---Top Face------------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Side Face-----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Front Face----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();
					}
					}
		}}}
	}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

 //---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
//	memDC.SelectObject(pOldPen);
}

 
//***********************************************************
//=================================================================
void CAngioNetDlg::FNConcGraphics(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//=================================================================
 {
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	//COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penColour(PS_SOLID,1,colour);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//	fibronectinConcMAX=constant;


			 
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	//int nbx=LabX(i,j,k);
	//int nby=LabY(i,j,k);
	//int nbz=LabZ(i,j,k);

	memDC.SelectObject(&penBlack);

	if (vFibronectinConc[i-1][j-1][k-1] <= 0.3*fibronectinConcMAX)      {memDC.SelectObject(&penDarkBlue);}

	else if (vFibronectinConc[i-1][j-1][k-1] > 0.3*fibronectinConcMAX &&
			 vFibronectinConc[i-1][j-1][k-1] <= 0.5*fibronectinConcMAX) {memDC.SelectObject(&penLightBlue);}

	else if (vFibronectinConc[i-1][j-1][k-1] > 0.5*fibronectinConcMAX &&
			 vFibronectinConc[i-1][j-1][k-1] <= 0.55*fibronectinConcMAX) {memDC.SelectObject(&penWhite);}

	else if (vFibronectinConc[i-1][j-1][k-1] > 0.55*fibronectinConcMAX &&
			 vFibronectinConc[i-1][j-1][k-1] <= 0.57*fibronectinConcMAX) {memDC.SelectObject(&penPink);}

	else if (vFibronectinConc[i-1][j-1][k-1] > 0.57*fibronectinConcMAX)  {memDC.SelectObject(&penRed);}
	

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	// draw colour segment in the y-direction
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	// draw colour segment in the z-direction
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}}}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}

 
//***********************************************************
//=================================================================
void CAngioNetDlg::ECDensityGraphics2(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//=================================================================
 {
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,100,100),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	//COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penColour(PS_SOLID,1,colour);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	//int nbx=LabX(i,j,k);
	//int nby=LabY(i,j,k);
	//int nbz=LabZ(i,j,k);

	memDC.SelectObject(&penBlack);
	//choiceColour=Black;

	//if (vEndoCellDensity[i-1][j-1][k-1] <= 0.25*runningEndoCellMAX)
	//{
	//	memDC.SelectObject(&penDarkBlue);
		//choiceColour=DarkBlue;
	//}
	if (vEndoCellDensity[i-1][j-1][k-1] > 0.25*runningEndoCellMAX &&
			 vEndoCellDensity[i-1][j-1][k-1] <= 0.5*runningEndoCellMAX)
	{
		memDC.SelectObject(&penLightBlue);
		//choiceColour=LightBlue;
	}
	else if (vEndoCellDensity[i-1][j-1][k-1] > 0.5*runningEndoCellMAX &&
			 vEndoCellDensity[i-1][j-1][k-1] <= 0.9*runningEndoCellMAX)
	{
		memDC.SelectObject(&penWhite);
		//choiceColour=White;
	}
	else if (vEndoCellDensity[i-1][j-1][k-1] > 0.9*runningEndoCellMAX)
	{
		memDC.SelectObject(&penPink);
		//choiceColour=pink;
	}

	//if (pFluid[nbx-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nby-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nbz-1]==66) { graphicsDC.SelectObject(&penBlack); }

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the z-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
		
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}}}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//==============================================================
void CAngioNetDlg::TracerGraphics2(int xMin, int xMax, int yMin, 
								  int yMax, int networkWidth, 
								  double deltaX, double deltaY)
//==============================================================
{

//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190);

//Define the pens 


	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);


//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

double	Bound1=2.0e-6,	//Normalises colours to Rmin and Rmax
		Bound2=4.0e-6,
		Bound3=7.0e-6,
		Bound4=10.0e-6;



//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

//x-pores

//Pen Widths
	int iLineWidth=1;
	if      (XBR[i-1][j-1][k-1]>Rmin  && XBR[i-1][j-1][k-1]<=Bound1) {iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>Bound1 && XBR[i-1][j-1][k-1]<=Bound2) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>Bound2 && XBR[i-1][j-1][k-1]<=Bound3) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>Bound3 && XBR[i-1][j-1][k-1]<=Bound4) { iLineWidth=2;}
	else if (XBR[i-1][j-1][k-1]>Bound4)                             { iLineWidth=3;}

	CPen penRed(PS_SOLID,iLineWidth,red);
	CPen penPink(PS_SOLID,iLineWidth,pink);
	CPen penGreen(PS_SOLID,iLineWidth,green);
	CPen penDarkBlue(PS_SOLID,iLineWidth,DarkBlue);
	CPen penLightBlue(PS_SOLID,iLineWidth,LightBlue);
	CPen penWhite(PS_SOLID,iLineWidth,White);
	 //penBlack(PS_SOLID,iLineWidth,Black);
	 //penGrey1(PS_SOLID,iLineWidth,Grey1);
	 //penGrey2(PS_SOLID,iLineWidth,Grey2);

  //if		(pXCON[i-1][j-1][k-1]<=0.001*ConMax)									{memDC.SelectObject(&penDarkBlue);}
    if		(pXCON[i-1][j-1][k-1]>0.001*ConMax && pXCON[i-1][j-1][k-1]<=0.1*ConMax) {memDC.SelectObject(&penLightBlue);}
	else if (pXCON[i-1][j-1][k-1]>0.1*ConMax   && pXCON[i-1][j-1][k-1]<=0.5*ConMax)	{memDC.SelectObject(&penWhite);}
	else if (pXCON[i-1][j-1][k-1]>0.5*ConMax   && pXCON[i-1][j-1][k-1]<=0.9*ConMax) {memDC.SelectObject(&penPink);}
	else if (pXCON[i-1][j-1][k-1]>0.9*ConMax   && pXCON[i-1][j-1][k-1]<=1.01*ConMax){memDC.SelectObject(&penRed);}
	else if (pXCON[i-1][j-1][k-1]>1.01*ConMax)										{memDC.SelectObject(&penBlack);}

	//if(pFluid[nbx-1]==66){memDC.SelectObject(&penBlack);}

	if (pXCON[i-1][j-1][k-1] > 0.001*ConMax)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	
	}

//y-pores--

//Pen Widths
	 iLineWidth=1;
	if      (YBR[i-1][j-1][k-1]>Rmin  && YBR[i-1][j-1][k-1]<=Bound1) {iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>Bound1 && YBR[i-1][j-1][k-1]<=Bound2) { iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>Bound2 && YBR[i-1][j-1][k-1]<=Bound3) { iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>Bound3 && YBR[i-1][j-1][k-1]<=Bound4) { iLineWidth=2;}
	else if (YBR[i-1][j-1][k-1]>Bound4)                             { iLineWidth=3;}

	CPen penRedy(PS_SOLID,iLineWidth,red);
	CPen penPinky(PS_SOLID,iLineWidth,pink);
	CPen penGreeny(PS_SOLID,iLineWidth,green);
	CPen penDarkBluey(PS_SOLID,iLineWidth,DarkBlue);
	CPen penLightBluey(PS_SOLID,iLineWidth,LightBlue);
	CPen penWhitey(PS_SOLID,iLineWidth,White);
	 //penBlack(PS_SOLID,iLineWidth,Black);
	 //penGrey1(PS_SOLID,iLineWidth,Grey1);
	 //penGrey2(PS_SOLID,iLineWidth,Grey2);

  //if    (pYCON[i-1][j-1][k-1]<=0.001*ConMax)										{memDC.SelectObject(&penDarkBlue);}
	if		(pYCON[i-1][j-1][k-1]>0.001*ConMax && pYCON[i-1][j-1][k-1]<=0.1*ConMax) {memDC.SelectObject(&penLightBluey);}
	else if (pYCON[i-1][j-1][k-1]>0.1*ConMax   && pYCON[i-1][j-1][k-1]<=0.5*ConMax) {memDC.SelectObject(&penWhitey);}
	else if (pYCON[i-1][j-1][k-1]>0.5*ConMax   && pYCON[i-1][j-1][k-1]<=0.9*ConMax) {memDC.SelectObject(&penPinky);}
	else if (pYCON[i-1][j-1][k-1]>0.9*ConMax   && pYCON[i-1][j-1][k-1]<=1.01*ConMax){memDC.SelectObject(&penRedy);}
	else if (pYCON[i-1][j-1][k-1]>1.01*ConMax)									    {memDC.SelectObject(&penBlack);}
	
	//if(pFluid[nby-1]==66){memDC.SelectObject(&penBlack);}

	if (pYCON[i-1][j-1][k-1] > 0.001*ConMax)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//z-pores--

	//Pen Widths
	 iLineWidth=1;
	if      (ZBR[i-1][j-1][k-1]>Rmin  && ZBR[i-1][j-1][k-1]<=Bound1) {iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>Bound1 && ZBR[i-1][j-1][k-1]<=Bound2) { iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>Bound2 && ZBR[i-1][j-1][k-1]<=Bound3) { iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>Bound3 && ZBR[i-1][j-1][k-1]<=Bound4) { iLineWidth=2;}
	else if (ZBR[i-1][j-1][k-1]>Bound4)                             { iLineWidth=3;}

	CPen penRedz(PS_SOLID,iLineWidth,red);
	CPen penPinkz(PS_SOLID,iLineWidth,pink);
	CPen penGreenz(PS_SOLID,iLineWidth,green);
	CPen penDarkBluez(PS_SOLID,iLineWidth,DarkBlue);
	CPen penLightBluez(PS_SOLID,iLineWidth,LightBlue);
	CPen penWhitez(PS_SOLID,iLineWidth,White);
	 //penBlack(PS_SOLID,iLineWidth,Black);
	 //penGrey1(PS_SOLID,iLineWidth,Grey1);
	 //penGrey2(PS_SOLID,iLineWidth,Grey2);
  //if		(pZCON[i-1][j-1][k-1]<=0.001*ConMax)									{memDC.SelectObject(&penDarkBlue);}
	if      (pZCON[i-1][j-1][k-1]>0.001*ConMax && pZCON[i-1][j-1][k-1]<=0.1*ConMax) {memDC.SelectObject(&penLightBluez);}
	else if (pZCON[i-1][j-1][k-1]>0.1*ConMax   && pZCON[i-1][j-1][k-1]<=0.5*ConMax) {memDC.SelectObject(&penWhitez);}
	else if (pZCON[i-1][j-1][k-1]>0.5*ConMax   && pZCON[i-1][j-1][k-1]<=0.9*ConMax) {memDC.SelectObject(&penPinkz);}
	else if (pZCON[i-1][j-1][k-1]>0.9*ConMax   && pZCON[i-1][j-1][k-1]<=1.01*ConMax){memDC.SelectObject(&penRedz);}
	else if (pZCON[i-1][j-1][k-1]>1.01*ConMax)										{memDC.SelectObject(&penBlack);}
	
	//if(pFluid[nbz-1]==66){memDC.SelectObject(&penBlack);}

	if (pZCON[i-1][j-1][k-1] > 0.001*ConMax)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}
		  }	//end i loop

//dangling x-pores
	int i=m_nx+1;
	int nbx=LabX(i,j,k);
//Pen Widths
	int iLineWidth=1;
	if      (XBR[i-1][j-1][k-1]>Rmin  && XBR[i-1][j-1][k-1]<=Bound1) {iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>Bound1 && XBR[i-1][j-1][k-1]<=Bound2) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>Bound2 && XBR[i-1][j-1][k-1]<=Bound3) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>Bound3 && XBR[i-1][j-1][k-1]<=Bound4) { iLineWidth=2;}
	else if (XBR[i-1][j-1][k-1]>Bound4)                             { iLineWidth=3;}

	CPen penRedx(PS_SOLID,iLineWidth,red);
	CPen penPinkx(PS_SOLID,iLineWidth,pink);
	CPen penGreenx(PS_SOLID,iLineWidth,green);
	CPen penDarkBluex(PS_SOLID,iLineWidth,DarkBlue);
	CPen penLightBluex(PS_SOLID,iLineWidth,LightBlue);
	CPen penWhitex(PS_SOLID,iLineWidth,White);
	 //penBlack(PS_SOLID,iLineWidth,Black);
	 //penGrey1(PS_SOLID,iLineWidth,Grey1);
	 //penGrey2(PS_SOLID,iLineWidth,Grey2);

  //if		(pXCON[i-1][j-1][k-1]<=0.001*ConMax)									{memDC.SelectObject(&penDarkBlue);}
	if		(pXCON[i-1][j-1][k-1]>0.001*ConMax && pXCON[i-1][j-1][k-1]<=0.1*ConMax) {memDC.SelectObject(&penLightBluex);}
	else if (pXCON[i-1][j-1][k-1]>0.1*ConMax   && pXCON[i-1][j-1][k-1]<=0.5*ConMax) {memDC.SelectObject(&penWhitex);}
	else if (pXCON[i-1][j-1][k-1]>0.5*ConMax   && pXCON[i-1][j-1][k-1]<=0.9*ConMax) {memDC.SelectObject(&penPinkx);}
	else if (pXCON[i-1][j-1][k-1]>0.9*ConMax   && pXCON[i-1][j-1][k-1]<=1.01*ConMax){memDC.SelectObject(&penRedx);}
	else if (pXCON[i-1][j-1][k-1]>1.01*ConMax)										{memDC.SelectObject(&penBlack);}
	
	//if(pFluid[nbx-1]==66){memDC.SelectObject(&penBlack);}

	if (pXCON[i-1][j-1][k-1] > 0.001*ConMax)
	{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	
	}
	   }}//end j- and k-loops

//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------
	
//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//======================================================================
void CAngioNetDlg::TracerAngioDrugGraphics(int xMin, int xMax, int yMin, 
								  int yMax, int networkWidth, 
								  double deltaX, double deltaY)
//======================================================================
{
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

//x-pores
  //if		(pXAngioDrug[i-1][j-1][k-1]<=0.001*AngioDrugMax)									{memDC.SelectObject(&penDarkBlue);}
    if		(pXAngioDrug[i-1][j-1][k-1]>0.001*AngioDrugMax && pXAngioDrug[i-1][j-1][k-1]<=0.1*AngioDrugMax) {memDC.SelectObject(&penLightBlue);}
	else if (pXAngioDrug[i-1][j-1][k-1]>0.1*AngioDrugMax   && pXAngioDrug[i-1][j-1][k-1]<=0.5*AngioDrugMax)	{memDC.SelectObject(&penWhite);}
	else if (pXAngioDrug[i-1][j-1][k-1]>0.5*AngioDrugMax   && pXAngioDrug[i-1][j-1][k-1]<=0.9*AngioDrugMax) {memDC.SelectObject(&penPink);}
	else if (pXAngioDrug[i-1][j-1][k-1]>0.9*AngioDrugMax   && pXAngioDrug[i-1][j-1][k-1]<=1.01*AngioDrugMax){memDC.SelectObject(&penRed);}
	else if (pXAngioDrug[i-1][j-1][k-1]>1.01*AngioDrugMax)										{memDC.SelectObject(&penBlack);}

	//if(pFluid[nbx-1]==66){memDC.SelectObject(&penBlack);}

	if (pXAngioDrug[i-1][j-1][k-1] > 0.001*AngioDrugMax)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--
  //if    (pYAngioDrug[i-1][j-1][k-1]<=0.001*AngioDrugMax)										{memDC.SelectObject(&penDarkBlue);}
	if		(pYAngioDrug[i-1][j-1][k-1]>0.001*AngioDrugMax && pYAngioDrug[i-1][j-1][k-1]<=0.1*AngioDrugMax) {memDC.SelectObject(&penLightBlue);}
	else if (pYAngioDrug[i-1][j-1][k-1]>0.1*AngioDrugMax   && pYAngioDrug[i-1][j-1][k-1]<=0.5*AngioDrugMax) {memDC.SelectObject(&penWhite);}
	else if (pYAngioDrug[i-1][j-1][k-1]>0.5*AngioDrugMax   && pYAngioDrug[i-1][j-1][k-1]<=0.9*AngioDrugMax) {memDC.SelectObject(&penPink);}
	else if (pYAngioDrug[i-1][j-1][k-1]>0.9*AngioDrugMax   && pYAngioDrug[i-1][j-1][k-1]<=1.01*AngioDrugMax){memDC.SelectObject(&penRed);}
	else if (pYAngioDrug[i-1][j-1][k-1]>1.01*AngioDrugMax)									    {memDC.SelectObject(&penBlack);}
	
	//if(pFluid[nby-1]==66){memDC.SelectObject(&penBlack);}

	if (pYAngioDrug[i-1][j-1][k-1] > 0.001*AngioDrugMax)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	
	}

//z-pores--
  //if		(pZAngioDrug[i-1][j-1][k-1]<=0.001*AngioDrugMax)									{memDC.SelectObject(&penDarkBlue);}
	if      (pZAngioDrug[i-1][j-1][k-1]>0.001*AngioDrugMax && pZAngioDrug[i-1][j-1][k-1]<=0.1*AngioDrugMax) {memDC.SelectObject(&penLightBlue);}
	else if (pZAngioDrug[i-1][j-1][k-1]>0.1*AngioDrugMax   && pZAngioDrug[i-1][j-1][k-1]<=0.5*AngioDrugMax) {memDC.SelectObject(&penWhite);}
	else if (pZAngioDrug[i-1][j-1][k-1]>0.5*AngioDrugMax   && pZAngioDrug[i-1][j-1][k-1]<=0.9*AngioDrugMax) {memDC.SelectObject(&penPink);}
	else if (pZAngioDrug[i-1][j-1][k-1]>0.9*AngioDrugMax   && pZAngioDrug[i-1][j-1][k-1]<=1.01*AngioDrugMax){memDC.SelectObject(&penRed);}
	else if (pZAngioDrug[i-1][j-1][k-1]>1.01*AngioDrugMax)										{memDC.SelectObject(&penBlack);}
	
	//if(pFluid[nbz-1]==66){memDC.SelectObject(&penBlack);}

	if (pZAngioDrug[i-1][j-1][k-1] > 0.001*AngioDrugMax)
	{

		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}
		  }	//end i loop

//dangling x-pores
	int i=m_nx+1;
	int nbx=LabX(i,j,k);

  //if		(pXAngioDrug[i-1][j-1][k-1]<=0.001*AngioDrugMax)									{memDC.SelectObject(&penDarkBlue);}
	if		(pXAngioDrug[i-1][j-1][k-1]>0.001*AngioDrugMax && pXAngioDrug[i-1][j-1][k-1]<=0.1*AngioDrugMax) {memDC.SelectObject(&penLightBlue);}
	else if (pXAngioDrug[i-1][j-1][k-1]>0.1*AngioDrugMax   && pXAngioDrug[i-1][j-1][k-1]<=0.5*AngioDrugMax) {memDC.SelectObject(&penWhite);}
	else if (pXAngioDrug[i-1][j-1][k-1]>0.5*AngioDrugMax   && pXAngioDrug[i-1][j-1][k-1]<=0.9*AngioDrugMax) {memDC.SelectObject(&penPink);}
	else if (pXAngioDrug[i-1][j-1][k-1]>0.9*AngioDrugMax   && pXAngioDrug[i-1][j-1][k-1]<=1.01*AngioDrugMax){memDC.SelectObject(&penRed);}
	else if (pXAngioDrug[i-1][j-1][k-1]>1.01*AngioDrugMax)										{memDC.SelectObject(&penBlack);}
	
	//if(pFluid[nbx-1]==66){memDC.SelectObject(&penBlack);}

	if (pXAngioDrug[i-1][j-1][k-1] > 0.001*AngioDrugMax)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}
	   }}//end j- and k-loops

//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------
	
//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//=================================================================
void CAngioNetDlg::HematocritGraphics(int xMin, int xMax, int yMin, 
								  int yMax, int networkWidth, 
								  double deltaX, double deltaY)
//=================================================================
{

//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),colour=RGB(255,0,0),White=RGB(255,255,255),
		     Black=RGB(0,0,0),Orange=RGB(255,128,0),
			 Grey1=RGB(170,170,170),Grey2=RGB(100,100,100),Yellow=RGB(255,255,0),
			 Grey3=RGB(64,64,64),Grey4=RGB(128,128,128);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,1,Orange);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penGrey3(PS_SOLID,1,Grey3);
	CPen penGrey4(PS_SOLID,1,Grey4);

	CBrush brushWhite(White);
	CBrush brushGrey3(Grey3);
	CBrush brushGrey4(Grey4);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);

//Print the loop variable
	CString myString;
	CString myString2;
	CString myString3;
	CString myString4;
	myString.Format("ANGIO %f",angiotime);
	myString2.Format("FLOW %f",flowTime);
	myString3.Format("%f",RateNutChangeMAX);
	myString4.Format("OXY %f",oxyTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(537,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(417,20,myString2);
	memDC.TextOut(230,20,myString3);
	memDC.TextOut(303,20,myString4);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)((networkWidth/max(1.0+0.7*cos(dAngle),1.0+0.7*sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=max(int(0.7*networkWidth/(max(max(m_nx, m_ny),m_nz))),1);}//


//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(50,50,50));

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------


//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

			  //Mike 09/10 - stimulus values read in as radii
/*				int RedShadeX=255-int(255*fabs(pXHem[i-1][j-1][k-1])/3.24);
				int RedShadeY=255-int(255*fabs(pYHem[i-1][j-1][k-1])/3.24);
				int RedShadeZ=255-int(255*fabs(pZHem[i-1][j-1][k-1])/3.24);
				
				COLORREF VesselShadeX=RGB(255,RedShadeX,RedShadeX);
				COLORREF VesselShadeY=RGB(255,RedShadeY,RedShadeY);
				COLORREF VesselShadeZ=RGB(255,RedShadeZ,RedShadeZ);
				CPen penVesselShadeX(PS_SOLID,2,VesselShadeX);
				CPen penVesselShadeY(PS_SOLID,2,VesselShadeY);
				CPen penVesselShadeZ(PS_SOLID,2,VesselShadeZ);
*/				

//z-pores
	if		(pZHem[i-1][j-1][k-1]<=0.1*MaxHt)								   {memDC.SelectObject(&penGrey2);}
	else if (pZHem[i-1][j-1][k-1]>0.1*MaxHt && pZHem[i-1][j-1][k-1]<=0.2*MaxHt){memDC.SelectObject(&penGrey1);}
	else if (pZHem[i-1][j-1][k-1]>0.2*MaxHt && pZHem[i-1][j-1][k-1]<=0.3*MaxHt){memDC.SelectObject(&penWhite);}
	else if (pZHem[i-1][j-1][k-1]>0.3*MaxHt && pZHem[i-1][j-1][k-1]<=0.4*MaxHt){memDC.SelectObject(&penYellow);}
	else if (pZHem[i-1][j-1][k-1]>0.4*MaxHt && pZHem[i-1][j-1][k-1]<=0.5*MaxHt){memDC.SelectObject(&penOrange);}
	else if (pZHem[i-1][j-1][k-1]>0.5*MaxHt)								   {memDC.SelectObject(&penRed);}

	//z-pores
//	if		(pZHem[i-1][j-1][k-1]>=0.0)	   {memDC.SelectObject(&penVesselShadeZ);}
	
	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//x-pores
    if		(pXHem[i-1][j-1][k-1]<=0.1*MaxHt)								   {memDC.SelectObject(&penGrey2);}
	else if (pXHem[i-1][j-1][k-1]>0.1*MaxHt && pXHem[i-1][j-1][k-1]<=0.2*MaxHt){memDC.SelectObject(&penGrey1);}
	else if (pXHem[i-1][j-1][k-1]>0.2*MaxHt && pXHem[i-1][j-1][k-1]<=0.3*MaxHt){memDC.SelectObject(&penWhite);}
	else if (pXHem[i-1][j-1][k-1]>0.3*MaxHt && pXHem[i-1][j-1][k-1]<=0.4*MaxHt){memDC.SelectObject(&penYellow);}
	else if (pXHem[i-1][j-1][k-1]>0.4*MaxHt && pXHem[i-1][j-1][k-1]<=0.5*MaxHt){memDC.SelectObject(&penOrange);}
	else if (pXHem[i-1][j-1][k-1]>0.5*MaxHt)								   {memDC.SelectObject(&penRed);}

	//x-pores
//	if		(pXHem[i-1][j-1][k-1]>=0.0)	   {memDC.SelectObject(&penVesselShadeX);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores
	if		(pYHem[i-1][j-1][k-1]<=0.1*MaxHt)								   {memDC.SelectObject(&penGrey2);}
	else if (pYHem[i-1][j-1][k-1]>0.1*MaxHt && pYHem[i-1][j-1][k-1]<=0.2*MaxHt){memDC.SelectObject(&penGrey1);}
	else if (pYHem[i-1][j-1][k-1]>0.2*MaxHt && pYHem[i-1][j-1][k-1]<=0.3*MaxHt){memDC.SelectObject(&penWhite);}
	else if (pYHem[i-1][j-1][k-1]>0.3*MaxHt && pYHem[i-1][j-1][k-1]<=0.4*MaxHt){memDC.SelectObject(&penYellow);}
	else if (pYHem[i-1][j-1][k-1]>0.4*MaxHt && pYHem[i-1][j-1][k-1]<=0.5*MaxHt){memDC.SelectObject(&penOrange);}
	else if (pYHem[i-1][j-1][k-1]>0.5*MaxHt)								   {memDC.SelectObject(&penRed);}

	//y-pores
//	if		(pYHem[i-1][j-1][k-1]>=0.0)	   {memDC.SelectObject(&penVesselShadeY);}

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//-----------------------------------------------
//---Draw Bone Tissue----------------------------
/*				if	(b_Bone_model)
				{
					if	(m_nz==1)
					{
						if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
						{
							memDC.SelectObject(&brushWhite);
							memDC.SelectObject(&penWhite);

							memDC.Rectangle(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),
											yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)),
											xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),
											yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
						}
					}

					else
					{
						if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
						{
							CPoint cubePts[5];	

//-----------------------------------------------

							//---Top Face------------
							memDC.SelectObject(&brushWhite);
							//memDC.SelectObject(&penWhite);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

							//---Side Face-----------
							memDC.SelectObject(&brushGrey3);
							//memDC.SelectObject(&penGrey3);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

							//---Front Face----------
							memDC.SelectObject(&brushGrey4);
							//memDC.SelectObject(&penGrey4);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();
						}
					}
				}
//----------------------------------------------------------
//----------------------------------------------------------
*/

	}	//end i loop

//dangling x-pores
	int i=m_nx+1;
	int nbx=LabX(i,j,k);

//	int RedShadeX=255-int(255*fabs(pXHem[i-1][j-1][k-1])/3.24);
//				
//	COLORREF VesselShadeX=RGB(255,RedShadeX,RedShadeX);
//	CPen penVesselShadeX(PS_SOLID,2,VesselShadeX);
	
	if		(pXHem[i-1][j-1][k-1]<=0.1*MaxHt)								   {memDC.SelectObject(&penGrey2);}
	else if (pXHem[i-1][j-1][k-1]>0.1*MaxHt && pXHem[i-1][j-1][k-1]<=0.2*MaxHt){memDC.SelectObject(&penGrey1);}
	else if (pXHem[i-1][j-1][k-1]>0.2*MaxHt && pXHem[i-1][j-1][k-1]<=0.3*MaxHt){memDC.SelectObject(&penWhite);}
	else if (pXHem[i-1][j-1][k-1]>0.3*MaxHt && pXHem[i-1][j-1][k-1]<=0.4*MaxHt){memDC.SelectObject(&penYellow);}
	else if (pXHem[i-1][j-1][k-1]>0.4*MaxHt && pXHem[i-1][j-1][k-1]<=0.5*MaxHt){memDC.SelectObject(&penOrange);}
	else if (pXHem[i-1][j-1][k-1]>0.5*MaxHt)								   {memDC.SelectObject(&penRed);}

	//x-danglers
//	if		(pXHem[i-1][j-1][k-1]>=0.0)	   {memDC.SelectObject(&penVesselShadeX);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//-----------------------------------------------
//---Draw Bone Tissue----------------------------
/*			if	(b_Bone_model)
			{
				if	(m_nz==1)
				{
					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
					{
						memDC.SelectObject(&brushWhite);
						memDC.SelectObject(&penWhite);

						memDC.Rectangle(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),
										yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)),
										xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),
										yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
					}
				}

				else
				{
					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
					{
						CPoint cubePts[5];	

//-----------------------------------------------

						//---Top Face------------
						memDC.SelectObject(&brushWhite);
						//memDC.SelectObject(&penWhite);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Side Face-----------
						memDC.SelectObject(&brushGrey3);
						//memDC.SelectObject(&penGrey3);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Front Face----------
						memDC.SelectObject(&brushGrey4);
						//memDC.SelectObject(&penGrey4);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();
					}
				}
			}
//----------------------------------------------------------
//----------------------------------------------------------
*/
	}}// end j- and k-loops

//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------
	
//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//===============================================================
void CAngioNetDlg::FlowStatGraphics(int xMin, int xMax, int yMin, 
								 int yMax, int networkWidth, 
								 double deltaX, double deltaY)
//===============================================================
{

/*	double FlowMax;
	CalculateMinMaxMean(XFlow,YFlow,ZFlow);
	FlowMax=MaxValue;
	

//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),
			 colour=RGB(255,0,0),
			 DarkOrange=RGB(255,64,0),
			 LightOrange=RGB(255,192,0),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 Yellow=RGB(255,255,0),
			 Orange=RGB(255,128,0),Grey1=RGB(128,128,128);;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penDarkOrange(PS_SOLID,1,DarkOrange);
	CPen penLightOrange(PS_SOLID,1,LightOrange);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,1,Orange);
	CPen penGrey1(PS_SOLID,1,Grey1);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);


//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);
//----------------------------------------------


//x-pores--

	if (fabs(XFlow[i-1][j-1][k-1])<=0.01*FlowMax) 
		{memDC.SelectObject(&penYellow);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.01*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=0.05*FlowMax) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(XFlow[i-1][j-1][k-1])>0.05*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=0.2*FlowMax) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.2*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=0.5*FlowMax) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.5*FlowMax) // && fabs(XFlow[i-1][j-1][k-1]))<=FlowMax) 	
		{memDC.SelectObject(&penRed);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	
	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//y-pores--

	if (fabs(YFlow[i-1][j-1][k-1])<=0.01*FlowMax) 
		{memDC.SelectObject(&penYellow);}
	else if (fabs(YFlow[i-1][j-1][k-1])>0.01*FlowMax && fabs(YFlow[i-1][j-1][k-1])<=0.05*FlowMax) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(YFlow[i-1][j-1][k-1])>0.05*FlowMax && fabs(YFlow[i-1][j-1][k-1])<=0.2*FlowMax) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(YFlow[i-1][j-1][k-1])>0.2*FlowMax && fabs(YFlow[i-1][j-1][k-1])<=0.5*FlowMax) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(YFlow[i-1][j-1][k-1])>0.5*FlowMax && fabs(YFlow[i-1][j-1][k-1])<=FlowMax) 	
		{memDC.SelectObject(&penRed);}
	
	if (pFluid[nby-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nby-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//z-pores--

 	if (fabs(ZFlow[i-1][j-1][k-1])<=0.01*FlowMax) 
		{memDC.SelectObject(&penYellow);}
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.01*FlowMax && fabs(ZFlow[i-1][j-1][k-1])<=0.05*FlowMax) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.05*FlowMax && fabs(ZFlow[i-1][j-1][k-1])<=0.2*FlowMax) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.2*FlowMax && fabs(ZFlow[i-1][j-1][k-1])<=0.5*FlowMax) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.5*FlowMax && fabs(ZFlow[i-1][j-1][k-1])<=FlowMax) 	
		{memDC.SelectObject(&penRed);}
	
	if (pFluid[nbz-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbz-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	i=m_nx+1;

	int nbx=LabX(i,j,k);
	
	if (fabs(XFlow[i-1][j-1][k-1])<=0.01*FlowMax) 
		{memDC.SelectObject(&penYellow);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.01*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=0.05*FlowMax) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(XFlow[i-1][j-1][k-1])>0.05*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=0.2*FlowMax) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.2*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=0.5*FlowMax) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.5*FlowMax && fabs(XFlow[i-1][j-1][k-1])<=FlowMax) 	
		{memDC.SelectObject(&penRed);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

	   }	//end j loop
	}		// end k loop


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }

//------------------------------------------------

//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);
*/

//=================================================================================================

/*

//Mike 11/08 - Code modified to monitor
//the wound remodelling process

int i,j,k;
int nbx,nby;
int NumVessels;

double SumFlows;
double AvgFlow;

NumVessels=0;
SumFlows=AvgFlow=0.0;

for (k=1;k<=m_nz;k++)
	{	
	for (j=1;j<=m_ny;j++)
		{	
		for (i=1;i<=m_nx;i++)
			{		
			
			if (

					i>iCentre-(int)sqrt( (double)(pow(iWoundRadius*(double)17/12,2))-pow(j-jCentre,2) )

					&&

					i<iCentre+(int)sqrt( (double)(pow(iWoundRadius*(double)17/12,2))-pow(j-jCentre,2) )

				)
					{
						nbx=LabX(i,j,k);  
						nby=LabY(i,j,k);  

						if (pFluid[nbx-1]==10) 
										
							{
								NumVessels+=1;
								SumFlows+=fabs(XFlow[i-1][j-1][k-1]);
											
							}
										                                                  
						if (pFluid[nby-1]==10) 

							{
								NumVessels+=1;
								SumFlows+=fabs(YFlow[i-1][j-1][k-1]);
										
							}

					}
			}
		}
	}

AvgFlow=double(SumFlows/NumVessels);	//average flow calculated for all vessels within the 
										//circle for which all results have been measured
	

//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),
			 colour=RGB(255,0,0),
			 DarkOrange=RGB(255,64,0),
			 LightOrange=RGB(255,192,0),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 Yellow=RGB(255,255,0),
			 Orange=RGB(255,128,0),Grey1=RGB(128,128,128);;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penDarkOrange(PS_SOLID,1,DarkOrange);
	CPen penLightOrange(PS_SOLID,1,LightOrange);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,1,Orange);
	CPen penGrey1(PS_SOLID,1,Grey1);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);


//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//------------------------------------------
//Draw the network
	for (k=1;k<=m_nz;k++)
	{
	   for (j=1;j<=m_ny;j++)
	   {
	      for (i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);
//----------------------------------------------


//x-pores--

	if (fabs(XFlow[i-1][j-1][k-1])==0)																		//Numbers chosen to reflect   
		{memDC.SelectObject(&penWhite);}																	//each stage of the remodelling
	else if (fabs(XFlow[i-1][j-1][k-1])>0 && fabs(XFlow[i-1][j-1][k-1])<=0.0003125*AvgFlow)					//process (provided we have 4 stages)
        {memDC.SelectObject(&penYellow);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.0003125*AvgFlow && fabs(XFlow[i-1][j-1][k-1])<=0.00125*AvgFlow) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(XFlow[i-1][j-1][k-1])>0.00125*AvgFlow && fabs(XFlow[i-1][j-1][k-1])<=0.0028125*AvgFlow) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.0028125*AvgFlow && fabs(XFlow[i-1][j-1][k-1])<=0.005*AvgFlow) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.005*AvgFlow) 	
		{memDC.SelectObject(&penRed);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	
	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--

	if (fabs(YFlow[i-1][j-1][k-1])==0)																		//Numbers chosen to reflect
		{memDC.SelectObject(&penWhite);}																	//each stage of the remodelling
	else if (fabs(YFlow[i-1][j-1][k-1])>0 && fabs(YFlow[i-1][j-1][k-1])<=0.0003125*AvgFlow)					//process (provided we have 4 stages)
        {memDC.SelectObject(&penYellow);}
	else if (fabs(YFlow[i-1][j-1][k-1])>0.0003125*AvgFlow && fabs(YFlow[i-1][j-1][k-1])<=0.00125*AvgFlow) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(YFlow[i-1][j-1][k-1])>0.00125*AvgFlow && fabs(YFlow[i-1][j-1][k-1])<=0.0028125*AvgFlow) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(YFlow[i-1][j-1][k-1])>0.0028125*AvgFlow && fabs(YFlow[i-1][j-1][k-1])<=0.005*AvgFlow) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(YFlow[i-1][j-1][k-1])>0.005*AvgFlow) 	
		{memDC.SelectObject(&penRed);}
	
	if (pFluid[nby-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//z-pores--

 	if (fabs(ZFlow[i-1][j-1][k-1])==0)																		//Numbers chosen to reflect
		{memDC.SelectObject(&penWhite);}																	//each stage of the remodelling
	else if (fabs(ZFlow[i-1][j-1][k-1])>0 && fabs(ZFlow[i-1][j-1][k-1])<=0.0003125*AvgFlow)					//process (provided we have 4 stages)
        {memDC.SelectObject(&penYellow);}
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.0003125*AvgFlow && fabs(ZFlow[i-1][j-1][k-1])<=0.00125*AvgFlow) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.00125*AvgFlow && fabs(ZFlow[i-1][j-1][k-1])<=0.0028125*AvgFlow) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.0028125*AvgFlow && fabs(ZFlow[i-1][j-1][k-1])<=0.005*AvgFlow) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(ZFlow[i-1][j-1][k-1])>0.005*AvgFlow) 	
		{memDC.SelectObject(&penRed);}
	
	if (pFluid[nbz-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
			
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	i=m_nx+1;

	int nbx=LabX(i,j,k);
	
	if (fabs(XFlow[i-1][j-1][k-1])==0)																		//Numbers chosen to reflect
		{memDC.SelectObject(&penWhite);}																	//each stage of the remodelling
	else if (fabs(XFlow[i-1][j-1][k-1])>0 && fabs(XFlow[i-1][j-1][k-1])<=0.0003125*AvgFlow)					//process (provided we have 4 stages)
        {memDC.SelectObject(&penYellow);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.0003125*AvgFlow && fabs(XFlow[i-1][j-1][k-1])<=0.00125*AvgFlow) 
        {memDC.SelectObject(&penLightOrange);} 
	else if (fabs(XFlow[i-1][j-1][k-1])>0.00125*AvgFlow && fabs(XFlow[i-1][j-1][k-1])<=0.0028125*AvgFlow) 	
		{memDC.SelectObject(&penOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.0028125*AvgFlow && fabs(XFlow[i-1][j-1][k-1])<=0.005*AvgFlow) 	
		{memDC.SelectObject(&penDarkOrange);}
	else if (fabs(XFlow[i-1][j-1][k-1])>0.005*AvgFlow) 	
		{memDC.SelectObject(&penRed);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

	   }	//end j loop
	}		// end k loop


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }

//------------------------------------------------

//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);

*/

//=================================================================================================

//Get a device context first
	CClientDC graphicsDC(this);

//---- MODIF A.S. -------------------------------------
	CDC memDC;
	CBitmap memBMP;
    memDC.CreateCompatibleDC(&graphicsDC);
	memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	memDC.SelectObject(&memBMP);
//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 DarkGreen=RGB(0,128,64),Yellow=RGB(255,255,0),
			 Orange=RGB(255,128,0),Grey1=RGB(128,128,128),
			 Green1=RGB(0,90,0),Green2=RGB(0,110,0),
			 Green3=RGB(0,130,0),Green4=RGB(0,150,0),
			 Green5=RGB(0,170,0),Green6=RGB(0,190,0),
			 Green7=RGB(0,210,0),Green8=RGB(0,230,0),
			 Green9=RGB(0,250,0);

//Define the pens 
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penPink(PS_SOLID,1,pink);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penDarkGreen(PS_SOLID,1,DarkGreen);
	CPen penGreen(PS_SOLID,1,green);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,2,Orange);
	CPen penRed(PS_SOLID,3,red);
	CPen penGreen1(PS_SOLID,1,Green1);
	CPen penGreen2(PS_SOLID,1,Green2);
	CPen penGreen3(PS_SOLID,1,Green3);
	CPen penGreen4(PS_SOLID,2,Green4);
	CPen penGreen5(PS_SOLID,2,Green5);
	CPen penGreen6(PS_SOLID,2,Green6);
	CPen penGreen7(PS_SOLID,3,Green7);
	CPen penGreen8(PS_SOLID,3,Green8);
	CPen penGreen9(PS_SOLID,3,Green9);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);

//Print the loop variable
	CString myString;
	CString myString2;
	CString myString3;
	CString myString4;
	myString.Format("ANGIO %f",angiotime);
	myString2.Format("FLOW %f",flowTime);
	myString3.Format("%f",RateNutChangeMAX);
	myString4.Format("OXY %f",oxyTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(537,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(417,20,myString2);
	memDC.TextOut(230,20,myString3);
	memDC.TextOut(303,20,myString4);

//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(25,25,25));	//changed from 50,50,50 by Mike 10/09

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)((networkWidth/max(1.0+0.7*cos(dAngle),1.0+0.7*sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=max(int(0.7*networkWidth/(max(max(m_nx, m_ny),m_nz))),1);}//

//------------------------------------------

//-----------------------------------------------
//---Find max flow (ie brightest bond)---
	double FlowMax, FlowMin;
	CalculateMinMaxMean(XFlow,YFlow,ZFlow);
	FlowMax=MaxValue;
	FlowMin=MaxValue*1.0e-2;//1.0e-18;//

	double ColourMult=0.0;
	
//	if (FlowMax>FlowMin) {ColourMult=255/(1.0-FlowMin/FlowMax);}	//ColourMult(iplier) used to define quasi-continuous spectrum of colours	
																	//correlated with flow rate (ie small => dark, large => bright)

	if (FlowMax>FlowMin) {ColourMult=255/(-log(FlowMin/FlowMax));}	//ColourMult(iplier) used to define quasi-continuous spectrum of colours	
																	//correlated with flow rate (ie small => dark, large => bright)

outfileDebugBone<<flowTime<<"\t"<<FlowMax<<"\t"<<FlowMin<<"\t"<<ColourMult<<endl;

//-----------------------------------------------
//---Draw the network---
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				int ZShade;
				
//				if (ColourMult>0.0) {ZShade=int(ColourMult*(fabs(ZFlow[i-1][j-1][k-1])-FlowMin)/FlowMax);}
//				else {ZShade=255;}

				if (ColourMult>0.0) {ZShade=int(ColourMult*(log(fabs(ZFlow[i-1][j-1][k-1]))-log(FlowMin)));}
				else {ZShade=255;}
	
				COLORREF ZColour=RGB(ZShade,ZShade,ZShade);

				CPen penZColour(PS_SOLID,1,ZColour);
		
				if	(fabs(ZFlow[i-1][j-1][k-1])>=FlowMin)	{memDC.SelectObject(&penZColour);}
	
				if (pFluid[nbz-1]==66) {memDC.SelectObject(&penBlack);}
				if (pFluid[nbz-1]!=10) {memDC.SelectObject(&penDarkGreen);}

//-----------------------------------------------

				if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1])>=FlowMin)
				{
					if (k!=1)
					{
						memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
										),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
									(int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
										));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
						memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
										),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
									(int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
										));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
					}
				}

//-----------------------------------------------

				int XShade;
				
//				if (ColourMult>0.0) {XShade=int(ColourMult*(fabs(XFlow[i-1][j-1][k-1])-FlowMin)/FlowMax);}
//				else {XShade=255;}

				if (ColourMult>0.0) {XShade=int(ColourMult*(log(fabs(XFlow[i-1][j-1][k-1]))-log(FlowMin)));}
				else {XShade=255;}
	
				COLORREF XColour=RGB(XShade,XShade,XShade);

				CPen penXColour(PS_SOLID,1,XColour);
		
				if	(fabs(XFlow[i-1][j-1][k-1])>=FlowMin)	{memDC.SelectObject(&penXColour);}
	
				if (pFluid[nbx-1]==66) {memDC.SelectObject(&penBlack);}
				if (pFluid[nbx-1]!=10) {memDC.SelectObject(&penDarkGreen);}

//-----------------------------------------------

				if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1])>=FlowMin)
				{
					memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
									(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
					memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
									(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
				}

//-----------------------------------------------

				int YShade;
				
//				if (ColourMult>0.0) {YShade=int(ColourMult*(fabs(YFlow[i-1][j-1][k-1])-FlowMin)/FlowMax);}
//				else {YShade=255;}

				if (ColourMult>0.0) {YShade=int(ColourMult*(log(fabs(YFlow[i-1][j-1][k-1]))-log(FlowMin)));}
				else {YShade=255;}
	
				COLORREF YColour=RGB(YShade,YShade,YShade);

				CPen penYColour(PS_SOLID,1,YColour);
		
				if	(fabs(YFlow[i-1][j-1][k-1])>=FlowMin)	{memDC.SelectObject(&penYColour);}
	
				if (pFluid[nby-1]==66) { memDC.SelectObject(&penBlack);}
				if (pFluid[nby-1]!=10) { memDC.SelectObject(&penDarkGreen);}
	
//-----------------------------------------------	

				if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1])>=FlowMin)
				{
					if (j!=1)
					{
						memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
									(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
						memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
									(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
					}

					else
					{
						memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
									(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
						memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
									(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
					}
				}

//----------------------------------------------------------

			}	//end i loop

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			int XShade;
				
//			if (ColourMult>0.0) {XShade=int(ColourMult*(fabs(XFlow[i-1][j-1][k-1])-FlowMin)/FlowMax);}
//			else {XShade=255;}

			if (ColourMult>0.0) {XShade=int(ColourMult*(log(fabs(XFlow[i-1][j-1][k-1]))-log(FlowMin)));}
			else {XShade=255;}
	
			COLORREF XColour=RGB(XShade,XShade,XShade);

			CPen penXColour(PS_SOLID,1,XColour);
		
			if	(fabs(XFlow[i-1][j-1][k-1])>=FlowMin)	{memDC.SelectObject(&penXColour);}
	
			if (pFluid[nbx-1]==66) {memDC.SelectObject(&penBlack);}
			if (pFluid[nbx-1]!=10) {memDC.SelectObject(&penDarkGreen);}

//-----------------------------------------------

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1])>=FlowMin)
			{
				memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
								(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
				memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
								(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
			}

//-----------------------------------------------

		}	//end j loop
	}		// end k loop


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }

//------------------------------------------------

//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//=============================================================
void CAngioNetDlg::WSSGraphics(int xMin, int xMax, int yMin, 
								  int yMax, int networkWidth, 
								  double deltaX, double deltaY)
//=============================================================
{

//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),colour=RGB(255,0,0),White=RGB(255,255,255),
		     Black=RGB(0,0,0),Orange=RGB(255,128,0),
			 Grey1=RGB(170,170,170),Yellow=RGB(255,255,0);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,1,Orange);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

//x-pores
    if      (XTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)										   {memDC.SelectObject(&penGrey1);}
	else if (XTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX){memDC.SelectObject(&penWhite);}
	else if (XTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX){memDC.SelectObject(&penYellow);}
	else if (XTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX){memDC.SelectObject(&penOrange);}
	else if (XTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)								           {memDC.SelectObject(&penRed);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--
	if		(YTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)										   {memDC.SelectObject(&penGrey1);}
	else if (YTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && YTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX){memDC.SelectObject(&penWhite);}
	else if (YTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && YTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX){memDC.SelectObject(&penYellow);}
	else if (YTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && YTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX){memDC.SelectObject(&penOrange);}
	else if (YTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)										   {memDC.SelectObject(&penRed);}

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//z-pores--
	if		(ZTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)										   {memDC.SelectObject(&penGrey1);}
	else if (ZTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && ZTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX){memDC.SelectObject(&penWhite);}
	else if (ZTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && ZTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX){memDC.SelectObject(&penYellow);}
	else if (ZTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && ZTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX){memDC.SelectObject(&penOrange);}
	else if (ZTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)								           {memDC.SelectObject(&penRed);}

	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

	}	//end i loop

//dangling x-pores
	int i=m_nx+1;
	int nbx=LabX(i,j,k);

	if		(XTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)									       {memDC.SelectObject(&penGrey1);}
	else if (XTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX){memDC.SelectObject(&penWhite);}
	else if (XTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX){memDC.SelectObject(&penYellow);}
	else if (XTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX){memDC.SelectObject(&penOrange);}
	else if (XTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)									       {memDC.SelectObject(&penRed);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}


	}}// end j- and k-loops

//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------
	
//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//==============================================================
void CAngioNetDlg::VesselGraphics2(int xMin, int xMax, int yMin, int yMax, int networkWidth, double deltaX, double deltaY)
//==============================================================
{
//Get a device context first
	CClientDC graphicsDC(this);
	

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Yellow=RGB(255,255,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penYellow(PS_SOLID,2,Yellow);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	//int nbx=LabX(i,j,k);
	//int nby=LabY(i,j,k);
	//int nbz=LabZ(i,j,k);

	memDC.SelectObject(&penBlack);

	if (vTAFConc[i-1][j-1][k-1] <= 0.3*runningTAFConcMAX)      {memDC.SelectObject(&penDarkBlue);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.3*runningTAFConcMAX &&
			 vTAFConc[i-1][j-1][k-1] <= 0.5*runningTAFConcMAX) {memDC.SelectObject(&penLightBlue);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.5*runningTAFConcMAX &&
			 vTAFConc[i-1][j-1][k-1] <= 0.7*runningTAFConcMAX) {memDC.SelectObject(&penWhite);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.7*runningTAFConcMAX &&
			 vTAFConc[i-1][j-1][k-1] <= 0.8*runningTAFConcMAX) {memDC.SelectObject(&penPink);}

	else if (vTAFConc[i-1][j-1][k-1] > 0.8*runningTAFConcMAX)  {memDC.SelectObject(&penRed);}
	

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	// draw colour segment in the y-direction
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	// draw colour segment in the z-direction
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
			
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}}}


//------------------------------------------
//Draw the network
/*	for (k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
		  {
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

//x-pores
	if ( pFluid[nbx-1] == 10)
	{
		//memDC.SelectObject(&penWhite);
		memDC.SelectObject(&penYellow);


	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//y-pores--
	if ( pFluid[nby-1] == 10)
	{
		//memDC.SelectObject(&penWhite);
		memDC.SelectObject(&penYellow);


	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//z-pores--
	if ( pFluid[nbz-1] == 10)
	{
		//memDC.SelectObject(&penWhite);
		memDC.SelectObject(&penYellow);


	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

		  }	//end i loop


//dangling x-pores
	i=m_nx+1;

	int nbx=LabX(i,j,k);


	if ( pFluid[nbx-1] == 10)
	{
		//memDC.SelectObject(&penWhite);
		memDC.SelectObject(&penYellow);


	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}


	   }	//end j loop
	}		// end k loop
*/
//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//------------------------------------------------


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//==============================================================
void CAngioNetDlg::VesselGraphics(int xMin, int xMax, int yMin, 
								  int yMax, int networkWidth, 
								  double deltaX, double deltaY)
//==============================================================
{
//Get a device context first
	CClientDC graphicsDC(this);
	

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Yellow=RGB(255,255,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penYellow(PS_SOLID,2,Yellow);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }


//------------------------------------------
//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
		  {
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

//x-pores
	if ( pFluid[nbx-1] == 10)
	{
		memDC.SelectObject(&penWhite);
		if (pSprout[nbx-1]==1) {memDC.SelectObject(&penRed);}

	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--
	if ( pFluid[nby-1] == 10)
	{
		memDC.SelectObject(&penWhite);
		if (pSprout[nby-1]==1) {memDC.SelectObject(&penRed);}

		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//z-pores--
	if ( pFluid[nbz-1] == 10)
	{
		memDC.SelectObject(&penWhite);
		if (pSprout[nbz-1]==1) {memDC.SelectObject(&penRed);}

		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}
		  }	//end i loop

//dangling x-pores
	int i=m_nx+1;

	int nbx=LabX(i,j,k);


	if ( pFluid[nbx-1] == 10)
	{
		memDC.SelectObject(&penWhite);
		if (pSprout[nbx-1]==1) {memDC.SelectObject(&penRed);}

	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}


	   }}	//end j and k loops



//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//------------------------------------------------


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//================================================================
void CAngioNetDlg::AgeVesselGraphics(int xMin, int xMax, int yMin, 
								  int yMax, int networkWidth, 
								  double deltaX, double deltaY)
//================================================================
{
//Get a device context first
	CClientDC graphicsDC(this);
	

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),
			 colour=RGB(255,0,0),Turquoise=RGB(0,255,255),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(0,175,255),
			 White=RGB(255,255,255),MediumBlue=RGB(75,75,255),
			 Black=RGB(0,0,0),Grey1=RGB(87,87,87);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penMediumBlue(PS_SOLID,1,MediumBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penTurquoise(PS_SOLID,1,Turquoise);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
		  {
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

//x-pores
	if ( pFluid[nbx-1] == 10)
	{
	//if      (pAgeOfVessel[nbx-1]<=0.2*runningAgeMax)										  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nbx-1]>0.2*runningAgeMax && pAgeOfVessel[nbx-1]<=0.4*runningAgeMax) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nbx-1]>0.4*runningAgeMax && pAgeOfVessel[nbx-1]<=0.6*runningAgeMax) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nbx-1]>0.6*runningAgeMax && pAgeOfVessel[nbx-1]<=0.8*runningAgeMax) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nbx-1]>0.8*runningAgeMax)										      { memDC.SelectObject(&penDarkBlue);}

	//if      (pAgeOfVessel[nbx-1]<=2.0)							  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nbx-1]>2.0 && pAgeOfVessel[nbx-1]<=4.0) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nbx-1]>4.0 && pAgeOfVessel[nbx-1]<=6.0) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nbx-1]>6.0 && pAgeOfVessel[nbx-1]<=8.0) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nbx-1]>8.0)							  { memDC.SelectObject(&penDarkBlue);}

	if      (pAgeOfVessel[nbx-1]<=0.2)							  { memDC.SelectObject(&penWhite);}			// Changed from above
	else if (pAgeOfVessel[nbx-1]>0.2 && pAgeOfVessel[nbx-1]<=1.0) { memDC.SelectObject(&penTurquoise);}		// by Mike (11/08) 
	else if (pAgeOfVessel[nbx-1]>1.0 && pAgeOfVessel[nbx-1]<=1.8) { memDC.SelectObject(&penLightBlue);}		// for wound model
	else if (pAgeOfVessel[nbx-1]>1.8 && pAgeOfVessel[nbx-1]<=2.6) { memDC.SelectObject(&penMediumBlue);}	//
	else if (pAgeOfVessel[nbx-1]>2.6)							  { memDC.SelectObject(&penDarkBlue);}		//


	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--
	if ( pFluid[nby-1] == 10)
	{
	if      (pAgeOfVessel[nby-1]<=0.2*runningAgeMax)									  	  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nby-1]>0.2*runningAgeMax && pAgeOfVessel[nby-1]<=0.4*runningAgeMax) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nby-1]>0.4*runningAgeMax && pAgeOfVessel[nby-1]<=0.6*runningAgeMax) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nby-1]>0.6*runningAgeMax && pAgeOfVessel[nby-1]<=0.8*runningAgeMax) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nby-1]>0.8*runningAgeMax)										      { memDC.SelectObject(&penDarkBlue);}

	//if      (pAgeOfVessel[nby-1]<=2.0)							  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nby-1]>2.0 && pAgeOfVessel[nby-1]<=4.0) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nby-1]>4.0 && pAgeOfVessel[nby-1]<=6.0) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nby-1]>6.0 && pAgeOfVessel[nby-1]<=8.0) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nby-1]>8.0)							  { memDC.SelectObject(&penDarkBlue);}

	if      (pAgeOfVessel[nby-1]<=0.2)							  { memDC.SelectObject(&penWhite);}			// Changed from above
	else if (pAgeOfVessel[nby-1]>0.2 && pAgeOfVessel[nby-1]<=1.0) { memDC.SelectObject(&penTurquoise);}		// by Mike (11/08)
	else if (pAgeOfVessel[nby-1]>1.0 && pAgeOfVessel[nby-1]<=1.8) { memDC.SelectObject(&penLightBlue);}		// for wound model
	else if (pAgeOfVessel[nby-1]>1.8 && pAgeOfVessel[nby-1]<=2.6) { memDC.SelectObject(&penMediumBlue);}	//
	else if (pAgeOfVessel[nby-1]>2.6)							  { memDC.SelectObject(&penDarkBlue);}		//

		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//z-pores--
	if ( pFluid[nbz-1] == 10)
	{
	//if      (pAgeOfVessel[nbz-1]<=0.2*runningAgeMax)										  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nbz-1]>0.2*runningAgeMax && pAgeOfVessel[nbz-1]<=0.4*runningAgeMax) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nbz-1]>0.4*runningAgeMax && pAgeOfVessel[nbz-1]<=0.6*runningAgeMax) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nbz-1]>0.6*runningAgeMax && pAgeOfVessel[nbz-1]<=0.8*runningAgeMax) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nbz-1]>0.8*runningAgeMax)										      { memDC.SelectObject(&penDarkBlue);}

	//if      (pAgeOfVessel[nbz-1]<=2.0)							  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nbz-1]>2.0 && pAgeOfVessel[nbz-1]<=4.0) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nbz-1]>4.0 && pAgeOfVessel[nbz-1]<=6.0) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nbz-1]>6.0 && pAgeOfVessel[nbz-1]<=8.0) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nbz-1]>8.0)							  { memDC.SelectObject(&penDarkBlue);}

	if      (pAgeOfVessel[nbz-1]<=0.2)							  { memDC.SelectObject(&penWhite);}			// Changed from above
	else if (pAgeOfVessel[nbz-1]>0.2 && pAgeOfVessel[nbz-1]<=1.0) { memDC.SelectObject(&penTurquoise);}		// by Mike (11/08)
	else if (pAgeOfVessel[nbz-1]>1.0 && pAgeOfVessel[nbz-1]<=1.8) { memDC.SelectObject(&penLightBlue);}		// for wound model
	else if (pAgeOfVessel[nbz-1]>1.8 && pAgeOfVessel[nbz-1]<=2.6) { memDC.SelectObject(&penMediumBlue);}	//
	else if (pAgeOfVessel[nbz-1]>2.6)							  { memDC.SelectObject(&penDarkBlue);}		//

		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
			
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

		  }	//end i loop

//dangling x-pores
	int i=m_nx+1;
	int nbx=LabX(i,j,k);

	if ( pFluid[nbx-1] == 10)
	{
	//if      (pAgeOfVessel[nbx-1]<=0.2*runningAgeMax)										  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nbx-1]>0.2*runningAgeMax && pAgeOfVessel[nbx-1]<=0.4*runningAgeMax) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nbx-1]>0.4*runningAgeMax && pAgeOfVessel[nbx-1]<=0.6*runningAgeMax) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nbx-1]>0.6*runningAgeMax && pAgeOfVessel[nbx-1]<=0.8*runningAgeMax) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nbx-1]>0.8*runningAgeMax)										      { memDC.SelectObject(&penDarkBlue);}

	//if      (pAgeOfVessel[nbx-1]<=2.0)							  { memDC.SelectObject(&penWhite);}
	//else if (pAgeOfVessel[nbx-1]>2.0 && pAgeOfVessel[nbx-1]<=4.0) { memDC.SelectObject(&penTurquoise);}
	//else if (pAgeOfVessel[nbx-1]>4.0 && pAgeOfVessel[nbx-1]<=6.0) { memDC.SelectObject(&penLightBlue);}
	//else if (pAgeOfVessel[nbx-1]>6.0 && pAgeOfVessel[nbx-1]<=8.0) { memDC.SelectObject(&penMediumBlue);}
	//else if (pAgeOfVessel[nbx-1]>8.0)						      { memDC.SelectObject(&penDarkBlue);}

	if      (pAgeOfVessel[nbx-1]<=0.2)							  { memDC.SelectObject(&penWhite);}			// Changed from above 
	else if (pAgeOfVessel[nbx-1]>0.2 && pAgeOfVessel[nbx-1]<=1.0) { memDC.SelectObject(&penTurquoise);}		// by Mike (11/08)
	else if (pAgeOfVessel[nbx-1]>1.0 && pAgeOfVessel[nbx-1]<=1.8) { memDC.SelectObject(&penLightBlue);}		// for wound model
	else if (pAgeOfVessel[nbx-1]>1.8 && pAgeOfVessel[nbx-1]<=2.6) { memDC.SelectObject(&penMediumBlue);}	//
	else if (pAgeOfVessel[nbx-1]>2.6)							  { memDC.SelectObject(&penDarkBlue);}		//

	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}


	}}	//end j and k loop

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//------------------------------------------------


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************
//******************************************************

void CAngioNetDlg::PericytesGraphics(int xMin, int xMax, int yMin, int yMax, 
									 int networkWidth, 
									 double deltaX, double deltaY)
{
//Get a device context first
	CClientDC graphicsDC(this);
	

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Yellow=RGB(255,255,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190),
			 purple0=RGB(0,0,100),//RGB(100,0,100),
			 purple1=RGB(50,0,100),//RGB(128,0,128),
			 purple2=RGB(100,0,100),//RGB(150,0,150),
			 purple3=RGB(175,0,100),//RGB(200,0,200),
			 purple4=RGB(255,0,0);//RGB(255,0,255);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penYellow(PS_SOLID,2,Yellow);
//	CPen penPurple0(PS_SOLID,1,purple0);
//	CPen penPurple1(PS_SOLID,1,purple1);
//	CPen penPurple2(PS_SOLID,2,purple2);
//	CPen penPurple3(PS_SOLID,3,purple3);
//	CPen penPurple4(PS_SOLID,4,purple4);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }


 double PC_DensityConversion=0.0;	//Used to convert normalised PC NUMBER to density
									//by scaling with Radius/artRad
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

	memDC.SelectObject(&penBlack);

	//xPores

//Pen Widths
	int iLineWidth=1;

	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>2e-6 && XBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (XBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4(PS_SOLID,iLineWidth,purple4);

	PC_DensityConversion=XBR[i-1][j-1][k-1]/artRad;  //Actually the scaling factor becomes
													// 1/(Pi Rpc^2)  
													//[=2 Pi R DeltaX/ 
													//	( (Pi Rpc^2)*2 Pi R DeltaX)

	if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.1)     {memDC.SelectObject(&penPurple0);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion> 0.1 &&
			 pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion<= 0.25) {memDC.SelectObject(&penPurple1);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion> 0.25 &&
			 pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion<= 0.5) {memDC.SelectObject(&penPurple2);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion> 0.5 &&
			 pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion<= 0.75) {memDC.SelectObject(&penPurple3);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max  / PC_DensityConversion> 0.75)  {memDC.SelectObject(&penPurple4);}
	
	if(pFluid[nbx-1]!=10) {	memDC.SelectObject(&penBlack);}
    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)((XPOS[i][j][k]-1)*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny));

	}
	//yPores


	if      (YBR[i-1][j-1][k-1]>0.0  && YBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>2e-6 && YBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>4e-6 && YBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>7e-6 && YBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (YBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0y(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1y(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2y(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3y(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4y(PS_SOLID,iLineWidth,purple4);

	PC_DensityConversion=YBR[i-1][j-1][k-1]/artRad;

	if (pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.1)     {memDC.SelectObject(&penPurple0y);}

	else if (pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.1 &&
			 pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.25) {memDC.SelectObject(&penPurple1y);}

	else if (pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.25 &&
			 pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.5) {memDC.SelectObject(&penPurple2y);}

	else if (pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.5 &&
			 pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.75) {memDC.SelectObject(&penPurple3y);}

	else if (pPericyteDensity[nby-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.75)  {memDC.SelectObject(&penPurple4y);}

	if(pFluid[nby-1]!=10) {	memDC.SelectObject(&penBlack);}

	// draw colour segment in the y-direction

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

	//zPores

	if      (ZBR[i-1][j-1][k-1]>0.0  && ZBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>2e-6 && ZBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>4e-6 && ZBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>7e-6 && ZBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (ZBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0z(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1z(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2z(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3z(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4z(PS_SOLID,iLineWidth,purple4);

	PC_DensityConversion=ZBR[i-1][j-1][k-1]/artRad;

	if (pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.1)     {memDC.SelectObject(&penPurple0z);}

	else if (pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.1 &&
			 pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.25) {memDC.SelectObject(&penPurple1z);}

	else if (pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.25 &&
			 pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.5) {memDC.SelectObject(&penPurple2z);}

	else if (pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.5 &&
			 pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.75) {memDC.SelectObject(&penPurple3z);}

	else if (pPericyteDensity[nbz-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.75)  {memDC.SelectObject(&penPurple4z);}

	if(pFluid[nbz-1]!=10) {	memDC.SelectObject(&penBlack);}

	// draw colour segment in the z-direction
	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}

	}	
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}
		int i=m_nx+1;
		int nbx=LabX(i,j,k),iLineWidth;

	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>2e-6 && XBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (XBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0xx(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1xx(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2xx(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3xx(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4xx(PS_SOLID,iLineWidth,purple4);

	PC_DensityConversion=XBR[i-1][j-1][k-1]/artRad;

	if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.1)     {memDC.SelectObject(&penPurple0xx);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.1 &&
			 pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.25) {memDC.SelectObject(&penPurple1xx);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.25 &&
			 pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.5) {memDC.SelectObject(&penPurple2xx);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.5 &&
			 pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion<= 0.75) {memDC.SelectObject(&penPurple3xx);}

	else if (pPericyteDensity[nbx-1]/PC_Carrying_Capacity_Max / PC_DensityConversion> 0.75)  {memDC.SelectObject(&penPurple4xx);}
	
	if(pFluid[nbx-1]!=10) {	memDC.SelectObject(&penBlack);}

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}
	//======================
	
	}}
//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }



//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//------------------------------------------------


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}
//******************************************************
//**************************************************************************

void CAngioNetDlg::FlowingGraphics(int xMin, int xMax, int yMin, 
								 int yMax, int networkWidth, 
								 double deltaX, double deltaY)
{
//Get a device context first
	CClientDC graphicsDC(this);
	

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Yellow=RGB(255,255,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190),
			 purple0=RGB(0,0,100),//RGB(100,0,100),
			 purple1=RGB(50,0,100),//RGB(128,0,128),
			 purple2=RGB(100,0,100),//RGB(150,0,150),
			 purple3=RGB(175,0,100),//RGB(200,0,200),
			 purple4=RGB(255,0,0);//RGB(255,0,255);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penYellow(PS_SOLID,2,Yellow);
//	CPen penPurple0(PS_SOLID,1,purple0);
//	CPen penPurple1(PS_SOLID,1,purple1);
//	CPen penPurple2(PS_SOLID,2,purple2);
//	CPen penPurple3(PS_SOLID,3,purple3);
//	CPen penPurple4(PS_SOLID,4,purple4);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }


									//by scaling with Radius/artRad
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

	memDC.SelectObject(&penBlack);

	//xPores

//Pen Widths
	int iLineWidth=1;

	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>2e-6 && XBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (XBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4(PS_SOLID,iLineWidth,purple4);


	if (bFlowingVessel[nbx-1])   {memDC.SelectObject(&penPurple4);}

	else						 {memDC.SelectObject(&penPurple0);}

	if(pFluid[nbx-1]==0) {	memDC.SelectObject(&penBlack);}
    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	
	//yPores


	if      (YBR[i-1][j-1][k-1]>0.0  && YBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>2e-6 && YBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>4e-6 && YBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (YBR[i-1][j-1][k-1]>7e-6 && YBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (YBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0y(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1y(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2y(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3y(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4y(PS_SOLID,iLineWidth,purple4);

	if (bFlowingVessel[nby-1])   {memDC.SelectObject(&penPurple4y);}

	else						 {memDC.SelectObject(&penPurple0y);}

	if(pFluid[nby-1]==0) {	memDC.SelectObject(&penBlack);}

	// draw colour segment in the y-direction
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}

	//zPores

	if      (ZBR[i-1][j-1][k-1]>0.0  && ZBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>2e-6 && ZBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>4e-6 && ZBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (ZBR[i-1][j-1][k-1]>7e-6 && ZBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (ZBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0z(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1z(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2z(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3z(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4z(PS_SOLID,iLineWidth,purple4);

	if (bFlowingVessel[nbz-1])   {memDC.SelectObject(&penPurple4z);}

	else						 {memDC.SelectObject(&penPurple0z);}

	if(pFluid[nbz-1]==0) {	memDC.SelectObject(&penBlack);}

	// draw colour segment in the z-direction
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}
		int i=m_nx+1;
		int nbx=LabX(i,j,k),iLineWidth;

	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=2e-6) {iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>2e-6 && XBR[i-1][j-1][k-1]<=4e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=7e-6) { iLineWidth=1;}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=10e-6) { iLineWidth=2;}
	else if (XBR[i-1][j-1][k-1]>10e-6)                             { iLineWidth=3;}

	CPen penPurple0xx(PS_SOLID,iLineWidth,purple0);
	CPen penPurple1xx(PS_SOLID,iLineWidth,purple1);
	CPen penPurple2xx(PS_SOLID,iLineWidth,purple2);
	CPen penPurple3xx(PS_SOLID,iLineWidth,purple3);
	CPen penPurple4xx(PS_SOLID,iLineWidth,purple4);

	if (bFlowingVessel[nbx-1])   {memDC.SelectObject(&penPurple4xx);}

	else						 {memDC.SelectObject(&penPurple0xx);}
	
	if(pFluid[nbx-1]==0) {	memDC.SelectObject(&penBlack);}

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	
	}}
//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }



//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//------------------------------------------------


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}
//**************************************************************************

//============================================================
void CAngioNetDlg::RadiiGraphics(int xMin, int xMax, int yMin, 
								 int yMax, int networkWidth, 
								 double deltaX, double deltaY)
//============================================================
{
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 DarkGreen=RGB(0,128,64),Yellow=RGB(255,255,0),
			 Orange=RGB(255,128,0),Grey1=RGB(128,128,128),
			 Green1=RGB(0,90,0),Green2=RGB(0,110,0),
			 Green3=RGB(0,130,0),Green4=RGB(0,150,0),
			 Green5=RGB(0,170,0),Green6=RGB(0,190,0),
			 Green7=RGB(0,210,0),Green8=RGB(0,230,0),
			 Green9=RGB(0,250,0),Grey2=RGB(64,64,64);

//Define the pens 
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penPink(PS_SOLID,1,pink);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penDarkGreen(PS_SOLID,1,DarkGreen);
	CPen penGreen(PS_SOLID,1,green);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,2,Orange);
	CPen penRed(PS_SOLID,3,red);
	CPen penGreen1(PS_SOLID,1,Green1);
	CPen penGreen2(PS_SOLID,1,Green2);
	CPen penGreen3(PS_SOLID,1,Green3);
	CPen penGreen4(PS_SOLID,2,Green4);
	CPen penGreen5(PS_SOLID,2,Green5);
	CPen penGreen6(PS_SOLID,2,Green6);
	CPen penGreen7(PS_SOLID,3,Green7);
	CPen penGreen8(PS_SOLID,3,Green8);
	CPen penGreen9(PS_SOLID,3,Green9);

	CBrush brushWhite(White);
	CBrush brushGrey1(Grey1);
	CBrush brushGrey2(Grey2);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);


//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("FLOW TIME %f",flowTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);

//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(25,25,25));	//changed from 50,50,50 by Mike 10/09

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;//
//outfileDebugBone<<networkWidth<<endl;
//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)((networkWidth/max(1.0+0.7*cos(dAngle),1.0+0.7*sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=max(int(0.7*networkWidth/(max(max(m_nx, m_ny),m_nz))),1);}//

//------------------------------------------
//double	Bound1=3e-6,	//2e-6 (Changed by	//Normalises colours to Rmin and Rmax
//		Bound2=5e-6,	//4e-6  Mike 05/09)
//		Bound3=7e-6,
//		Bound4=10e-6;

	double	Bound1=2e-6,		//Added by Mike 10/09	
			Bound2=6e-6,		//Bound values now only used to 
			Bound3=9e-6;		//determine thickness of displayed vessel

//-----------------------------------------------
//---Find max vessel rad (ie brightest bond)---
	double Rmax=12.0e-6;//14.0e-6;//
	double Rmin=2.0e-6;//3.0e-6;//

/*	for	(int k=1;k<=m_nz;k++)
	{	for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if	(pFluid[nbx-1]==10)
				{
					if	(XBR[i-1][j-1][k-1]>Rmax)	{Rmax=XBR[i-1][j-1][k-1];}
				}

				if	(pFluid[nby-1]==10)
				{
					if	(YBR[i-1][j-1][k-1]>Rmax)	{Rmax=YBR[i-1][j-1][k-1];}
				}

				if	(pFluid[nbz-1]==10)
				{
					if	(ZBR[i-1][j-1][k-1]>Rmax)	{Rmax=ZBR[i-1][j-1][k-1];}
				}

			}	//end i loop

			i=m_nx+1;
			int nbx=LabX(i,j,k);

			if	(pFluid[nbx-1]==10)
				{
					if	(XBR[i-1][j-1][k-1]>Rmax)	{Rmax=XBR[i-1][j-1][k-1];}
				}

		}	//end j loop

	}	//end k loop
*/
	double ColourMult=255/(Rmax-Rmin);	//ColourMult(iplier) & Rmax used to define quasi-continuous spectrum of colours	
								//correlated with vessel radius (ie small radius => dark, large radius => bright)

//-----------------------------------------------
//---Draw the network---
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------
//	int ZShade=int(ColourMult*ZBR[i-1][j-1][k-1]);	//ie 255*(ZBR/Rmax) => integer between 0,255

//	COLORREF ZGreen1=RGB(0,ZShade,0),ZGreen2=RGB(0,ZShade,0),ZGreen3=RGB(0,ZShade,0);

//	CPen penZGreen1(PS_SOLID,1,ZGreen1);	//Same colours, 
//	CPen penZGreen2(PS_SOLID,2,ZGreen2);	//different line
//	CPen penZGreen3(PS_SOLID,3,ZGreen3);	//thickness

	int ZBlue=int(ColourMult*(Rmax-ZBR[i-1][j-1][k-1]));
	int ZRed=int(ColourMult*(ZBR[i-1][j-1][k-1]-Rmin));

	COLORREF ZColour1=RGB(ZRed,0,ZBlue),ZColour2=RGB(ZRed,0,ZBlue),ZColour3=RGB(ZRed,0,ZBlue);

	CPen penZColour1(PS_SOLID,1,ZColour1);
	CPen penZColour2(PS_SOLID,2,ZColour2);
	CPen penZColour3(PS_SOLID,3,ZColour3);
	
//z-pores-- DO FIRST SO x and Y lie ABOVE THE VESSELS
/*
	//if      (ZBR[i-1][j-1][k-1]>0 && ZBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (ZBR[i-1][j-1][k-1]>0.0  && ZBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (ZBR[i-1][j-1][k-1]>10e-6 && ZBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (ZBR[i-1][j-1][k-1]>15e-6 && ZBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (ZBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}

	if      (ZBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (ZBR[i-1][j-1][k-1]>Bound1 && ZBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (ZBR[i-1][j-1][k-1]>Bound2 && ZBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (ZBR[i-1][j-1][k-1]>Bound3 && ZBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (ZBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/
/*	if		(ZBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (ZBR[i-1][j-1][k-1]>4e-6 && ZBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (ZBR[i-1][j-1][k-1]>6e-6 && ZBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (ZBR[i-1][j-1][k-1]>7e-6 && ZBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (ZBR[i-1][j-1][k-1]>8e-6 && ZBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (ZBR[i-1][j-1][k-1]>9e-6 && ZBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (ZBR[i-1][j-1][k-1]>10e-6 && ZBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (ZBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/

//	if		(ZBR[i-1][j-1][k-1]>=Bound1 && ZBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penZGreen1);}
//	else if (ZBR[i-1][j-1][k-1]>=Bound2 && ZBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penZGreen2);}
//	else if (ZBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penZGreen3);}

	if		(ZBR[i-1][j-1][k-1]>=Bound1 && ZBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penZColour1);}
	else if (ZBR[i-1][j-1][k-1]>=Bound2 && ZBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penZColour2);}
	else if (ZBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penZColour3);}

	if (pFluid[nbz-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbz-1]!=10) { memDC.SelectObject(&penDarkGreen);}

///SMcD Retino 10/08



	///SMcD Retino 10/08
//	memDC.SelectObject(&penYellow);
	///--------------------------

	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}


	}

//x-pores--

//	int XShade=int(ColourMult*XBR[i-1][j-1][k-1]);	//ie 255*(XBR/Rmax) => integer between 0,255

//	COLORREF XGreen1=RGB(0,XShade,0),XGreen2=RGB(0,XShade,0),XGreen3=RGB(0,XShade,0);

//	CPen penXGreen1(PS_SOLID,1,XGreen1);	//Same colour,
//	CPen penXGreen2(PS_SOLID,2,XGreen2);	//different line
//	CPen penXGreen3(PS_SOLID,3,XGreen3);	//thickness

	int XBlue=int(ColourMult*(Rmax-XBR[i-1][j-1][k-1]));
	int XRed=int(ColourMult*(XBR[i-1][j-1][k-1]-Rmin));

	COLORREF XColour1=RGB(XRed,0,XBlue),XColour2=RGB(XRed,0,XBlue),XColour3=RGB(XRed,0,XBlue);

	CPen penXColour1(PS_SOLID,1,XColour1);
	CPen penXColour2(PS_SOLID,2,XColour2);
	CPen penXColour3(PS_SOLID,3,XColour3);

/*
	//if      (XBR[i-1][j-1][k-1]>0.0 && XBR[i-1][j-1][k-1]<=2e-6)  { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}

	if      (XBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound1 && XBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound2 && XBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (XBR[i-1][j-1][k-1]>Bound3 && XBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/
/*	if		(XBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (XBR[i-1][j-1][k-1]>6e-6 && XBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (XBR[i-1][j-1][k-1]>8e-6 && XBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (XBR[i-1][j-1][k-1]>9e-6 && XBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (XBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/
//	if		(XBR[i-1][j-1][k-1]>=Bound1 && XBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penXGreen1);}
//	else if (XBR[i-1][j-1][k-1]>=Bound2 && XBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penXGreen2);}
//	else if (XBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penXGreen3);}

	if		(XBR[i-1][j-1][k-1]>=Bound1 && XBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penXColour1);}
	else if (XBR[i-1][j-1][k-1]>=Bound2 && XBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penXColour2);}
	else if (XBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penXColour3);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penDarkGreen);}

	///SMcD Retino 10/08
//	memDC.SelectObject(&penYellow);
	///--------------------------

////Draw all network
	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}


//y-pores--

//	int YShade=int(ColourMult*YBR[i-1][j-1][k-1]);	//ie 255*(YBR/Rmax) => integer between 0,255

//	COLORREF YGreen1=RGB(0,YShade,0),YGreen2=RGB(0,YShade,0),YGreen3=RGB(0,YShade,0);

//	CPen penYGreen1(PS_SOLID,1,YGreen1);	//Same colour,
//	CPen penYGreen2(PS_SOLID,2,YGreen2);	//different line
//	CPen penYGreen3(PS_SOLID,3,YGreen3);	//thickness

	int YBlue=int(ColourMult*(Rmax-YBR[i-1][j-1][k-1]));
	int YRed=int(ColourMult*(YBR[i-1][j-1][k-1]-Rmin));

	COLORREF YColour1=RGB(YRed,0,YBlue),YColour2=RGB(YRed,0,YBlue),YColour3=RGB(YRed,0,YBlue);

	CPen penYColour1(PS_SOLID,1,YColour1);
	CPen penYColour2(PS_SOLID,2,YColour2);
	CPen penYColour3(PS_SOLID,3,YColour3);

/*
	//if      (YBR[i-1][j-1][k-1]>0 && YBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (YBR[i-1][j-1][k-1]>0.0  && YBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (YBR[i-1][j-1][k-1]>10e-6 && YBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (YBR[i-1][j-1][k-1]>15e-6 && YBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (YBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}


	if      (YBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (YBR[i-1][j-1][k-1]>Bound1 && YBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (YBR[i-1][j-1][k-1]>Bound2 && YBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (YBR[i-1][j-1][k-1]>Bound3 && YBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (YBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/

/*	if		(YBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (YBR[i-1][j-1][k-1]>4e-6 && YBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (YBR[i-1][j-1][k-1]>6e-6 && YBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (YBR[i-1][j-1][k-1]>7e-6 && YBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (YBR[i-1][j-1][k-1]>8e-6 && YBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (YBR[i-1][j-1][k-1]>9e-6 && YBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (YBR[i-1][j-1][k-1]>10e-6 && YBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (YBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/

//	if		(YBR[i-1][j-1][k-1]>=Bound1 && YBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penYGreen1);}
//	else if (YBR[i-1][j-1][k-1]>=Bound2 && YBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penYGreen2);}
//	else if (YBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penYGreen3);}

	if		(YBR[i-1][j-1][k-1]>=Bound1 && YBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penYColour1);}
	else if (YBR[i-1][j-1][k-1]>=Bound2 && YBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penYColour2);}
	else if (YBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penYColour3);}

	if (pFluid[nby-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nby-1]!=10) { memDC.SelectObject(&penDarkGreen);}
	
	
	///SMcD Retino 10/08
///	memDC.SelectObject(&penYellow);
	///--------------------------

	if (pFluid[nby-1]==10)
	{

		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//-----------------------------------------------
//---Draw Bone Tissue----------------------------
/*				if	(b_Bone_model)
				{
					if	(m_nz==1)
					{
						if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
						{
							memDC.SelectObject(&brushWhite);
							memDC.SelectObject(&penWhite);

							memDC.Rectangle(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),
											yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)),
											xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),
											yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
						}
					}

					else
					{
						if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
						{
							CPoint cubePts[5];	

//-----------------------------------------------

							//---Top Face------------
							memDC.SelectObject(&brushWhite);
							//memDC.SelectObject(&penWhite);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

							//---Side Face-----------
							memDC.SelectObject(&brushGrey2);
							//memDC.SelectObject(&penGrey2);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

							//---Front Face----------
							memDC.SelectObject(&brushGrey1);
							//memDC.SelectObject(&penGrey1);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();
						}
					}
				}*/
//----------------------------------------------------------
//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	int i=m_nx+1;

	int nbx=LabX(i,j,k);

//	int XShade=int(ColourMult*XBR[i-1][j-1][k-1]);	//ie 255*(ZBR/Rmax) => integer between 0,255

//	COLORREF XGreen1=RGB(0,XShade,0),XGreen2=RGB(0,XShade,0),XGreen3=RGB(0,XShade,0);

//	CPen penXGreen1(PS_SOLID,1,XGreen1);	//Same colour,
//	CPen penXGreen2(PS_SOLID,2,XGreen2);	//different line
//	CPen penXGreen3(PS_SOLID,3,XGreen3);	//thickness

	int XBlue=int(ColourMult*(Rmax-XBR[i-1][j-1][k-1]));
	int XRed=int(ColourMult*(XBR[i-1][j-1][k-1]-Rmin));

	COLORREF XColour1=RGB(XRed,0,XBlue),XColour2=RGB(XRed,0,XBlue),XColour3=RGB(XRed,0,XBlue);

	CPen penXColour1(PS_SOLID,1,XColour1);
	CPen penXColour2(PS_SOLID,2,XColour2);
	CPen penXColour3(PS_SOLID,3,XColour3);
/*	
	//if      (XBR[i-1][j-1][k-1]>0 && XBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}

	if      (XBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound1 && XBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound2 && XBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (XBR[i-1][j-1][k-1]>Bound3 && XBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/

/*	if		(XBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (XBR[i-1][j-1][k-1]>6e-6 && XBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (XBR[i-1][j-1][k-1]>8e-6 && XBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (XBR[i-1][j-1][k-1]>9e-6 && XBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (XBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/

//	if		(XBR[i-1][j-1][k-1]>=Bound1 && XBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penXGreen1);}
//	else if (XBR[i-1][j-1][k-1]>=Bound2 && XBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penXGreen2);}
//	else if (XBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penXGreen3);}

	if		(XBR[i-1][j-1][k-1]>=Bound1 && XBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penXColour1);}
	else if (XBR[i-1][j-1][k-1]>=Bound2 && XBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penXColour2);}
	else if (XBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penXColour3);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penDarkGreen);}


	///SMcD Retino 10/08
//	memDC.SelectObject(&penYellow);
	///--------------------------

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//-----------------------------------------------
//---Draw Bone Tissue----------------------------
/*			if	(b_Bone_model)
			{
				if	(m_nz==1)
				{
					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
					{
						memDC.SelectObject(&brushWhite);
						memDC.SelectObject(&penWhite);

						memDC.Rectangle(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),
										yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)),
										xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),
										yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
					}
				}

				else
				{
					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
					{
						CPoint cubePts[5];	

//-----------------------------------------------

						//---Top Face------------
						memDC.SelectObject(&brushWhite);
						//memDC.SelectObject(&penWhite);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Side Face-----------
						memDC.SelectObject(&brushGrey2);
						//memDC.SelectObject(&penGrey2);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Front Face----------
						memDC.SelectObject(&brushGrey1);
						//memDC.SelectObject(&penGrey1);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();
					}
				}
			}*/
//----------------------------------------------------------
//----------------------------------------------------------

	   }	//end j loop
	}		// end k loop

//-----------------------------------------------

//---Draw Bone Tissue----------------------------
	for	(int k=1;k<=m_nz;k++)
	{	for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx+1;i++)
			{
				if	(m_nz==1)
				{
					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
					{
/*						memDC.SelectObject(&brushWhite);
						memDC.SelectObject(&penWhite);

						memDC.Rectangle(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),
										yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)),
										xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),
										yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
*/
/*
outfileDebugBone<<i<<"\t"<<xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))<<"\t"<<
	yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))<<"\t"<<
		xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))<<"\t"<<
			yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))<<endl;
*/
/*						memDC.SelectObject(&penWhite);

						memDC.MoveTo(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)));
						memDC.LineTo(xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)));
						memDC.LineTo(xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx)),yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
						memDC.LineTo(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny)));
						memDC.LineTo(xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx)),yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny)));
*/
						CPoint cubePts[5];

						memDC.SelectObject(&brushWhite);
						memDC.SelectObject(&penWhite);

						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.StrokeAndFillPath();//memDC.FillPath();//
					}
				}

				else
				{
//					if	(k==57)//(j==57)//(i==57)//(i>2 && j>2 && i<m_nx-1 && j<m_ny-2 && k>2 && k<m_nz-2)//
//					{
					if	(bBoneTissue[i-1][j-1][k-1]==TRUE)
					{
						CPoint cubePts[5];	

//-----------------------------------------------

						//---Top Face------------
//						if (bBoneTissue[i-1][j-1-1][k-1]==FALSE)
//						{
							memDC.SelectObject(&brushWhite);
							//memDC.SelectObject(&penWhite);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();
//						}

//-----------------------------------------------

						//---Side Face-----------
//						if (bBoneTissue[i-1-1][j-1][k-1]==FALSE)
//						{
							memDC.SelectObject(&brushGrey2);
							//memDC.SelectObject(&penGrey2);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();
//						}

//-----------------------------------------------

						//---Front Face----------
//						if (bBoneTissue[i-1][j-1][k+1-1]==FALSE)
//						{
							memDC.SelectObject(&brushGrey1);
							//memDC.SelectObject(&penGrey1);

							cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

							cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
							cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

							memDC.BeginPath();
							memDC.Polygon(cubePts,5);
							memDC.EndPath();
							memDC.FillPath();//memDC.StrokeAndFillPath();
//						}
					}
//					}
				}
			}
		}
	}

//-----------------------------------------------

//---- draw the frame for 2D networks -----------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
//outfileDebugBone<<xMin<<"\t"<<(int)deltaX<<"\t"<<yMin<<"\t"<<(int)deltaY<<"\t"<<networkWidth<<"\t"<<m_nz<<"\t"<<iOffset<<"\t"<<sin(dAngle)<<endl;
 }

//------------------------------------------------

//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//==============================================================
void CAngioNetDlg::RadiiGraphicsBW(int xMin, int xMax, int yMin, 
								 int yMax, int networkWidth, 
								 double deltaX, double deltaY)
//==============================================================
{
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF White=RGB(255,255,255),Black=RGB(0,0,0),
			 Grey1=RGB(87,87,87),Grey2=RGB(150,150,150),
			 Grey3=RGB(195,195,195),Grey4=RGB(230,230,230),
			 colour=RGB(255,0,0),red=RGB(255,0,0);

//Define the pens
	CPen penRed(PS_SOLID,1,red);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penGrey3(PS_SOLID,1,Grey3);
	CPen penGrey4(PS_SOLID,1,Grey4);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);


//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);
//----------------------------------------------


//x-pores--

	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=2e-6) { memDC.SelectObject(&penBlack);}
	else if (XBR[i-1][j-1][k-1]>2e-6 && XBR[i-1][j-1][k-1]<=3e-6) { memDC.SelectObject(&penGrey1);}
	else if (XBR[i-1][j-1][k-1]>3e-6 && XBR[i-1][j-1][k-1]<=4e-6) { memDC.SelectObject(&penGrey2);}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=5e-6) { memDC.SelectObject(&penGrey3);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=6e-6) { memDC.SelectObject(&penGrey4);}
	else if (XBR[i-1][j-1][k-1]>6e-6)							  { memDC.SelectObject(&penWhite);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&Black);}
	
	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//y-pores--

	if      (YBR[i-1][j-1][k-1]>0    && YBR[i-1][j-1][k-1]<=2e-6) { memDC.SelectObject(&penBlack);}
	else if (YBR[i-1][j-1][k-1]>2e-6 && YBR[i-1][j-1][k-1]<=3e-6) { memDC.SelectObject(&penGrey1);}
	else if (YBR[i-1][j-1][k-1]>3e-6 && YBR[i-1][j-1][k-1]<=4e-6) { memDC.SelectObject(&penGrey2);}
	else if (YBR[i-1][j-1][k-1]>4e-6 && YBR[i-1][j-1][k-1]<=5e-6) { memDC.SelectObject(&penGrey3);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=6e-6) { memDC.SelectObject(&penGrey4);}
	else if (YBR[i-1][j-1][k-1]>6e-6)                             { memDC.SelectObject(&penWhite);}

	if (pFluid[nby-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nby-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//z-pores--

	if      (ZBR[i-1][j-1][k-1]>0    && ZBR[i-1][j-1][k-1]<=2e-6) { memDC.SelectObject(&penBlack);}
	else if (ZBR[i-1][j-1][k-1]>2e-6 && ZBR[i-1][j-1][k-1]<=3e-6) { memDC.SelectObject(&penGrey1);}
	else if (ZBR[i-1][j-1][k-1]>3e-6 && ZBR[i-1][j-1][k-1]<=4e-6) { memDC.SelectObject(&penGrey2);}
	else if (ZBR[i-1][j-1][k-1]>4e-6 && ZBR[i-1][j-1][k-1]<=5e-6) { memDC.SelectObject(&penGrey3);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=6e-6) {	memDC.SelectObject(&penGrey4);}
	else if (ZBR[i-1][j-1][k-1]>6e-6)                             { memDC.SelectObject(&penWhite);}

	if (pFluid[nbz-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbz-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}

//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	int i=m_nx+1;

	int nbx=LabX(i,j,k);
	
	if      (XBR[i-1][j-1][k-1]>0    && XBR[i-1][j-1][k-1]<=2e-6) { memDC.SelectObject(&penBlack);}
	else if (XBR[i-1][j-1][k-1]>2e-6 && XBR[i-1][j-1][k-1]<=3e-6) { memDC.SelectObject(&penGrey1);}
	else if (XBR[i-1][j-1][k-1]>3e-6 && XBR[i-1][j-1][k-1]<=4e-6) { memDC.SelectObject(&penGrey2);}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=5e-6) { memDC.SelectObject(&penGrey3);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=6e-6) { memDC.SelectObject(&penGrey4);}
	else if (XBR[i-1][j-1][k-1]>6e-6)                             { memDC.SelectObject(&penWhite);}

	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	}


	   }	//end j loop
	}		// end k loop


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }


//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}


//*****************************************************

//============================================================
void CAngioNetDlg::SpareGraphics(int xMin, int xMax, int yMin, 
								 int yMax, int networkWidth, 
								 double deltaX, double deltaY)
//============================================================
{
//Get a device context first
	CClientDC graphicsDC(this);

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0);

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,1,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=graphicsDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	graphicsDC.TextOut(387,20,myString);


//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}
//------------------------------------------
	//Get Max Mass in a bond----
	double	dMaxMass=ConMax*PI*artRad*artRad*bondLength/5.0;
//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------

//---------------------------------------------

//x-pores
	if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.001*dMaxMass)
	{
		graphicsDC.SelectObject(&penDarkBlue);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.001*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.1*dMaxMass)
	{
		graphicsDC.SelectObject(&penLightBlue);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.1*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.5*dMaxMass)
	{
		graphicsDC.SelectObject(&penWhite);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.5*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.9*dMaxMass)
	{
		graphicsDC.SelectObject(&penPink);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.9*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}

///	if( XBR[i-1][j-1][k-1]<)
//	{
//		graphicsDC.SelectObject(&penLightBlue);
//	}

	if( *(pFluid+(nbx-1))==66)
	{
		graphicsDC.SelectObject(&penBlack);
	}

	graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

//	graphicsDC.MoveTo(xMin+(int)deltaX+(i-1)*networkWidth/m_nx,
//						 yMin+(int)deltaY+j*networkWidth/m_ny);
//	graphicsDC.LineTo(xMin+(int)deltaX+i*networkWidth/m_nx,
//						 yMin+(int)deltaY+j*networkWidth/m_ny);


//y-pores--
	if (pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength <= 0.001*dMaxMass)
	{
		graphicsDC.SelectObject(&penDarkBlue);
	}
	else if (pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength > 0.001*dMaxMass &&
			 pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength <= 0.1*dMaxMass)
	{
		graphicsDC.SelectObject(&penLightBlue);
	}
	else if (pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength > 0.1*dMaxMass &&
			 pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength <= 0.5*dMaxMass)
	{
		graphicsDC.SelectObject(&penWhite);
	}
	else if (pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength > 0.5*dMaxMass &&
			 pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength <= 0.9*dMaxMass)
	{
		graphicsDC.SelectObject(&penPink);
	}
	else if (pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength > 0.9*dMaxMass &&
			 pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength <= 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}
	else if (pYCON[i-1][j-1][k-1] * PI* pow(YBR[i-1][j-1][k-1],2) * bondLength > 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}

//	if( YBR[i-1][j-1][k-1]<)
//	{
//		graphicsDC.SelectObject(&penLightBlue);
//	}
	
	if( *(pFluid+(nby-1))==66)
	{
		graphicsDC.SelectObject(&penBlack);
	}

	graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);


//	graphicsDC.MoveTo(xMin+(int)deltaX+i*networkWidth/m_nx,
//						 yMin+(int)deltaY+(j-1)*networkWidth/m_ny);
//	graphicsDC.LineTo(xMin+(int)deltaX+i*networkWidth/m_nx,
//						 yMin+(int)deltaY+j*networkWidth/m_ny);

//z-pores--
	if (pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength  <= 0.001*dMaxMass)
	{
		graphicsDC.SelectObject(&penDarkBlue);
	}
	else if (pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength > 0.001*dMaxMass &&
			 pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength <= 0.1*dMaxMass)
	{
		graphicsDC.SelectObject(&penLightBlue);
	}
	else if (pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength > 0.1*dMaxMass &&
			 pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength <= 0.5*dMaxMass)
	{
		graphicsDC.SelectObject(&penWhite);
	}
	else if (pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength> 0.5*dMaxMass &&
			 pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength <= 0.9*dMaxMass)
	{
		graphicsDC.SelectObject(&penPink);
	}
	else if (pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength > 0.9*dMaxMass &&
			 pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength <= 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}
	else if (pZCON[i-1][j-1][k-1] * PI* pow(ZBR[i-1][j-1][k-1],2) * bondLength > 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}

//	if( ZBR[i-1][j-1][k-1]<)
//	{
//		graphicsDC.SelectObject(&penLightBlue);
//	}
	
	if( *(pFluid+(nbz-1))==66)
	{
		graphicsDC.SelectObject(&penBlack);
	}

	graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores
	int i=m_nx+1;

	int nbx=LabX(i,j,k);
//------------------------------------
	if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.001*dMaxMass)
	{
		graphicsDC.SelectObject(&penDarkBlue);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.001*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.1*dMaxMass)
	{
		graphicsDC.SelectObject(&penLightBlue);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.1*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.5*dMaxMass)
	{
		graphicsDC.SelectObject(&penWhite);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.5*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 0.9*dMaxMass)
	{
		graphicsDC.SelectObject(&penPink);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 0.9*dMaxMass &&
			 pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength <= 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}
	else if (pXCON[i-1][j-1][k-1] * PI* pow(XBR[i-1][j-1][k-1],2) * bondLength > 1.01*dMaxMass)
	{
		graphicsDC.SelectObject(&penRed);
	}

///	if( XBR[i-1][j-1][k-1]<)
//	{
//		graphicsDC.SelectObject(&penLightBlue);
//	}

	if( *(pFluid+(nbx-1))==66)
	{
		graphicsDC.SelectObject(&penBlack);
	}

	graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

//	graphicsDC.MoveTo(xMin+(int)deltaX+(i-1)*networkWidth/m_nx,
//						 yMin+(int)deltaY+j*networkWidth/m_ny);
//	graphicsDC.LineTo(xMin+(int)deltaX+i*networkWidth/m_nx,
//						 yMin+(int)deltaY+j*networkWidth/m_ny);


	   }	//end j loop
	}		// end k loop

//Finally, restore old pen
	graphicsDC.SelectObject(pOldPen);
}


//*****************************************************

//============================================
void CAngioNetDlg::SetInitialAngioDrugTracer()
//============================================
{
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]==66)	{pXAngioDrug[i-1][j-1][k-1]=0.0;}
		   	 else					{pXAngioDrug[i-1][j-1][k-1]=AngioDrugMin/AngioDrugMax;}
		
		  	 if (pFluid[nby-1]==66)	{pYAngioDrug[i-1][j-1][k-1]=0.0;}
			 else					{pYAngioDrug[i-1][j-1][k-1]=AngioDrugMin/AngioDrugMax;}
		
	         if (pFluid[nbz-1]==66)	{pZAngioDrug[i-1][j-1][k-1]=0.0;}
			 else					{pZAngioDrug[i-1][j-1][k-1]=AngioDrugMin/AngioDrugMax;}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==66)	{pXAngioDrug[i-1][j-1][k-1]=0.0;}
			else					{pXAngioDrug[i-1][j-1][k-1]=AngioDrugMin/AngioDrugMax;}
	 }}
}


//*****************************************************

//===================================
void CAngioNetDlg::SetInitialTracer()
//===================================
{
//I could just do an nn loop here BUT I want to keep
//the i j k looping structure to facilitate translation
//from my existing FORTRAN code

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);

			//x-pores
			 if (pFluid[nbx-1]==66)	{pXCON[i-1][j-1][k-1]=0.0;}
		   	 else					{pXCON[i-1][j-1][k-1]=ConMin/ConMax;}
			//y-pores
		  	 if (pFluid[nby-1]==66)	{pYCON[i-1][j-1][k-1]=0.0;}
			 else					{pYCON[i-1][j-1][k-1]=ConMin/ConMax;}
			//z-pores
	         if (pFluid[nbz-1]==66)	{pZCON[i-1][j-1][k-1]=0.0;}
			 else					{pZCON[i-1][j-1][k-1]=ConMin/ConMax;}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			//dangling x-pores
			if (pFluid[nbx-1]==66)	{pXCON[i-1][j-1][k-1]=0.0;}
			else					{pXCON[i-1][j-1][k-1]=ConMin/ConMax;}
	 }}
}


//*****************************************************

//=======================================
void CAngioNetDlg::SetInitialHematocrit()
//=======================================
{
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
	double randDice;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 nbx=LabX(i,j,k);
			 nby=LabY(i,j,k);
			 nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]==66)	{pXHem[i-1][j-1][k-1]=0.0;}
			 else					
			 {	 randDice=float(rand())/float(RAND_MAX);
				 pXHem[i-1][j-1][k-1]=AverageHt+(randDice-0.5)*0.2;
			 }
		  	 if (pFluid[nby-1]==66)	{pYHem[i-1][j-1][k-1]=0.0;}
			 else					
			 {	 randDice=float(rand())/float(RAND_MAX);
				 pYHem[i-1][j-1][k-1]=AverageHt+(randDice-0.5)*0.2;
			 }
	         if (pFluid[nbz-1]==66)	{pZHem[i-1][j-1][k-1]=0.0;}
			 else					
			 {	 randDice=float(rand())/float(RAND_MAX);
				 pZHem[i-1][j-1][k-1]=AverageHt+(randDice-0.5)*0.2;
			 }
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==66)	{pXHem[i-1][j-1][k-1]=0.0;}
			else					
			{	randDice=float(rand())/float(RAND_MAX);
				pXHem[i-1][j-1][k-1]=AverageHt+(randDice-0.5)*0.2;
			}
	 }}
*/
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
	ifstream inputfileInitHem("Results/InitHem.txt");

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  inputfileInitHem >> pXHem[i-1][j-1][k-1];
			  inputfileInitHem >> pYHem[i-1][j-1][k-1];
			  inputfileInitHem >> pZHem[i-1][j-1][k-1];
			}
			i=m_nx+1;
			inputfileInitHem >> pXHem[i-1][j-1][k-1];
	}}
*/
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				pXHem[i-1][j-1][k-1]=0.0;
				pYHem[i-1][j-1][k-1]=0.0;
				pZHem[i-1][j-1][k-1]=0.0;
			}
			int i=m_nx+1;
				pXHem[i-1][j-1][k-1]=0.0;
	 }}

//-----------------------------------------------

//---Initialise intact PV hematocrits to 0.45---
	int i;
	int kk=1;
	if (m_nz!=1) {kk=m_nz/2;}	//3D arteriole in middle of top face

	for	(i=1;i<=m_nx+1;i++)	//do an x-scan
	{
//		pXHem[i-1][0][5-1]=AverageHt;//pXHem[i-1][0][kk-1]=AverageHt;//	//Upper PV

		if	(b_venousIncluded || b_UU_wound_Model) //venule if required
		{
//			pXHem[i-1][m_ny-1-1][45-1]=AverageHt;//pXHem[i-1][m_ny-1-1][kk-1]=AverageHt;//
		}

//------------------------------------------------------
		if	(b_UU_wound_Model && (!b_HexNetwork || (b_HexNetwork && b_StraightPVs)))	//square network or hex network with straight PVs 
		{
			for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
			{
//				if	(
//						nCount*m_ny/(nAdditionalCentralPVs+1)<=jCentre-iWoundRadius
//						||
//						nCount*m_ny/(nAdditionalCentralPVs+1)>=jCentre+iWoundRadius
//					)

				{
					pXHem[i-1][nCount*m_ny/(nAdditionalCentralPVs+1)-1][kk-1]=AverageHt;//0.0;//
				}

//-----------------------------------------------
			}	//end nCount loop

//-----------------------------------------------
		}	//end if UU wound

//-----------------------------------------------
	}	//end i loop

//-----------------------------------------------

	if	(b_UU_wound_Model && b_HexNetwork && !b_StraightPVs)	//hex network with wiggly PVs
	{
		for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{
			int	j=nCount*m_ny/(nAdditionalCentralPVs+1);//4;

			if	(int(j/2)-double(j/2.0)==0)	//if j even (inlets & outlets on j+1)
			{
				for (i=2;i<=m_nx-2;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pXHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pXHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

				for (i=1;i<=m_nx;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pXHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				i=m_nx+1;	
		
				if	(
						j<=jCentre-iWoundRadius
						||
						j>=jCentre+iWoundRadius
					)

				{
					pXHem[i-1][j-1][kk-1]=AverageHt;
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pYHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

						{
							pYHem[i-1][j-1][kk-1]=AverageHt;
						}
				}

//-----------------------------------------------
			}	//end if j even

//-----------------------------------------------

			else	//if j odd (inlets & outlets on j)
			{
				for (i=1;i<=m_nx;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pYHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				i=m_nx+1;	
		
				if	(
						j<=jCentre-iWoundRadius
						||
						j>=jCentre+iWoundRadius
					)

				{
					pXHem[i-1][j-1][kk-1]=AverageHt;
				}

//-----------------------------------------------
				j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

				for (i=2;i<=m_nx-2;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pYHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pXHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pYHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pYHem[i-1][j-1][kk-1]=AverageHt;
					}
				}

//-----------------------------------------------								
			}	//end if j odd
//-----------------------------------------------

		}	//end nCount loop

	}	//end if hexagonal vasculature

//-----------------------------------------------
//-----------------------------------------------
	//Arterioles 11.06 SMcD Could leave this assigned to simulate healthy state
	
/////	for (int i=1;i<=m_nx+1;i++)
/////	{
/////		pXHem[i-1][1-1][k-1]=AverageHt;
/////		pXHem[i-1][m_ny-1-1][k-1]=AverageHt;
/////	}

//-----------------------------------------------
/*
	int nbx,nby,nbz;

	for (k=1;k<=m_nz;k++)
	{	for (int j=55;j<=70;j++)
		{	for (int i=20;i<=60;i++) //1 to 25
			{
			 nbx=LabX(i,j,k);
			 nby=LabY(i,j,k);
			 nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]==10)	{pXHem[i-1][j-1][k-1]=0.45;}
		  	 if (pFluid[nby-1]==10)	{pYHem[i-1][j-1][k-1]=0.45;}
	         if (pFluid[nbz-1]==10)	{pZHem[i-1][j-1][k-1]=0.45;}
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10)	{pXHem[i-1][j-1][k-1]=0.45;}
	 }}

	for (k=1;k<=m_nz;k++)
	{	for (int j=55;j<=70;j++)
		{	for (int i=45;i<=70;i++)
			{
			 nbx=LabX(i,j,k);
			 nby=LabY(i,j,k);
			 nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]==10)	{pXHem[i-1][j-1][k-1]=0.45;}
		  	 if (pFluid[nby-1]==10)	{pYHem[i-1][j-1][k-1]=0.45;}
	         if (pFluid[nbz-1]==10)	{pZHem[i-1][j-1][k-1]=0.45;}
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10)	{pXHem[i-1][j-1][k-1]=0.45;}
	 }}
*/
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
}

//***********************************************
//=====================================
void CAngioNetDlg::CycleAndGraphics()
//=====================================
{
//Update loop number
	loop++;

///	Take a timestep
//	if (bGrowing)	//read in growth deltaT - different mu will still give
					//correct deltaT during flow from AdaptVasc()
//	{
//	infileTime >> angioDeltaT; //use the deltaT from later sims for growth
//	}

///	if (!bGrowing)	//only save growth deltaT
///	{
///	outfileTime << angioDeltaT << endl; //save the deltaT for later sims
///	}

///	angioDeltaT=0.003;	//definite floor value for rho=0.28 case
						//(ran this first with variable deltaT to get floor value)

	flowDeltaT=angioDeltaT;  //angioDeltaT will vary during flow loops (mass conservation)
	if (bGrowing)
	{
		angioDeltaT=0.005;
//		if	(m_Nutrients && m_presetNetwork)	{oxyTime+=oxyDeltaT;}//angioDeltaT=oxyDeltaT;}
//		else	{angiotime+=angioDeltaT;}
		angiotime+=angioDeltaT;
	}
	else
	{
		flowTime+=flowDeltaT;
//	outfileFlow2 << flowDeltaT << endl;
	}

	//-----------------------------------
	if(m_adaptVasculature)	//if remodelling
	{
		if (
			  flowTime+angiotime>=(nGrowthInterval-1)*growthDuration + 
					 (nGrowthInterval-1)*flowDuration       && 
			  flowTime+angiotime<=(nGrowthInterval)*growthDuration + 
					 (nGrowthInterval-1)*flowDuration
		   )
		   
		{
			bGrowing=true;	//currently in a growth+flow interval
		}

		else 
		{
			if(bGrowing) {nGrowthInterval++;} //define next growth period
			bGrowing=false;	//currently in a flow only interval
			b_justFinishedFlowPeriod=true;
			//FlowingVessels();  //Find the conected vessels at end of growth phase and start of flowingg phase

//--------------------------------------

		}

	}//end if remodelling

////	angiotime+=angioDeltaT; //SMcD May2005 just for me to track a posteriori remodelling
							//or drug delivery simulations
	//---------------------------------------

//-----------------------------------------------
// CONTINUOUS PDE SOLUTIONS
//-----------------------------------------------

	if (m_presetNetwork==FALSE//TRUE// 
		&& m_circTumour==FALSE
		&& m_WoundOption==FALSE && bGrowing) //only do if network is not preset and at certain times



	{
/*
	//--MODIF A.S. (version 2.0)---
		OverWriteOldWithNew2();
		UpdateVariables();
		UpdateFN2();
		UpdateTAF2();
		CellConservation2();
	//-----------------------------
*/

		if	(b_justFinishedFlowPeriod)
		{
			if	(m_Nutrients)
			{
				oxyTime=0.0;
				RateNutChangeMAX=0.0;

				LocaliseVesselNutrients();
//				outfileOxygen << "got past localise" << endl;
				CalculateNutrientTimeStep();
//				outfileOxygen << "got past time step" << endl;

				oxyTime+=oxyDeltaT;

				while	(
							oxyTime<10.0 
							||
							//RateNutChangeMAX!=0
							//&&
							RateNutChangeMAX>8.0e-5//2.5e-5
						)
				{
					UpdateTissueNutrientConcs();
//					outfileOxygen << "got past update concs" << endl;
					OverWriteOldWithNewVesselConcs();
//					outfileOxygen << "got past overwrite vessels" << endl;

					OnDrawIt3();
//					outfileOxygen << "got past graphics" << endl;

					ProcessMessageLoop();
					UpdateData();

					oxyTime+=oxyDeltaT;
				}
			}

//			PruneCapillaries();

			SaveVasculature();
			SaveVasculatureRadii();
			SaveHematocrit();
			SaveFlows();
			SaveNutrient();

			b_justFinishedFlowPeriod=false;
		}

	//--MODIF A.S. (version 3.0)---
	// new model taking into account the matrix degrading factor (MDF)
		OverWriteOldWithNew3();
		LocalizeSproutsTips(); //just seems to assign vSproutTips=1 to all tip cells
		//UpdateMDF();
		UpdateMDF2();	//reduced diffusion in bone tissue
		UpdateFN3();
		UpdateTAF3();
/////		UpdateTAFWithDiffusion();

/*		if (m_Nutrients)	
		{
			LocaliseVesselNutrients();	//Resets sources to Omax to avoid numerical issues
			UpdateTissueNutrientConcs();	//put here to do nutrients during dynamic growth
		
		}
*/
		
		//-----------------------------

	}//not done if preset network


//-----------------------------------------------
// DISCRETE VESSEL GROWTH
//-----------------------------------------------

	if (m_presetNetwork==FALSE 
		&& m_circTumour==FALSE
		&& m_WoundOption==FALSE && bGrowing)	//only do if network is not preset and at certain times


	{
	//Get the probabilities for sprout tip migration and grow the vessels
/*
	//--MODIF A.S. (version 2.0)-----------------
	//if (angiotime>=0.5)
	//{  
		for (int tt=1; tt<4; tt++)
		{
			GetProbs();
			GrowVasculature();
			Anastomosis();
			AgeSprouts();
			BranchSprouts2();
		}
	//}
	// To save the vasculature grown
		double saveTime=angiotime;
	    if (saveTime=14.02) { SaveVasculature(); }
	//--------------------------------------------
*/

	//--MODIF A.S. (version 3.0)-----------------

		//Move the pericytes first
		if (b_IncludeDiscretePericytes)
		{
		  GetProbsPericytes();
		  MovePericytes();
		}
		//------------------
outfileDebugBone << angiotime << endl;
	  //Now grow the vessels
		//GetProbs();
		//GetProbs2();	//Corrections on the probability coefficients
		  GetProbs3();	//Includes bone barriers (Mike 01/13)
outfileDebugBone << "got past probs" << endl;
		//GrowVasculature();
		//GrowVasculatureMDF();
		GrowVasculatureMDF2();	//Some small modifications (Mike 01/13)
outfileDebugBone << "got past grow" << endl;
		  Anastomosis();
		  AgeSprouts();
		  AgeVessels();

//		    if	(m_adaptVasculature)	{WoundRemodelling();}	//Mike 11/08
//			WoundConnectivity();	//Mike 11/08
//			WoundVesselCount();	//Mike 11/08
//			WoundBranchPoints();	//Mike 11/08
//			WoundVesselRadius();	//Mike 11/08
//			if	(angiotime>growthDuration)	
//			{
//				CalculateWoundArea();
//			}
		  		  
	///BranchSprouts2();
	///	BranchSproutsMDF();
////SMcD2005		  
////		  BranchSproutsTAF();
		  //BranchSproutsTAFWSS();
		  BranchSproutsTAFWSS2();	//More general algorithm (Mike 01/13)
									//Choose whether or not 1 sprout maintains original direction (in 2D and 3D)
outfileDebugBone << "got past branch" << endl;
		//--------------------------

		//Finally, update the pericyte dendity base upon discrete coverage
	    //(NB only uses logistic law at present)-------------
		  UpdatePericyteDensity();
		//------------------------------------



		//SMcD 10/2004 -- Get probabilities and move tumour cells
////Comment out for now 2005		  GetProbsTumCells();
////Comment out for now 2005		  MoveTumCells();
		//---------------------------

////Comment out for now 2005	      AntiangiogenicTreatment();

	// To save the vasculature grown
		double saveTime=angiotime;
		if (loop%500==0) 
		{ 
//			SaveVasculature();
//			SaveVasculatureRadii();
//			SavePericytes();
//			SaveMDE();
//			SaveDiscretePCs();
//			SaveNutrient();
//			SaveFlows();				//Mike 12/08
//			SaveAgeVessels();			//Mike 12/08
//			SaveHematocrit();			//Mike 06/09
//			SaveWoundArea();			//Mike 07/10
			
			
		}
		
	//--------------------------------------------

	}	//not done if preset network



//----------Nutrient Updates if network has been read-in
	if ((m_presetNetwork || m_circTumour || m_WoundOption) && m_Nutrients)
	{
//		UpdateTissueNutrientConcs();	//need to comment this if no diffusion needed
//		UpdateTissueNutrientConcs2();
//		OverWriteOldWithNewVesselConcs();

		if	(bGrowing && loop==1)
		{
//			if (b_justFinishedFlowPeriod)
//			{
				oxyTime=0.0;
				RateNutChangeMAX=0.0;

				SetInitialVesselNutConc();
				SetInitialTissueNutrientConc();
				LocaliseVesselNutrients();
				//if(oxyTime>8.0) {outfileTracerOxy << "got past localise" << endl;
				CalculateNutrientTimeStep();
				//if(oxyTime>8.0) {outfileTracerOxy << "got past time step" << endl;

				oxyTime+=oxyDeltaT;

				while	(
							oxyTime<10.0 
							||
							//RateNutChangeMAX!=0
							//&&
							RateNutChangeMAX>8.0e-5//4.0e-5//2.5e-5
						)
				{
					UpdateTissueNutrientConcs();
					//if(oxyTime>8.0) {outfileTracerOxy << "got past update concs" << endl;
					OverWriteOldWithNewVesselConcs();
//					outfileOxygen << "got past overwrite vessels" << endl;

					OnDrawIt3();
//					outfileOxygen << "got past graphics" << endl;

					ProcessMessageLoop();
					UpdateData();
					
					oxyTime+=oxyDeltaT;
				}

				SaveNutrient();
//				SaveVasculature();
//				SaveVasculatureRadii();

//			}

//			b_justFinishedFlowPeriod=false;	//means that network is only 
											//pruned immediately 
											//after a flow period (and oxygen update if required - Mike 11/10)
		}
	}
//-----------------------------------------------------



//If tracer flood has been requested, call the tracer routine
	CButton* pTracer=(CButton*)GetDlgItem(IDC_TRACER1);

	if (pTracer->GetCheck())
	{
			outfileVasc << "before tracer" << endl;

		if (m_WoundOption)
		{
			UpdateTracerWound();	//SMcD 10/2004  only for James' wound vessels
		}
		else
		{
			UpdateTracer();			//Should be used normally
		}

			outfileVasc << "after tracer" << endl;

		//----- Antiangiogenic therapy ---------------------
//SMcD 10/2004 change for wound BCs	if I want to put drug into wound
////		if (angiotime>10.0 && !m_WoundOption) 
////		{
////			UpdateAntiangioDrugTracer();
			TumourUptake();
////		}
////		//--------------------------------------------------


	//---------------------------------------------------			
		if(angiotime>dStore) 
		{
			WriteAwayMasses();
			dStore+=1.0;	//only write away after another 1.0 second
		}

		if(angiotime> replayStore)//replayStore*m_angiotimeMax/m_nReplayLoops) 
		{
///Feb2007			WriteAwayConcs();
			replayStore+=1;
		}

//----------------------------------------------------	


//		double saveTime2=angiotime;
//		if (saveTime2=3.5) {SaveVasculatureRadii();}
	}

//-----------------End Tracer option----------------------



//--------Now adapt vasculature if required---------------------

	if (m_adaptVasculature && bGrowing==false) //need to remodel radii
	{
		if (m_WoundOption )
		{
			AdaptVasculatureWound();
		}
		else
		{
			AdaptVasculature2();	//remove this to get earlier tracer results
		}

		if (loop%1000==0) 
		{ 
//			SaveVasculature();
//			SaveVasculatureRadii();
//			SavePericytes();
//			SaveMDE();
//			SaveDiscretePCs();
//			SaveNutrient();
//			SaveFlows();				//Mike 12/08
//			SaveAgeVessels();			//Mike 12/08
//			SaveHematocrit();			//Mike 06/09
//			SaveWoundArea();			//Mike 07/10

					}

	}

		outfileVasc << "Out of adapt" << endl;
//-----------------------------------------------------------------
}


//*****************************************************

//===================================
void CAngioNetDlg::AdaptVasculature()
//===================================
{
	//UpdateHematocrit();
	//UpdateViscosity();

	IterationNumber=0;
	//UpdateHematocrit();

	while (ConvergenceFlow==false)
	{
		while (ConvergenceRadius==false) 
		{
			UpdateViscosity();
			CalculateWallShearStress();
			UpdateRadii2();
			IterationNumber+=1;
			OnDrawIt3();
			
			outfileIteration << "Shear" << "\t" << IterationNumber << endl;
		}
		ConvergenceRadius=false;

		KeepOldFlow();
		assignConductivities2();
		VesselConductivities();
		calculatePressuresAndFlows(10);
		FlowConvergence();
		//UpdateHematocrit();
		IterationNumber+=1;
		OnDrawIt3();

		//-------
		CalculateMinMaxMean(XFlow,YFlow,ZFlow);
		outfileFlow << IterationNumber << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;
		//-------

		outfileIteration << "Flow" << "\t" << IterationNumber <<endl;
	}
}

//*****************************************************

//====================================
void CAngioNetDlg::AdaptVasculature3()
//====================================
{
	IterationNumber=0;

	while (ConvergenceFlow==false)
	{
		while (ConvergenceRadius==false) 
		{
			while (ConvergenceViscosity==false)
			{
				UpdateHematocrit();
				UpdateViscosity();
				ViscosityConvergence();
				IterationNumber+=1;
				OnDrawIt3();

				outfileIteration << "Viscosity" << "\t" << IterationNumber << endl;
			}
			ConvergenceViscosity=false;

			CalculateWallShearStress();
			UpdateRadii2();
			IterationNumber+=1;
			OnDrawIt3();
			
			outfileIteration << "Shear" << "\t" << IterationNumber << endl;
		}
		ConvergenceRadius=false;

		KeepOldFlow();
		assignConductivities2();
		VesselConductivities();
		calculatePressuresAndFlows(10);
		FlowConvergence();
		IterationNumber+=1;
		OnDrawIt3();

		//-------
		CalculateMinMaxMean(XFlow,YFlow,ZFlow);
		outfileFlow << IterationNumber << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;
		//-------

		outfileIteration << "Flow" << "\t" << IterationNumber <<endl;
	}
}

//*****************************************************

//====================================
void CAngioNetDlg::AdaptVasculature2()
//====================================
{	


//SMcD 11.06================
/*	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]!=10) {XBR[i-1][j-1][k-1]*=100.0;}
				if (pFluid[nby-1]!=10) {YBR[i-1][j-1][k-1]*=100.0;}
				if (pFluid[nbz-1]!=10) {ZBR[i-1][j-1][k-1]*=100.0;}

			}
				int nbx=LabX(m_nx+1,j,k);
				

				if (pFluid[nbx-1]!=10) {XBR[i-1][j-1][k-1]*=100.0;}

		}
	}
	*/
//==========================

	outfileVasc << "in adaptvasc" << endl;
//	if	(flowTime>15.0)
//	{
//		if (m_Nutrients)	//Mike 07/10
//		{
//			LocaliseVesselNutrients();	
//			outfileVasc << "after localise" << endl;
//		}
//	}

//	if	(flowTime<=15.0)
//	{
//		CalculateFlowTimeStep();
//	}

	outfileVasc << "after timestep" << endl;

//	if	(flowTime>15.0)
//	{
//		if	(m_Nutrients)	//Mike 07/10
//		{
			//LocaliseVesselNutrients();	//Resets sources to Omax to avoid numerical issues
//			UpdateTissueNutrientConcs();	//put here to do nutrients during dynamic growth
//			OverWriteOldWithNewVesselConcs();

//			outfileVasc << "after nutrient" << endl;
//		}
//	}

//	if	(flowTime<=15.0)
//	{
/*		if	(bSkimming)
		{UpdateHematocrit2();
		outfileVasc << "after hem2" << endl;}
		else
		{UpdateHematocrit();
		outfileVasc << "after hem" << endl;}
*/
//=================================================================================================
	//Find the min time needed until a pore is completely emptied
	//can't go longer than this otherwise mass isn't conserved

	double tempDeltaT;
	double theminflow=1.0e-30;
	double timestep=1.0e20;
	double timeStepInit=1.0e20;
	int MinTime_i,MinTime_j,MinTime_k;
	double MinTime_Rad,MinTime_Flow;
	double MinTime_NP1,MinTime_NP2;
	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
				{
					tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
					if (tempDeltaT < timestep) {timestep=tempDeltaT; 
												MinTime_i=i;
												MinTime_j=j;
												MinTime_k=k;
												MinTime_Rad=XBR[i-1][j-1][k-1];
												MinTime_Flow=fabs(XFlow[i-1][j-1][k-1]);
												if (i==1) {MinTime_NP1=Pin;} else {MinTime_NP1=NodalPressures[i-1-1][j-1][k-1];}
												MinTime_NP2=NodalPressures[i-1][j-1][k-1];}
				}
			

				if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
				{
					tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/fabs(YFlow[i-1][j-1][k-1]);
					if (tempDeltaT < timestep) {timestep=tempDeltaT; 
												MinTime_i=i;
												MinTime_j=j;
												MinTime_k=k;
												MinTime_Rad=YBR[i-1][j-1][k-1];
												MinTime_Flow=fabs(YFlow[i-1][j-1][k-1]);
												MinTime_NP1=NodalPressures[i-1][j-1-1][k-1];
												MinTime_NP2=NodalPressures[i-1][j-1][k-1];}
				}
			

				if (m_nz !=1)
				{
					if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
					{
					tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/fabs(ZFlow[i-1][j-1][k-1]);
					if (tempDeltaT < timestep) {timestep=tempDeltaT;
												MinTime_i=i;
												MinTime_j=j;
												MinTime_k=k;
												MinTime_Rad=ZBR[i-1][j-1][k-1];
												MinTime_Flow=fabs(ZFlow[i-1][j-1][k-1]);
												MinTime_NP1=NodalPressures[i-1][j-1][k-1-1];
												MinTime_NP2=NodalPressures[i-1][j-1][k-1];}
					}
				}


			}

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_k=k;
											MinTime_Rad=XBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(XFlow[i-1][j-1][k-1]);
											MinTime_NP1=NodalPressures[i-1-1][j-1][k-1];
											MinTime_NP2=Pout;}
			}
	}}

	if ( fabs(timeStepInit-timestep) / timeStepInit <= 0.01) 
	{MessageBox("Timestep error");}

	outfileDebugTime << timestep << "\t" << MinTime_i << "\t" << 
						MinTime_j << "\t" << MinTime_k << "\t" <<
						MinTime_Rad << "\t" << MinTime_Flow << "\t" <<
						MinTime_NP1 << "\t" << MinTime_NP2 << "\t" << flowTime << endl;

	angioDeltaT=timestep/TimeFactor;
//=================================================================================================

		outfileVasc << "after update haem" << endl;	  	
	
		UpdateViscosity();

		outfileVasc << "after update visc" << endl;

//if	(!b_TestNetwork)
//	{

//	if	(angiotime>3.16)
//	{
/*		CalculateWallShearStress();
		outfileVasc << "after TauW" << endl;
		CalculateTauE();
		outfileVasc << "after TauE" << endl;

		if (loop%10==0 && b_NewPries==true)
		{
//			CalculateConvectedStim();
//			CalculateConductedStim();
			IdentifyFalseFlows();
			outfileVasc << "after false flow" << endl;
			CalculateConvectedStim2();
			CalculateConductedStim2();
			outfileVasc << "after convected" << endl;
			
			outfileVasc << "after conducted" << endl;
		}

		

		UpdateRadii3();
*/
//	}
//	}

	  	outfileVasc << "after radii" << endl;

//--------------------------------------
		assignConductivities2();
		VesselConductivities();
		calculatePressuresAndFlows(10);
//--------------------------------------
	  //SproutPressure();
		CalculatePressureInVessel();
		outfileVasc << "after calcpressflowsinvessel" << endl;
//	}

/*		outfileDebugBone<<flowTime<<endl;
		for (int k=1;k<=m_nz;k++)
		{
			outfileDebugBone<<k<<endl;
		for (int j=1;j<=m_ny;j++)
		{
			for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);
				
				if ((pFluid[nbz-1]==10 && FalseFlow[nbz-1]==false) || (pFluid[nbx-1]==10 && FalseFlow[nbx-1]==false) || (pFluid[nby-1]==10 && FalseFlow[nby-1]==false)){outfileDebugBone<<NodalPressures[i-1][j-1][k-1]<<"\t";}
				else {outfileDebugBone<<"\t";}
				if (i==m_nx) {outfileDebugBone<<endl;}
			}
		}
		}
		outfileDebugBone<<endl;
*/

//	if (loop%10==0) {

//CalculateMinMaxMean(pXHem,pYHem,pZHem);
//outfileHem << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(Xmu,Ymu,Zmu);
//outfileViscosity << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(XTauW,YTauW,ZTauW);
//outfileWallShearStress << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(XTauE,YTauE,ZTauE);
//outfileTauE << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(XBR,YBR,ZBR);
//outfileRadius << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(XCond,YCond,ZCond);
//outfiletest << "Conductivity" << "\t" << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(vesselXCond,vesselYCond,vesselZCond);
//outfileVesselCond << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

CalculateMinMaxMean(XFlow,YFlow,ZFlow);
outfileFlow << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//	}

}


//*****************************************************

//==================================
void CAngioNetDlg::FlowConvergence()
//==================================
{
	double epsilon=1e-18;

	ConvergenceFlow=true;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (fabs(XOldFlow[i-1][j-1][k-1]-XFlow[i-1][j-1][k-1])>epsilon) {ConvergenceFlow=false;}
			  //outfileFlowConvergence << IterationNumber << "\t" << "X" << XFlow[i-1][j-1][k-1] << endl;
			  if (fabs(YOldFlow[i-1][j-1][k-1]-YFlow[i-1][j-1][k-1])>epsilon) {ConvergenceFlow=false;}
			  if (fabs(ZOldFlow[i-1][j-1][k-1]-ZFlow[i-1][j-1][k-1])>epsilon) {ConvergenceFlow=false;}
			}
			int i=m_nx+1;
			if (fabs(XOldFlow[i-1][j-1][k-1]-XFlow[i-1][j-1][k-1])>epsilon) {ConvergenceFlow=false;}
	}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::ViscosityConvergence()
//=======================================
{
	double epsilon=1e-6;

	ConvergenceViscosity=true;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (fabs(XOldmu[i-1][j-1][k-1]-Xmu[i-1][j-1][k-1])>epsilon) {ConvergenceViscosity=false;}
			  if (fabs(YOldmu[i-1][j-1][k-1]-Ymu[i-1][j-1][k-1])>epsilon) {ConvergenceViscosity=false;}
			  if (fabs(ZOldmu[i-1][j-1][k-1]-Zmu[i-1][j-1][k-1])>epsilon) {ConvergenceViscosity=false;}
			}
			int i=m_nx+1;
			if (fabs(XOldmu[i-1][j-1][k-1]-Xmu[i-1][j-1][k-1])>epsilon) {ConvergenceViscosity=false;}
	}}
}


//*****************************************************

//===================================
void CAngioNetDlg::KeepOldViscosity()
//===================================
{
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  //outfiletest << IterationNumber << "\t" << XFlow[i-1][j-1][k-1] << endl;
			  XOldmu[i-1][j-1][k-1]=Xmu[i-1][j-1][k-1];
			  YOldmu[i-1][j-1][k-1]=Ymu[i-1][j-1][k-1];
			  ZOldmu[i-1][j-1][k-1]=Zmu[i-1][j-1][k-1];
			}
			  XOldmu[m_nx][j-1][k-1]=Xmu[m_nx][j-1][k-1];
	}}
}


//*****************************************************

//==============================
void CAngioNetDlg::KeepOldFlow()
//==============================
{
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  //outfiletest << IterationNumber << "\t" << XFlow[i-1][j-1][k-1] << endl;
			  XOldFlow[i-1][j-1][k-1]=XFlow[i-1][j-1][k-1];
			  YOldFlow[i-1][j-1][k-1]=YFlow[i-1][j-1][k-1];
			  ZOldFlow[i-1][j-1][k-1]=ZFlow[i-1][j-1][k-1];
			}
			  XOldFlow[m_nx][j-1][k-1]=XFlow[m_nx][j-1][k-1];
	}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::OverWriteOldWithNew2()
//=======================================
{ 
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
		     vOldFibronectinConc[i][j][k]=vFibronectinConc[i][j][k];
			 vOldTAFConc[i][j][k]=vTAFConc[i][j][k];
			 vOldEndoCellDensity[i][j][k]=vEndoCellDensity[i][j][k];
			 vOldMDFConc[i][j][k]=vMDFConc[i][j][k];
	}}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::OverWriteOldWithNew3()
//=======================================
{ 
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
		     vOldFibronectinConc[i][j][k]=vFibronectinConc[i][j][k];
			 vOldTAFConc[i][j][k]=vTAFConc[i][j][k];
			 vOldMDFConc[i][j][k]=vMDFConc[i][j][k];
	}}}
}


//*****************************************************

//=========================================
void CAngioNetDlg::OverWriteOldWithNewECD()
//=========================================
{ 
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 vOldEndoCellDensity[i][j][k]=vEndoCellDensity[i][j][k];
	}}}
}


//*****************************************************

//=========================================
void CAngioNetDlg::OverWriteOldWithNewMDF()
//=========================================
{ 
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 vOldMDFConc[i][j][k]=vMDFConc[i][j][k];
	}}}
}


//*****************************************************

//==================================
void CAngioNetDlg::UpdateVariables()
//==================================
{

	//outfileUV << angiotime << "\t" << "avant SolveX " << endl;
	//outfileUV << vFibronectinConc[0][0][0] << endl;

	// Print out some stuff
	// Get a device context first
	CClientDC graphicsDC(this);

	// Print the loop variable
	CString myString;
	int yval=200; // ?

	//---------------------------------
	//m_rho=0.0; // without haptotaxis
	//m_chi=0.0; // without chemotaxis
	//---------------------------------

	int iplus,iminus,jplus,jminus,kplus,kminus;

	double subAngioDeltaT;

	if (m_nz==1) { subAngioDeltaT=angioDeltaT/2.0; } // for a 2D network
		else     { subAngioDeltaT=angioDeltaT/3.0; } // for a 3D network
 
	double gamma=0.1;
	double beta=0.05;
	double eta=0.1;
	double lambdaX=(m_diffCoeff*subAngioDeltaT)/(pow(angioDeltaX,2));
	double lambdaY=(m_diffCoeff*subAngioDeltaT)/(pow(angioDeltaY,2));
	
	angioDeltaZ=angioDeltaY;
	double lambdaZ=(m_diffCoeff*subAngioDeltaT)/(pow(angioDeltaZ,2));
	//or angioDeltaZ=angioDeltaY to avoid a division by zero (see InitVariables())

    double* coeffA;
	double* coeffB; 
	double* coeffC;
	double* coeffD;

//---------------------------------------------------------------------------
// calculation of the variables in the x-direction time=[t,t+subAngioDeltaT]
//---------------------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nx+1];
	coeffB=new double[m_nx+1];
    coeffC=new double[m_nx+1];
	coeffD=new double[m_nx+1];

	//-----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{  //----------------------------
		
			for (int i=0;i<=m_nx;i++) 
			{	
		
		//outfileUV << i << "\t" << j << "\t" << vEndoCellDensity[i][j][k] << endl;
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}
			

	/*// update FN
    	vFibronectinConc[i][j][k]=vOldFibronectinConc[i][j][k]*
         (1.0-gamma*subAngioDeltaT*vOldEndoCellDensity[i][j][k]) 
	      +beta*subAngioDeltaT*vOldEndoCellDensity[i][j][k];

	// update TAF
		vTAFConc[i][j][k]=vOldTAFConc[i][j][k]*
		 (1.0-eta*subAngioDeltaT*vOldEndoCellDensity[i][j][k]);*/

	// update EndoCellDensity
		coeffA[i]=-lambdaX;
		coeffB[i]=1.0+2.0*lambdaX;
		coeffC[i]=-lambdaX;

		coeffD[i]=vOldEndoCellDensity[i][j][k]+subAngioDeltaT*( 
			
		m_diffCoeff*(//--------------------------------------------------------------

		((vOldEndoCellDensity[i][jplus][k]-2.0*vOldEndoCellDensity[i][j][k]+
		  vOldEndoCellDensity[i][jminus][k])/pow(angioDeltaY,2)) 

	   +((vOldEndoCellDensity[i][j][kplus]-2.0*vOldEndoCellDensity[i][j][k]+
		  vOldEndoCellDensity[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close m_diffCoeff-------------------------------------------------------

		 
	   /*-(m_chi/(1.0+m_alpha*vOldTAFConc[i][j][k]))*(//------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[iplus][j][k]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[iminus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[iminus][j][k]))/(2.0*pow(angioDeltaX,2)))

     +(((vOldEndoCellDensity[i][jplus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][jplus][k]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[i][jminus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[i][jminus][k]))/(2.0*pow(angioDeltaY,2)))

	 +(((vOldEndoCellDensity[i][j][kplus]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[i][j][kminus]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[i][j][kminus]))/(2.0*pow(angioDeltaZ,2)))

		) //close m_chi---------------------------------------------------------------*/


		//--- new discretisation for the m_chi term ----------------------------------
	   -(m_chi/(1.0+m_alpha*vOldTAFConc[i][j][k]))*(//----------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]-vOldEndoCellDensity[iminus][j][k])
	   *(vOldTAFConc[iplus][j][k]-vOldTAFConc[iminus][j][k]))/(4.0*pow(angioDeltaX,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[iplus][j][k]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[iminus][j][k]))/pow(angioDeltaX,2))

 	 +(((vOldEndoCellDensity[i][jplus][k]-vOldEndoCellDensity[i][jminus][k])
	   *(vOldTAFConc[i][jplus][k]-vOldTAFConc[i][jminus][k]))/(4.0*pow(angioDeltaY,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[i][jplus][k]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[i][jminus][k]))/pow(angioDeltaY,2))

	 +(((vOldEndoCellDensity[i][j][kplus]-vOldEndoCellDensity[i][j][kminus])
	   *(vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][kminus]))/(4.0*pow(angioDeltaZ,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[i][j][kplus]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[i][j][kminus]))/pow(angioDeltaZ,2))

		) //close m_chi---------------------------------------------------------------

	   +((m_chi*m_alpha)/pow(1.0+m_alpha*vOldTAFConc[i][j][k],2))*vOldEndoCellDensity[i][j][k]*(//--------

	    pow(((vOldTAFConc[iplus][j][k]-vOldTAFConc[iminus][j][k])/(2.0*angioDeltaX)),2)
	   +pow(((vOldTAFConc[i][jplus][k]-vOldTAFConc[i][jminus][k])/(2.0*angioDeltaY)),2)
	   +pow(((vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][kminus])/(2.0*angioDeltaZ)),2)

	   )//-------------------------------------------------------------------------------------------------
		//--- end of new discretisation for the m_chi term ---------------------------


	   -m_rho*(//---------------------------------------------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[iplus][j][k]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[iminus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[iminus][j][k]))/(2.0*pow(angioDeltaX,2)))

     +(((vOldEndoCellDensity[i][jplus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][jplus][k]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[i][jminus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[i][jminus][k]))/(2.0*pow(angioDeltaY,2)))

	 +(((vOldEndoCellDensity[i][j][kplus]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][kplus]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[i][j][kminus]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[i][j][kminus]))/(2.0*pow(angioDeltaZ,2)))

		) //close m_rho---------------------------------------------------------------


		/*//--- new discretisation for the m_rho term ----------------------------------
	   -m_rho*(//---------------------------------------------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]-vOldEndoCellDensity[iminus][j][k])
	   *(vOldFibronectinConc[iplus][j][k]-vOldFibronectinConc[iminus][j][k]))/(4.0*pow(angioDeltaX,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[iplus][j][k]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[iminus][j][k]))
	   /pow(angioDeltaX,2))

 	 +(((vOldEndoCellDensity[i][jplus][k]-vOldEndoCellDensity[i][jminus][k])
	   *(vOldFibronectinConc[i][jplus][k]-vOldFibronectinConc[i][jminus][k]))/(4.0*pow(angioDeltaY,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[i][jplus][k]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[i][jminus][k]))
	   /pow(angioDeltaY,2))

	 +(((vOldEndoCellDensity[i][j][kplus]-vOldEndoCellDensity[i][j][kminus])
	   *(vOldFibronectinConc[i][j][kplus]-vOldFibronectinConc[i][j][kminus]))/(4.0*pow(angioDeltaZ,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[i][j][kplus]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[i][j][kminus]))
	   /pow(angioDeltaZ,2))

		) //close m_rho---------------------------------------------------------------
		//--- end of new discretisation for the m_rho term ---------------------------*/


		); //close subAngioDeltaT


		} // end loop i

		//outfileUV << angiotime << "\t" << i << "\t" << j << "\t" << 1.0/pow(angioDeltaX,2) << endl;
		//outfileUV << coeffD[i] << endl;

		SolveTridiagX(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);
	
	
	}} // end loops j and k

		//outfileUV << angiotime << "\t" << "apres SolveX " << endl;
	    //outfileUV << vOldFibronectinConc[0][0][0] << endl;
	    //outfileUV << vFibronectinConc[0][0][0] << endl;
		//outfileUV << coeffD[0] << endl;
	


//--------------------------------------------------------------------------------------------
// calculation of the variables in the y-direction time=[t+subAngioDeltaT,t+2*subAngioDeltaT]
//--------------------------------------------------------------------------------------------

	//=======================
	  OverWriteOldWithNewECD();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_ny];
	coeffB=new double[m_ny];
    coeffC=new double[m_ny];
	coeffD=new double[m_ny];
 
	//----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{   for ( int i=0;i<=m_nx;i++)
		{  //----------------------------
		
			for (int j=0;j<=m_ny-1;j++) 
			{

		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}

			    
	/*// update FN
    	vFibronectinConc[i][j][k]=vOldFibronectinConc[i][j][k]*
         (1.0-gamma*subAngioDeltaT*vOldEndoCellDensity[i][j][k]) 
	      +beta*subAngioDeltaT*vOldEndoCellDensity[i][j][k];

	// update TAF
		vTAFConc[i][j][k]=vOldTAFConc[i][j][k]*
		 (1.0-eta*subAngioDeltaT*vOldEndoCellDensity[i][j][k]);*/

	// update EndoCellDensity
		coeffA[j]=-lambdaY;
		coeffB[j]=1.0+2.0*lambdaY;
		coeffC[j]=-lambdaY;

		coeffD[j]=vOldEndoCellDensity[i][j][k]+subAngioDeltaT*( 
			
		m_diffCoeff*(//--------------------------------------------------------------

		((vOldEndoCellDensity[iplus][j][k]-2.0*vOldEndoCellDensity[i][j][k]+
		  vOldEndoCellDensity[iminus][j][k])/pow(angioDeltaX,2))

	   +((vOldEndoCellDensity[i][j][kplus]-2.0*vOldEndoCellDensity[i][j][k]+
		  vOldEndoCellDensity[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close m_diffCoeff-------------------------------------------------------


	   /*-(m_chi/(1.0+m_alpha*vOldTAFConc[i][j][k]))*(//------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[iplus][j][k]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[iminus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[iminus][j][k]))/(2.0*pow(angioDeltaX,2)))

     +(((vOldEndoCellDensity[i][jplus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][jplus][k]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[i][jminus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[i][jminus][k]))/(2.0*pow(angioDeltaY,2)))

	 +(((vOldEndoCellDensity[i][j][kplus]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[i][j][kminus]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[i][j][kminus]))/(2.0*pow(angioDeltaZ,2)))

		) //close m_chi---------------------------------------------------------------*/


		//--- new discretisation for the m_chi term ----------------------------------
	   -(m_chi/(1.0+m_alpha*vOldTAFConc[i][j][k]))*(//----------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]-vOldEndoCellDensity[iminus][j][k])
	   *(vOldTAFConc[iplus][j][k]-vOldTAFConc[iminus][j][k]))/(4.0*pow(angioDeltaX,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[iplus][j][k]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[iminus][j][k]))/pow(angioDeltaX,2))

 	 +(((vOldEndoCellDensity[i][jplus][k]-vOldEndoCellDensity[i][jminus][k])
	   *(vOldTAFConc[i][jplus][k]-vOldTAFConc[i][jminus][k]))/(4.0*pow(angioDeltaY,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[i][jplus][k]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[i][jminus][k]))/pow(angioDeltaY,2))

	 +(((vOldEndoCellDensity[i][j][kplus]-vOldEndoCellDensity[i][j][kminus])
	   *(vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][kminus]))/(4.0*pow(angioDeltaZ,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[i][j][kplus]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[i][j][kminus]))/pow(angioDeltaZ,2))

		) //close m_chi---------------------------------------------------------------

		+((m_chi*m_alpha)/pow(1.0+m_alpha*vOldTAFConc[i][j][k],2))*vOldEndoCellDensity[i][j][k]*(//--------

	    pow(((vOldTAFConc[iplus][j][k]-vOldTAFConc[iminus][j][k])/(2.0*angioDeltaX)),2)
	   +pow(((vOldTAFConc[i][jplus][k]-vOldTAFConc[i][jminus][k])/(2.0*angioDeltaY)),2)
	   +pow(((vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][kminus])/(2.0*angioDeltaZ)),2)

	   )//-------------------------------------------------------------------------------------------------
		//--- end of new discretisation for the m_chi term ---------------------------


	   -m_rho*(//---------------------------------------------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[iplus][j][k]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[iminus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[iminus][j][k]))/(2.0*pow(angioDeltaX,2)))

     +(((vOldEndoCellDensity[i][jplus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][jplus][k]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[i][jminus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[i][jminus][k]))/(2.0*pow(angioDeltaY,2)))

	 +(((vOldEndoCellDensity[i][j][kplus]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][kplus]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[i][j][kminus]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[i][j][kminus]))/(2.0*pow(angioDeltaZ,2)))

		) //close m_rho---------------------------------------------------------------


		/*//--- new discretisation for the m_rho term ----------------------------------
	   -m_rho*(//---------------------------------------------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]-vOldEndoCellDensity[iminus][j][k])
	   *(vOldFibronectinConc[iplus][j][k]-vOldFibronectinConc[iminus][j][k]))/(4.0*pow(angioDeltaX,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[iplus][j][k]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[iminus][j][k]))
	   /pow(angioDeltaX,2))

 	 +(((vOldEndoCellDensity[i][jplus][k]-vOldEndoCellDensity[i][jminus][k])
	   *(vOldFibronectinConc[i][jplus][k]-vOldFibronectinConc[i][jminus][k]))/(4.0*pow(angioDeltaY,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[i][jplus][k]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[i][jminus][k]))
	   /pow(angioDeltaY,2))

	 +(((vOldEndoCellDensity[i][j][kplus]-vOldEndoCellDensity[i][j][kminus])
	   *(vOldFibronectinConc[i][j][kplus]-vOldFibronectinConc[i][j][kminus]))/(4.0*pow(angioDeltaZ,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[i][j][kplus]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[i][j][kminus]))
	   /pow(angioDeltaZ,2))

		) //close m_rho---------------------------------------------------------------
		//--- end of new discretisation for the m_rho term ---------------------------*/


		); //close subAngioDeltaT

		} // end loop j

		SolveTridiagY(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and k
 


//-----------------------------------------------------------------------------------------
// calculation of the variables in the z-direction time=[t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz is not equal to 1 (i.e. 3D network)
//------------------------------------------------------------------------------------------


	if (m_nz!=1) { //=====================================================================


	//=======================
	  OverWriteOldWithNewECD();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nz];
	coeffB=new double[m_nz];
    coeffC=new double[m_nz];
	coeffD=new double[m_nz];

	//-----------------------------
	for (int i=0;i<=m_nx;i++)
	{   for (int j=0;j<=m_ny-1;j++)
		{   //----------------------------
		
			for (int k=0;k<=m_nz-1;k++) 
			{	
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}


	/*// update FN
    	vFibronectinConc[i][j][k]=vOldFibronectinConc[i][j][k]*
         (1.0-gamma*subAngioDeltaT*vOldEndoCellDensity[i][j][k]) 
	      +beta*subAngioDeltaT*vOldEndoCellDensity[i][j][k];

	// update TAF
		vTAFConc[i][j][k]=vOldTAFConc[i][j][k]*
		 (1.0-eta*subAngioDeltaT*vOldEndoCellDensity[i][j][k]);*/

	// update EndoCellDensity
		coeffA[k]=-lambdaZ;
		coeffB[k]=1.0+2.0*lambdaZ;
		coeffC[k]=-lambdaZ;
		
        coeffD[k]=vOldEndoCellDensity[i][j][k]+subAngioDeltaT*( 
			
		m_diffCoeff*(//--------------------------------------------------------------

		((vOldEndoCellDensity[iplus][j][k]-2.0*vOldEndoCellDensity[i][j][k]+
		  vOldEndoCellDensity[iminus][j][k])/pow(angioDeltaX,2))

	   +((vOldEndoCellDensity[i][jplus][k]-2.0*vOldEndoCellDensity[i][j][k]+
		  vOldEndoCellDensity[i][jminus][k])/pow(angioDeltaY,2))

		  ) //close m_diffCoeff-------------------------------------------------------
		  
	  
	   /*-(m_chi/(1.0+m_alpha*vOldTAFConc[i][j][k]))*(//----------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[iplus][j][k]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[iminus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[iminus][j][k]))/(2.0*pow(angioDeltaX,2)))

     +(((vOldEndoCellDensity[i][jplus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][jplus][k]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[i][jminus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[i][jminus][k]))/(2.0*pow(angioDeltaY,2)))

	 +(((vOldEndoCellDensity[i][j][kplus]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][k])
	   -(vOldEndoCellDensity[i][j][kminus]+vOldEndoCellDensity[i][j][k])
	   *(vOldTAFConc[i][j][k]-vOldTAFConc[i][j][kminus]))/(2.0*pow(angioDeltaZ,2)))

		) //close m_chi---------------------------------------------------------------*/

		//--- new discretisation for the m_chi term ----------------------------------
	   -(m_chi/(1.0+m_alpha*vOldTAFConc[i][j][k]))*(//----------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]-vOldEndoCellDensity[iminus][j][k])
	   *(vOldTAFConc[iplus][j][k]-vOldTAFConc[iminus][j][k]))/(4.0*pow(angioDeltaX,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[iplus][j][k]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[iminus][j][k]))/pow(angioDeltaX,2))

 	 +(((vOldEndoCellDensity[i][jplus][k]-vOldEndoCellDensity[i][jminus][k])
	   *(vOldTAFConc[i][jplus][k]-vOldTAFConc[i][jminus][k]))/(4.0*pow(angioDeltaY,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[i][jplus][k]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[i][jminus][k]))/pow(angioDeltaY,2))

	 +(((vOldEndoCellDensity[i][j][kplus]-vOldEndoCellDensity[i][j][kminus])
	   *(vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][kminus]))/(4.0*pow(angioDeltaZ,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldTAFConc[i][j][kplus]-2.0*vOldTAFConc[i][j][k]+vOldTAFConc[i][j][kminus]))/pow(angioDeltaZ,2))

		) //close m_chi---------------------------------------------------------------

		+((m_chi*m_alpha)/pow(1.0+m_alpha*vOldTAFConc[i][j][k],2))*vOldEndoCellDensity[i][j][k]*(//--------

	    pow(((vOldTAFConc[iplus][j][k]-vOldTAFConc[iminus][j][k])/(2.0*angioDeltaX)),2)
	   +pow(((vOldTAFConc[i][jplus][k]-vOldTAFConc[i][jminus][k])/(2.0*angioDeltaY)),2)
	   +pow(((vOldTAFConc[i][j][kplus]-vOldTAFConc[i][j][kminus])/(2.0*angioDeltaZ)),2)

	   )//-------------------------------------------------------------------------------------------------
		//--- end of new discretisation for the m_chi term ---------------------------


	   -m_rho*(//---------------------------------------------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[iplus][j][k]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[iminus][j][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[iminus][j][k]))/(2.0*pow(angioDeltaX,2)))

     +(((vOldEndoCellDensity[i][jplus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][jplus][k]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[i][jminus][k]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[i][jminus][k]))/(2.0*pow(angioDeltaY,2)))

	 +(((vOldEndoCellDensity[i][j][kplus]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][kplus]-vOldFibronectinConc[i][j][k])
	   -(vOldEndoCellDensity[i][j][kminus]+vOldEndoCellDensity[i][j][k])
	   *(vOldFibronectinConc[i][j][k]-vOldFibronectinConc[i][j][kminus]))/(2.0*pow(angioDeltaZ,2)))

		) //close m_rho---------------------------------------------------------------


		/*//--- new discretisation for the m_rho term ----------------------------------
	   -m_rho*(//---------------------------------------------------------------------
	   
	  (((vOldEndoCellDensity[iplus][j][k]-vOldEndoCellDensity[iminus][j][k])
	   *(vOldFibronectinConc[iplus][j][k]-vOldFibronectinConc[iminus][j][k]))/(4.0*pow(angioDeltaX,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[iplus][j][k]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[iminus][j][k]))
	   /pow(angioDeltaX,2))

 	 +(((vOldEndoCellDensity[i][jplus][k]-vOldEndoCellDensity[i][jminus][k])
	   *(vOldFibronectinConc[i][jplus][k]-vOldFibronectinConc[i][jminus][k]))/(4.0*pow(angioDeltaY,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[i][jplus][k]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[i][jminus][k]))
	   /pow(angioDeltaY,2))

	 +(((vOldEndoCellDensity[i][j][kplus]-vOldEndoCellDensity[i][j][kminus])
	   *(vOldFibronectinConc[i][j][kplus]-vOldFibronectinConc[i][j][kminus]))/(4.0*pow(angioDeltaZ,2))
	   +(vOldEndoCellDensity[i][j][k]
	   *(vOldFibronectinConc[i][j][kplus]-2.0*vOldFibronectinConc[i][j][k]+vOldFibronectinConc[i][j][kminus]))
	   /pow(angioDeltaZ,2))

		) //close m_rho---------------------------------------------------------------
		//--- end of new discretisation for the m_rho term ---------------------------*/


		); //close subAngioDeltaT

		} // end loop k

		SolveTridiagZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and j

	} // end if (m_nz!=1) =============================================================




// Now get new running ECDensity maximum

	runningEndoCellMAX=0.0; // used for graphics

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 if (vEndoCellDensity[i][j][k]>runningEndoCellMAX)
			 {	
				 runningEndoCellMAX=vEndoCellDensity[i][j][k];
			 }		
	}}}



	if (loop%1000==0) {
		outfileUV << endl;
		outfileUV << loop << "\t" << angiotime << endl;
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
		     outfileUV << i << "\t" << j << "\t" << vEndoCellDensity[i][j][k] << endl;
	}}}
	}

}


//*****************************************************

//============================
void CAngioNetDlg::UpdateMDF()
//============================
{
	// Print out some stuff
	// Get a device context first
	CClientDC graphicsDC(this);

	// Print the loop variable
	CString myString;
	int yval=200; // ?

	int iplus,iminus,jplus,jminus,kplus,kminus;

	double subAngioDeltaT;

	if (m_nz==1) { subAngioDeltaT=angioDeltaT/2.0; } // for a 2D network
		else     { subAngioDeltaT=angioDeltaT/3.0; } // for a 3D network
 
	double nu=3.0*D_TAF_Scaling;	//rescales for new TAF diffusion coeff;//3.0;3.0 used in all pre-UU work	//decay constant
	double alpha=10.0e-6*D_TAF_Scaling;	//rescales for new TAF diffusion coeff;//10e-6;	//production rate
	double epsilon=0.01*D_TAF_Scaling;	//rescales for new TAF diffusion coeff;//0.01;0.01 used for all pre-UU work    //0.00035;	//Diffusion constant
	double lambdaX=(epsilon*subAngioDeltaT)/(pow(angioDeltaX,2));
	double lambdaY=(epsilon*subAngioDeltaT)/(pow(angioDeltaY,2));
	
	angioDeltaZ=angioDeltaY;
	double lambdaZ=(epsilon*subAngioDeltaT)/(pow(angioDeltaZ,2));
	//or angioDeltaZ=angioDeltaY to avoid a division by zero (see InitVariables())

    double* coeffA;
	double* coeffB; 
	double* coeffC;
	double* coeffD;

//---------------------------------------------------------------------------
// calculation of the variables in the x-direction time=[t,t+subAngioDeltaT]
//---------------------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nx+1];
	coeffB=new double[m_nx+1];
    coeffC=new double[m_nx+1];
	coeffD=new double[m_nx+1];

	//-----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{  //----------------------------
		
			for (int i=0;i<=m_nx;i++) 
			{	
		
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}
			

	// update Matrix Degradation Factor (MDF)
		coeffA[i]=-lambdaX;
		coeffB[i]=1.0+2.0*lambdaX;
		coeffC[i]=-lambdaX;

		coeffD[i]=vOldMDFConc[i][j][k]+subAngioDeltaT*( 

	     alpha*vSproutsTips[i][j][k]-nu*vOldMDFConc[i][j][k]
		
	   + epsilon*(//--------------------------------------------------------------

		((vOldMDFConc[i][jplus][k]-2.0*vOldMDFConc[i][j][k]+
		  vOldMDFConc[i][jminus][k])/pow(angioDeltaY,2)) 

	   +((vOldMDFConc[i][j][kplus]-2.0*vOldMDFConc[i][j][k]+
		  vOldMDFConc[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close epsilon-------------------------------------------------------

		); //close subAngioDeltaT


		} // end loop i


		SolveTridiagMDFX(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);
	
	
	}} // end loops j and k

	

//--------------------------------------------------------------------------------------------
// calculation of the variables in the y-direction time=[t+subAngioDeltaT,t+2*subAngioDeltaT]
//--------------------------------------------------------------------------------------------

	//=======================
	  OverWriteOldWithNewMDF();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_ny];
	coeffB=new double[m_ny];
    coeffC=new double[m_ny];
	coeffD=new double[m_ny];
 
	//----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{   for ( int i=0;i<=m_nx;i++)
		{  //----------------------------
		
			for (int j=0;j<=m_ny-1;j++) 
			{

		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}

			    

	// update Matrix Degradation Factor (MDF)
		coeffA[j]=-lambdaY;
		coeffB[j]=1.0+2.0*lambdaY;
		coeffC[j]=-lambdaY;

		coeffD[j]=vOldMDFConc[i][j][k]+subAngioDeltaT*( 

		 alpha*vSproutsTips[i][j][k]-nu*vOldMDFConc[i][j][k]
			
	   + epsilon*(//--------------------------------------------------------------

		((vOldMDFConc[iplus][j][k]-2.0*vOldMDFConc[i][j][k]+
		  vOldMDFConc[iminus][j][k])/pow(angioDeltaX,2))

	   +((vOldMDFConc[i][j][kplus]-2.0*vOldMDFConc[i][j][k]+
		  vOldMDFConc[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close epsilon-------------------------------------------------------

		); //close subAngioDeltaT

		} // end loop j

		SolveTridiagMDFY(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and k
 

	//=======================
	  OverWriteOldWithNewMDF();	///SMcD  $$$$  SHOULD WE NOT CALL THIS HERE TOO 
								
	//=======================
//-----------------------------------------------------------------------------------------
// calculation of the variables in the z-direction time=[t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz is not equal to 1 (i.e. 3D network)
//------------------------------------------------------------------------------------------


	if (m_nz!=1) { //=====================================================================


	//=======================
	  ////SMcD here and commented this out  
//		OverWriteOldWithNewMDF();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nz];
	coeffB=new double[m_nz];
    coeffC=new double[m_nz];
	coeffD=new double[m_nz];

	//-----------------------------
	for (int i=0;i<=m_nx;i++)
	{   for (int j=0;j<=m_ny-1;j++)
		{   //----------------------------
		
			for (int k=0;k<=m_nz-1;k++) 
			{	
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}


	// update EndoCellDensity
		coeffA[k]=-lambdaZ;
		coeffB[k]=1.0+2.0*lambdaZ;
		coeffC[k]=-lambdaZ;
		
        coeffD[k]=vOldMDFConc[i][j][k]+subAngioDeltaT*( 
			
		alpha*vSproutsTips[i][j][k]-nu*vOldMDFConc[i][j][k]

	  + epsilon*(//--------------------------------------------------------------

		((vOldMDFConc[iplus][j][k]-2.0*vOldMDFConc[i][j][k]+
		  vOldMDFConc[iminus][j][k])/pow(angioDeltaX,2))

	   +((vOldMDFConc[i][jplus][k]-2.0*vOldMDFConc[i][j][k]+
		  vOldMDFConc[i][jminus][k])/pow(angioDeltaY,2))

		  ) //close epsilon-------------------------------------------------------
		 
		); //close subAngioDeltaT

		} // end loop k

		SolveTridiagMDFZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and j

	} // end if (m_nz!=1) =============================================================

	//=======================
	  OverWriteOldWithNewMDF();	///SMcD  $$$$  SHOULD WE NOT CALL THIS HERE TOO 
								////   (if  nz=1 then the y-values are not overwritten)
	//=======================


	// Now get new running MDFConc maximum
	runningMDFConcMAX=0.0; // used for graphics

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 if (vMDFConc[i][j][k]>runningMDFConcMAX)
			 {	
				 runningMDFConcMAX=vMDFConc[i][j][k];
			 }		
	}}}


//----------------------------------------------
	//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------

}


//*****************************************************

//======================================
void CAngioNetDlg::LocalizeSproutsTips()
//======================================
{
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{	
				vSproutsTips[i][j][k]=0;
	}}}

	for (int k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) { vSproutsTips[i-1][j-1][k-1]=1; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) { vSproutsTips[i-1][j-1][k-1]=1; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) { vSproutsTips[i-1][j-1][k-1]=1; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1){ vSproutsTips[i-2][j-1][k-1]=1; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1){ vSproutsTips[i-1][j-2][k-1]=1; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1){ vSproutsTips[i-1][j-1][k-2]=1; }
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) { vSproutsTips[i-1][j-1][k-1]=1; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false){ vSproutsTips[i-2][j-1][k-1]=1; }
	}}
}


//*****************************************************

//============================
void CAngioNetDlg::UpdateFN2()
//============================
{
	double gamma=0.1;
	double beta=0.05;

	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 vFibronectinConc[i][j][k]=vOldFibronectinConc[i][j][k]*
		    	(1.0-gamma*angioDeltaT*vOldEndoCellDensity[i][j][k]) 
				 +beta*angioDeltaT*vOldEndoCellDensity[i][j][k];
	}}}	

}


//*****************************************************

//=============================
void CAngioNetDlg::UpdateTAF2()
//=============================
{	
	double eta=0.1;

	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 vTAFConc[i][j][k]=vOldTAFConc[i][j][k]*
				(1.0-eta*angioDeltaT*vOldEndoCellDensity[i][j][k]);
	}}}
}


//*****************************************************

//============================
void CAngioNetDlg::UpdateFN3()
//============================
{
// new model taking into account the matrix degrading factor (MDF)
////SMcD June 2008	for steep FN gradients for hapto effect on PCs
	//double gamma=0.1*D_TAF_Scaling*0.25e7;	//rescales for new TAF diffusion coeff
	double gamma=0.1*D_TAF_Scaling;//original value
	double beta=0.05*D_TAF_Scaling;	//rescales for new TAF diffusion coeff

	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 vFibronectinConc[i][j][k]=vOldFibronectinConc[i][j][k]*
		    	(1.0-gamma*angioDeltaT*vOldMDFConc[i][j][k]) 
				 +beta*angioDeltaT*vSproutsTips[i][j][k];
	}}}	

}


//*****************************************************

//=============================
void CAngioNetDlg::UpdateTAF3()
//=============================
{
// new model taking into account the matrix degrading factor (MDF)
	double eta=0.1*D_TAF_Scaling;	//rescales for new TAF diffusion coeff

	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 vTAFConc[i][j][k]=vOldTAFConc[i][j][k]*
				(1.0-eta*angioDeltaT*vSproutsTips[i][j][k]);
	}}}

	// Now get new running TAFConc maximum
	runningTAFConcMAX=0.0; // used for graphics

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 if (vTAFConc[i][j][k]>runningTAFConcMAX)
			 {	
				 runningTAFConcMAX=vTAFConc[i][j][k];
			 }		
	}}}
}


//*****************************************************

//====================================
void CAngioNetDlg::CellConservation2()
//====================================
{
	double totalCells=0.0,oldTotalCells=0.0;
	
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				 totalCells+=vEndoCellDensity[i][j][k];
				 oldTotalCells+=vEndoCellDensity[i][j][k];
			 }
	}}
			 
	if(fabs(totalCells-oldTotalCells)/oldTotalCells>0.001)
	{
		CClientDC graphicsDC(this);

		CString endoString,oldEndoString;
		endoString.Format("New Cell Concs %g",totalCells);
		graphicsDC.TextOut(200,275,endoString);
		oldEndoString.Format("Old Cell Concs %g",oldTotalCells);
		graphicsDC.TextOut(200,300,oldEndoString);
	}

	//----------------------------------------------------------------
	  //outfileCellConserv << angiotime << "\t" << totalCells << endl;
	//----------------------------------------------------------------
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::CalculateMinMaxMean(double*** fx, double*** fy, double*** fz)
//==============================================================================
{
	double compt;
	MinValue=1e50;
	MaxValue=0.0;
	MeanValue=0.0;
	compt=0.0;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++) //Parent vessel excluded 
		{	for (int i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{	MeanValue=MeanValue+fabs(fx[i-1][j-1][k-1]);
					compt+=1;
					if (fabs(fx[i-1][j-1][k-1])<MinValue) {MinValue=fabs(fx[i-1][j-1][k-1]);}
					if (fabs(fx[i-1][j-1][k-1])>MaxValue) {MaxValue=fabs(fx[i-1][j-1][k-1]);}
				}
				if (pFluid[nby-1]==10)
				{	MeanValue=MeanValue+fabs(fy[i-1][j-1][k-1]);
					compt+=1;
					if (fabs(fy[i-1][j-1][k-1])<MinValue) {MinValue=fabs(fy[i-1][j-1][k-1]);}
					if (fabs(fy[i-1][j-1][k-1])>MaxValue) {MaxValue=fabs(fy[i-1][j-1][k-1]);} 
				}

				if (pFluid[nbz-1]==10)
				{	MeanValue=MeanValue+fabs(fz[i-1][j-1][k-1]);
					compt+=1;
					if (fabs(fz[i-1][j-1][k-1])<MinValue) {MinValue=fabs(fz[i-1][j-1][k-1]);}
					if (fabs(fz[i-1][j-1][k-1])>MaxValue) {MaxValue=fabs(fz[i-1][j-1][k-1]);} 
				}
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
				{	MeanValue=MeanValue+fabs(fx[i-1][j-1][k-1]);
					compt+=1;
					if (fabs(fx[i-1][j-1][k-1])<MinValue) {MinValue=fabs(fx[i-1][j-1][k-1]);}
					if (fabs(fx[i-1][j-1][k-1])>MaxValue) {MaxValue=fabs(fx[i-1][j-1][k-1]);} 
				}
	}}
	MeanValue=MeanValue/compt;

///	outfileMinMaxMean << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::SolveTridiagX(int m_nx, int m_ny, int m_nz, int j, int k,
				            	 double* coeffA, double* coeffB, double* coeffC,
				            	 double* coeffD)
//==============================================================================
{ 
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nx+1]; // indice: 0 to m_nx
	q=new double[m_nx+1];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int i=1;i<=m_nx;i++)
	{
		p[i]=coeffC[i]/(coeffB[i]-coeffA[i]*p[i-1]);
		q[i]=(coeffD[i]-coeffA[i]*q[i-1])/(coeffB[i]-coeffA[i]*p[i-1]);
	}

	//calculation of the function for the next time step (iteration)
	vEndoCellDensity[m_nx][j][k]=(q[m_nx]-p[m_nx]*q[m_nx-1])/(1.0-p[m_nx]*p[m_nx-1]);

	int i=m_nx-1;
	while(i>-1)
    {
		vEndoCellDensity[i][j][k]=q[i]-vEndoCellDensity[i+1][j][k]*p[i];
		i=i-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::SolveTridiagY(int m_nx, int m_ny, int m_nz, int i, int k,
				            	 double* coeffA, double* coeffB, double* coeffC,
				            	 double* coeffD)
//==============================================================================
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_ny]; // indice: 0 to m_ny-1
	q=new double[m_ny];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int j=1;j<=m_ny-1;j++)
	{
		p[j]=coeffC[j]/(coeffB[j]-coeffA[j]*p[j-1]);
		q[j]=(coeffD[j]-coeffA[j]*q[j-1])/(coeffB[j]-coeffA[j]*p[j-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	vEndoCellDensity[i][m_ny-1][k]=(q[m_ny-1]-p[m_ny-1]*q[m_ny-2])/(1.0-p[m_ny-1]*p[m_ny-2]);

	int j=m_ny-2;
	while(j>-1)
    {
		vEndoCellDensity[i][j][k]=q[j]-vEndoCellDensity[i][j+1][k]*p[j];
		j=j-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::SolveTridiagZ(int m_nx, int m_ny, int m_nz, int i, int j,
				            	 double* coeffA, double* coeffB, double* coeffC,
				            	 double* coeffD)
//==============================================================================
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nz]; // indice: 0 to m_nz-1
	q=new double[m_nz];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int k=1;k<=m_nz-1;k++)
	{
		p[k]=coeffC[k]/(coeffB[k]-coeffA[k]*p[k-1]);
		q[k]=(coeffD[k]-coeffA[k]*q[k-1])/(coeffB[k]-coeffA[k]*p[k-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	vEndoCellDensity[i][j][m_nz-1]=(q[m_nz-1]-p[m_nz-1]*q[m_nz-2])/(1.0-p[m_nz-1]*p[m_nz-2]);

	int k=m_nz-2;
	while(k>-1)
    {
		vEndoCellDensity[i][j][k]=q[k]-vEndoCellDensity[i][j][k+1]*p[k];
		k=k-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::SolveTridiagMDFX(int m_nx, int m_ny, int m_nz, int j, int k,
				            	 double* coeffA, double* coeffB, double* coeffC,
				            	 double* coeffD)
//==============================================================================
{ 
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nx+1]; // indice: 0 to m_nx
	q=new double[m_nx+1];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int i=1;i<=m_nx;i++)
	{
		p[i]=coeffC[i]/(coeffB[i]-coeffA[i]*p[i-1]);
		q[i]=(coeffD[i]-coeffA[i]*q[i-1])/(coeffB[i]-coeffA[i]*p[i-1]);
	}

	//calculation of the function for the next time step (iteration)
	vMDFConc[m_nx][j][k]=(q[m_nx]-p[m_nx]*q[m_nx-1])/(1.0-p[m_nx]*p[m_nx-1]);
//outfileDebugBone << m_nx << "\t" << j << "\t" << vMDFConc[m_nx][j][k] << endl;
	int i=m_nx-1;
	while(i>-1)
    {
		vMDFConc[i][j][k]=q[i]-vMDFConc[i+1][j][k]*p[i];
//outfileDebugBone << i << "\t" << j << "\t" << vMDFConc[i][j][k] << endl;
		i=i-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::SolveTridiagMDFY(int m_nx, int m_ny, int m_nz, int i, int k,
				            	 double* coeffA, double* coeffB, double* coeffC,
				            	 double* coeffD)
//==============================================================================
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_ny]; // indice: 0 to m_ny-1
	q=new double[m_ny];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int j=1;j<=m_ny-1;j++)
	{
		p[j]=coeffC[j]/(coeffB[j]-coeffA[j]*p[j-1]);
		q[j]=(coeffD[j]-coeffA[j]*q[j-1])/(coeffB[j]-coeffA[j]*p[j-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	vMDFConc[i][m_ny-1][k]=(q[m_ny-1]-p[m_ny-1]*q[m_ny-2])/(1.0-p[m_ny-1]*p[m_ny-2]);
//outfileDebugBone << i << "\t" << m_ny-1 << "\t" << vMDFConc[i][m_ny-1][k] << endl;
	int j=m_ny-2;
	while(j>-1)
    {
		vMDFConc[i][j][k]=q[j]-vMDFConc[i][j+1][k]*p[j];
//outfileDebugBone << i << "\t" << j << "\t" << vMDFConc[i][j][k] << endl;
		j=j-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}


//*****************************************************

//==============================================================================
void CAngioNetDlg::SolveTridiagMDFZ(int m_nx, int m_ny, int m_nz, int i, int j,
				            	 double* coeffA, double* coeffB, double* coeffC,
				            	 double* coeffD)
//==============================================================================
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nz]; // indice: 0 to m_nz-1
	q=new double[m_nz];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int k=1;k<=m_nz-1;k++)
	{
		p[k]=coeffC[k]/(coeffB[k]-coeffA[k]*p[k-1]);
		q[k]=(coeffD[k]-coeffA[k]*q[k-1])/(coeffB[k]-coeffA[k]*p[k-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	vMDFConc[i][j][m_nz-1]=(q[m_nz-1]-p[m_nz-1]*q[m_nz-2])/(1.0-p[m_nz-1]*p[m_nz-2]);

	int k=m_nz-2;
	while(k>-1)
    {
		vMDFConc[i][j][k]=q[k]-vMDFConc[i][j][k+1]*p[k];
		k=k-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}


//*****************************************************

//===========================
void CAngioNetDlg::GetProbs()
//===========================
{	
	// Initialisation of the probabilities to zero
	//--------------------------------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				probP0[i][j][k]=0.0;
				probP1[i][j][k]=0.0;
				probP2[i][j][k]=0.0;
				probP3[i][j][k]=0.0;
				probP4[i][j][k]=0.0;
				probP5[i][j][k]=0.0;
				probP6[i][j][k]=0.0;
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=0.0;
				R1inf[i][j][k]=0.0;
				R1sup[i][j][k]=0.0;
				R2inf[i][j][k]=0.0;
				R2sup[i][j][k]=0.0;
				R3inf[i][j][k]=0.0;
				R3sup[i][j][k]=0.0;
				R4inf[i][j][k]=0.0;
				R4sup[i][j][k]=0.0;
				R5inf[i][j][k]=0.0;
				R5sup[i][j][k]=0.0;
				R6inf[i][j][k]=0.0;
				R6sup[i][j][k]=0.0;			
	}}}

    
	// Calculation of the probabilities P0 to P6 for each point (i,j,k)
    //-----------------------------------------------------------------

	 angioDeltaZ=angioDeltaX;

	//---------- switch 2D / 3D ---------------
	  int coeffZ;
	  if (m_nz==1) {coeffZ=0;} else {coeffZ=1;}
	//-----------------------------------------

	int iminus,iplus,jminus,jplus,kminus,kplus;

    for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
		
		if (i==0) {iminus=1;} else  {iminus=i-1;}
		if (j==0) {jminus=1;} else  {jminus=j-1;}
		if (k==0) {kminus=1;} else  {kminus=k-1;}
		if (i==m_nx)   {iplus=m_nx-1;} else  {iplus=i+1;}
		if (j==m_ny-1) {jplus=m_ny-2;} else  {jplus=j+1;}
		if (k==m_nz-1) {kplus=m_nz-2;} else  {kplus=k+1;}


	//----------------------------------------------
	// P0 = Probability to remain stationary (i,j,k)
	//----------------------------------------------

    probP0[i][j][k]=
	
	1.0-2.0*m_diffCoeff*angioDeltaT*
	( (1.0/pow(angioDeltaX,2))+(1.0/pow(angioDeltaY,2))+(1.0/pow(angioDeltaZ,2))*coeffZ )

    + ((m_chi*m_alpha*angioDeltaT)/pow((1.0+m_alpha*vTAFConc[i][j][k]),2))
	*( (pow((vTAFConc[iplus][j][k]-vTAFConc[iminus][j][k]),2)/pow((2.0*angioDeltaX),2))
	  +(pow((vTAFConc[i][jplus][k]-vTAFConc[i][jminus][k]),2)/pow((2.0*angioDeltaY),2))   
	  +(pow((vTAFConc[i][j][kplus]-vTAFConc[i][j][kminus]),2)/pow((2.0*angioDeltaZ),2))*coeffZ ) 

	- ((m_chi*angioDeltaT)/(1.0+m_alpha*vTAFConc[i][j][k]))
	*( ((vTAFConc[iplus][j][k]-2.0*vTAFConc[i][j][k]+vTAFConc[iminus][j][k])/pow(angioDeltaX,2))
      +((vTAFConc[i][jplus][k]-2.0*vTAFConc[i][j][k]+vTAFConc[i][jminus][k])/pow(angioDeltaY,2))  
	  +((vTAFConc[i][j][kplus]-2.0*vTAFConc[i][j][k]+vTAFConc[i][j][kminus])/pow(angioDeltaZ,2))*coeffZ )
	
	- m_rho*angioDeltaT
	*( ((vFibronectinConc[iplus][j][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[iminus][j][k])/pow(angioDeltaX,2))
	  +((vFibronectinConc[i][jplus][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][jminus][k])/pow(angioDeltaY,2))   
	  +((vFibronectinConc[i][j][kplus]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][j][kminus])/pow(angioDeltaZ,2))*coeffZ );


	//------------------------------------------------
    // P1 = Probability to move to the right (i+1,j,k)
	//------------------------------------------------

	//probP1[i][j][k]=0.0;

	if (i==m_nx)  { probP1[i][j][k]= 0.0; }
	else {
				    probP1[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaX,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaX,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[iplus][j][k]-vTAFConc[iminus][j][k])
		  + m_rho*(vFibronectinConc[iplus][j][k]-vFibronectinConc[iminus][j][k]) );
	}


	//-----------------------------------------------
	// P2 = Probability to move to the left (i-1,j,k)
	//-----------------------------------------------

	//probP2[i][j][k]=0.0;

	if (i==0)    { probP2[i][j][k]= 0.0; }
	else {
				   probP2[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaX,2)

		- (angioDeltaT/(4.0*pow(angioDeltaX,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[iplus][j][k]-vTAFConc[iminus][j][k])
		  + m_rho*(vFibronectinConc[iplus][j][k]-vFibronectinConc[iminus][j][k]) );
	}


	//----------------------------------------
	// P3 = Probability to move down (i,j+1,k)
	//----------------------------------------

	//probP3[i][j][k]=1.0;

	if (j==m_ny-1) { probP3[i][j][k]=0.0; }
	else {	
					 probP3[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaY,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaY,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][jplus][k]-vTAFConc[i][jminus][k])
	      + m_rho*(vFibronectinConc[i][jplus][k]-vFibronectinConc[i][jminus][k]) );
	}


	//--------------------------------------
	// P4 = Probability to move up (i,j-1,k)
	//--------------------------------------

	probP4[i][j][k]=0.0;
/*
	if (j==0)    { probP4[i][j][k]=0.0; }
	else {
				   probP4[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaY,2)

		- (angioDeltaT/(4.0*pow(angioDeltaY,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][jplus][k]-vTAFConc[i][jminus][k])
		  + m_rho*(vFibronectinConc[i][jplus][k]-vFibronectinConc[i][jminus][k]) );
	}
*/

	//------------------------------------------------
	// P5 = Probability to move to the front (i,j,k+1)
	//------------------------------------------------

	//probP5[i][j][k]=0.0;
	
	if (k==m_nz-1 || coeffZ==0) { probP5[i][j][k]=0.0; }
	else {
					probP5[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaZ,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaZ,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][j][kplus]-vTAFConc[i][j][kminus])
		  + m_rho*(vFibronectinConc[i][j][kplus]-vFibronectinConc[i][j][kminus]) );
	}


	//----------------------------------------
	// P6 = Probability to move back (i,j,k-1)
	//----------------------------------------

	//probP6[i][j][k]=0.0;

	if (k==0 || coeffZ==0)    { probP6[i][j][k]=0.0; }
	else {	
				probP6[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaZ,2)

		- (angioDeltaT/(4.0*pow(angioDeltaZ,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][j][kplus]-vTAFConc[i][j][kminus])
		  + m_rho*(vFibronectinConc[i][j][kplus]-vFibronectinConc[i][j][kminus]) );
	}


	}}}


	
	// Probability that a sprout grows on itself is null
	//---------------------------------------------------


	for (int k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) { probP2[i-1][j-1][k-1]=0.0; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) { probP4[i-1][j-1][k-1]=0.0; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) { probP6[i-1][j-1][k-1]=0.0; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1){ probP1[i-2][j-1][k-1]=0.0; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1){ probP3[i-1][j-2][k-1]=0.0; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1){ probP5[i-1][j-1][k-2]=0.0; }
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) { probP2[i-1][j-1][k-1]=0.0; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false){ probP1[i-2][j-1][k-1]=0.0; }
	}}



	// Probability that a sprout grows on bond already occupied is null
	//------------------------------------------------------------------

	// Attention au passage 2D/3D pour la gestion de k.
/*
	for (k=1;k<=m_nz;k++) {            
		for (int j=2;j<=m_ny-1;j++) {
			for (int i=2;i<=m_nx-1;i++) {   
											
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			//-------------xbonds-----------------------------
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true)
			{
				if (pFluid[LabX(i+1,j,k)-1]==10) { probP1[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j,k)-1]==10)   { probP4[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j+1,k)-1]==10) { probP3[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k)-1]==10)   { probP6[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k+1)-1]==10) { probP5[i-1][j-1][k-1]; }
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false)
			{
				if (pFluid[LabX(i-1,j,k)-1]==10)   { probP2[i-2][j-1][k-1]; }
				if (pFluid[LabY(i-1,j,k)-1]==10)   { probP4[i-2][j-1][k-1]; }
				if (pFluid[LabY(i-1,j+1,k)-1]==10) { probP3[i-2][j-1][k-1]; }
				//if (pFluid[LabZ(i-1,j,k)-1]==10)   { probP6[i-2][j-1][k-1]; }
				//if (pFluid[LabZ(i-1,j,k+1)-1]==10) { probP5[i-2][j-1][k-1]; }
			}

			//-------------ybonds-----------------------------
			if (pSprout[nby-1]!=0 && poleSprout[nby-1]==true)
			{
				if (pFluid[LabX(i,j,k)-1]==10)   { probP2[i-1][j-1][k-1]; }
				if (pFluid[LabX(i+1,j,k)-1]==10) { probP1[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j+1,k)-1]==10) { probP3[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k)-1]==10)   { probP6[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k+1)-1]==10) { probP5[i-1][j-1][k-1]; }
			}
			if (pSprout[nby-1]!=0 && poleSprout[nby-1]==false)
			{
				if (pFluid[LabX(i,j-1,k)-1]==10)   { probP2[i-1][j-2][k-1]; }
				if (pFluid[LabX(i+1,j-1,k)-1]==10) { probP1[i-1][j-2][k-1]; }
				if (pFluid[LabY(i,j-1,k)-1]==10)   { probP4[i-1][j-2][k-1]; }
				//if (pFluid[LabZ(i,j-1,k)-1]==10)   { probP6[i-1][j-2][k-1]; }
				//if (pFluid[LabZ(i,j-1,k+1)-1]==10) { probP5[i-1][j-2][k-1]; }
			}

			//-------------zbonds-----------------------------
			if (pSprout[nbz-1]!=0 && poleSprout[nbz-1]==true)
			{
				if (pFluid[LabX(i,j,k)-1]==10)   { probP2[i-1][j-1][k-1]; }
				if (pFluid[LabX(i+1,j,k)-1]==10) { probP1[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j,k)-1]==10)   { probP4[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j+1,k)-1]==10) { probP3[i-1][j-1][k-1]; }
				if (pFluid[LabZ(i,j,k+1)-1]==10) { probP5[i-1][j-1][k-1]; }
			}
			if (pSprout[nbz-1]!=0 && poleSprout[nbz-1]==false)
			{
				if (pFluid[LabX(i,j,k-1)-1]==10)   { probP2[i-1][j-1][k-2]; }
				if (pFluid[LabX(i+1,j,k-1)-1]==10) { probP1[i-1][j-1][k-2]; }
				if (pFluid[LabY(i,j,k-1)-1]==10)   { probP4[i-1][j-1][k-2]; }
				if (pFluid[LabY(i,j+1,k-1)-1]==10) { probP3[i-1][j-1][k-2]; }
				if (pFluid[LabZ(i,j,k-1)-1]==10)   { probP6[i-1][j-1][k-2]; }
			}

	}}}
*/


	// The negative probabilities are set to zero
	//--------------------------------------------
	/*
	for (i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				if (probP0[i][j][k]<0.0) { probP0[i][j][k]=0.0; }
				if (probP1[i][j][k]<0.0) { probP1[i][j][k]=0.0; }
				if (probP2[i][j][k]<0.0) { probP2[i][j][k]=0.0; }
				if (probP3[i][j][k]<0.0) { probP3[i][j][k]=0.0; }
				if (probP4[i][j][k]<0.0) { probP4[i][j][k]=0.0; }
				if (probP5[i][j][k]<0.0) { probP5[i][j][k]=0.0; }
				if (probP6[i][j][k]<0.0) { probP6[i][j][k]=0.0; }
	}}}*/



	// Normalisation of the probabilities
	//------------------------------------

	double probTot;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				probTot = 0.0;
				probTot = fabs(probP0[i][j][k])
					     +fabs(probP1[i][j][k])+fabs(probP2[i][j][k])
						 +fabs(probP3[i][j][k])+fabs(probP4[i][j][k])
				         +fabs(probP5[i][j][k])+fabs(probP6[i][j][k]);  

				if (probTot!=0.0)
				{
					probP0[i][j][k]=fabs(probP0[i][j][k])/probTot;
					probP1[i][j][k]=fabs(probP1[i][j][k])/probTot;
					probP2[i][j][k]=fabs(probP2[i][j][k])/probTot;
					probP3[i][j][k]=fabs(probP3[i][j][k])/probTot;
					probP4[i][j][k]=fabs(probP4[i][j][k])/probTot;
					probP5[i][j][k]=fabs(probP5[i][j][k])/probTot;
					probP6[i][j][k]=fabs(probP6[i][j][k])/probTot;
				}
	}}}


	//--------------------- FOR DEBUGGING --------------------------------------
/*	outfileProb << angiotime << endl;

	for (k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
			{	outfileProb << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1) 
			{	outfileProb << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-2][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-2][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-2][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-2][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-2][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-2][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-2][j-1][k-1] << endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
			{	outfileProb << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1) 
			{	outfileProb << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-2][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-2][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-2][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-2][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-2][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-2][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-2][k-1] << endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) 
			{	outfileProb << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1) 
			{	outfileProb << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-2] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-2] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-2] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-2] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-2] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-2] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-2] << endl;
			}
	}}}

	outfileProb << endl;
*/
	//------------------------------------------------------------------------------

	
	// Calculation of the probability ranges
	//---------------------------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=probP0[i][j][k];
				R1inf[i][j][k]=R0sup[i][j][k];
				R1sup[i][j][k]=R0sup[i][j][k]+probP1[i][j][k];
				R2inf[i][j][k]=R1sup[i][j][k];
				R2sup[i][j][k]=R1sup[i][j][k]+probP2[i][j][k];
				R3inf[i][j][k]=R2sup[i][j][k];
				R3sup[i][j][k]=R2sup[i][j][k]+probP3[i][j][k];
				R4inf[i][j][k]=R3sup[i][j][k];
				R4sup[i][j][k]=R3sup[i][j][k]+probP4[i][j][k];
				R5inf[i][j][k]=R4sup[i][j][k];
				R5sup[i][j][k]=R4sup[i][j][k]+probP5[i][j][k];
				R6inf[i][j][k]=R5sup[i][j][k];
				R6sup[i][j][k]=R5sup[i][j][k]+probP6[i][j][k];
	}}}


//--------------------- FOR DEBUGGING --------------------------------------
/*	outfileGrowth << angiotime << endl;

	for (k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
			{	outfileGrowth << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;	
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1) 
			{	outfileGrowth << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-2][j-1][k-1] << "\t" << R0sup[i-2][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-2][j-1][k-1] << "\t" << R1sup[i-2][j-1][k-1] <<endl;	
				outfileGrowth << "R2" << "\t" << R2inf[i-2][j-1][k-1] << "\t" << R2sup[i-2][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-2][j-1][k-1] << "\t" << R3sup[i-2][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-2][j-1][k-1] << "\t" << R4sup[i-2][j-1][k-1] <<endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
			{	outfileGrowth << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1) 
			{	outfileGrowth << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-2][k-1] << "\t" << R0sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-2][k-1] << "\t" << R1sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-2][k-1] << "\t" << R2sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-2][k-1] << "\t" << R3sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-2][k-1] << "\t" << R4sup[i-1][j-2][k-1] <<endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) 
			{	outfileGrowth << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1) 
			{	outfileGrowth << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-2] << "\t" << R0sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-2] << "\t" << R1sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-2] << "\t" << R2sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-2] << "\t" << R3sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-2] << "\t" << R4sup[i-1][j-1][k-2] <<endl;
			}
	}}}

	outfileGrowth << endl;
*/
//-----------------------------------------------------------------------------------

	
} 


//*****************************************************

//============================
void CAngioNetDlg::GetProbs2()
//============================
{	
	// Initialisation of the probabilities to zero
	//--------------------------------------------

	m_chi=m_chi*D_TAF_Scaling;	//rescales for new TAF diffusion coeff
	m_rho=m_rho*D_TAF_Scaling;	//rescales for new TAF diffusion coeff
	m_diffCoeff=m_diffCoeff*D_TAF_Scaling;	//rescales for new TAF diffusion coeff

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				probP0[i][j][k]=0.0;
				probP1[i][j][k]=0.0;
				probP2[i][j][k]=0.0;
				probP3[i][j][k]=0.0;
				probP4[i][j][k]=0.0;
				probP5[i][j][k]=0.0;
				probP6[i][j][k]=0.0;
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=0.0;
				R1inf[i][j][k]=0.0;
				R1sup[i][j][k]=0.0;
				R2inf[i][j][k]=0.0;
				R2sup[i][j][k]=0.0;
				R3inf[i][j][k]=0.0;
				R3sup[i][j][k]=0.0;
				R4inf[i][j][k]=0.0;
				R4sup[i][j][k]=0.0;
				R5inf[i][j][k]=0.0;
				R5sup[i][j][k]=0.0;
				R6inf[i][j][k]=0.0;
				R6sup[i][j][k]=0.0;			
	}}}
    
	// Calculation of the probabilities P0 to P6 for each point (i,j,k)
    //-----------------------------------------------------------------

	 angioDeltaZ=angioDeltaX;

	//---------- switch 2D / 3D ---------------
	  int coeffZ;
	  if (m_nz==1) {coeffZ=0;} else {coeffZ=1;}
	//-----------------------------------------

	int iminus,iplus,jminus,jplus,kminus,kplus;

    for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
		
		if (i==0) {iminus=1;} else  {iminus=i-1;}
		if (j==0) {jminus=1;} else  {jminus=j-1;}
		if (k==0) {kminus=1;} else  {kminus=k-1;}
		if (i==m_nx  ) {iplus=m_nx-1;} else  {iplus=i+1;}
		if (j==m_ny-1) {jplus=m_ny-2;} else  {jplus=j+1;}
		if (k==m_nz-1) {kplus=m_nz-2;} else  {kplus=k+1;}

		if (m_nz==1) {k=0; kminus=0;kplus=0;}
	//----------------------------------------------
	// P0 = Probability to remain stationary (i,j,k)
	//----------------------------------------------
	double diffPrefactor=0.0;
	if (m_nz==1)	{diffPrefactor=4.0;}	//2D
	else			{diffPrefactor=6.0;}	//3D


    probP0[i][j][k]=
	
	1.0-diffPrefactor*m_diffCoeff*angioDeltaT*
	( (1.0/pow(angioDeltaX,2))+(1.0/pow(angioDeltaY,2))+(1.0/pow(angioDeltaZ,2))*coeffZ )

    + ((m_chi*m_alpha*angioDeltaT)/pow((1.0+m_alpha*vTAFConc[i][j][k]),2))
	*( (pow((vTAFConc[iplus][j][k]-vTAFConc[iminus][j][k]),2)/pow((2.0*angioDeltaX),2))
	  +(pow((vTAFConc[i][jplus][k]-vTAFConc[i][jminus][k]),2)/pow((2.0*angioDeltaY),2))   
	  +(pow((vTAFConc[i][j][kplus]-vTAFConc[i][j][kminus]),2)/pow((2.0*angioDeltaZ),2))*coeffZ ) 

	- ((m_chi*angioDeltaT)/(1.0+m_alpha*vTAFConc[i][j][k]))
	*( ((vTAFConc[iplus][j][k]-2.0*vTAFConc[i][j][k]+vTAFConc[iminus][j][k])/pow(angioDeltaX,2))
      +((vTAFConc[i][jplus][k]-2.0*vTAFConc[i][j][k]+vTAFConc[i][jminus][k])/pow(angioDeltaY,2))  
	  +((vTAFConc[i][j][kplus]-2.0*vTAFConc[i][j][k]+vTAFConc[i][j][kminus])/pow(angioDeltaZ,2))*coeffZ )
	
	- m_rho*angioDeltaT
	*( ((vFibronectinConc[iplus][j][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[iminus][j][k])/pow(angioDeltaX,2))
	  +((vFibronectinConc[i][jplus][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][jminus][k])/pow(angioDeltaY,2))   
	  +((vFibronectinConc[i][j][kplus]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][j][kminus])/pow(angioDeltaZ,2))*coeffZ );


	//------------------------------------------------
    // P1 = Probability to move to the right (i+1,j,k)
	//------------------------------------------------

	//probP1[i][j][k]=0.0;

	if (i==m_nx || i==m_nx-1)  { probP1[i][j][k]= 0.0; }

	else if	(pFluid[LabX(iplus+1,j+1,k+1)-1]==66)	{probP1[i][j][k]=0.0;}	//can't grow onto pFluid=66 bonds
																			//in hex network (Mike 09/09)
	else {																	
				    probP1[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaX,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaX,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[iplus][j][k]-vTAFConc[iminus][j][k])
		  + m_rho*(vFibronectinConc[iplus][j][k]-vFibronectinConc[iminus][j][k]) );
	}

	//-----------------------------------------------
	// P2 = Probability to move to the left (i-1,j,k)
	//-----------------------------------------------

	//probP2[i][j][k]=0.0;

	if (i==0)    { probP2[i][j][k]= 0.0; }

	else if	(pFluid[LabX(i+1,j+1,k+1)-1]==66)	{probP2[i][j][k]=0.0;}	//can't grow onto pFluid=66 bonds
																		//in hex network (Mike 09/09)
	else {																
				   probP2[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaX,2)

		- (angioDeltaT/(4.0*pow(angioDeltaX,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[iplus][j][k]-vTAFConc[iminus][j][k])
		  + m_rho*(vFibronectinConc[iplus][j][k]-vFibronectinConc[iminus][j][k]) );
	}
	
	//----------------------------------------
	// P3 = Probability to move down (i,j+1,k)
	//----------------------------------------

	//probP3[i][j][k]=1.0;

	if (j==m_ny-1) { probP3[i][j][k]=0.0; }

	else if	(pFluid[LabY(i+1,jplus+1,k+1)-1]==66)	{probP3[i][j][k]=0.0;}	//can't grow onto pFluid=66 bonds
																			//in hex network (Mike 09/09)
	else {																	
					 probP3[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaY,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaY,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][jplus][k]-vTAFConc[i][jminus][k])
	      + m_rho*(vFibronectinConc[i][jplus][k]-vFibronectinConc[i][jminus][k]) );
	}
	
	//--------------------------------------
	// P4 = Probability to move up (i,j-1,k)
	//--------------------------------------

	probP4[i][j][k]=0.0;

	if	(b_venousIncluded || b_UU_wound_Model) //let upward migration if venule present
		{									//or if central wound with lower PVs
			if (j==0)    { probP4[i][j][k]=0.0; }

			else if	(pFluid[LabY(i+1,j+1,k+1)-1]==66)	{probP4[i][j][k]=0.0;}	//can't grow onto pFluid=66 bonds
																				//in hex network (Mike 09/09)
			else	{																
						probP4[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaY,2)

						- (angioDeltaT/(4.0*pow(angioDeltaY,2)))
						*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][jplus][k]-vTAFConc[i][jminus][k])
						+ m_rho*(vFibronectinConc[i][jplus][k]-vFibronectinConc[i][jminus][k]) );
					}
		}
		
	//------------------------------------------------
	// P5 = Probability to move to the front (i,j,k+1)
	//------------------------------------------------

	//probP5[i][j][k]=0.0;
	
	if (k==m_nz-1 || coeffZ==0) { probP5[i][j][k]=0.0; }

	else if	(pFluid[LabZ(i+1,j+1,kplus+1)-1]==66)	{probP5[i][j][k]=0.0;}	//can't grow onto pFluid=66 bonds
																			//in hex network (Mike 09/09)
	else {																	
					probP5[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaZ,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaZ,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][j][kplus]-vTAFConc[i][j][kminus])
		  + m_rho*(vFibronectinConc[i][j][kplus]-vFibronectinConc[i][j][kminus]) );
	}

	//----------------------------------------
	// P6 = Probability to move back (i,j,k-1)
	//----------------------------------------

	//probP6[i][j][k]=0.0;

	if (k==0 || coeffZ==0)    { probP6[i][j][k]=0.0; }

	else if	(pFluid[LabZ(i+1,j+1,k+1)-1]==66)	{probP6[i][j][k]=0.0;}	//can't grow onto pFluid=66 bonds
																		//in hex network (Mike 09/09)
	else {																
				probP6[i][j][k]= (m_diffCoeff*angioDeltaT)/pow(angioDeltaZ,2)

		- (angioDeltaT/(4.0*pow(angioDeltaZ,2)))
		*( (m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*(vTAFConc[i][j][kplus]-vTAFConc[i][j][kminus])
		  + m_rho*(vFibronectinConc[i][j][kplus]-vFibronectinConc[i][j][kminus]) );
	}

	}}}
	
	// Probability that a sprout grows on itself is null
	//---------------------------------------------------

	for (int k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) { probP2[i-1][j-1][k-1]=0.0; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) { probP4[i-1][j-1][k-1]=0.0; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) { probP6[i-1][j-1][k-1]=0.0; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1){ probP1[i-2][j-1][k-1]=0.0; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1){ probP3[i-1][j-2][k-1]=0.0; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1){ probP5[i-1][j-1][k-2]=0.0; }
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) { probP2[i-1][j-1][k-1]=0.0; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false){ probP1[i-2][j-1][k-1]=0.0; }
	}}


	// Probability that a sprout grows on bond already occupied is null
	//------------------------------------------------------------------

	// Attention au passage 2D/3D pour la gestion de k.
/*
	for (k=1;k<=m_nz;k++) {            
		for (int j=2;j<=m_ny-1;j++) {
			for (int i=2;i<=m_nx-1;i++) {   
											
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			//-------------xbonds-----------------------------
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true)
			{
				if (pFluid[LabX(i+1,j,k)-1]==10) { probP1[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j,k)-1]==10)   { probP4[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j+1,k)-1]==10) { probP3[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k)-1]==10)   { probP6[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k+1)-1]==10) { probP5[i-1][j-1][k-1]; }
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false)
			{
				if (pFluid[LabX(i-1,j,k)-1]==10)   { probP2[i-2][j-1][k-1]; }
				if (pFluid[LabY(i-1,j,k)-1]==10)   { probP4[i-2][j-1][k-1]; }
				if (pFluid[LabY(i-1,j+1,k)-1]==10) { probP3[i-2][j-1][k-1]; }
				//if (pFluid[LabZ(i-1,j,k)-1]==10)   { probP6[i-2][j-1][k-1]; }
				//if (pFluid[LabZ(i-1,j,k+1)-1]==10) { probP5[i-2][j-1][k-1]; }
			}

			//-------------ybonds-----------------------------
			if (pSprout[nby-1]!=0 && poleSprout[nby-1]==true)
			{
				if (pFluid[LabX(i,j,k)-1]==10)   { probP2[i-1][j-1][k-1]; }
				if (pFluid[LabX(i+1,j,k)-1]==10) { probP1[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j+1,k)-1]==10) { probP3[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k)-1]==10)   { probP6[i-1][j-1][k-1]; }
				//if (pFluid[LabZ(i,j,k+1)-1]==10) { probP5[i-1][j-1][k-1]; }
			}
			if (pSprout[nby-1]!=0 && poleSprout[nby-1]==false)
			{
				if (pFluid[LabX(i,j-1,k)-1]==10)   { probP2[i-1][j-2][k-1]; }
				if (pFluid[LabX(i+1,j-1,k)-1]==10) { probP1[i-1][j-2][k-1]; }
				if (pFluid[LabY(i,j-1,k)-1]==10)   { probP4[i-1][j-2][k-1]; }
				//if (pFluid[LabZ(i,j-1,k)-1]==10)   { probP6[i-1][j-2][k-1]; }
				//if (pFluid[LabZ(i,j-1,k+1)-1]==10) { probP5[i-1][j-2][k-1]; }
			}

			//-------------zbonds-----------------------------
			if (pSprout[nbz-1]!=0 && poleSprout[nbz-1]==true)
			{
				if (pFluid[LabX(i,j,k)-1]==10)   { probP2[i-1][j-1][k-1]; }
				if (pFluid[LabX(i+1,j,k)-1]==10) { probP1[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j,k)-1]==10)   { probP4[i-1][j-1][k-1]; }
				if (pFluid[LabY(i,j+1,k)-1]==10) { probP3[i-1][j-1][k-1]; }
				if (pFluid[LabZ(i,j,k+1)-1]==10) { probP5[i-1][j-1][k-1]; }
			}
			if (pSprout[nbz-1]!=0 && poleSprout[nbz-1]==false)
			{
				if (pFluid[LabX(i,j,k-1)-1]==10)   { probP2[i-1][j-1][k-2]; }
				if (pFluid[LabX(i+1,j,k-1)-1]==10) { probP1[i-1][j-1][k-2]; }
				if (pFluid[LabY(i,j,k-1)-1]==10)   { probP4[i-1][j-1][k-2]; }
				if (pFluid[LabY(i,j+1,k-1)-1]==10) { probP3[i-1][j-1][k-2]; }
				if (pFluid[LabZ(i,j,k-1)-1]==10)   { probP6[i-1][j-1][k-2]; }
			}

	}}}
*/

	// The negative probabilities are set to zero
	//--------------------------------------------
	/*
	for (i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				if (probP0[i][j][k]<0.0) { probP0[i][j][k]=0.0; }
				if (probP1[i][j][k]<0.0) { probP1[i][j][k]=0.0; }
				if (probP2[i][j][k]<0.0) { probP2[i][j][k]=0.0; }
				if (probP3[i][j][k]<0.0) { probP3[i][j][k]=0.0; }
				if (probP4[i][j][k]<0.0) { probP4[i][j][k]=0.0; }
				if (probP5[i][j][k]<0.0) { probP5[i][j][k]=0.0; }
				if (probP6[i][j][k]<0.0) { probP6[i][j][k]=0.0; }
	}}}*/


	// If the probability to move in one direction is negative
	// then this contribution is added to the growth probability in 
	// the opposite direction
	//--------------------------------------------------------------

	double add1,add2,add3,add4,add5,add6;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				if (i==0) {iminus=1;} else  {iminus=i-1;}
				if (j==0) {jminus=1;} else  {jminus=j-1;}
				if (k==0) {kminus=1;} else  {kminus=k-1;}
				if (i==m_nx  ) {iplus=m_nx-1;} else  {iplus=i+1;}
				if (j==m_ny-1) {jplus=m_ny-2;} else  {jplus=j+1;}
				if (k==m_nz-1) {kplus=m_nz-2;} else  {kplus=k+1;}

				if (m_nz==1) {k=0; kminus=0;kplus=0;}

				add1=0.0;
				add2=0.0;
				add3=0.0;
				add4=0.0;
				add5=0.0;
				add6=0.0;

				if (probP0[i][j][k]<0.0) { probP0[i][j][k]=0.0; }
				if (probP1[i][j][k]<0.0) { add1=fabs(probP1[i][j][k]);
										   probP1[i][j][k]=0.0; }
				if (probP2[i][j][k]<0.0) { add2=fabs(probP2[i][j][k]); 
										   probP2[i][j][k]=0.0; }
				if (probP3[i][j][k]<0.0) { add3=fabs(probP3[i][j][k]); 
										   probP3[i][j][k]=0.0; }
				if (probP4[i][j][k]<0.0) { add4=fabs(probP4[i][j][k]); 
										   probP4[i][j][k]=0.0; }
				if (probP5[i][j][k]<0.0) { add5=fabs(probP5[i][j][k]); 
										   probP5[i][j][k]=0.0; }
				if (probP6[i][j][k]<0.0) { add6=fabs(probP6[i][j][k]); 
										   probP6[i][j][k]=0.0; }

				if	(pFluid[LabX(iplus+1,j+1,k+1)-1]!=66)	{probP1[i][j][k]=probP1[i][j][k]+add2;}	//Prob of     
				if	(pFluid[LabX(i+1,j+1,k+1)-1]!=66)		{probP2[i][j][k]=probP2[i][j][k]+add1;}	//growing
				if	(pFluid[LabY(i+1,jplus+1,k+1)-1]!=66)	{probP3[i][j][k]=probP3[i][j][k]+add4;}	//onto
				if	(pFluid[LabY(i+1,j+1,k+1)-1]!=66)		{probP4[i][j][k]=probP4[i][j][k]+add3;}	//pFluid=66
				if	(pFluid[LabZ(i+1,j+1,kplus+1)-1]!=66)	{probP5[i][j][k]=probP5[i][j][k]+add6;}	//bonds must
				if	(pFluid[LabZ(i+1,j+1,k+1)-1]!=66)		{probP6[i][j][k]=probP6[i][j][k]+add5;}	//remain zero
	}}}


	// Normalisation of the probabilities
	//------------------------------------

	double probTot;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				probTot = 0.0;
				probTot = fabs(probP0[i][j][k])
					     +fabs(probP1[i][j][k])+fabs(probP2[i][j][k])
						 +fabs(probP3[i][j][k])+fabs(probP4[i][j][k])
				         +fabs(probP5[i][j][k])+fabs(probP6[i][j][k]);  

				if (probTot!=0.0)
				{
					probP0[i][j][k]=fabs(probP0[i][j][k])/probTot;
					probP1[i][j][k]=fabs(probP1[i][j][k])/probTot;
					probP2[i][j][k]=fabs(probP2[i][j][k])/probTot;
					probP3[i][j][k]=fabs(probP3[i][j][k])/probTot;
					probP4[i][j][k]=fabs(probP4[i][j][k])/probTot;
					probP5[i][j][k]=fabs(probP5[i][j][k])/probTot;
					probP6[i][j][k]=fabs(probP6[i][j][k])/probTot;
				}
	}}}

	//--------------------- FOR DEBUGGING --------------------------------------
/*	outfileProb << angiotime << endl;

	for (k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
			{	outfileProb << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1) 
			{	outfileProb << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-2][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-2][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-2][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-2][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-2][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-2][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-2][j-1][k-1] << endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
			{	outfileProb << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1) 
			{	outfileProb << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-2][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-2][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-2][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-2][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-2][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-2][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-2][k-1] << endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) 
			{	outfileProb << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1) 
			{	outfileProb << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-2] << endl;
				outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-2] << endl;
				outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-2] << endl;
				outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-2] << endl;
				outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-2] << endl;
				outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-2] << endl;
				outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-2] << endl;
			}
	}}}

	outfileProb << endl;
*/
	//------------------------------------------------------------------------------

	
	// Calculation of the probability ranges
	//---------------------------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=probP0[i][j][k];
				R1inf[i][j][k]=R0sup[i][j][k];
				R1sup[i][j][k]=R0sup[i][j][k]+probP1[i][j][k];
				R2inf[i][j][k]=R1sup[i][j][k];
				R2sup[i][j][k]=R1sup[i][j][k]+probP2[i][j][k];
				R3inf[i][j][k]=R2sup[i][j][k];
				R3sup[i][j][k]=R2sup[i][j][k]+probP3[i][j][k];
				R4inf[i][j][k]=R3sup[i][j][k];
				R4sup[i][j][k]=R3sup[i][j][k]+probP4[i][j][k];
				R5inf[i][j][k]=R4sup[i][j][k];
				R5sup[i][j][k]=R4sup[i][j][k]+probP5[i][j][k];
				R6inf[i][j][k]=R5sup[i][j][k];
				R6sup[i][j][k]=R5sup[i][j][k]+probP6[i][j][k];
	}}}


//--------------------- FOR DEBUGGING --------------------------------------
/*	outfileGrowth << angiotime << endl;

	for (k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
			{	outfileGrowth << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;	
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1) 
			{	outfileGrowth << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-2][j-1][k-1] << "\t" << R0sup[i-2][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-2][j-1][k-1] << "\t" << R1sup[i-2][j-1][k-1] <<endl;	
				outfileGrowth << "R2" << "\t" << R2inf[i-2][j-1][k-1] << "\t" << R2sup[i-2][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-2][j-1][k-1] << "\t" << R3sup[i-2][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-2][j-1][k-1] << "\t" << R4sup[i-2][j-1][k-1] <<endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
			{	outfileGrowth << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1) 
			{	outfileGrowth << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-2][k-1] << "\t" << R0sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-2][k-1] << "\t" << R1sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-2][k-1] << "\t" << R2sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-2][k-1] << "\t" << R3sup[i-1][j-2][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-2][k-1] << "\t" << R4sup[i-1][j-2][k-1] <<endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) 
			{	outfileGrowth << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1) 
			{	outfileGrowth << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
				outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-2] << "\t" << R0sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-2] << "\t" << R1sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-2] << "\t" << R2sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-2] << "\t" << R3sup[i-1][j-1][k-2] <<endl;
				outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-2] << "\t" << R4sup[i-1][j-1][k-2] <<endl;
			}
	}}}

	outfileGrowth << endl;
*/
//-----------------------------------------------------------------------------------

} 

//***********************************************
//=====================================
void CAngioNetDlg::GrowVasculature()
//=====================================
{

	//-----------------------------------------------------------------
	// Throw dice and decide which way to go for each sprout according 
	// to the probabilities ranges Rj=[Rjinf-Rjsup] with j=0 to 6
	//-----------------------------------------------------------------

	double thd=0.0; //threshold for cell density (0.25)
	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond]; 
	
	for (int nn=1;nn<=Nbond;nn++) { pOldSprout[nn-1]=0; }
	for (int nn=1;nn<=Nbond;nn++) { pOldSprout[nn-1]=pSprout[nn-1]; }

	//-- get total number of sprouts ---------------
	  int nTotSprouts=0;
	  for (int nn=1;nn<=Nbond;nn++) { 
		  if (pOldSprout[nn-1]!=0) {nTotSprouts+=1;}
	  }

	//outfileGrowVasc << angiotime << "\t" << "nTotSprouts=" << nTotSprouts << endl;

    double throwDice;
	int nbx,nby,nbz;
	int move,moveRight,moveLeft,moveDown,moveUp,moveFront,moveBack;

	outfileGrowVasc << angiotime << endl;

	//--------- FOR DEBUGGING------------
	outfileSprouts << angiotime << endl;

	for (int k=1;k<=m_nz;k++) {            
		for (int j=2;j<=m_ny;j++) {
			for (int i=1;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);

			if (pOldSprout[nbx-1]!=0) {outfileSprouts << "x-bond" << "\t" << i << "\t" << j << endl;}
			if (pOldSprout[nby-1]!=0) {outfileSprouts << "y-bond" << "\t" << i << "\t" << j << endl;}
			if (pOldSprout[nbz-1]!=0) {outfileSprouts << "z-bond" << "\t" << i << "\t" << j << endl;}

			//if (pFluid[nbx-1]==10) {outfileSprouts << "x-bond" << "\t" << i << "\t" << j << endl;}
			//if (pFluid[nby-1]==10) {outfileSprouts << "y-bond" << "\t" << i << "\t" << j << endl;}
			//if (pFluid[nbz-1]==10) {outfileSprouts << "z-bond" << "\t" << i << "\t" << j << endl;}
	}}}
	outfileSprouts << endl;
	//------------------------------------

	int kstart;
	if (m_nz=1) {kstart=1;}
	else		{kstart=2;}

	for (int k=kstart;k<=m_nz;k++) {            
		for (int j=2;j<=m_ny-1;j++) {
			for (int i=2;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);


	//---- x-bond -------------------------------------------------------------------------

	  if (pOldSprout[nbx-1]!=0) 
	  { 
		if (poleSprout[nbx-1]==true && vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
		{		
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;
				outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;
				outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;
				outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;
				outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;
				outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;
				outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack; 
				outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else    {poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{
					pSprout[nbx-1]=0;
					pAgeOfSprout[nbx-1]=0.0;
					outfileGrowVasc << "kill-sprout-x" << endl;
					outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
				}
			}

		}//end if poleSprout[nbx-1]==true

		if (poleSprout[nbx-1]==false && vEndoCellDensity[i-2][j-1][k-1]>thd*runningEndoCellMAX)
		{
			moveRight=LabX(i,j,k);   
			moveLeft=LabX(i-1,j,k);
			moveDown=LabY(i-1,j+1,k);
			moveUp=LabY(i-1,j,k);
			moveFront=LabZ(i-1,j,k+1);
			moveBack=LabZ(i-1,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-2][j-1][k-1] && throwDice<R0sup[i-2][j-1][k-1]) {move=0;
				outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-2][j-1][k-1] && throwDice<R1sup[i-2][j-1][k-1]) {move=moveRight;
				outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-2][j-1][k-1] && throwDice<R2sup[i-2][j-1][k-1]) {move=moveLeft;
				outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-2][j-1][k-1] && throwDice<R3sup[i-2][j-1][k-1]) {move=moveDown;
				outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-2][j-1][k-1] && throwDice<R4sup[i-2][j-1][k-1]) {move=moveUp;
				outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-2][j-1][k-1] && throwDice<R5sup[i-2][j-1][k-1]) {move=moveFront;
				outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-2][j-1][k-1] && throwDice<R6sup[i-2][j-1][k-1]) {move=moveBack; 
				outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else    {poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{
					pSprout[nbx-1]=0;
					pAgeOfSprout[nbx-1]=0.0;
					outfileGrowVasc << "kill-sprout-x" << endl;
					outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
				}
			}

		}//end if poleSprout[nbx-1]==false

	  }//end if pOldSprout[nbx-1]!=0 


	//---- y-bond -------------------------------------------------------------------------

	  if (pOldSprout[nby-1]!=0) 
	  {
		if (poleSprout[nby-1]==true && vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
		{	
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;
				outfileGrowVasc << "y-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;
				outfileGrowVasc << "y-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;
				outfileGrowVasc << "y-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;
				outfileGrowVasc << "y-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;
				outfileGrowVasc << "y-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;
				outfileGrowVasc << "y-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack; 
				outfileGrowVasc << "y-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{	
					pSprout[nby-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nby-1];
				}
				else
				{
					pSprout[nby-1]=0;
					pAgeOfSprout[nby-1]=0.0;
					outfileGrowVasc << "kill-sprout-y" << endl;
					outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
				}
			}
		}//end if poleSprout[nby-1]==true

		if (poleSprout[nby-1]==false && vEndoCellDensity[i-1][j-2][k-1]>thd*runningEndoCellMAX)
		{
			moveRight=LabX(i+1,j-1,k);   
			moveLeft=LabX(i,j-1,k);
			moveDown=LabY(i,j,k);
			moveUp=LabY(i,j-1,k);
			moveFront=LabZ(i,j-1,k+1);
			moveBack=LabZ(i,j-1,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-2][k-1] && throwDice<R0sup[i-1][j-2][k-1]) {move=0;
				outfileGrowVasc << "y-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R1inf[i-1][j-2][k-1] && throwDice<R1sup[i-1][j-2][k-1]) {move=moveRight;
				outfileGrowVasc << "y-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-1][j-2][k-1] && throwDice<R2sup[i-1][j-2][k-1]) {move=moveLeft;
				outfileGrowVasc << "y-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-1][j-2][k-1] && throwDice<R3sup[i-1][j-2][k-1]) {move=moveDown;
				outfileGrowVasc << "y-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-1][j-2][k-1] && throwDice<R4sup[i-1][j-2][k-1]) {move=moveUp;
				outfileGrowVasc << "y-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-1][j-2][k-1] && throwDice<R5sup[i-1][j-2][k-1]) {move=moveFront;
				outfileGrowVasc << "y-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-2][k-1] && throwDice<R6sup[i-1][j-2][k-1]) {move=moveBack; 
				outfileGrowVasc << "y-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{	
					pSprout[nby-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nby-1];
				}
				else
				{
					pSprout[nby-1]=0;
					pAgeOfSprout[nby-1]=0.0;
					outfileGrowVasc << "kill-sprout-y" << endl;
					outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
				}
			}
		}//end if poleSprout[nby-1]==false

	  }//end if pOldSprout[nby-1]!=0


	//---- z-bond -------------------------------------------------------------------------

	  if (pOldSprout[nbz-1]!=0) 
	  {
		if (poleSprout[nbz-1]==true && vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
		{
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;
				outfileGrowVasc << "z-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;
				outfileGrowVasc << "z-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft; 
				outfileGrowVasc << "z-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown; 
				outfileGrowVasc << "z-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;   
				outfileGrowVasc << "z-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;
				outfileGrowVasc << "z-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack; 
				outfileGrowVasc << "z-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10) 
				{	
					pSprout[nbz-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbz-1];
				}
				else
				{
					pSprout[nbz-1]=0;
					pAgeOfSprout[nbz-1]=0.0;
					outfileGrowVasc << "kill-sprout-z" << endl;
					outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
				}
			}
		}//end if poleSprout[nbz-1]==true

		if (poleSprout[nbz-1]==false && vEndoCellDensity[i-1][j-1][k-2]>thd*runningEndoCellMAX)
		{
			moveRight=LabX(i+1,j,k-1);   
			moveLeft=LabX(i,j,k-1);
			moveDown=LabY(i,j+1,k-1);
			moveUp=LabY(i,j,k-1);
			moveFront=LabZ(i,j,k);
			moveBack=LabZ(i,j,k-1);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-2] && throwDice<R0sup[i-1][j-1][k-2]) {move=0;
				outfileGrowVasc << "z-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-1][j-1][k-2] && throwDice<R1sup[i-1][j-1][k-2]) {move=moveRight;
				outfileGrowVasc << "z-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R2inf[i-1][j-1][k-2] && throwDice<R2sup[i-1][j-1][k-2]) {move=moveLeft; 
				outfileGrowVasc << "z-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R3inf[i-1][j-1][k-2] && throwDice<R3sup[i-1][j-1][k-2]) {move=moveDown; 
				outfileGrowVasc << "z-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R4inf[i-1][j-1][k-2] && throwDice<R4sup[i-1][j-1][k-2]) {move=moveUp;   
				outfileGrowVasc << "z-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R5inf[i-1][j-1][k-2] && throwDice<R5sup[i-1][j-1][k-2]) {move=moveFront;
				outfileGrowVasc << "z-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-2] && throwDice<R6sup[i-1][j-1][k-2]) {move=moveBack; 
				outfileGrowVasc << "z-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10) 
				{	
					pSprout[nbz-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbz-1];
				}
				else
				{
					pSprout[nbz-1]=0;
					pAgeOfSprout[nbz-1]=0.0;
					outfileGrowVasc << "kill-sprout-z" << endl;
					outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
				}
			}
		}//end if poleSprout[nbz-1]==false

	  }//end if pOldSprout[nbz-1]!=0

}//end i loop

	int i=m_nx+1;

	nbx=LabX(i,j,k);


	//---- dangling x-bond ----------------------------------------------------------------

	  if (pOldSprout[nbx-1]!=0) 
	  {
		if (poleSprout[nbx-1]==true && vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
		{
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;}
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack; }

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{
					pSprout[nbx-1]=0;
					pAgeOfSprout[nbx-1]=0.0;
				}
			}
		}//end if poleSprout[nbx-1]==true

		if (poleSprout[nbx-1]==false && k>1 && vEndoCellDensity[i-2][j-1][k-1]>thd*runningEndoCellMAX)
		{
			moveRight=LabX(i,j,k);   
			moveLeft=LabX(i-1,j,k);
			moveDown=LabY(i-1,j+1,k);
			moveUp=LabY(i-1,j,k);
			moveFront=LabZ(i-1,j,k+1);
			moveBack=LabZ(i-1,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1

			if (throwDice>=R0inf[i-2][j-1][k-1] && throwDice<R0sup[i-2][j-1][k-1]) {move=0;}
			if (throwDice>=R1inf[i-2][j-1][k-1] && throwDice<R1sup[i-2][j-1][k-1]) {move=moveRight;}
			if (throwDice>=R2inf[i-2][j-1][k-1] && throwDice<R2sup[i-2][j-1][k-1]) {move=moveLeft;}
			if (throwDice>=R3inf[i-2][j-1][k-1] && throwDice<R3sup[i-2][j-1][k-1]) {move=moveDown;}
			if (throwDice>=R4inf[i-2][j-1][k-1] && throwDice<R4sup[i-2][j-1][k-1]) {move=moveUp;}
			if (throwDice>=R5inf[i-2][j-1][k-1] && throwDice<R5sup[i-2][j-1][k-1]) {move=moveFront;}
			if (throwDice>=R6inf[i-2][j-1][k-1] && throwDice<R6sup[i-2][j-1][k-1]) {move=moveBack; }

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{
					pSprout[nbx-1]=0;
					pAgeOfSprout[nbx-1]=0.0;
				}
			}
		}//end if poleSprout[nbx-1]==true

	  }//end if pOldSprout[nbx-1]!=0


}}//end j and k loops




	// The sprouts which have just reached the boundaries are killed
	//---------------------------------------------------------------

	for (int k=1;k<=m_nz;k++) {            
		for (int j=1;j<=m_ny;j++) {
			for (int i=1;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]!=0 && i==1) {
				pSprout[nbx-1]=0;
				pAgeOfSprout[nbx-1]=0.0;
			}
			if (pSprout[nby-1]!=0 && poleSprout[nby-1]==false && j==2) {
				pSprout[nby-1]=0;
				pAgeOfSprout[nby-1]=0.0;
			}
			if (pSprout[nby-1]!=0 && j==m_ny) {
				pSprout[nby-1]=0;
				pAgeOfSprout[nby-1]=0.0;
			}
			if (pSprout[nbz-1]!=0 && k==1) {
				pSprout[nbz-1]=0;
				pAgeOfSprout[nbz-1]=0.0;
			}
			if (pSprout[nbz-1]!=0 && k==m_nz) {
				pSprout[nbz-1]=0;
				pAgeOfSprout[nbz-1]=0.0;
			}
			}//end i-loop
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pSprout[nbx-1]!=0) {
				pSprout[nbx-1]=0;
				pAgeOfSprout[nbx-1]=0.0;
			}
	}}



	delete [] pOldSprout;

	outfileGrowVasc << endl;

}


//******************************************************

//=====================================
void CAngioNetDlg::GrowVasculatureMDF()
//=====================================
{

	//-----------------------------------------------------------------
	// Throw dice and decide which way to go for each sprout according 
	// to the probabilities ranges Rj=[Rjinf-Rjsup] with j=0 to 6
	//-----------------------------------------------------------------

	double thd=0.0; //threshold for cell density (0.25)
	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond]; 
	
	for (int nn=1;nn<=Nbond;nn++) { pOldSprout[nn-1]=0; }
	for (int nn=1;nn<=Nbond;nn++) { pOldSprout[nn-1]=pSprout[nn-1]; }

	//-- get total number of sprouts ---------------
	  int nTotSprouts=0;
	  for (int nn=1;nn<=Nbond;nn++) { 
		  if (pOldSprout[nn-1]!=0) {nTotSprouts+=1;}
	  }

	//outfileGrowVasc << angiotime << "\t" << "nTotSprouts=" << nTotSprouts << endl;
	//outfileGrowVasc << angiotime << endl;

    double throwDice;
	int nbx,nby,nbz;
	int move,moveRight,moveLeft,moveDown,moveUp,moveFront,moveBack;

	double AnastThreshold=0.98;	//defeines % of tip-vessel deaths
	//--------- FOR DEBUGGING------------
/*	outfileSprouts << angiotime << endl;

	for (int k=1;k<=m_nz;k++) {            
		for (int j=2;j<=m_ny;j++) {
			for (int i=1;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);

			if (pOldSprout[nbx-1]!=0) {outfileSprouts << "x-bond" << "\t" << i << "\t" << j << endl;}
			if (pOldSprout[nby-1]!=0) {outfileSprouts << "y-bond" << "\t" << i << "\t" << j << endl;}
			if (pOldSprout[nbz-1]!=0) {outfileSprouts << "z-bond" << "\t" << i << "\t" << j << endl;}

			//if (pFluid[nbx-1]==10) {outfileSprouts << "x-bond" << "\t" << i << "\t" << j << endl;}
			//if (pFluid[nby-1]==10) {outfileSprouts << "y-bond" << "\t" << i << "\t" << j << endl;}
			//if (pFluid[nbz-1]==10) {outfileSprouts << "z-bond" << "\t" << i << "\t" << j << endl;}
	}}}

	outfileSprouts << endl;*/
	//------------------------------------

	int kstart;
	if (m_nz==1) {kstart=1;}
	else	 	 {kstart=2;}

	for (int k=kstart;k<=m_nz;k++) {            
		for (int j=2;j<=m_ny;j++) {
			for (int i=2;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);
	
	//---- x-bond -------------------------------------------------------------------------

	  if (pOldSprout[nbx-1]!=0) 
	  { 
		if (poleSprout[nbx-1]==true)
		{		
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
				//outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
				//outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=0;}//SMcD 2005 moveLeft;}
				//outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
				//outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}
				//outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
				//outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack;}
				//outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	
				{						
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;

					if (pArterialVenousID[nbx-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else    {poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{

					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
						pSprout[nbx-1]=0;
						pAgeOfSprout[nbx-1]=0.0;
						//outfileGrowVasc << "kill-sprout-x" << endl;
						//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
					}
				}
			}	//end if move !=0

		}//end if poleSprout[nbx-1]==true

		if (poleSprout[nbx-1]==false)
		{
			moveRight=LabX(i,j,k);   
			moveLeft=LabX(i-1,j,k);
			moveDown=LabY(i-1,j+1,k);
			moveUp=LabY(i-1,j,k);
			moveFront=LabZ(i-1,j,k+1);
			moveBack=LabZ(i-1,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-2][j-1][k-1] && throwDice<R0sup[i-2][j-1][k-1]) {move=0;}
				//outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-2][j-1][k-1] && throwDice<R1sup[i-2][j-1][k-1]) {move=0;}//SMcD 2005 moveRight;}
				//outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-2][j-1][k-1] && throwDice<R2sup[i-2][j-1][k-1]) {move=moveLeft;}
				//outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-2][j-1][k-1] && throwDice<R3sup[i-2][j-1][k-1]) {move=moveDown;}
				//outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-2][j-1][k-1] && throwDice<R4sup[i-2][j-1][k-1]) {move=moveUp;}
				//outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-2][j-1][k-1] && throwDice<R5sup[i-2][j-1][k-1]) {move=moveFront;}
				//outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-2][j-1][k-1] && throwDice<R6sup[i-2][j-1][k-1]) {move=moveBack;}
				//outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	
				{						
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;

					if (pArterialVenousID[nbx-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else    {poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{	
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
					pSprout[nbx-1]=0;
					pAgeOfSprout[nbx-1]=0.0;
					//outfileGrowVasc << "kill-sprout-x" << endl;
					//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
					}
				}
			}

		}//end if poleSprout[nbx-1]==false
 
	  }//end if pOldSprout[nbx-1]!=0 


	//---- y-bond -------------------------------------------------------------------------

	  if (pOldSprout[nby-1]!=0) 
	  {
		if (poleSprout[nby-1]==true)
		{	
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
				//outfileGrowVasc << "y-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
				//outfileGrowVasc << "y-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;}
				//outfileGrowVasc << "y-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
				//outfileGrowVasc << "y-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=0;}//moveUp;}
				//outfileGrowVasc << "y-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
				//outfileGrowVasc << "y-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack;}
				//outfileGrowVasc << "y-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)
				{					
					pSprout[nby-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;
					
					if (pArterialVenousID[nby-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nby-1];
				}
				else
				{
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
					pSprout[nby-1]=0;
					pAgeOfSprout[nby-1]=0.0;
					//outfileGrowVasc << "kill-sprout-y" << endl;
					//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
					}
				}
			}
		}//end if poleSprout[nby-1]==true

		if (poleSprout[nby-1]==false)
		{
			moveRight=LabX(i+1,j-1,k);   
			moveLeft=LabX(i,j-1,k);
			moveDown=LabY(i,j,k);
			moveUp=LabY(i,j-1,k);
			moveFront=LabZ(i,j-1,k+1);
			moveBack=LabZ(i,j-1,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-2][k-1] && throwDice<R0sup[i-1][j-2][k-1]) {move=0;}
				//outfileGrowVasc << "y-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R1inf[i-1][j-2][k-1] && throwDice<R1sup[i-1][j-2][k-1]) {move=moveRight;}
				//outfileGrowVasc << "y-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[i-1][j-2][k-1] && throwDice<R2sup[i-1][j-2][k-1]) {move=moveLeft;}
				//outfileGrowVasc << "y-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[i-1][j-2][k-1] && throwDice<R3sup[i-1][j-2][k-1]) {move=0;}//moveDown;}
				//outfileGrowVasc << "y-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[i-1][j-2][k-1] && throwDice<R4sup[i-1][j-2][k-1]) {move=moveUp;}
				//outfileGrowVasc << "y-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[i-1][j-2][k-1] && throwDice<R5sup[i-1][j-2][k-1]) {move=moveFront;}
				//outfileGrowVasc << "y-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-2][k-1] && throwDice<R6sup[i-1][j-2][k-1]) {move=moveBack;}
				//outfileGrowVasc << "y-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	
				{						
					pSprout[nby-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;
					
					if (pArterialVenousID[nby-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nby-1];
				}
				else
				{
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
					pSprout[nby-1]=0;
					pAgeOfSprout[nby-1]=0.0;
					//outfileGrowVasc << "kill-sprout-y" << endl;
					//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
					}
				}
			}
		}//end if poleSprout[nby-1]==false

	  }//end if pOldSprout[nby-1]!=0


	//---- z-bond -------------------------------------------------------------------------

	  if (pOldSprout[nbz-1]!=0) 
	  {
		if (poleSprout[nbz-1]==true)
		{
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
				//outfileGrowVasc << "z-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
				//outfileGrowVasc << "z-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;}
				//outfileGrowVasc << "z-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
				//outfileGrowVasc << "z-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}  
				//outfileGrowVasc << "z-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
				//outfileGrowVasc << "z-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=0;}//moveBack;} 
				//outfileGrowVasc << "z-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	 
				{						
					pSprout[nbz-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;
					
					if (pArterialVenousID[nbz-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbz-1];
				}
				else
				{
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{	pSprout[nbz-1]=0;
						pAgeOfSprout[nbz-1]=0.0;
					//outfileGrowVasc << "kill-sprout-z" << endl;
					//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
					}
				}
			}
		}//end if poleSprout[nbz-1]==true

		if (poleSprout[nbz-1]==false)
		{
			moveRight=LabX(i+1,j,k-1);   
			moveLeft=LabX(i,j,k-1);
			moveDown=LabY(i,j+1,k-1);
			moveUp=LabY(i,j,k-1);
			moveFront=LabZ(i,j,k);
			moveBack=LabZ(i,j,k-1);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[i-1][j-1][k-2] && throwDice<R0sup[i-1][j-1][k-2]) {move=0;}
				//outfileGrowVasc << "z-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[i-1][j-1][k-2] && throwDice<R1sup[i-1][j-1][k-2]) {move=moveRight;}
				//outfileGrowVasc << "z-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R2inf[i-1][j-1][k-2] && throwDice<R2sup[i-1][j-1][k-2]) {move=moveLeft;}
				//outfileGrowVasc << "z-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R3inf[i-1][j-1][k-2] && throwDice<R3sup[i-1][j-1][k-2]) {move=moveDown;}
				//outfileGrowVasc << "z-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R4inf[i-1][j-1][k-2] && throwDice<R4sup[i-1][j-1][k-2]) {move=moveUp;}   
				//outfileGrowVasc << "z-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R5inf[i-1][j-1][k-2] && throwDice<R5sup[i-1][j-1][k-2]) {move=0;}//moveFront;}
				//outfileGrowVasc << "z-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[i-1][j-1][k-2] && throwDice<R6sup[i-1][j-1][k-2]) {move=moveBack;}
				//outfileGrowVasc << "z-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	 
				{						
					pSprout[nbz-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;
					
					if (pArterialVenousID[nbz-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbz-1];
				}
				else
				{
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
						pSprout[nbz-1]=0;
						pAgeOfSprout[nbz-1]=0.0;
					//outfileGrowVasc << "kill-sprout-z" << endl;
					//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
					}
				}
			}
		}//end if poleSprout[nbz-1]==false

	  }//end if pOldSprout[nbz-1]!=0

}//end i loop

	int i=m_nx+1;

	nbx=LabX(i,j,k);


	//---- dangling x-bond ----------------------------------------------------------------

	  if (pOldSprout[nbx-1]!=0) 
	  {
		if (poleSprout[nbx-1]==true)
		{
			moveRight=LabX(i+1,j,k);   
			moveLeft=LabX(i,j,k);
			moveDown=LabY(i,j+1,k);
			moveUp=LabY(i,j,k);
			moveFront=LabZ(i,j,k+1);
			moveBack=LabZ(i,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1

			if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
			if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
			if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;}
			if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
			if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}
			if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
			if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack; }

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	
				{						
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;
					
					if (pArterialVenousID[nbx-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
						pSprout[nbx-1]=0;
						pAgeOfSprout[nbx-1]=0.0;
					}
				}
			}
		}//end if poleSprout[nbx-1]==true

		if (poleSprout[nbx-1]==false && k>1)
		{
			moveRight=LabX(i,j,k);   
			moveLeft=LabX(i-1,j,k);
			moveDown=LabY(i-1,j+1,k);
			moveUp=LabY(i-1,j,k);
			moveFront=LabZ(i-1,j,k+1);
			moveBack=LabZ(i-1,j,k);

			throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1

			if (throwDice>=R0inf[i-2][j-1][k-1] && throwDice<R0sup[i-2][j-1][k-1]) {move=0;}
			if (throwDice>=R1inf[i-2][j-1][k-1] && throwDice<R1sup[i-2][j-1][k-1]) {move=moveRight;}
			if (throwDice>=R2inf[i-2][j-1][k-1] && throwDice<R2sup[i-2][j-1][k-1]) {move=moveLeft;}
			if (throwDice>=R3inf[i-2][j-1][k-1] && throwDice<R3sup[i-2][j-1][k-1]) {move=moveDown;}
			if (throwDice>=R4inf[i-2][j-1][k-1] && throwDice<R4sup[i-2][j-1][k-1]) {move=moveUp;}
			if (throwDice>=R5inf[i-2][j-1][k-1] && throwDice<R5sup[i-2][j-1][k-1]) {move=moveFront;}
			if (throwDice>=R6inf[i-2][j-1][k-1] && throwDice<R6sup[i-2][j-1][k-1]) {move=moveBack; }

			if (move!=0) 
			{
				if (pFluid[move-1]!=10)	
				{						
					pSprout[nbx-1]=0;	
					pSprout[move-1]=1;
					pFluid[move-1]=10;
					pPericyteDensity[move-1]=PericyteDensityInit;
					
					if (pArterialVenousID[nbx-1]>0)
					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
					else 
					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

					if (move==moveLeft || move==moveUp || move==moveBack) 
							{poleSprout[move-1]=false;}
					else	{poleSprout[move-1]=true;}
					pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
				}
				else
				{	
					if (throwDice<AnastThreshold) //use throwdice so that I'm not disturbing the random no. sequence
					{
					pSprout[nbx-1]=0;
					pAgeOfSprout[nbx-1]=0.0;
					}
				}
			}
		}//end if poleSprout[nbx-1]==true

	  }//end if pOldSprout[nbx-1]!=0


}}//end j and k loops


	// The sprouts which have just reached the boundaries are killed
	//---------------------------------------------------------------

	for (int k=1;k<=m_nz;k++) {            
		for (int j=1;j<=m_ny;j++) {
			for (int i=1;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]!=0 && i==1) {
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pAgeOfSprout[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
			}
			if (pSprout[nbx-1]!=0 && i==m_nx) { 
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pAgeOfSprout[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
			}
			if ((pSprout[nby-1]!=0 && poleSprout[nby-1]==false && j==2) || j==1) {
				pSprout[nby-1]=0;
				pFluid[nby-1]=0;
				pPericyteDensity[nby-1]=0.0;
				pAgeOfSprout[nby-1]=0.0;
				pArterialVenousID[nby-1]=0;
			}
			if (pSprout[nby-1]!=0 && j==m_ny) {
				pSprout[nby-1]=0;
				pFluid[nby-1]=0; //comment out to make sure tracer reaches tumour
				pPericyteDensity[nby-1]=0.0;
				pAgeOfSprout[nby-1]=0.0;
				pArterialVenousID[nby-1]=0;
			}
			if (pSprout[nbz-1]!=0 && k==1) {
				pSprout[nbz-1]=0;
				pFluid[nbz-1]=0;
				pPericyteDensity[nbz-1]=0.0;
				pAgeOfSprout[nbz-1]=0.0;
				pArterialVenousID[nbz-1]=0;
			}
			if (pSprout[nbz-1]!=0 && k==m_nz) {
				pSprout[nbz-1]=0;
				pFluid[nbz-1]=0;
				pPericyteDensity[nbz-1]=0.0;
				pAgeOfSprout[nbz-1]=0.0;
				pArterialVenousID[nbz-1]=0;
			}
			}//end i-loop
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pSprout[nbx-1]!=0) {
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pAgeOfSprout[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
			}
	}}

	delete [] pOldSprout;

	//outfileGrowVasc << endl;
}

//***********************************************
//================================
void CAngioNetDlg::Anastomosis()
//================================
{
	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++) {            
		for (int j=1;j<=m_ny;j++) {
			for (int i=1;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);

			

			//-------------xbonds-----------------------------
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true)
			{
				if (pSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==false)
				{ 
					pSprout[LabX(i+1,j,k)-1]=0;
					pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
				}	//Don't kill if 2 x sprouts converge (stops vessels dying out)
				if (pSprout[LabY(i,j,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==true) 
				{ 
					pSprout[LabY(i,j,k)-1]=0;
					pAgeOfSprout[LabY(i,j,k)-1]=0.0;
				}
				if (pSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==false) 
				{ 
					pSprout[LabY(i,j+1,k)-1]=0;
					pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j,k)-1]==1 && poleSprout[LabZ(i,j,k)-1]==true) 
				{ 
					pSprout[LabZ(i,j,k)-1]=0;
					pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j,k+1)-1]==1 && poleSprout[LabZ(i,j,k+1)-1]==false)
				{ 
					pSprout[LabZ(i,j,k+1)-1]=0;
					pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
				}
			}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false)
			{
				if (pSprout[LabX(i-1,j,k)-1]==1 && poleSprout[LabX(i-1,j,k)-1]==true)
				{	
					pSprout[LabX(i-1,j,k)-1]=0;
					pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;
				}
				if (pSprout[LabY(i-1,j,k)-1]==1 && poleSprout[LabY(i-1,j,k)-1]==true)
				{	
					pSprout[LabY(i-1,j,k)-1]=0;
					pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
				}
				if (pSprout[LabY(i-1,j+1,k)-1]==1 && poleSprout[LabY(i-1,j+1,k)-1]==false)
				{	
					pSprout[LabY(i-1,j+1,k)-1]=0;
					pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
				}
				if (pSprout[LabZ(i-1,j,k)-1]==1 && poleSprout[LabZ(i-1,j,k)-1]==true)
				{	
					pSprout[LabZ(i-1,j,k)-1]=0;
					pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
				}
				if (pSprout[LabZ(i-1,j,k+1)-1]==1 && poleSprout[LabZ(i-1,j,k+1)-1]==false)
				{	
					pSprout[LabZ(i-1,j,k+1)-1]=0;
					pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
				}
			}

			//-------------ybonds-----------------------------
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true)
			{
				if (pSprout[LabX(i,j,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==true)
				{ 
					pSprout[LabX(i,j,k)-1]=0;
					pAgeOfSprout[LabX(i,j,k)-1]=0.0;
				}
				if (pSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==false)
				{ 
					pSprout[LabX(i+1,j,k)-1]=0;
					pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
				}
				if (pSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==false)
				{ 
					pSprout[LabY(i,j+1,k)-1]=0;
					pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j,k)-1]==1 && poleSprout[LabZ(i,j,k)-1]==true)
				{ 
					pSprout[LabZ(i,j,k)-1]=0;
					pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j,k+1)-1]==1 && poleSprout[LabZ(i,j,k+1)-1]==false)
				{ 
					pSprout[LabZ(i,j,k+1)-1]=0;
					pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
				}
			}
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false)
			{
				if (pSprout[LabX(i,j-1,k)-1]==1 && poleSprout[LabX(i,j-1,k)-1]==true)
					{	
					pSprout[LabX(i,j-1,k)-1]=0;
					pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
				}
				if (pSprout[LabX(i+1,j-1,k)-1]==1 && poleSprout[LabX(i+1,j-1,k)-1]==false)
				{	
					pSprout[LabX(i+1,j-1,k)-1]=0;
					pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
				}
				if (pSprout[LabY(i,j-1,k)-1]==1 && poleSprout[LabY(i,j-1,k)-1]==true)
				{	
					pSprout[LabY(i,j-1,k)-1]=0;
					pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j-1,k)-1]==1 && poleSprout[LabZ(i,j-1,k)-1]==true)
				{	
					pSprout[LabZ(i,j-1,k)-1]=0;
					pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j-1,k+1)-1]==1 && poleSprout[LabZ(i,j-1,k+1)-1]==false)
				{	
					pSprout[LabZ(i,j-1,k+1)-1]=0;
					pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
				}
			}

			//-------------zbonds-----------------------------
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true)
			{
				if (pSprout[LabX(i,j,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==true)
				{ 
					pSprout[LabX(i,j,k)-1]=0;
					pAgeOfSprout[LabX(i,j,k)-1]=0.0;
				}
				if (pSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==false)
				{ 
					pSprout[LabX(i+1,j,k)-1]=0;
					pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
				}
				if (pSprout[LabY(i,j,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==true)
				{ 
					pSprout[LabY(i,j,k)-1]=0;
					pAgeOfSprout[LabY(i,j,k)-1]=0.0;
				}
				if (pSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==false)
				{ 
					pSprout[LabY(i,j+1,k)-1]=0;
					pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
				}
				if (pSprout[LabZ(i,j,k+1)-1]==1 && poleSprout[LabZ(i,j,k+1)-1]==false)
				{ 
					pSprout[LabZ(i,j,k+1)-1]=0;
					pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
				}
			}
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false)
			{
				if (pSprout[LabX(i,j,k-1)-1]==1 && poleSprout[LabX(i,j,k-1)-1]==true)
				{ 
					pSprout[LabX(i,j,k-1)-1]=0;
					pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
				}
				if (pSprout[LabX(i+1,j,k-1)-1]==1 && poleSprout[LabX(i+1,j,k-1)-1]==false)
				{ 
					pSprout[LabX(i+1,j,k-1)-1]=0;
					pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
				}
				if (pSprout[LabY(i,j,k-1)-1]==1 && poleSprout[LabY(i,j,k-1)-1]==true)
				{ 
					pSprout[LabY(i,j,k-1)-1]=0;
					pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
				}
				if (pSprout[LabY(i,j+1,k-1)-1]==1 && poleSprout[LabY(i,j+1,k-1)-1]==false)
				{ 
					pSprout[LabY(i,j+1,k-1)-1]=0;
					pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
				}
				if (pSprout[LabZ(i,j,k-1)-1]==1 && poleSprout[LabZ(i,j,k-1)-1]==true)
				{	
					pSprout[LabZ(i,j,k-1)-1]=0;
					pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;
				}
			}
	}}}
}


//*****************************************************

//=============================
void CAngioNetDlg::AgeSprouts()
//=============================
{
	for(int nn=1;nn<=Nbond;nn++)
	{
		if(pSprout[nn-1]!=0) {pAgeOfSprout[nn-1]+=angioDeltaT;}
	}
}


//******************************************************

//=============================
void CAngioNetDlg::AgeVessels()
//=============================
{
	runningAgeMax=0.0;

	for (int nn=1;nn<=Nbond;nn++)
	{if (pFluid[nn-1]==10) {pAgeOfVessel[nn-1]=pAgeOfVessel[nn-1]+angioDeltaT;}}

	for (int nn=1;nn<Nbond;nn++)
	{if (pAgeOfVessel[nn-1]>runningAgeMax) {runningAgeMax=pAgeOfVessel[nn-1];}}
}


//******************************************************

//=================================
void CAngioNetDlg::BranchSprouts2()
//=================================
{
	
	thresholdAge=0.5;
	double thd=0.25;

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond];

	//-----Define dummies for sprouts---
	for(int nn=1;nn<=Nbond;nn++) {pOldSprout[nn-1]=pSprout[nn-1];}


	//--Probability of branching depends upon TAF conc.---
	//--Do this by dividing the domain into strips-------

	double probBranch,randDice;
	int i,j,k,nbx,nby,nbz,randBranchDirection;

//---------------------------------
//   Strip 1
//---------------------------------
	probBranch=0.0;

	for(k=1;k<=m_nz;k++)
	{	for(j=1;j<int(m_ny/4.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//--------xBonds----------------------------
				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge 
										&& vEndoCellDensity[i-1][j-1][k-1]>0.25*runningEndoCellMAX) {}//Do Nothing
				
				//--------yBonds----------------------------
				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge 
										&& vEndoCellDensity[i-1][j-1][k-1]>0.25*runningEndoCellMAX) {}//Do Nothing	

				//--------zBonds----------------------------
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge 
										&& vEndoCellDensity[i-1][j-1][k-1]>0.25*runningEndoCellMAX) {}//Do Nothing
						
	}}}

//---------------------------------
//   Strip 2
//---------------------------------
	probBranch=0.2;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(m_ny/4.0);j<int(45.0*m_ny/100.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
				{randBranchDirection=1;} //1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.25*runningEndoCellMAX)
					{	
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{	
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{ 
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{	
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false 
											&& vEndoCellDensity[i-2][j-1][k-1]>0.25*runningEndoCellMAX)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{	pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.25*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{	pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false 
											&& vEndoCellDensity[i-1][j-2][k-1]>0.25*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.25*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false 
											&& vEndoCellDensity[i-1][j-1][k-2]>0.25*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if(m_nz!=1)
		
	}}}
	
//---------------------------------
//   Strip 3
//---------------------------------
	probBranch=0.3;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(45.0*m_ny/100.0);j<int(60.0*m_ny/100.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.15*runningEndoCellMAX)
					{
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false 
											&& vEndoCellDensity[i-2][j-1][k-1]>0.15*runningEndoCellMAX)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{
										pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{	
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.15*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false 
											&& vEndoCellDensity[i-1][j-2][k-1]>0.15*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.15*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false 
											&& vEndoCellDensity[i-1][j-1][k-2]>0.15*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}	
				}//end if (m_nz!=1)
				
	}}}
		
//---------------------------------
//   Strip 4
//---------------------------------
	probBranch=0.4;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(60.0*m_ny/100.0);j<int(68.0*m_ny/100.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false 
											&& vEndoCellDensity[i-2][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{
										pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false 
											&& vEndoCellDensity[i-1][j-2][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
									    pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false 
											&& vEndoCellDensity[i-1][j-1][k-2]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if (m_nz!=1)
	}}}

//---------------------------------
//   Strip 5
//---------------------------------
	probBranch=1.0;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(68.0*m_ny/100.0);j<=m_ny-1;j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>0.35) //thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false 
											&& vEndoCellDensity[i-2][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{
										pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>0.35) //thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false 
											&& vEndoCellDensity[i-1][j-2][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{	
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>0.35) //thresholdAge)
										//&& vEndoCellDensity[i-1][j-1][k-1]>thd*runningEndoCellMAX)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true 
											&& vEndoCellDensity[i-1][j-1][k-1]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{	
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false 
										    && vEndoCellDensity[i-1][j-1][k-2]>0.0*runningEndoCellMAX)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if (m_nz!=1)
	}}}


	//-------------------
	delete [] pOldSprout;
	//-------------------
			
}


//******************************************************

//===================================
void CAngioNetDlg::BranchSproutsMDF()
//===================================
{
	
	thresholdAge=0.5;
	double thd=0.25;

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond];

	//-----Define dummies for sprouts---
	for(int nn=1;nn<=Nbond;nn++) {pOldSprout[nn-1]=pSprout[nn-1];}


	//--Probability of branching depends upon TAF conc.---
	//--Do this by dividing the domain into strips-------

	double probBranch,randDice;
	int i,j,k,nbx,nby,nbz,randBranchDirection;

//---------------------------------
//   Strip 1
//---------------------------------
	probBranch=0.0;

	for(k=1;k<=m_nz;k++)
	{	for(j=1;j<int(m_ny/4.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//--------xBonds----------------------------
				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge) {}//Do Nothing
				
				//--------yBonds----------------------------
				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge) {}//Do Nothing	

				//--------zBonds----------------------------
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge) {}//Do Nothing
						
	}}}

//---------------------------------
//   Strip 2
//---------------------------------
	probBranch=0.2;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(m_ny/4.0);j<int(45.0*m_ny/100.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
				{randBranchDirection=1;} //1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true)
					{	
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{	
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{ 
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{	
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{	pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{	pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if(m_nz!=1)
		
	}}}
	
//---------------------------------
//   Strip 3
//---------------------------------
	probBranch=0.3;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(45.0*m_ny/100.0);j<int(60.0*m_ny/100.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true)
					{
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{
										pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{	
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}	
				}//end if (m_nz!=1)
				
	}}}
		
//---------------------------------
//   Strip 4
//---------------------------------
	probBranch=0.4;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(60.0*m_ny/100.0);j<int(68.0*m_ny/100.0);j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true)
					{
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{
										pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
									    pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if (m_nz!=1)
	}}}

//---------------------------------
//   Strip 5
//---------------------------------
	probBranch=1.0;

	for(k=1;k<=m_nz;k++)
	{	for(j=int(68.0*m_ny/100.0);j<=m_ny-1;j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>0.35) //thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbx-1]==true)
					{
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{
										pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>0.35) //thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{	
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>0.35) //thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<=probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{	
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<=probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if (m_nz!=1)
	}}}


	//--------------------
	delete [] pOldSprout;
	//--------------------
			
}


//******************************************************

//===================================
void CAngioNetDlg::BranchSproutsTAF()
//===================================
{
	thresholdAge=0.5;
	double thd=0.25;

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond];

	//-----Define dummies for sprouts---
	for(int nn=1;nn<=Nbond;nn++) {pOldSprout[nn-1]=pSprout[nn-1];}


	//--Probability of branching depends upon TAF conc.---
	//--Do this by dividing the domain into strips-------

	double probBranch,randDice;
	int i,j,k,nbx,nby,nbz,randBranchDirection;

	//outfiletest << angiotime << endl;

	for(k=1;k<=m_nz;k++)
	{	for(j=1;j<=m_ny;j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				probBranch=0.0;

				//------------- FOR GROWTH WITH TAF ONLY ---------------------------------
				if (vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)      {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
					vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)      {probBranch=0.2;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
					vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)      {probBranch=0.3;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
					vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)      {probBranch=0.4;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX) {probBranch=1.0;}

				//------------- FOR GROWTH WITH WSS --------------------------------------
/*				if (vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)      {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
					vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)      {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
					vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)      {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
					vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)      {probBranch=0.1;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX) {probBranch=0.1;}

*/	
				//-----------xBonds--------------------------------------------------
				if (m_nz==1) 
				{randBranchDirection=1;} //1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
				{
					//outfiletest << "Xbond0" << "\t" << nbx 
					//			<< "\t" << i << "\t" << j << "\t" << k << endl;

					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<probBranch && poleSprout[nbx-1]==true)
					{	
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{	
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;

							//outfiletest << angiotime << "\t" << "Xbond" << "\t" << LabX(i+1,j,k) 
							//			<< "\t" << i+1 << "\t" << j << "\t" << k << endl;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{ 
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

										//outfiletest << angiotime << "\t" << "Ybond" << "\t" << LabY(i,j+1,k) 
										//			<< "\t" << i << "\t" << j+1 << "\t" << k << endl;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
										
										//outfiletest << angiotime << "\t" << "Ybond" << "\t" << LabY(i,j,k) 
										//			<< "\t" << i << "\t" << j << "\t" << k << endl;

									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{	
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;

							//outfiletest << angiotime << "\t" << "Xbond" << "\t" << LabX(i-1,j,k) 
							//			<< "\t" << i-1 << "\t" << j << "\t" << k << endl;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{	pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;

										//outfiletest << angiotime << "\t" << "Ybond" << "\t" << LabY(i-1,j+1,k) 
										//			<< "\t" << i-1 << "\t" << j+1 << "\t" << k << endl;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;

										//outfiletest << angiotime << "\t" << "Ybond" << "\t" << LabY(i-1,j,k) 
										//			<< "\t" << i-1 << "\t" << j << "\t" << k << endl;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
				{

					//outfiletest << "Ybond0" << "\t" << nby 
					//			<< "\t" << i << "\t" << j << "\t" << k << endl;

					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;

							//outfiletest << angiotime << "\t" << "Ybond" << "\t" << LabY(i,j+1,k) 
							//			<< "\t" << i << "\t" << j+1 << "\t" << k << endl;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

										//outfiletest << angiotime << "\t" << "Xbond" << "\t" << LabX(i+1,j,k) 
										//			<< "\t" << i+1 << "\t" << j << "\t" << k << endl;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{	pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;

										//outfiletest << angiotime << "\t" << "Xbond" << "\t" << LabX(i,j,k) 
										//			<< "\t" << i << "\t" << j << "\t" << k << endl;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;

							//outfiletest << angiotime << "\t" << "Ybond" << "\t" << LabY(i,j-1,k) 
							//			<< "\t" << i << "\t" << j-1 << "\t" << k << endl;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;

										//outfiletest << angiotime << "\t" << "Xbond" << "\t" << LabX(i+1,j-1,k) 
										//			<< "\t" << i+1 << "\t" << j-1 << "\t" << k << endl;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;

										//outfiletest << angiotime << "\t"<< "Xbond" << "\t" << LabX(i,j-1,k) 
										//			<< "\t" << i << "\t" << j-1 << "\t" << k << endl;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if(m_nz!=1)
	}}}

	//----------------
	delete [] pOldSprout;
	//----------------
}


//******************************************************

//======================================
void CAngioNetDlg::BranchSproutsTAFWSS()
//======================================
{	
	//thresholdAge=0.5;
	runningWSSMAX=10000.0;//(changed by Mike 10/08 - branching OFF for wound model)	
	//2.0;original value//STOP Vessel branching  2.0;	//2.0;    //1.0;used for Feb2005 runs  //0.2; //(Pa)


	//////SMcD2005//////////
	double thresholdAgeInf=2.66;	//3.3 is for a definite loop fog 
								//when rho2=0.28
								//2.66; //(4 days)    0.4*runningAgeMax;
	double thresholdAgeSup=5.33; //(8 days)    0.45*runningAgeMax;
	double thresholdAge=0.5;//0.1;//0.2;//0.2;	//0.25;//0.5; (changed by Mike 10/08 for wound model)	//0.05;//0.125;  //0.5;0.5 used in ALL pre-UUC Retinopathy work
	double thd=0.25;
//	double score;


//=================
	double carryingCapacity=0.0;
	double branchFraction=1.001;//0.5;	//1.001; for no pericyte effect on branching
//=============================

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond];

	//-----Define dummies for sprouts---
	for(int nn=1;nn<=Nbond;nn++) {pOldSprout[nn-1]=pSprout[nn-1];}


	//--Probability of branching depends upon TAF conc.---
	//--Do this by dividing the domain into strips-------

	double probBranch,randDice;
	int i,j,k,nbx,nby,nbz,randBranchDirection;

	bool bWSS=true;//;//true;//true;//false;	//Wall shear Stress included or not?

//--------------------------------------------------

	for(k=1;k<=m_nz;k++)
	{	for(j=1;j<=m_ny;j++)
		{	for(i=3;i<=m_nx-1;i++)
			{	
					nbx=LabX(i,j,k);
					nby=LabY(i,j,k);
					nbz=LabZ(i,j,k);

//-----------xBonds--------------------------------------------------

///X-Sprout branching first

	probBranch=0.0;

	if	(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
	{
		if	(b_UU_wound_Model==false)
		{
			if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0.1;//0;
			}																				//Used for all tumour
			else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&						//angiogenesis work
					 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.4;//0.1;
					 }	//
			else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&						//Branch probs correlated
					 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.6;//0.3;
					 }																			//to TAF conc
			else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.8;//0.4;
					 }
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=1;}
		}

		if	(b_UU_wound_Model==true)
		{
/*			if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}		//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&						//by Mike 11/08
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.01;}	//for 01/09 results
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.02;}	//Branch probs correlated
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&						//to TAF conc
					 vTAFConc[i-1][j-1][k-1]<=0.9*runningTAFConcMAX)   {probBranch=0.05;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.9*runningTAFConcMAX)   {probBranch=0.25;}
*/

			if		(vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX)   {probBranch=0.002;}	//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&						//by Mike 05/09
					 vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX)   {probBranch=0.004;}	//for 05/09 results
			else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.005;}	//Branch probs correlated
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//to TAF grad
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.01;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.92*runningTAFConcMAX)   {probBranch=0.005;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.92*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)   {probBranch=0.004;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)   {probBranch=0.002;}


/*			if		(vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX)   {probBranch=0.002;}	//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&						//by Mike 08/09
					 vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX)   {probBranch=0.004;}	//for 09/09 (TNP-470) results
			else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.005;}	//As above but branch 
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//probs reduced by 25%
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.0075;}	//within wound
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.92*runningTAFConcMAX)   {probBranch=0.00375;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.92*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)   {probBranch=0.003;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)   {probBranch=0.0015;}
*/
		}

	}			

	
	if (bWSS && pOldSprout[nbx-1]==0)	//WSS and not a sprout
{		
	if		(XTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)      
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.0;}		
	}	

	if		(XTauW[i-1][j-1][k-1]> 0.2*runningWSSMAX &&
						XTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.02;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.03;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.04;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.1;}		
	}	
				
	else if (XTauW[i-1][j-1][k-1]> 0.4*runningWSSMAX &&
						 XTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX) 
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.04;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.06;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.08;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.2;}			
   }

	else if (XTauW[i-1][j-1][k-1]> 0.6*runningWSSMAX &&
						 XTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.06;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.09;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.12;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.3;}			
	}

	else if (XTauW[i-1][j-1][k-1]> 0.8*runningWSSMAX)
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.08;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.12;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.16;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.4;}			
	}

}	//end if WSS


				//============Arteries don't branch============
				if (j==1 || j== m_ny-1)// && b_venousIncluded)) 
				{probBranch=0.0;}

				//==============================================

				if (m_nz==1) 
						//{randBranchDirection=1;} //Version used before venule added SMcD Jan 2008
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

		//============
		carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
		//============

//			randDice=float(rand())/float(RAND_MAX); //(0,1)  //Need to throw here 
															//so as to repeat random 
															//no generation sequence 
															//regardless of branching condition
		
			if(  (pFluid[nbx-1]==10 &&  pAgeOfVessel[nbx-1]<=thresholdAgeSup
				 && pAgeOfVessel[nbx-1]>=thresholdAgeInf)
				 //&& pPericyteDensity[nbx-1] <= branchFraction*carryingCapacity)
				|| (pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge) )
			{	//%%%%
					randDice=float(rand())/float(RAND_MAX); //(0,1)

//					if(bWSS || (pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)  )	// lets me throw a dice but only do TAF branching
//					{

					if(randDice<probBranch && poleSprout[nbx-1]==true)
					{	//NB the polesprout variable isn't really defined for 
						//non-sprout vessel segments.  For non-sprouts,
						//the polesprout=true section (below) will be done
						//anyway and this may give a directional bias for branching
						//(all vessels initialised to true in InitialiseVariables())

						if (pFluid[LabX(i+1,j,k)-1]!=10 && pFluid[LabX(i+1,j,k)-1]!=66)	//2nd condition added by Mike 09/09	
						{																//for hexagonal vasculature
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
							if (pArterialVenousID[nbx-1]>0)
							{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from an arterial vessel
							else 
							{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from a venous vessel

							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10 && pFluid[LabY(i,j+1,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10 && pFluid[LabY(i,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{															//for hexagonal vasculature
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10 && pFluid[LabZ(i,j,k+1)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10 && pFluid[LabZ(i,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{															//for hexagonal vasculature
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10 && pFluid[LabX(i-1,j,k)-1]!=66)	//2nd condition added by Mike 09/09
						{																//for hexagonal vasculature
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							pPericyteDensity[LabX(i-1,j,k)-1]=PericyteDensityInit;
							

							if (pArterialVenousID[nbx-1]>0)
							{pArterialVenousID[LabX(i-1,j,k)-1]=1;} //grown from an arterial vessel
							else 
							{pArterialVenousID[LabX(i-1,j,k)-1]=-1;}//grown from a venous vessel
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10 && pFluid[LabY(i-1,j+1,k)-1]!=66)	//2nd condition added by Mike 09/09
									{	pFluid[LabY(i-1,j+1,k)-1]=10;									//for hexagonal vasculature
										pSprout[LabY(i-1,j+1,k)-1]=1;
										pPericyteDensity[LabY(i-1,j+1,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabY(i-1,j+1,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i-1,j+1,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10 && pFluid[LabY(i-1,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										pPericyteDensity[LabY(i-1,j,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabY(i-1,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i-1,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10 && pFluid[LabZ(i-1,j,k+1)-1]!=66)	//2nd condition added by Mike 09/09
									{																	//for hexagonal vasculature
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										pPericyteDensity[LabZ(i-1,j,k+1)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabZ(i-1,j,k+1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i-1,j,k+1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10 && pFluid[LabZ(i-1,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										pPericyteDensity[LabZ(i-1,j,k)-1]=PericyteDensityInit;
										
										if (pArterialVenousID[nbx-1]>0)
										{pArterialVenousID[LabZ(i-1,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i-1,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}
			//	}	//end if  pOldSprout
			}	//end %%%%
						
//-----------yBonds--------------------------------------------------
	if(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
	{
		if	(b_UU_wound_Model==false)
		{
			if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0.1;//0;
			}		//Used for all tumour
			else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&						//angiogenesis work
					 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.4;//0.1;
					 }	//
			else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&						//Branch probs correlated
					 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.6;//0.3;
					 }	//to TAF conc
			else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.8;//0.4;
					 }
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=1;}
		}

		if	(b_UU_wound_Model==true)
		{
/*			if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}		//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&						//by Mike 11/08
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.01;}	//for 01/09 results
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.02;}	//Branch probs correlated
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&						//to TAF conc
					 vTAFConc[i-1][j-1][k-1]<=0.9*runningTAFConcMAX)   {probBranch=0.05;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.9*runningTAFConcMAX)   {probBranch=0.25;}
*/

			if		(vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX)   {probBranch=0.002;}	//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&						//by Mike 05/09
					 vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX)   {probBranch=0.004;}	//for 05/09 results
			else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.005;}	//Branch probs correlated
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//to TAF grad
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.01;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.92*runningTAFConcMAX)   {probBranch=0.005;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.92*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)   {probBranch=0.004;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)   {probBranch=0.002;}


/*			if		(vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX)   {probBranch=0.002;}	//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&						//by Mike 08/09
					 vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX)   {probBranch=0.004;}	//for 09/09 (TNP-470) results
			else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.005;}	//As above but branch
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//probs reduced by 25%
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.0075;}	//within wound
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.92*runningTAFConcMAX)   {probBranch=0.00375;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.92*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)   {probBranch=0.003;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)   {probBranch=0.0015;}
*/
		}

	}
	
if (bWSS && pOldSprout[nby-1]==0)	//need to change branching probs
{				
	if		(YTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)      
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.0;}		
	}	

	if		(YTauW[i-1][j-1][k-1]> 0.2*runningWSSMAX &&
						YTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.02;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.03;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.04;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.1;}		
	}	
				
	else if (YTauW[i-1][j-1][k-1]> 0.4*runningWSSMAX &&
						 YTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX) 
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.04;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.06;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.08;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.2;}			
   }

	else if (YTauW[i-1][j-1][k-1]> 0.6*runningWSSMAX &&
						 YTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.06;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.09;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.12;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.3;}			
	}

	else if (YTauW[i-1][j-1][k-1]> 0.8*runningWSSMAX)
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.08;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.12;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.16;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.4;}			
	}

}	//end if WSS	

			if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
			else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 


		//============
		carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);
		//============
//			randDice=float(rand())/float(RAND_MAX); //(0,1)
				   
			if(  (pFluid[nby-1]==10 && pAgeOfVessel[nby-1]<=thresholdAgeSup
				&& pAgeOfVessel[nby-1]>=thresholdAgeInf)
				//&&  pPericyteDensity[nby-1] <= branchFraction*carryingCapacity)

				|| (pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge) )
			{
					randDice=float(rand())/float(RAND_MAX); //(0,1)

//					if(bWSS || (pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)  )	// lets me trow a dice but only do TAF branching
//					{

					if(randDice<probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10 && pFluid[LabY(i,j+1,k)-1]!=66)	//2nd condition added by Mike 09/09
						{																//for hexagonal vasculature
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
							

							if (pArterialVenousID[nby-1]>0)
							{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from an arterial vessel
							else 
							{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from a venous vessel
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10 && pFluid[LabX(i+1,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10 && pFluid[LabX(i,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{	pFluid[LabX(i,j,k)-1]=10;								//for hexagonal vasculature
										pSprout[LabX(i,j,k)-1]=1;
										pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10 && pFluid[LabZ(i,j,k+1)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10 && pFluid[LabZ(i,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{															//for hexagonal vasculature
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10 && pFluid[LabY(i,j-1,k)-1]!=66)	//2nd condition added by Mike 09/09
						{																//for hexagonal vasculature
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							pPericyteDensity[LabY(i,j-1,k)-1]=PericyteDensityInit;
							

							if (pArterialVenousID[nby-1]>0)
							{pArterialVenousID[LabY(i,j-1,k)-1]=1;} //grown from an arterial vessel
							else 
							{pArterialVenousID[LabY(i,j-1,k)-1]=-1;}//grown from a venous vessel
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10 && pFluid[LabX(i+1,j-1,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																	//for hexagonal vasculature
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										pPericyteDensity[LabX(i+1,j-1,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabX(i+1,j-1,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i+1,j-1,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10 && pFluid[LabX(i,j-1,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										pPericyteDensity[LabX(i,j-1,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabX(i,j-1,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i,j-1,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10 && pFluid[LabZ(i,j-1,k+1)-1]!=66)	//2nd condition added by Mike 09/09
									{																	//for hexagonal vasculature
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										pPericyteDensity[LabZ(i,j-1,k+1)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabZ(i,j-1,k+1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i,j-1,k+1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10 && pFluid[LabZ(i,j-1,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal vasculature
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										pPericyteDensity[LabZ(i,j-1,k)-1]=PericyteDensityInit;
										

										if (pArterialVenousID[nby-1]>0)
										{pArterialVenousID[LabZ(i,j-1,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabZ(i,j-1,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}

					//}//end  if  pOldSprout


				

				}




//-----------zBonds--------------------------------------------------
	if(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
	{
		if	(b_UU_wound_Model==false)
		{
			if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}		//Used for all tumour
			else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&						//angiogenesis work
					 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.1;}	//
			else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&						//Branch probs correlated
					 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.3;}	//to TAF conc
			else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.4;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=1;}
		}

		if	(b_UU_wound_Model==true)
		{
/*			if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}		// Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&						// by Mike 11/08
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.01;}	// for 01/09 results
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.02;}	//Branch probs correlated
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&						//to TAF conc
					 vTAFConc[i-1][j-1][k-1]<=0.9*runningTAFConcMAX)   {probBranch=0.05;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.9*runningTAFConcMAX)   {probBranch=0.25;}

*/
			if		(vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX)   {probBranch=0.002;}	// Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&						// by Mike 05/09
					 vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX)   {probBranch=0.004;}	// for 05/09 results
			else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.005;}	//Branch probs correlated
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//to TAF grad
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.01;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.92*runningTAFConcMAX)   {probBranch=0.005;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.92*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)   {probBranch=0.004;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)   {probBranch=0.002;}


/*			if		(vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX)   {probBranch=0.002;}	//Changed from above 
			else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&						//by Mike 08/09
					 vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX)   {probBranch=0.004;}	//for 09/09 (TNP-470) results
			else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&						//
					 vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX)   {probBranch=0.005;}	//As above but branch
			else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&						//probs reduced by 25%
					 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.0075;}	//within wound
			else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.92*runningTAFConcMAX)   {probBranch=0.00375;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.92*runningTAFConcMAX &&
					 vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)   {probBranch=0.003;}
			else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)   {probBranch=0.0015;}
*/
		}

	}	


if (bWSS && pOldSprout[nbz-1]==0)	//WSS and not a sprout
{				
	if		(ZTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)      
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.0;}		
	}	

	if		(ZTauW[i-1][j-1][k-1]> 0.2*runningWSSMAX &&
						ZTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.02;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.03;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.04;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.1;}		
	}	
				
	else if (ZTauW[i-1][j-1][k-1]> 0.4*runningWSSMAX &&
						 ZTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX) 
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.04;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.06;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.08;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.2;}			
   }

	else if (ZTauW[i-1][j-1][k-1]> 0.6*runningWSSMAX &&
						 ZTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.06;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.09;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.12;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.3;}			
	}

	else if (ZTauW[i-1][j-1][k-1]> 0.8*runningWSSMAX)
	{
		if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {probBranch=0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {probBranch=0.08;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {probBranch=0.12;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {probBranch=0.16;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {probBranch=0.4;}			
	}

}	//end if WSS			

				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));

				

		//============
		carryingCapacity=2.0*ZBR[i-1][j-1][k-1]*angioDeltaZ/pow(RadiusPericyte,2);
		//============

//			randDice=float(rand())/float(RAND_MAX); //(0,1)	
			

			if(  (pFluid[nbz-1]==10 && pAgeOfVessel[nbz-1]<=thresholdAgeSup
			    && pAgeOfVessel[nbz-1]>=thresholdAgeInf)
				//&&  pPericyteDensity[nbz-1] <= branchFraction*carryingCapacity)

				|| (pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge) )
			{			
					randDice=float(rand())/float(RAND_MAX); //(0,1)

//					if(bWSS || (pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)  )	// lets me trow a dice but only do TAF branching
//					{

					if(randDice<probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10 && pFluid[LabZ(i,j,k+1)-1]!=66)	//2nd condition added by Mike 09/09
						{																//for hexagonal network
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
							if (pArterialVenousID[nbz-1]>0)
							{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from an arterial vessel
							else 
							{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from a venous vessel
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10 && pFluid[LabX(i+1,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal network
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10 && pFluid[LabX(i,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{															//for hexagonal network
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10 && pFluid[LabY(i,j+1,k)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal network
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10 && pFluid[LabY(i,j,k)-1]!=66)	//2nd condition added by Mike 09/09
									{															//for hexagonal network
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10 && pFluid[LabZ(i,j,k-1)-1]!=66)	//2nd condition added by Mike 09/09
						{																//for hexagonal network
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							pPericyteDensity[LabZ(i,j,k-1)-1]=PericyteDensityInit;
							if (pArterialVenousID[nbz-1]>0)
							{pArterialVenousID[LabZ(i,j,k-1)-1]=1;} //grown from an arterial vessel
							else 
							{pArterialVenousID[LabZ(i,j,k-1)-1]=-1;}//grown from a venous vessel
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;

						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10 && pFluid[LabX(i+1,j,k-1)-1]!=66)	//2nd condition added by Mike 09/09
									{																	//for hexagonal network
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										pPericyteDensity[LabX(i+1,j,k-1)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabX(i+1,j,k-1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i+1,j,k-1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10 && pFluid[LabX(i,j,k-1)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal network
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										pPericyteDensity[LabX(i,j,k-1)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabX(i,j,k-1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabX(i,j,k-1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10 && pFluid[LabY(i,j+1,k-1)-1]!=66)	//2nd condition added by Mike 09/09
									{																	//for hexagonal network
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										pPericyteDensity[LabY(i,j+1,k-1)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabY(i,j+1,k-1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i,j+1,k-1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10 && pFluid[LabY(i,j,k-1)-1]!=66)	//2nd condition added by Mike 09/09
									{																//for hexagonal network
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										pPericyteDensity[LabY(i,j,k-1)-1]=PericyteDensityInit;
										if (pArterialVenousID[nbz-1]>0)
										{pArterialVenousID[LabY(i,j,k-1)-1]=1;} //grown from an arterial vessel
										else 
										{pArterialVenousID[LabY(i,j,k-1)-1]=-1;}//grown from a venous vessel
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}


				//	}//end if pOldSprout
				}

				}//end if(m_nz!=1)

				
				}
				}
				}

//***************************************
		// The sprouts which have just reached the boundaries are killed
	//---------------------------------------------------------------
	//Not by me SMcD2005??

	for (k=1;k<=m_nz;k++) {            
		for (int j=1;j<=m_ny;j++) {
			for (  i=1;i<=m_nx;i++) {   
											
			nbx=LabX(i,j,k);
			nby=LabY(i,j,k);
			nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]!=0 && i==1) {
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
				pAgeOfSprout[nbx-1]=0.0;
			}
			if (pSprout[nbx-1]!=0 && i==m_nx) { 
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
				pAgeOfSprout[nbx-1]=0.0;
			}
			if ((pSprout[nby-1]!=0 && poleSprout[nby-1]==false && j==2) || j==1) {
				pSprout[nby-1]=0;
				pFluid[nby-1]=0;
				pPericyteDensity[nby-1]=0.0;
				pArterialVenousID[nby-1]=0;
				pAgeOfSprout[nby-1]=0.0;
			}
			if (pSprout[nby-1]!=0 && j==m_ny) {
				pSprout[nby-1]=0;
				pFluid[nby-1]=0; //comment out to make sure tracer reaches tumour
				pPericyteDensity[nby-1]=0.0;
				pArterialVenousID[nby-1]=0;
				pAgeOfSprout[nby-1]=0.0;
			}
			if (pSprout[nbz-1]!=0 && k==1) {
				pSprout[nbz-1]=0;
				pFluid[nbz-1]=0;
				pPericyteDensity[nbz-1]=0.0;
				pArterialVenousID[nbz-1]=0;
				pAgeOfSprout[nbz-1]=0.0;
			}
			if (pSprout[nbz-1]!=0 && k==m_nz) {
				pSprout[nbz-1]=0;
				pFluid[nbz-1]=0;
				pPericyteDensity[nbz-1]=0.0;
				pArterialVenousID[nbz-1]=0;
				pAgeOfSprout[nbz-1]=0.0;
			}
			}//end i-loop
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pSprout[nbx-1]!=0) {
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
				pAgeOfSprout[nbx-1]=0.0;
			}
	}}
 

//******************************************


/*
	//thresholdAge=0.5;
	runningWSSMAX=0.2; //(Pa)

	double thresholdAgeInf=2.66; //(4 days)    0.4*runningAgeMax;
	double thresholdAgeSup=5.33; //(8 days)    0.45*runningAgeMax;
	double thd=0.25;
	double score;

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond];

	//-----Define dummies for sprouts---
	for(int nn=1;nn<=Nbond;nn++) {pOldSprout[nn-1]=pSprout[nn-1];}


	//--Probability of branching depends upon TAF conc.---
	//--Do this by dividing the domain into strips-------

	double probBranch,randDice;
	int i,j,k,nbx,nby,nbz,randBranchDirection;


	for(k=1;k<=m_nz;k++)
	{	for(j=1;j<=m_ny;j++)
		{	for(i=3;i<=m_nx-1;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
				
				
				if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)   {score=1.0;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)   {score=0.7;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)   {score=0.5;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
						 vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)   {score=0.4;}
				else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX)   {score=0.0;}
				
			
				//-----------xBonds--------------------------------------------------
				if		(XTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      {probBranch=0.0-score;}
				else if (XTauW[i-1][j-1][k-1]> 0.4*runningWSSMAX &&
						 XTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX)      {probBranch=0.5-score;}
				else if (XTauW[i-1][j-1][k-1]> 0.6*runningWSSMAX &&
						 XTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)      {probBranch=0.8-score;}
				else if (XTauW[i-1][j-1][k-1]> 0.8*runningWSSMAX)	   {probBranch=1.0-score;}	

				if (probBranch<0) {probBranch=0.0;}

				if (m_nz==1) 
						{randBranchDirection=1;} //1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pFluid[nbx-1]==10 && pAgeOfVessel[nbx-1]<=thresholdAgeSup
									 && pAgeOfVessel[nbx-1]>=thresholdAgeInf)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<probBranch && poleSprout[nbx-1]==true)
					{	
						if (pFluid[LabX(i+1,j,k)-1]!=10)
						{	
							pFluid[LabX(i+1,j,k)-1]=10;
							pSprout[LabX(i+1,j,k)-1]=1;
							poleSprout[LabX(i+1,j,k)-1]=true;
							pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{ 
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{	
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nbx-1]==false)
					{
						if (pFluid[LabX(i-1,j,k)-1]!=10)
						{
							pFluid[LabX(i-1,j,k)-1]=10;
							pSprout[LabX(i-1,j,k)-1]=1;
							poleSprout[LabX(i-1,j,k)-1]=false;
							pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

							pAgeOfSprout[nbx-1]=0.0;
							pSprout[nbx-1]=0;
						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabY(i-1,j+1,k)-1]!=10)
									{	pFluid[LabY(i-1,j+1,k)-1]=10;
										pSprout[LabY(i-1,j+1,k)-1]=1;
										poleSprout[LabY(i-1,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabY(i-1,j,k)-1]!=10)
									{
										pFluid[LabY(i-1,j,k)-1]=10;
										pSprout[LabY(i-1,j,k)-1]=1;
										poleSprout[LabY(i-1,j,k)-1]=false;
										pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i-1,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k+1)-1]=10;
										pSprout[LabZ(i-1,j,k+1)-1]=1;
										poleSprout[LabZ(i-1,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i-1,j,k)-1]!=10)
									{
										pFluid[LabZ(i-1,j,k)-1]=10;
										pSprout[LabZ(i-1,j,k)-1]=1;
										poleSprout[LabZ(i-1,j,k)-1]=false;
										pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;
									}
									break;
					}}

				}
						
				//-----------yBonds--------------------------------------------------
				if		(YTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      {probBranch=0.0-score;}
				else if (YTauW[i-1][j-1][k-1]> 0.4*runningWSSMAX &&
						 YTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX)      {probBranch=0.5-score;}
				else if (YTauW[i-1][j-1][k-1]> 0.6*runningWSSMAX &&
						 YTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)      {probBranch=0.8-score;}
				else if (YTauW[i-1][j-1][k-1]> 0.8*runningWSSMAX)	   {probBranch=1.0-score;}	
				
				if (probBranch<0) {probBranch=0.0;}

				if (m_nz==1) 
						{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
				   else {randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

				if(pOldSprout[nby-1]==10 && pAgeOfVessel[nby-1]<=thresholdAgeSup
										 && pAgeOfVessel[nby-1]>=thresholdAgeInf)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<probBranch && poleSprout[nby-1]==true)
					{
						if (pFluid[LabY(i,j+1,k)-1]!=10)
						{
							pFluid[LabY(i,j+1,k)-1]=10;
							pSprout[LabY(i,j+1,k)-1]=1;
							poleSprout[LabY(i,j+1,k)-1]=true;
							pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{	pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j,k)-1]!=10)
									{
										pFluid[LabZ(i,j,k)-1]=10;
										pSprout[LabZ(i,j,k)-1]=1;
										poleSprout[LabZ(i,j,k)-1]=false;
										pAgeOfSprout[LabZ(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nby-1]==false)
					{
						if (pFluid[LabY(i,j-1,k)-1]!=10)
						{
							pFluid[LabY(i,j-1,k)-1]=10;
							pSprout[LabY(i,j-1,k)-1]=1;
							poleSprout[LabY(i,j-1,k)-1]=false;
							pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

							pAgeOfSprout[nby-1]=0.0;
							pSprout[nby-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j-1,k)-1]!=10)
									{
										pFluid[LabX(i+1,j-1,k)-1]=10;
										pSprout[LabX(i+1,j-1,k)-1]=1;
										poleSprout[LabX(i+1,j-1,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j-1,k)-1]!=10)
									{
										pFluid[LabX(i,j-1,k)-1]=10;
										pSprout[LabX(i,j-1,k)-1]=1;
										poleSprout[LabX(i,j-1,k)-1]=false;
										pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabZ(i,j-1,k+1)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k+1)-1]=10;
										pSprout[LabZ(i,j-1,k+1)-1]=1;
										poleSprout[LabZ(i,j-1,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabZ(i,j-1,k)-1]!=10)
									{
										pFluid[LabZ(i,j-1,k)-1]=10;
										pSprout[LabZ(i,j-1,k)-1]=1;
										poleSprout[LabZ(i,j-1,k)-1]=false;
										pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;
									}
									break;
					}}
				}

				//-----------zBonds--------------------------------------------------
				if		(ZTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      {probBranch=0.0-score;}
				else if (ZTauW[i-1][j-1][k-1]> 0.4*runningWSSMAX &&
						 ZTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX)      {probBranch=0.5-score;}
				else if (ZTauW[i-1][j-1][k-1]> 0.6*runningWSSMAX &&
						 ZTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)      {probBranch=0.8-score;}
				else if (ZTauW[i-1][j-1][k-1]> 0.8*runningWSSMAX)	   {probBranch=1.0-score;}		
				
				if (probBranch<0) {probBranch=0.0;}

				if (m_nz!=1){
				randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));
				 
				if(pOldSprout[nbz-1]==10 && pAgeOfVessel[nbz-1]<=thresholdAgeSup
										 && pAgeOfSprout[nbz-1]>=thresholdAgeInf)
				{
					randDice=float(rand())/float(RAND_MAX); //(0,1)
					if(randDice<probBranch && poleSprout[nbz-1]==true)
					{
						if (pFluid[LabZ(i,j,k+1)-1]!=10)
						{
							pFluid[LabZ(i,j,k+1)-1]=10;
							pSprout[LabZ(i,j,k+1)-1]=1;
							poleSprout[LabZ(i,j,k+1)-1]=true;
							pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;
						}
						
						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k)-1]!=10)
									{
										pFluid[LabX(i+1,j,k)-1]=10;
										pSprout[LabX(i+1,j,k)-1]=1;
										poleSprout[LabX(i+1,j,k)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k)-1]!=10)
									{
										pFluid[LabX(i,j,k)-1]=10;
										pSprout[LabX(i,j,k)-1]=1;
										poleSprout[LabX(i,j,k)-1]=false;
										pAgeOfSprout[LabX(i,j,k)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k)-1]!=10)
									{
										pFluid[LabY(i,j+1,k)-1]=10;
										pSprout[LabY(i,j+1,k)-1]=1;
										poleSprout[LabY(i,j+1,k)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k)-1]!=10)
									{
										pFluid[LabY(i,j,k)-1]=10;
										pSprout[LabY(i,j,k)-1]=1;
										poleSprout[LabY(i,j,k)-1]=false;
										pAgeOfSprout[LabY(i,j,k)-1]=0.0;
									}
									break;
					}}

					if(randDice<probBranch && poleSprout[nbz-1]==false)
					{
						if (pFluid[LabZ(i,j,k-1)-1]!=10)
						{
							pFluid[LabZ(i,j,k-1)-1]=10;
							pSprout[LabZ(i,j,k-1)-1]=1;
							poleSprout[LabZ(i,j,k-1)-1]=false;
							pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

							pAgeOfSprout[nbz-1]=0.0;
							pSprout[nbz-1]=0;

						}

						switch(randBranchDirection)
						{
							case 1: if (pFluid[LabX(i+1,j,k-1)-1]!=10)
									{
										pFluid[LabX(i+1,j,k-1)-1]=10;
										pSprout[LabX(i+1,j,k-1)-1]=1;
										poleSprout[LabX(i+1,j,k-1)-1]=true;
										pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;
									}
									break;

							case 2: if (pFluid[LabX(i,j,k-1)-1]!=10)
									{
										pFluid[LabX(i,j,k-1)-1]=10;
										pSprout[LabX(i,j,k-1)-1]=1;
										poleSprout[LabX(i,j,k-1)-1]=false;
										pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;
									}
									break;
									
							case 3: if (pFluid[LabY(i,j+1,k-1)-1]!=10)
									{
										pFluid[LabY(i,j+1,k-1)-1]=10;
										pSprout[LabY(i,j+1,k-1)-1]=1;
										poleSprout[LabY(i,j+1,k-1)-1]=true;
										pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;
									}
									break;

							case 4: if (pFluid[LabY(i,j,k-1)-1]!=10)
									{
										pFluid[LabY(i,j,k-1)-1]=10;
										pSprout[LabY(i,j,k-1)-1]=1;
										poleSprout[LabY(i,j,k-1)-1]=false;
										pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;
									}
									break;
					}}
				}
				}//end if(m_nz!=1)
		
	}}}
*/
	//----------------
	delete [] pOldSprout;
	//----------------
}

//***********************************************
//==========================================
void CAngioNetDlg::AntiangiogenicTreatment()
//==========================================
{

	double MaturationLevel1=3.0;
	double MaturationLevel2=7.0;
	double MaturationLevel3=10.5;
	double DrugLevel1=0.6;
	double DrugLevel2=0.7;
	double DrugLevel3=0.8;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=3;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 nbx=LabX(i,j,k);
			 nby=LabY(i,j,k);
			 nbz=LabZ(i,j,k);

			 //------- Maturation Level 1 -------------
			 if(pAgeOfVessel[nbx-1]<=MaturationLevel1)
			 {if(pXAngioDrug[i-1][j-1][k-1]>DrugLevel1) {pFluid[nbx-1]=0;}}

			 if(pAgeOfVessel[nby-1]<=MaturationLevel1)
			 {if(pYAngioDrug[i-1][j-1][k-1]>DrugLevel1) {pFluid[nby-1]=0;}}

			 if(pAgeOfVessel[nbz-1]<=MaturationLevel1)
			 {if(pZAngioDrug[i-1][j-1][k-1]>DrugLevel1) {pFluid[nbz-1]=0;}}

			 //------- Maturation Level 2 -------------
			 if(pAgeOfVessel[nbx-1]>MaturationLevel1 && pAgeOfVessel[nbx-1]<=MaturationLevel2)
			 {if(pXAngioDrug[i-1][j-1][k-1]>DrugLevel2) {pFluid[nbx-1]=0;}}

			 if(pAgeOfVessel[nby-1]>MaturationLevel1 && pAgeOfVessel[nby-1]<=MaturationLevel2)
			 {if(pYAngioDrug[i-1][j-1][k-1]>DrugLevel2) {pFluid[nby-1]=0;}}

			 if(pAgeOfVessel[nbz-1]>MaturationLevel1 && pAgeOfVessel[nbz-1]<=MaturationLevel2)
			 {if(pZAngioDrug[i-1][j-1][k-1]>DrugLevel2) {pFluid[nbz-1]=0;}}

			 //------- Maturation Level 3 -------------
			 if(pAgeOfVessel[nbx-1]>MaturationLevel2 && pAgeOfVessel[nbx-1]<=MaturationLevel3)
			 {if(pXAngioDrug[i-1][j-1][k-1]>DrugLevel3) {pFluid[nbx-1]=0;}}

			 if(pAgeOfVessel[nby-1]>MaturationLevel2 && pAgeOfVessel[nby-1]<=MaturationLevel3)
			 {if(pYAngioDrug[i-1][j-1][k-1]>DrugLevel3) {pFluid[nby-1]=0;}}

			 if(pAgeOfVessel[nbz-1]>MaturationLevel2 && pAgeOfVessel[nbz-1]<=MaturationLevel3)
			 {if(pZAngioDrug[i-1][j-1][k-1]>DrugLevel3) {pFluid[nbz-1]=0;}}


			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			 //------- Maturation Level 1 -------------
			 if(pAgeOfVessel[nbx-1]<=MaturationLevel1)
			 {if(pXAngioDrug[i-1][j-1][k-1]>DrugLevel1) {pFluid[nbx-1]=0;}}

			 //------- Maturation Level 2 -------------
			 if(pAgeOfVessel[nbx-1]>MaturationLevel1 && pAgeOfVessel[nbx-1]<=MaturationLevel2)
			 {if(pXAngioDrug[i-1][j-1][k-1]>DrugLevel2) {pFluid[nbx-1]=0;}}

			 //------- Maturation Level 3 -------------
			 if(pAgeOfVessel[nbx-1]>MaturationLevel2 && pAgeOfVessel[nbx-1]<=MaturationLevel3)
			 {if(pXAngioDrug[i-1][j-1][k-1]>DrugLevel3) {pFluid[nbx-1]=0;}}
	}}

}

//***********************************************
//=====================================
void CAngioNetDlg::UpdateHematocrit()
//=====================================
{
	double*** TotalFlowOut=NULL; 
	double*** TotalFlowIn=NULL;
	double*** TotalMassIn=NULL;

	TotalFlowOut=new double**[m_nx];
	TotalFlowIn=new double**[m_nx];
	TotalMassIn=new double**[m_nx];

	for (int i=0;i<m_nx;i++)
	{
		TotalFlowOut[i]=new double* [m_ny];
		TotalFlowIn[i]=new double* [m_ny];
		TotalMassIn[i]=new double* [m_ny];
	}
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			TotalFlowOut[i][j]=new double [m_nz];
			TotalFlowIn[i][j]=new double [m_nz];
			TotalMassIn[i][j]=new double [m_nz];
	}}

	if	(b_TestNetwork)	//stop top PV mysteriously appearing
		{
			for	(int i=1;i<=m_nx+1;i++)
				{
					pFluid[LabX(i,1,1)-1]=0;
				}
		}

//----Updates the Hematocrit in each bond-----

	double theminflow=1.0e-30;
	double timestep=1.0e20;
	double timeStepInit=1.0e20;
	int MinTime_i,MinTime_j;
	double MinTime_Rad,MinTime_Flow;

	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXHem[i-1][j-1][k-1]=0.0;}
			if (pFluid[nby-1]!=10)	{pYHem[i-1][j-1][k-1]=0.0;}
			if (pFluid[nbz-1]!=10)	{pZHem[i-1][j-1][k-1]=0.0;}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXHem[i-1][j-1][k-1]=0.0;}
	}}


//Find the min time needed until a pore is completely emptied
//can't go longer than this otherwise mass isn't conserved

	double tempDeltaT;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)		//away from PVs, which are assumed const Ht
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_Rad=XBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(XFlow[i-1][j-1][k-1]);}
			}
			

			if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/fabs(YFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_Rad=YBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(YFlow[i-1][j-1][k-1]);}
			}
			

			if (m_nz !=1)
			{
				if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
				{
				tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/fabs(ZFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT;}
				}
			}


			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_Rad=XBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(XFlow[i-1][j-1][k-1]);}
			}
			
	}}


//Now set the actual sim timestep to the tracer-constrained timestep
//to keep everything consistent
//	if (m_presetNetwork==FALSE && m_circTumour==FALSE)
//	{
//		if (timestep<angioDeltaT) {exit(1);}	//need to change angioDeltaT
//		else	{}//timestep=angioDeltaT*10;}	//set to the smaller angioDeltaT
//	}											//IDEALLY update concs
												//angiodeltaT(in secs)/tmstep
												//times before returning
												//to cycle.
												//Currently, the 2 timescales
												//are not synchronised.
//	else	//we're only doing tracer so no real need to worry about timestep
//	{
//		angioDeltaT=timestep;
//	}

	//SMcD 10/2004-----
	if ( fabs(timeStepInit-timestep) / timeStepInit <= 0.01) 
	{MessageBox("Timestep error");}

	outfileDebugTime << timestep << "\t" << MinTime_i << "\t" << 
						MinTime_j << "\t" <<
						MinTime_Rad << "\t" <<
						MinTime_Flow << "\t" << flowTime << endl;

	angioDeltaT=timestep/TimeFactor;
	//---------------

//Now calculate the total flow into and out of nodes--
//initialise first

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalMassIn[i-1][j-1][k-1]=0.0;
	}}}
///Changes here

//Now do the calculation - NB total flow in = total flow out
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
			  if (k==m_nz) {kp1=1;} else {kp1=k+1;}

			  TotalFlowIn[i-1][j-1][k-1]=0.5*(
				  fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
				  fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
				  fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

			  TotalFlowOut[i-1][j-1][k-1]=TotalFlowIn[i-1][j-1][k-1];
	}}}


//Calculate the total mass flowing into each node.  Be careful about signs--

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{			
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
			  if (k==m_nz) {kp1=1;} else {kp1=k+1;}

			  if (XFlow[i-1][j-1][k-1]>0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (XFlow[i+1-1][j-1][k-1]<0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1])*pXHem[i+1-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (YFlow[i-1][j-1][k-1]>0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (YFlow[i-1][jp1-1][k-1]<0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][jp1-1][k-1])*pYHem[i-1][jp1-1][k-1]*angioDeltaT*TimeFactor;}

			  if (ZFlow[i-1][j-1][k-1]>0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

		  	  if (ZFlow[i-1][j-1][kp1-1]<0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][kp1-1])*pZHem[i-1][j-1][kp1-1]*angioDeltaT*TimeFactor;}
	}}}

//	outfileDebugNetwork << "got to update tracer conc" << endl;
//Update tracer concentrations----------------------

	int jm1,km1,zpos;

	int nCount=0;

	if (m_nz==1) {zpos=1;} else {zpos=int(m_nz/2);}

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==1) {jm1=m_ny;} else {jm1=j-1;}
				if (k==1) {km1=m_nz;} else {km1=k-1;}

//---x-pores----
				//---Restore if only one arteriole*** if (i==1 && j==1 && k==1)	//inlet port first
				if	(i==1)
				{									
					if	(
							!b_TestNetwork && 
							(
								(j==1 && k==zpos)	
								|| 
								(b_venousIncluded && j==m_ny-1 && k==zpos)
								|| 
								(b_UU_wound_Model && j==nCount*m_ny/(nAdditionalCentralPVs+1) && k==zpos)
								|| 
								(b_UU_wound_Model && j==m_ny-1 && k==zpos)
							)
						)//**arts** 

					{
						if	(!b_HexNetwork || (b_HexNetwork && b_StraightPVs))	//square network or hex network with straight PVs
						{
							pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
													(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
														(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;

							nCount++;
						}

//-----------------------------------------------						
						else if	(b_HexNetwork && !b_StraightPVs)	//hex network with wiggly PVs	
						{
							if	(int(j/2)-double(j/2.0)==0)	//if j even, inlet bond at j+1
							{
								pXHem[i-1][j+1-1][k-1]+=fabs(XFlow[i-1][j+1-1][k-1])*angioDeltaT/
														(pi*pow(XBR[i-1][j+1-1][k-1],2)*XBL[i-1][j+1-1][k-1]) *
															(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j+1-1][k-1])/MaxHt;
							}

							else	//if j odd	
							{
								pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
														(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
															(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
							}

							nCount++;	//step to next additional PV

						}	//end if hexagonal network

//-----------------------------------------------
					}	//end if j=...

//-----------------------------------------------
								//pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06

			  					//pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*timestep/
			  					//(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
			  					//(AverageHt-pXHem[i-1][j-1][k-1]);

//-----------------------------------------------					
					if	(b_TestNetwork)
					{
						if	(
								(j==51 && pFluid[LabX(i,51,k)-1]==10)	//one inlet at centre for branching networks
								||
								(j==2 && pFluid[LabX(i,2,k)-1]==10)		//one inlet at top for retina network
							)
						{
							pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
													(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
														(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
						}
					}

//-----------------------------------------------					
			  //2nd arteriole
			  //if (j==m_ny-1 && k==1) //**2nd art** //Updated SMcD 07.11.06
				//	{
				  //pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
				//		(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
				//		(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
				  
			//		pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06
			//		}

//-----------------------------------------------
				}  //end if i=1

				else	//not the inlet port	
				{	
					if	(TotalFlowOut[i-1][j-1][k-1]>0)
					{
						if	(XFlow[i-1][j-1][k-1]<0.0)
						{
							pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
													(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
														(  TotalMassIn[i-1][j-1][k-1]/
															TotalFlowOut[i-1][j-1][k-1]/angioDeltaT
																-TimeFactor*pXHem[i-1][j-1][k-1]  )/MaxHt;
						}

						else if (XFlow[i-1][j-1][k-1]>0.0)
						{
							pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
													(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
														(  TotalMassIn[i-1-1][j-1][k-1]/
															TotalFlowOut[i-1-1][j-1][k-1]/angioDeltaT
																-TimeFactor*pXHem[i-1][j-1][k-1]  )/MaxHt;
						}
					}	//end if TotalFlowOut>0

				}	//end if i!=1

//-----------------------------------------------
//---y-pores---

				if	(TotalFlowOut[i-1][j-1][k-1]>0)
				{
					if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						pYHem[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
												(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
													(  TotalMassIn[i-1][j-1][k-1]/
														TotalFlowOut[i-1][j-1][k-1]/angioDeltaT
															-TimeFactor*pYHem[i-1][j-1][k-1]  )/MaxHt;
					}

					else if (YFlow[i-1][j-1][k-1]>0.0)
					{
						pYHem[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
												(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
													(  TotalMassIn[i-1][jm1-1][k-1]/
														TotalFlowOut[i-1][jm1-1][k-1]/angioDeltaT
															-TimeFactor*pYHem[i-1][j-1][k-1]  )/MaxHt;
					}
				}	//end if TotalFlowOut>0

//-----------------------------------------------
//---z-pores---

				if (TotalFlowOut[i-1][j-1][k-1]>0)
				{
					if (ZFlow[i-1][j-1][k-1]<0.0)
					{
						pZHem[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
												(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
													(  TotalMassIn[i-1][j-1][k-1]/
														TotalFlowOut[i-1][j-1][k-1]/angioDeltaT
															-TimeFactor*pZHem[i-1][j-1][k-1]  )/MaxHt;
					}

					else if (ZFlow[i-1][j-1][k-1]>0.0)
					{
						pZHem[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
												(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
													(  TotalMassIn[i-1][j-1][km1-1]/
														TotalFlowOut[i-1][j-1][km1-1]/angioDeltaT-
															TimeFactor*pZHem[i-1][j-1][k-1]  )/MaxHt;
					}
				}	//end if TotalFlowOut>0

//-----------------------------------------------
			}// end i-loop

//-----------------------------------------------
//---x-danglers---

			int i=m_nx+1;

			if (TotalFlowOut[m_nx-1][j-1][k-1]>0)
			{
				pXHem[m_nx+1-1][j-1][k-1]+=fabs(XFlow[m_nx+1-1][j-1][k-1])*angioDeltaT/
											(pi*pow(XBR[m_nx+1-1][j-1][k-1],2)*XBL[m_nx+1-1][j-1][k-1]) *
												(  TotalMassIn[m_nx-1][j-1][k-1]/
													TotalFlowOut[m_nx-1][j-1][k-1]/angioDeltaT-
														TimeFactor*pXHem[m_nx+1-1][j-1][k-1]  )/MaxHt;
			}

//-----------------------------------------------
		}	//end j loop
	}// end k loop

//-----------------------------------------------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if ( pXHem[i-1][j-1][k-1]>1.0)	{pXHem[i-1][j-1][k-1]=1.0;}
			if ( pXHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}
			if ( pYHem[i-1][j-1][k-1]>1.0)	{pYHem[i-1][j-1][k-1]=1.0;}
			if ( pYHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}
			if ( pZHem[i-1][j-1][k-1]>1.0)	{pZHem[i-1][j-1][k-1]=1.0;}
			if ( pZHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}

//			if	(loop%200==0)
//			{
//				if	(pFluid[nbx-1]==10)	{outfileDebugHem << flowTime << "\t" << "\t" << "X Hem" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << endl;}
//				if	(pFluid[nby-1]==10)	{outfileDebugHem << flowTime << "\t" << "\t" << "Y Hem" << "\t" << i << "\t" << j << "\t" << pYHem[i-1][j-1][k-1] << endl;}
//			}

			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if ( pXHem[i-1][j-1][k-1]>1.0)	{pXHem[i-1][j-1][k-1]=1.0;}
			if ( pXHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}

//			if	(loop%200==0)
//			{
//				if	(pFluid[nbx-1]==10)	{outfileDebugHem << flowTime << "\t" << "\t" << "X Hem" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << endl;}
//			}
	}}

//	if	(loop%200==0)	{outfileDebugHem << endl;}

//-----------------------------------------------
//Clear up arrays
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowIn[i][j];
			delete[] TotalFlowOut[i][j];
			delete[] TotalMassIn[i][j];
	}}
	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowIn[i];
			delete[] TotalFlowOut[i];
			delete[] TotalMassIn[i];
	}
			delete[] TotalFlowIn;
			delete[] TotalFlowOut;
			delete[] TotalMassIn;

//-----------------------------------------------
}

//***********************************************
//===============================================
void CAngioNetDlg::UpdateAntiangioDrugTracer()
//===============================================
{
		double*** TotalFlowOut=NULL; 
		double*** TotalFlowIn=NULL;
		double*** TotalMassIn=NULL;

		TotalFlowOut=new double**[m_nx];
		TotalFlowIn=new double**[m_nx];
		TotalMassIn=new double**[m_nx];

		for (int i=0;i<m_nx;i++)
		{
			TotalFlowOut[i]=new double* [m_ny];
			TotalFlowIn[i]=new double* [m_ny];
			TotalMassIn[i]=new double* [m_ny];
		}

		for (int i=0;i<m_nx;i++)
		{
			for (int j=0;j<m_ny;j++)
			{
				TotalFlowOut[i][j]=new double [m_nz];
				TotalFlowIn[i][j]=new double [m_nz];
				TotalMassIn[i][j]=new double [m_nz];
			}
		}

//----Updates the angio-tracer conc in each bond-----

	double theminflow=1.0e-30;
	double timestep=1.0e20;

	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]!=10)	{pXAngioDrug[i-1][j-1][k-1]=0.0;}
			 if (pFluid[nby-1]!=10)	{pYAngioDrug[i-1][j-1][k-1]=0.0;}
			 if (pFluid[nbz-1]!=10)	{pZAngioDrug[i-1][j-1][k-1]=0.0;}
		  }
	 	  int i=m_nx+1;
	      int nbx=LabX(i,j,k);

		  if (pFluid[nbx-1]!=10)	{pXAngioDrug[i-1][j-1][k-1]=0.0;}
	}}

//Find the min time needed until a pore is completely emptied
//can't go longer than this otherwise mass isn't conserved

	double tempDeltaT;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			 { tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
			   if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			 }

			 if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
			 { tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/fabs(YFlow[i-1][j-1][k-1]);
			   if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			 }

			 if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
			 { tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/fabs(ZFlow[i-1][j-1][k-1]);
			   if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			 }
		  }
		  int i=m_nx+1;
		  int nbx=LabX(i,j,k);

		  if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
		  { tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
		    if (tempDeltaT < timestep) {timestep=tempDeltaT;}
		  }
	}}

//Now set the actual sim timestep to the tracer-constrained timestep
//to keep everything consistent
//	if (m_presetNetwork==FALSE && m_circTumour==FALSE)
//	{
//		if (timestep<angioDeltaT) {exit(1);}	//need to change angioDeltaT
//		else	{}//timestep=angioDeltaT*10;}	//set to the smaller angioDeltaT
//	}											//IDEALLY update concs
												//angiodeltaT(in secs)/tmstep
												//times before returning
												//to cycle.
												//Currently, the 2 timescales
												//are not synchronised.
//	else	//we're only doing tracer so no real need to worry about timestep
//	{
//		angioDeltaT=timestep;
//	}

//---SMcD 10/2004
	angioDeltaT=timestep;
	//-------------------

//Now calculate the total flow into and out of nodes--
//initialise first

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalMassIn[i-1][j-1][k-1]=0.0;
	}}}

//Now do the calculation - NB total flow in = total flow out
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
			  if (k==m_nz) {kp1=1;} else {kp1=k+1;}

			  TotalFlowIn[i-1][j-1][k-1]=0.5*(
				  fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
				  fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
				  fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

			  TotalFlowOut[i-1][j-1][k-1]=TotalFlowIn[i-1][j-1][k-1];
	}}}

//Calculate the total mass flowing into each node.  Be careful about signs--

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{			
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
		      if (k==m_nz) {kp1=1;} else {kp1=k+1;}
			  
			  if (XFlow[i-1][j-1][k-1]>0.0)
			  { TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*pXAngioDrug[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (XFlow[i+1-1][j-1][k-1]<0.0)
			  { TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1])*pXAngioDrug[i+1-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (YFlow[i-1][j-1][k-1]>0.0)
			  { TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*pYAngioDrug[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (YFlow[i-1][jp1-1][k-1]<0.0)
			  { TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][jp1-1][k-1])*pYAngioDrug[i-1][jp1-1][k-1]*angioDeltaT*TimeFactor;}

			  if (ZFlow[i-1][j-1][k-1]>0.0)
			  { TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*pZAngioDrug[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (ZFlow[i-1][j-1][kp1-1]<0.0)
			  { TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][kp1-1])*pZAngioDrug[i-1][j-1][kp1-1]*angioDeltaT*TimeFactor;}
	}}}

//Update tracer concentrations----------------------

	int jm1,km1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (j==1) {jm1=m_ny;} else {jm1=j-1;}
		      if (k==1) {km1=m_nz;} else {km1=k-1;}

//--x-pores----
			  // ***Restore if only one arteriole*** if (i==1 && j==1 && k==1)	//inlet port first
			  if (i==1)
			  {
				if(j==1 && k==1) //**1st art** 
				//------ MODIF A.S. ------------------------------------
				  //if(j==1 && k==15) // for vasculature 3d-linear-30-2.txt 
				//------------------------------------------------------
				{
					if (m_slug==FALSE || (m_slug==TRUE && angiotime<flushtime))
					{
					pXAngioDrug[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*AngioDrugMax-TimeFactor*pXAngioDrug[i-1][j-1][k-1])/AngioDrugMax;				
					}
					else	//slug in place now do postflush
					{
					pXAngioDrug[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*AngioDrugMin-TimeFactor*pXAngioDrug[i-1][j-1][k-1])/AngioDrugMax;
					}
				}//end if j and k
			  }//end if i

			  //-------------
			  else	//not the inlet port
			  {
				if (TotalFlowOut[i-1][j-1][k-1]>0)
				{
				  if (XFlow[i-1][j-1][k-1]<0.0)
				  {
					 pXAngioDrug[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXAngioDrug[i-1][j-1][k-1]  )/AngioDrugMax;
				  }
				  else if (XFlow[i-1][j-1][k-1]>0.0)
				  {

					pXAngioDrug[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1-1][j-1][k-1]/
						   TotalFlowOut[i-1-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXAngioDrug[i-1][j-1][k-1]  )/AngioDrugMax;
				  }
				}//end if
			  }//end else

//--y-pores------
			  if (TotalFlowOut[i-1][j-1][k-1]>0)
			  {
				if (YFlow[i-1][j-1][k-1]<0.0)
				{
					pYAngioDrug[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/timestep-
						   TimeFactor*pYAngioDrug[i-1][j-1][k-1]  )/AngioDrugMax;
				}
				else if (YFlow[i-1][j-1][k-1]>0.0)
				{
					pYAngioDrug[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][jm1-1][k-1]/
						   TotalFlowOut[i-1][jm1-1][k-1]/angioDeltaT-
						   TimeFactor*pYAngioDrug[i-1][j-1][k-1]  )/AngioDrugMax;
				}
			  }

//--z-pores----------
			if (TotalFlowOut[i-1][j-1][k-1]>0)
			{
			  if (ZFlow[i-1][j-1][k-1]<0.0)
			  {
				  pZAngioDrug[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pZAngioDrug[i-1][j-1][k-1]  )/AngioDrugMax;
			  }
			  else if (ZFlow[i-1][j-1][k-1]>0.0)
			  {
				  pZAngioDrug[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][km1-1]/
						   TotalFlowOut[i-1][j-1][km1-1]/angioDeltaT-
						   TimeFactor*pZAngioDrug[i-1][j-1][k-1]  )/AngioDrugMax;
			  }
			}
		  }//end i-loop

//--x-danglers----
		int i=m_nx+1;
		if (TotalFlowOut[m_nx-1][j-1][k-1]>0)
		{

				pXAngioDrug[m_nx+1-1][j-1][k-1]+=
				fabs(XFlow[m_nx+1-1][j-1][k-1])*angioDeltaT/
				(pi*pow(XBR[m_nx+1-1][j-1][k-1],2)*XBL[m_nx+1-1][j-1][k-1]) *
						(  TotalMassIn[m_nx-1][j-1][k-1]/
						   TotalFlowOut[m_nx-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXAngioDrug[m_nx+1-1][j-1][k-1]  )/AngioDrugMax;
		}
	}}//end jand k loops

//Only want tracer in vessels, so set any others to 0.0
//(already done before - just a check)------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 int nbx=LabX(i,j,k);
			 int nby=LabY(i,j,k);
			 int nbz=LabZ(i,j,k);

			 if (pFluid[nbx-1]!=10)	{pXAngioDrug[i-1][j-1][k-1]=0.0;}
			 if ( pXAngioDrug[i-1][j-1][k-1]>1.0)	{pXAngioDrug[i-1][j-1][k-1]=1.0;}
			 if ( pXAngioDrug[i-1][j-1][k-1]<0.0)	{MessageBox("Drug not conserved");}

			 if (pFluid[nby-1]!=10)	{pYAngioDrug[i-1][j-1][k-1]=0.0;}
			 if ( pYAngioDrug[i-1][j-1][k-1]>1.0)	{pYAngioDrug[i-1][j-1][k-1]=1.0;}
			 if ( pYAngioDrug[i-1][j-1][k-1]<0.0)	{MessageBox("Drug not conserved");}

			 if (pFluid[nbz-1]!=10)	{pZAngioDrug[i-1][j-1][k-1]=0.0;}
			 if ( pZAngioDrug[i-1][j-1][k-1]>1.0)	{pZAngioDrug[i-1][j-1][k-1]=1.0;}
			 if ( pZAngioDrug[i-1][j-1][k-1]<0.0)	{MessageBox("Drug not conserved");}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXAngioDrug[i-1][j-1][k-1]=0.0;}
			if ( pXAngioDrug[i-1][j-1][k-1]>1.0)	{pXAngioDrug[i-1][j-1][k-1]=1.0;}
			if ( pXAngioDrug[i-1][j-1][k-1]<0.0)	{MessageBox("Drug not conserved");}
	}}

//Clear up arrays----
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowIn[i][j];
			delete[] TotalFlowOut[i][j];
			delete[] TotalMassIn[i][j];
	}}
	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowIn[i];
			delete[] TotalFlowOut[i];
			delete[] TotalMassIn[i];
	}
			delete[] TotalFlowIn;
			delete[] TotalFlowOut;
			delete[] TotalMassIn;
}


//*****************************************************

//===============================
void CAngioNetDlg::UpdateTracer()
//===============================
{
//----------output file for debugging-------------
//----------------------------------------------------
//need to define some arrays first

//	pFluid[888]=10;
//	outfileConc <<"HELP";
//***********************
//NB TimeFactor defined in InitialiseVariables()
//***********************

		double*** TotalFlowOut=NULL; 
		double*** TotalFlowIn=NULL;
		double*** TotalMassIn=NULL;

		TotalFlowOut=new double**[m_nx];
		TotalFlowIn=new double**[m_nx];
		TotalMassIn=new double**[m_nx];

		for (int i=0;i<m_nx;i++)
		{
			TotalFlowOut[i]=new double* [m_ny];
			TotalFlowIn[i]=new double* [m_ny];
			TotalMassIn[i]=new double* [m_ny];
		}

		for (int i=0;i<m_nx;i++)
		{
			for (int j=0;j<m_ny;j++)
			{
				TotalFlowOut[i][j]=new double [m_nz];
				TotalFlowIn[i][j]=new double [m_nz];
				TotalMassIn[i][j]=new double [m_nz];
			}
		}
//-----------------------------------------------------------------
//			outfileConc <<"HELP2";

//----Updates the tracer conc in each bond-----

	double theminflow=1.0e-30;
	double timestep=1.0e20;

	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------

//x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}
//y-pores
	if ( *(pFluid+nby-1)!=10)	{pYCON[i-1][j-1][k-1]=0.0;}
//z-pores
	if ( *(pFluid+nbz-1)!=10)	{pZCON[i-1][j-1][k-1]=0.0;}

		  }

	int i=m_nx+1;
	int nbx=LabX(i,j,k);

//dangling x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}

	   }
	}
//-------------------------------------------------------------
//		outfileConc << "STEP1";

//Find the min time needed until a pore is completely emptied
//can't go longer than this otherwise mass isn't conserved

	double tempDeltaT;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------
	if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
								fabs(XFlow[i-1][j-1][k-1]);

//	outfile5 << XBR[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << XBL[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << pow(XBR[i-1][j-1][k-1],2);
//	outfile5 << "\t";
//	outfile5 << pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
//								fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << timestep;
//	outfile5 << endl;

			if (tempDeltaT < timestep) {timestep=tempDeltaT;} //These are real times
	}

//----------------------------------------------
	if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/
								fabs(YFlow[i-1][j-1][k-1]);

//	outfile5 << XBR[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << XBL[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << pow(XBR[i-1][j-1][k-1],2);
//	outfile5 << "\t";
//	outfile5 << pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
//								fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << timestep;
//	outfile5 << endl;
//
		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//----------------------------------------------
	if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/
								fabs(ZFlow[i-1][j-1][k-1]);

//	outfile5 << XBR[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << XBL[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << pow(XBR[i-1][j-1][k-1],2);
//	outfile5 << "\t";
//	outfile5 << pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
								fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << timestep;
//	outfile5 << endl;

		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//------------------------------------------------------------------


		  }

		  int i=m_nx+1;
		  int nbx=LabX(i,j,k);

//----------------------------------------------
	if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
								fabs(XFlow[i-1][j-1][k-1]);

		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//----------------------------------------------

	   }
	}	//We now have the min REAL time.  But AngioDeltaT is now dimensionless
		//(unless we are just running an a posteriori tracer sim

		angioDeltaT=timestep/TimeFactor;	//Timefactor set to unity if a posteriori
										//flood is being done

//		outfile5 << angiotime << "\t" << angioDeltaT << "\t" 
//			<< timestep << "\t" << TimeFactor << endl;
//----------------------------------------------------
//------------------------------------------------------
//	outfileConc <<"HELP3";

//Now set the actual sim timestep to the tracer-constrained timestep
//to keep everything consistent
//	if (m_presetNetwork==FALSE && m_circTumour==FALSE && m_WoundOption==FALSE)
//	{//SMcD2004
//		if (timestep/TimeFactor<angioDeltaT)
//		{
//			angioDeltaT=timestep;	//ensures mass conservation
//		}//{exit(1);}	//need to change angioDeltaT
//		else	{}//timestep=angioDeltaT*10;}	//set to the smaller angioDeltaT
//	}											//IDEALLY update concs
												//angiodeltaT(in secs)/tmstep
												//times before returning
												//to cycle.
												//Currently, the 2 timescales
												//are not synchronised.
//	else	//we're only doing tracer so no real need to worry about timestep
//	{
//		angioDeltaT=timestep;
//	}

//SMcD2004--------------------------
//		angioDeltaT=timestep;
//		timestep=angioDeltaT;
//SMcD2004--------------------------


		outfileVasc << "UpdateTracer1" << "\t" << angioDeltaT << 
			"\t" << theminflow << endl;

//--------------------------------------------------------


//Now calculate the total flow into and out of nodes--
//initialise first

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalMassIn[i-1][j-1][k-1]=0.0;
		  }
	   }
	}


//--------------------------------------------------------
//Now do the calculation - NB total flow in = total flow out
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			  if (j==m_ny) {jp1=1;}
			  else {jp1=j+1;}

			  if (k==m_nz) {kp1=1;}
			  else {kp1=k+1;}

			  TotalFlowIn[i-1][j-1][k-1]=0.5*(
				  fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
				  fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
				  fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

			  TotalFlowOut[i-1][j-1][k-1]=TotalFlowIn[i-1][j-1][k-1];

//			outfile5 << i;
//			outfile5 << "\t";
//			outfile5 << j;
//			outfile5 << "\t";
//			outfile5 << TotalFlowIn[i-1][j-1][k-1];
//			outfile5 << "\t";
//			outfile5 << TotalFlowOut[i-1][j-1][k-1];
//			outfile5 << endl;
		  }
	   }
	}
//-----------------------------------------------------------
//outfileConc << "HERE11" ;

//----------------------------------------------------------------------
//Calculate the total mass flowing into each node.  Be careful about signs--

//NEED REAL MASSES SO *TimeFactor NEEDED now
	//SMcD 10/2004
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {			
			  if (j==m_ny) {jp1=1;}
			  else {jp1=j+1;}

			  if (k==m_nz) {kp1=1;}
			  else {kp1=k+1;}
			  
//-----------------------

			if (XFlow[i-1][j-1][k-1]>0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*
											pXCON[i-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (XFlow[i+1-1][j-1][k-1]<0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1])*
											pXCON[i+1-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (YFlow[i-1][j-1][k-1]>0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*
											pYCON[i-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (YFlow[i-1][jp1-1][k-1]<0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][jp1-1][k-1])*
											pYCON[i-1][jp1-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (ZFlow[i-1][j-1][k-1]>0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*
											pZCON[i-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (ZFlow[i-1][j-1][kp1-1]<0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][kp1-1])*
											pZCON[i-1][j-1][kp1-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

		  }
	   }
	}
//-------------------------------------------------------



//-------------------------------------------------------
//Update tracer concentrations----------------------

	int jm1,km1,zpos;

	int nCount=1;	//New UU Wound variable (may need to change back if crashes

	if (m_nz==1) {zpos=1;} else {zpos=int(m_nz/2);}

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

			  if (j==1) {jm1=m_ny;}
			  else {jm1=j-1;}

			  if (k==1) {km1=m_nz;}
			  else {km1=k-1;}

//-----------------------
//--x-pores----
			  // ***Restore if only one arteriole*** if (i==1 && j==1 && k==1)	//inlet port first
			  if (i==1)
			  {////	

				if(
					(j==1 && k==zpos) || (b_venousIncluded && j==m_ny-1 && k==zpos)
									  || (b_UU_wound_Model && j==nCount*m_ny/(nAdditionalCentralPVs+1) && k==zpos)
									  || (b_UU_wound_Model && j==m_ny-1 && k==zpos)
				  ) //**1st art** and additional PVs
				//------ MODIF A.S. ------------------------------------
				  //if(j==1 && k==15) // for vasculature 3d-linear-30-2.txt 
				//------------------------------------------------------
				{//
					if (m_slug==FALSE || (m_slug==TRUE && angiotime<flushtime))
					{
						pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*ConMax-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;
				  		
				  //pXCON[i-1][j-1][k-1]=ConMax;

				//if ( pXCON[i-1][j-1][k-1]<0.0)	{MessageBox("Xinlet Mass not conserved");}


					}
					else	//slug in place now do postflush
					{
						pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*ConMin-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;
				  //pXCON[i-1][j-1][k-1]=ConMin;
					}
				
					nCount++;	//as j increases, pick up next inlet of additionalPVs

				}// end **1st art** and additional PVs
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				if (m_CentralTumour)
				{	////////
					if(j==m_ny-1 && k==zpos) //**2nd art**
					{//
						if (m_slug==FALSE || (m_slug==TRUE && angiotime<flushtime))
						{
							pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
							(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
							(TimeFactor*ConMax-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;

				  //pXCON[i-1][j-1][k-1]=ConMax;

							outfileConc << angiotime << "\t" << pXCON[i-1][j-1][k-1] << endl;
						}
						else	//slug in place now do postflush
						{
							pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
							(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
							(TimeFactor*ConMin-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;

				  //pXCON[i-1][j-1][k-1]=ConMin;
						}


					}//
			  }		////////

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			  }////

			  //-------------
			  else	//not the inlet port
			  {////



			  if (TotalFlowOut[i-1][j-1][k-1]>0)
			  {
				if (XFlow[i-1][j-1][k-1]<0.0)
				{
//				outfile5 << "into 1";

				pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXCON[i-1][j-1][k-1]  )/ConMax;	//SMcD 10/2004
				}
				else if (XFlow[i-1][j-1][k-1]>0.0)
				{
/*				outfile5 << "into 2";
				outfile5 << "\t";
				outfile5 << pXCON[i-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << timestep;
				outfile5 << "\t";
				outfile5 << fabs(XFlow[i-1][j-1][k-1]);
				outfile5 << "\t";
				outfile5 << TotalMassIn[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << TotalFlowOut[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << 
					(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]);
				outfile5 << endl;*/

				pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1-1][j-1][k-1]/
						   TotalFlowOut[i-1-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXCON[i-1][j-1][k-1]  )/ConMax;
				}
			  }
//			  else
//			  {
//				outfile5 << "into 3";
//				pXCON[i-1][j-1][k-1]=pXCON[i-1][j-1][k-1];
//			  }

			  //--------------------------
			  }//// end x-pores

//			  if(pXCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pXCON[i-1][j-1][k-1]=0.0;}

/*			outfile5 << "x";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << TotalMassIn[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pXCON[i-1][j-1][k-1];
//			outfile5 << "\t";
//			outfile5 << (XFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/


//--y-pores------

			  if (TotalFlowOut[i-1][j-1][k-1]>0)
			  {
				if (YFlow[i-1][j-1][k-1]<0.0)
				{
				pYCON[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pYCON[i-1][j-1][k-1]  )/ConMax;

				/*outfile5 << "into y2";
				outfile5 << "\t";
				outfile5 << pYCON[i-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << timestep;
				outfile5 << "\t";
				outfile5 << fabs(YFlow[i-1][j-1][k-1]);
				outfile5 << "\t";
				outfile5 << TotalMassIn[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << TotalFlowOut[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << 
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]);
				outfile5 << endl;*/
				}
				else if (YFlow[i-1][j-1][k-1]>0.0)
				{
				pYCON[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][jm1-1][k-1]/
						   TotalFlowOut[i-1][jm1-1][k-1]/angioDeltaT-
						   TimeFactor*pYCON[i-1][j-1][k-1]  )/ConMax;

				/*outfile5 << "into y3";
				outfile5 << "\t";
				outfile5 << pYCON[i-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << timestep;
				outfile5 << "\t";
				outfile5 << fabs(YFlow[i-1][j-1][k-1]);
				outfile5 << "\t";
				outfile5 << TotalMassIn[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << TotalFlowOut[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << 
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]);
				outfile5 << endl;*/
				}
			  }
//			   else
//			  {
//				pYCON[i-1][j-1][k-1]=pYCON[i-1][j-1][k-1];
//			  }


//			  if(pYCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pYCON[i-1][j-1][k-1]=0.0;}

/*			outfile5 << "y";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pYCON[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << (YFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/
//--z-pores----------

			if (TotalFlowOut[i-1][j-1][k-1]>0)
			{
			  if (ZFlow[i-1][j-1][k-1]<0.0)
			  {
				pZCON[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pZCON[i-1][j-1][k-1]  )/ConMax;
			  }
			  else if (ZFlow[i-1][j-1][k-1]>0.0)
			  {
				pZCON[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][km1-1]/
						   TotalFlowOut[i-1][j-1][km1-1]/angioDeltaT-
						   TimeFactor*pZCON[i-1][j-1][k-1]  )/ConMax;
			  }
			}
//			else
//			{
//				pZCON[i-1][j-1][k-1]=pZCON[i-1][j-1][k-1];
//			}


//			  if(pZCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pZCON[i-1][j-1][k-1]=0.0;}

/*			outfile5 << "z";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pZCON[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << (ZFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/
//----------------------

//-----------------------------------------
		  }


//--x-danglers----

		int i=m_nx+1;

		if (TotalFlowOut[m_nx-1][j-1][k-1]>0)
		{

				pXCON[m_nx+1-1][j-1][k-1]+=
				fabs(XFlow[m_nx+1-1][j-1][k-1])*angioDeltaT/
				(pi*pow(XBR[m_nx+1-1][j-1][k-1],2)*XBL[m_nx+1-1][j-1][k-1]) *
						(  TotalMassIn[m_nx-1][j-1][k-1]/
						   TotalFlowOut[m_nx-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXCON[m_nx+1-1][j-1][k-1]  )/ConMax;
		}
//		else
//		{
//				pXCON[m_nx+1-1][j-1][k-1]=pXCON[m_nx+1-1][j-1][k-1];
//		}

//			  if(pXCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pXCON[i-1][j-1][k-1]=0.0;}
		
/*			outfile5 << "xend";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[m_nx-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pXCON[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << (XFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/
//---------------------------------------------
	   }
	}
//-------------------------------------------------------------

//-----------------------------------------------
//Only want tracer in vessels, so set any others to 0.0
//(already done before - just a check)------

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------

//---------------------------------------------

//x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}
	if ( pXCON[i-1][j-1][k-1]>1.0)	{pXCON[i-1][j-1][k-1]=1.0;}
	if ( pXCON[i-1][j-1][k-1]<0.0)	{MessageBox("X Mass not conserved");}
//y-pores
	if ( *(pFluid+nby-1)!=10)	{pYCON[i-1][j-1][k-1]=0.0;}
	if ( pYCON[i-1][j-1][k-1]>1.0)	{pYCON[i-1][j-1][k-1]=1.0;}
	if ( pYCON[i-1][j-1][k-1]<0.0)	{MessageBox("Y Mass not conserved");}
//z-pores
	if ( *(pFluid+nbz-1)!=10)	{pZCON[i-1][j-1][k-1]=0.0;}
	if ( pZCON[i-1][j-1][k-1]>1.0)	{pZCON[i-1][j-1][k-1]=1.0;}
	if ( pZCON[i-1][j-1][k-1]<0.0)	{MessageBox("Z Mass not conserved");}


		  }

	int i=m_nx+1;
	int nbx=LabX(i,j,k);

//dangling x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}
	if ( pXCON[i-1][j-1][k-1]>1.0)	{pXCON[i-1][j-1][k-1]=1.0;}
	if ( pXCON[i-1][j-1][k-1]<0.0)	{MessageBox("Xend Mass not conserved");}

	   }
	}
//-------------------------------------------------------------



//--------------------------------------------------------
//Clear up arrays----
	for (int i=0;i<m_nx;i++)
	{
		for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowIn[i][j];
			delete[] TotalFlowOut[i][j];
			delete[] TotalMassIn[i][j];
		}
	}

	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowIn[i];
			delete[] TotalFlowOut[i];
			delete[] TotalMassIn[i];
	}

			delete[] TotalFlowIn;
			delete[] TotalFlowOut;
			delete[] TotalMassIn;
//------------------------------------------
}
//*****************************************************

/*void CAngioNetDlg::NeighX(int i, int j, int k)
{
//Neighbours of x-bonds-----------------------------
	if (i==1)	
	{
		*(pIwork+1-1)=0;				//Iwork(1) [FORTRAN]
		*(pIwork+2-1)=LabX(2,j,k);		//Iwork(2)
		*(pIwork+3-1)=0;				//Iwork(3)
		*(pIwork+4-1)=0;				//Iwork(4)
		*(pIwork+5-1)=LabY(1,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabY(1,j+1,k);	//Iwork(6)
		*(pIwork+7-1)=0;				//Iwork(7)
		*(pIwork+8-1)=0;				//Iwork(8)
		*(pIwork+9-1)=LabZ(1,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(1,j,k+1);	//Iwork(10)
	}
	else if (i==m_nx+1)
	{
		*(pIwork+1-1)=LabX(m_nx,j,k);	//Iwork(1)
		*(pIwork+2-1)=0;				//Iwork(2)
		*(pIwork+3-1)=LabY(m_nx,j,k);	//Iwork(3)
		*(pIwork+4-1)=LabY(m_nx,j+1,k);	//Iwork(4)
		*(pIwork+5-1)=0;				//Iwork(5)
		*(pIwork+6-1)=0;				//Iwork(6)
		*(pIwork+7-1)=LabZ(m_nx,j,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(m_nx,j,k+1);	//Iwork(8)
		*(pIwork+9-1)=0;				//Iwork(9)
		*(pIwork+10-1)=0;				//Iwork(10)
	}
	else
	{
		*(pIwork+1-1)=LabX(i-1,j,k);	//Iwork(1)
		*(pIwork+2-1)=LabX(i+1,j,k);	//Iwork(2)
		*(pIwork+3-1)=LabY(i-1,j,k);	//Iwork(3)
		*(pIwork+4-1)=LabY(i-1,j+1,k);	//Iwork(4)
		*(pIwork+5-1)=LabY(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabY(i,j+1,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i-1,j,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i-1,j,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}

//------------------------------------------------

//Clusters connected to each x-bond--
	*(pNwork+1-1)=( *pIclus+(*(pIwork+1-1)) );  //Nwork(1)=Iclus(Iwork(1))
	*(pNwork+2-1)=( *pIclus+(*(pIwork+2-1)) );  //Nwork(2)=
	*(pNwork+3-1)=( *pIclus+(*(pIwork+3-1)) );  //Nwork(3)=
	*(pNwork+4-1)=( *pIclus+(*(pIwork+4-1)) );  //Nwork(4)=
	*(pNwork+5-1)=( *pIclus+(*(pIwork+5-1)) );  //Nwork(5)=
	*(pNwork+6-1)=( *pIclus+(*(pIwork+6-1)) );  //Nwork(6)=
	*(pNwork+7-1)=( *pIclus+(*(pIwork+7-1)) );  //Nwork(7)=
	*(pNwork+8-1)=( *pIclus+(*(pIwork+8-1)) );  //Nwork(8)=
	*(pNwork+9-1)=( *pIclus+(*(pIwork+9-1)) );  //Nwork(9)=
	*(pNwork+10-1)=( *pIclus+(*(pIwork+10-1)) );  //Nwork(10)=

}
//*****************************************************

void CAngioNetDlg::NeighY(int i, int j, int k)
{
//Neighbours of y-bonds-----------------------------
	if (j==1)	
	{
		*(pIwork+1-1)=LabY(i,m_ny,k);	//Iwork(1) [FORTRAN]
		*(pIwork+2-1)=LabY(i,2,k);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,m_ny,k);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,m_ny,k);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i,m_ny,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i,m_ny,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}
	else if (j==m_ny)
	{
		*(pIwork+1-1)=LabY(i,m_ny-1,k);	//Iwork(1)
		*(pIwork+2-1)=LabY(i,1,k);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,j-1,k);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j-1,k);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i,j-1,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i,j-1,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}
	else
	{
		*(pIwork+1-1)=LabY(i,j-1,k);	//Iwork(1)
		*(pIwork+2-1)=LabY(i,j+1,k);	//Iwork(2)
		*(pIwork+3-1)=LabX(i,j-1,k);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j-1,k);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i,j-1,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i,j-1,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}

//------------------------------------------------

//Clusters connected to each y-bond--
	*(pNwork+1-1)=( *pIclus+(*(pIwork+1-1)) );  //Nwork(1)=Iclus(Iwork(1))
	*(pNwork+2-1)=( *pIclus+(*(pIwork+2-1)) );  //Nwork(2)=
	*(pNwork+3-1)=( *pIclus+(*(pIwork+3-1)) );  //Nwork(3)=
	*(pNwork+4-1)=( *pIclus+(*(pIwork+4-1)) );  //Nwork(4)=
	*(pNwork+5-1)=( *pIclus+(*(pIwork+5-1)) );  //Nwork(5)=
	*(pNwork+6-1)=( *pIclus+(*(pIwork+6-1)) );  //Nwork(6)=
	*(pNwork+7-1)=( *pIclus+(*(pIwork+7-1)) );  //Nwork(7)=
	*(pNwork+8-1)=( *pIclus+(*(pIwork+8-1)) );  //Nwork(8)=
	*(pNwork+9-1)=( *pIclus+(*(pIwork+9-1)) );  //Nwork(9)=
	*(pNwork+10-1)=( *pIclus+(*(pIwork+10-1)) );  //Nwork(10)=
}
//*****************************************************

void CAngioNetDlg::NeighZ(int i, int j, int k)
{
//Neighbours of z-bonds-----------------------------
	if (k==1)	
	{
		*(pIwork+1-1)=LabZ(i,j,m_nz);	//Iwork(1) [FORTRAN]
		*(pIwork+2-1)=LabZ(i,j,2);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,j,m_nz);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j,m_nz);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabY(i,j,m_nz);	//Iwork(7)
		*(pIwork+8-1)=LabY(i,j+1,m_nz);	//Iwork(8)
		*(pIwork+9-1)=LabY(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabY(i,j+1,k);	//Iwork(10)
	}
	else if (k==m_nz)
	{
		*(pIwork+1-1)=LabZ(i,j,m_nz-1);	//Iwork(1)
		*(pIwork+2-1)=LabZ(i,j,1);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,j,k-1);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j,k-1);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabY(i,j,k-1);	//Iwork(7)
		*(pIwork+8-1)=LabY(i,j+1,k-1);	//Iwork(8)
		*(pIwork+9-1)=LabY(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabY(i,j+1,k);	//Iwork(10)
	}
	else
	{
		*(pIwork+1-1)=LabZ(i,j,k-1);	//Iwork(1)
		*(pIwork+2-1)=LabZ(i,j,k+1);	//Iwork(2)
		*(pIwork+3-1)=LabX(i,j,k-1);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j,k-1);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabY(i,j,k-1);	//Iwork(7)
		*(pIwork+8-1)=LabY(i,j+1,k-1);	//Iwork(8)
		*(pIwork+9-1)=LabY(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabY(i,j+1,k);	//Iwork(10)
	}

//------------------------------------------------

//Clusters connected to each z-bond--
	*(pNwork+1-1)=( *pIclus+(*(pIwork+1-1)) );  //Nwork(1)=Iclus(Iwork(1))
	*(pNwork+2-1)=( *pIclus+(*(pIwork+2-1)) );  //Nwork(2)=
	*(pNwork+3-1)=( *pIclus+(*(pIwork+3-1)) );  //Nwork(3)=
	*(pNwork+4-1)=( *pIclus+(*(pIwork+4-1)) );  //Nwork(4)=
	*(pNwork+5-1)=( *pIclus+(*(pIwork+5-1)) );  //Nwork(5)=
	*(pNwork+6-1)=( *pIclus+(*(pIwork+6-1)) );  //Nwork(6)=
	*(pNwork+7-1)=( *pIclus+(*(pIwork+7-1)) );  //Nwork(7)=
	*(pNwork+8-1)=( *pIclus+(*(pIwork+8-1)) );  //Nwork(8)=
	*(pNwork+9-1)=( *pIclus+(*(pIwork+9-1)) );  //Nwork(9)=
	*(pNwork+10-1)=( *pIclus+(*(pIwork+10-1)) );  //Nwork(10)=
}
//*****************************************************
*/

//=======================================================
void CAngioNetDlg::NeighX(int i,int j,int k, int* pIclus,
					int* pIwork,int* pNwork	)
//=======================================================
	{
//Neighbours of x-bonds-----------------------------
	if (i==1)	
	{
		pIwork[1-1]=0;					//Iwork(1) [FORTRAN]
		pIwork[2-1]=LabX(2,j,k);		//Iwork(2)
		pIwork[3-1]=0;					//Iwork(3)
		pIwork[4-1]=0;					//Iwork(4)
		pIwork[5-1]=LabY(1,j,k);		//Iwork(5)
		pIwork[6-1]=LabY(1,j+1,k);		//Iwork(6)
		pIwork[7-1]=0;					//Iwork(7)
		pIwork[8-1]=0;					//Iwork(8)
		pIwork[9-1]=LabZ(1,j,k);		//Iwork(9)
		pIwork[10-1]=LabZ(1,j,k+1);		//Iwork(10)
	}
	else if (i==m_nx+1)
	{
		*(pIwork+1-1)=LabX(m_nx,j,k);	//Iwork(1)
		*(pIwork+2-1)=0;				//Iwork(2)
		*(pIwork+3-1)=LabY(m_nx,j,k);	//Iwork(3)
		*(pIwork+4-1)=LabY(m_nx,j+1,k);	//Iwork(4)
		*(pIwork+5-1)=0;				//Iwork(5)
		*(pIwork+6-1)=0;				//Iwork(6)
		*(pIwork+7-1)=LabZ(m_nx,j,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(m_nx,j,k+1);	//Iwork(8)
		*(pIwork+9-1)=0;				//Iwork(9)
		*(pIwork+10-1)=0;				//Iwork(10)
	}
	else
	{
		*(pIwork+1-1)=LabX(i-1,j,k);	//Iwork(1)
		*(pIwork+2-1)=LabX(i+1,j,k);	//Iwork(2)
		*(pIwork+3-1)=LabY(i-1,j,k);	//Iwork(3)
		*(pIwork+4-1)=LabY(i-1,j+1,k);	//Iwork(4)
		*(pIwork+5-1)=LabY(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabY(i,j+1,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i-1,j,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i-1,j,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}

//------------------------------------------------

//Clusters connected to each x-bond--
	if(pIwork[1-1]!=0)
	{pNwork[1-1]=pIclus[pIwork[1-1]-1];}			//Nwork(1)=Iclus(Iwork(1))
	else
	{pNwork[1-1]=1000000;}
	if(pIwork[2-1]!=0)
	{pNwork[2-1]=pIclus[pIwork[2-1]-1];}			//Nwork(2)=
	else
	{pNwork[2-1]=1000000;}
	if(pIwork[3-1]!=0)
	{pNwork[3-1]=pIclus[pIwork[3-1]-1];}			//Nwork(3)=
	else
	{pNwork[3-1]=1000000;}	
	if(pIwork[4-1]!=0)
	{pNwork[4-1]=pIclus[pIwork[4-1]-1];}			//Nwork(4)=
	else
	{pNwork[4-1]=1000000;}	
	if(pIwork[5-1]!=0)
	{pNwork[5-1]=pIclus[pIwork[5-1]-1];}			//Nwork(5)=
	else
	{pNwork[5-1]=1000000;}	
	if(pIwork[6-1]!=0)
	{pNwork[6-1]=pIclus[pIwork[6-1]-1];}			//Nwork(6)=
	else
	{pNwork[6-1]=1000000;}	
	if(pIwork[7-1]!=0)
	{pNwork[7-1]=pIclus[pIwork[7-1]-1];}			//Nwork(7)=
	else
	{pNwork[7-1]=1000000;}	
	if(pIwork[8-1]!=0)
	{pNwork[8-1]=pIclus[pIwork[8-1]-1];}			//Nwork(8)=
	else
	{pNwork[8-1]=1000000;}	
	if(pIwork[9-1]!=0)
	{pNwork[9-1]=pIclus[pIwork[9-1]-1];}			//Nwork(9)=
	else
	{pNwork[9-1]=1000000;}
	if(pIwork[10-1]!=0)
	{pNwork[10-1]=pIclus[pIwork[10-1]-1];}			//Nwork(10)=
	else
	{pNwork[10-1]=1000000;}
	

}


//*****************************************************

//=======================================================
void CAngioNetDlg::NeighY(int i,int j,int k, int* pIclus,
					int* pIwork,int* pNwork	)
//=======================================================
	{
//Neighbours of y-bonds-----------------------------
	if (j==1)	
	{
		*(pIwork+1-1)=LabY(i,m_ny,k);	//Iwork(1) [FORTRAN]
		*(pIwork+2-1)=LabY(i,2,k);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,m_ny,k);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,m_ny,k);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i,m_ny,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i,m_ny,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}
	else if (j==m_ny)
	{
		*(pIwork+1-1)=LabY(i,m_ny-1,k);	//Iwork(1)
		*(pIwork+2-1)=LabY(i,1,k);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,j-1,k);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j-1,k);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i,j-1,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i,j-1,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}
	else
	{
		*(pIwork+1-1)=LabY(i,j-1,k);	//Iwork(1)
		*(pIwork+2-1)=LabY(i,j+1,k);	//Iwork(2)
		*(pIwork+3-1)=LabX(i,j-1,k);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j-1,k);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabZ(i,j-1,k);	//Iwork(7)
		*(pIwork+8-1)=LabZ(i,j-1,k+1);	//Iwork(8)
		*(pIwork+9-1)=LabZ(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabZ(i,j,k+1);	//Iwork(10)
	}

//------------------------------------------------
//Clusters connected to each y-bond--
	if(pIwork[1-1]!=0)
	{pNwork[1-1]=pIclus[pIwork[1-1]-1];}			//Nwork(1)=Iclus(Iwork(1))
	else
	{pNwork[1-1]=1000000;}
	if(pIwork[2-1]!=0)
	{pNwork[2-1]=pIclus[pIwork[2-1]-1];}			//Nwork(2)=
	else
	{pNwork[2-1]=1000000;}
	if(pIwork[3-1]!=0)
	{pNwork[3-1]=pIclus[pIwork[3-1]-1];}			//Nwork(3)=
	else
	{pNwork[3-1]=1000000;}	
	if(pIwork[4-1]!=0)
	{pNwork[4-1]=pIclus[pIwork[4-1]-1];}			//Nwork(4)=
	else
	{pNwork[4-1]=1000000;}	
	if(pIwork[5-1]!=0)
	{pNwork[5-1]=pIclus[pIwork[5-1]-1];}			//Nwork(5)=
	else
	{pNwork[5-1]=1000000;}	
	if(pIwork[6-1]!=0)
	{pNwork[6-1]=pIclus[pIwork[6-1]-1];}			//Nwork(6)=
	else
	{pNwork[6-1]=1000000;}	
	if(pIwork[7-1]!=0)
	{pNwork[7-1]=pIclus[pIwork[7-1]-1];}			//Nwork(7)=
	else
	{pNwork[7-1]=1000000;}	
	if(pIwork[8-1]!=0)
	{pNwork[8-1]=pIclus[pIwork[8-1]-1];}			//Nwork(8)=
	else
	{pNwork[8-1]=1000000;}	
	if(pIwork[9-1]!=0)
	{pNwork[9-1]=pIclus[pIwork[9-1]-1];}			//Nwork(9)=
	else
	{pNwork[9-1]=1000000;}
	if(pIwork[10-1]!=0)
	{pNwork[10-1]=pIclus[pIwork[10-1]-1];}			//Nwork(10)=
	else
	{pNwork[10-1]=1000000;}
	}


//***********************************************************

//=======================================================
void CAngioNetDlg::NeighZ(int i,int j,int k, int* pIclus,
					int* pIwork,int* pNwork	)
//=======================================================
	{
//Neighbours of z-bonds-----------------------------
	if (k==1)	
	{
		*(pIwork+1-1)=LabZ(i,j,m_nz);	//Iwork(1) [FORTRAN]
		*(pIwork+2-1)=LabZ(i,j,2);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,j,m_nz);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j,m_nz);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabY(i,j,m_nz);	//Iwork(7)
		*(pIwork+8-1)=LabY(i,j+1,m_nz);	//Iwork(8)
		*(pIwork+9-1)=LabY(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabY(i,j+1,k);	//Iwork(10)
	}
	else if (k==m_nz)
	{
		*(pIwork+1-1)=LabZ(i,j,m_nz-1);	//Iwork(1)
		*(pIwork+2-1)=LabZ(i,j,1);		//Iwork(2)
		*(pIwork+3-1)=LabX(i,j,k-1);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j,k-1);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabY(i,j,k-1);	//Iwork(7)
		*(pIwork+8-1)=LabY(i,j+1,k-1);	//Iwork(8)
		*(pIwork+9-1)=LabY(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabY(i,j+1,k);	//Iwork(10)
	}
	else
	{
		*(pIwork+1-1)=LabZ(i,j,k-1);	//Iwork(1)
		*(pIwork+2-1)=LabZ(i,j,k+1);	//Iwork(2)
		*(pIwork+3-1)=LabX(i,j,k-1);	//Iwork(3)
		*(pIwork+4-1)=LabX(i+1,j,k-1);	//Iwork(4)
		*(pIwork+5-1)=LabX(i,j,k);		//Iwork(5)
		*(pIwork+6-1)=LabX(i+1,j,k);	//Iwork(6)
		*(pIwork+7-1)=LabY(i,j,k-1);	//Iwork(7)
		*(pIwork+8-1)=LabY(i,j+1,k-1);	//Iwork(8)
		*(pIwork+9-1)=LabY(i,j,k);		//Iwork(9)
		*(pIwork+10-1)=LabY(i,j+1,k);	//Iwork(10)
	}

//------------------------------------------------

//Clusters connected to each z-bond--
	if(pIwork[1-1]!=0)
	{pNwork[1-1]=pIclus[pIwork[1-1]-1];}			//Nwork(1)=Iclus(Iwork(1))
	else
	{pNwork[1-1]=1000000;}
	if(pIwork[2-1]!=0)
	{pNwork[2-1]=pIclus[pIwork[2-1]-1];}			//Nwork(2)=
	else
	{pNwork[2-1]=1000000;}
	if(pIwork[3-1]!=0)
	{pNwork[3-1]=pIclus[pIwork[3-1]-1];}			//Nwork(3)=
	else
	{pNwork[3-1]=1000000;}	
	if(pIwork[4-1]!=0)
	{pNwork[4-1]=pIclus[pIwork[4-1]-1];}			//Nwork(4)=
	else
	{pNwork[4-1]=1000000;}	
	if(pIwork[5-1]!=0)
	{pNwork[5-1]=pIclus[pIwork[5-1]-1];}			//Nwork(5)=
	else
	{pNwork[5-1]=1000000;}	
	if(pIwork[6-1]!=0)
	{pNwork[6-1]=pIclus[pIwork[6-1]-1];}			//Nwork(6)=
	else
	{pNwork[6-1]=1000000;}	
	if(pIwork[7-1]!=0)
	{pNwork[7-1]=pIclus[pIwork[7-1]-1];}			//Nwork(7)=
	else
	{pNwork[7-1]=1000000;}	
	if(pIwork[8-1]!=0)
	{pNwork[8-1]=pIclus[pIwork[8-1]-1];}			//Nwork(8)=
	else
	{pNwork[8-1]=1000000;}	
	if(pIwork[9-1]!=0)
	{pNwork[9-1]=pIclus[pIwork[9-1]-1];}			//Nwork(9)=
	else
	{pNwork[9-1]=1000000;}
	if(pIwork[10-1]!=0)
	{pNwork[10-1]=pIclus[pIwork[10-1]-1];}			//Nwork(10)=
	else
	{pNwork[10-1]=1000000;}
	}


//*****************************************************

//============================
void CAngioNetDlg::OnDestroy()
//============================
{
	KillTimer(1);
	outfileTot.close();
	outfileUptake.close();
	outfileConc.close();
	//Clean up pressure arrays
	MySolver.cleanupPressureArrays(m_nx,m_ny,m_nz);	//clean up press arrays

	//Clean up dynamic arrays

	delete [] pFluid;

	delete [] pIclusO;
	delete [] pIclusW;
	delete [] pIwork;
	delete [] pNwork;

	delete [] pAgeOfSprout;

	delete [] pSprout;

	
	//------------ MODIF A.S. -------------------
	for (int i=0;i<m_nx+1;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] vFibronectinConc[i][j];
			delete[] vOldFibronectinConc[i][j];
			delete[] vMDFConc[i][j];
			delete[] vOldMDFConc[i][j];
			delete[] vEndoCellDensity[i][j];
			delete[] vOldEndoCellDensity[i][j];
			delete[] vTAFConc[i][j];
			delete[] vOldTAFConc[i][j];
			delete[] vAgeOfSprout[i][j];
			delete[] vSprout[i][j];
			delete[] vSproutsTips[i][j];
			delete[] bBoneTissue[i][j];

			delete[] probP0[i][j];
			delete[] probP1[i][j];
			delete[] probP2[i][j];
			delete[] probP3[i][j];
			delete[] probP4[i][j];
			delete[] probP5[i][j];
			delete[] probP6[i][j];

			delete[] R0inf[i][j];
			delete[] R1inf[i][j];
			delete[] R2inf[i][j];
			delete[] R3inf[i][j];
			delete[] R4inf[i][j];
			delete[] R5inf[i][j];
			delete[] R6inf[i][j];
			delete[] R0sup[i][j];
			delete[] R1sup[i][j];
			delete[] R2sup[i][j];
			delete[] R3sup[i][j];
			delete[] R4sup[i][j];
			delete[] R5sup[i][j];
			delete[] R6sup[i][j];
	}}

	for (int i=0;i<m_nx+1;i++)
	{
		delete[] vFibronectinConc[i];
		delete[] vOldFibronectinConc[i];
		delete[] vMDFConc[i];
		delete[] vOldMDFConc[i];
		delete[] vEndoCellDensity[i];
		delete[] vOldEndoCellDensity[i];
		delete[] vTAFConc[i];
		delete[] vOldTAFConc[i];
		delete[] vAgeOfSprout[i];
		delete[] vSprout[i];
		delete[] vSproutsTips[i];
		delete[] bBoneTissue[i];

		delete[] probP0[i];
		delete[] probP1[i];
		delete[] probP2[i];
		delete[] probP3[i];
		delete[] probP4[i];
		delete[] probP5[i];
		delete[] probP6[i];

		delete[] R0inf[i];
		delete[] R1inf[i];
		delete[] R2inf[i];
		delete[] R3inf[i];
		delete[] R4inf[i];
		delete[] R5inf[i];
		delete[] R6inf[i];
		delete[] R0sup[i];
		delete[] R1sup[i];
		delete[] R2sup[i];
		delete[] R3sup[i];
		delete[] R4sup[i];
		delete[] R5sup[i];
		delete[] R6sup[i];
	}

	delete[] vFibronectinConc;
	delete[] vOldFibronectinConc;
	delete[] vMDFConc;
	delete[] vOldMDFConc;
	delete[] vEndoCellDensity;
	delete[] vOldEndoCellDensity;
	delete[] vTAFConc;
	delete[] vOldTAFConc;
	delete[] vAgeOfSprout;
	delete[] vSprout;
	delete[] vSproutsTips;
	delete[] bBoneTissue;

	delete[] probP0;
	delete[] probP1;
	delete[] probP2;
	delete[] probP3;
	delete[] probP4;
	delete[] probP5;
	delete[] probP6;

	delete[] R0inf;
	delete[] R1inf;
	delete[] R2inf;
	delete[] R3inf;
	delete[] R4inf;
	delete[] R5inf;
	delete[] R6inf;
	delete[] R0sup;
	delete[] R1sup;
	delete[] R2sup;
	delete[] R3sup;
	delete[] R4sup;
	delete[] R5sup;
	delete[] R6sup;

	//-------------------------------------------

	for (int i=0;i<m_nx+1;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] XBR[i][j];
			delete[] XBROld[i][j];
			delete[] XBL[i][j];
			delete[] XCond[i][j];
			delete[] XFlow[i][j];
			delete[] vesselXCond[i][j];
			delete[] pXCON[i][j];
			delete[] XOldFlow[i][j];
			delete[] Xmu[i][j];
			delete[] pXHem[i][j];
			delete[] XTauW[i][j];
			delete[] XTauE[i][j];
			delete[] Prune_AgeX[i][j];
			delete[] ConductedStimX[i][j];
			delete[] ConvectedStimX[i][j];
			delete[] NormFractRBCFlowX[i][j];
	}}

	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] YBR[i][j];
			delete[] YBROld[i][j];
			delete[] YBL[i][j];
			delete[] YCond[i][j];
			delete[] YFlow[i][j];
			delete[] vesselYCond[i][j];
			delete[] pYCON[i][j];
			delete[] YOldFlow[i][j];
			delete[] Ymu[i][j];
			delete[] pYHem[i][j];
			delete[] YTauW[i][j];
			delete[] YTauE[i][j];
			delete[] Prune_AgeY[i][j];
			delete[] ConductedStimY[i][j];
			delete[] ConvectedStimY[i][j];
			delete[] NormFractRBCFlowY[i][j];


			delete[] ZBR[i][j];
			delete[] ZBROld[i][j];
			delete[] ZBL[i][j];
			delete[] ZCond[i][j];
			delete[] ZFlow[i][j];
			delete[] vesselZCond[i][j];
			delete[] pZCON[i][j];
			delete[] ZOldFlow[i][j];
			delete[] Zmu[i][j];
			delete[] pZHem[i][j];
			delete[] ZTauW[i][j];
			delete[] ZTauE[i][j];
			delete[] Prune_AgeZ[i][j];
			delete[] ConductedStimZ[i][j];
			delete[] ConvectedStimZ[i][j];
			delete[] NormFractRBCFlowZ[i][j];
	}}


	for (int i=0;i<m_nx+1;i++)
	{
			delete[] XBR[i];
			delete[] XBROld[i];
			delete[] XBL[i];
			delete[] XCond[i];
			delete[] XFlow[i];
			delete[] vesselXCond[i];
			delete[] pXCON[i];
			delete[] XOldFlow[i];
			delete[] Xmu[i];
			delete[] pXHem[i];
			delete[] XTauW[i];
			delete[] XTauE[i];
			delete[] Prune_AgeX[i];
			delete[] ConductedStimX[i];
			delete[] ConvectedStimX[i];
			delete[] NormFractRBCFlowX[i];
	}

	for (int i=0;i<m_nx;i++)
	{
			delete[] YBR[i];
			delete[] YBROld[i];
			delete[] YBL[i];
			delete[] YCond[i];
			delete[] YFlow[i];
			delete[] vesselYCond[i];
			delete[] pYCON[i];
			delete[] YOldFlow[i];
			delete[] Ymu[i];
			delete[] pYHem[i];
			delete[] YTauW[i];
			delete[] YTauE[i];
			delete[] Prune_AgeY[i];
			delete[] ConductedStimY[i];
			delete[] ConvectedStimY[i];
			delete[] NormFractRBCFlowY[i];

			delete[] ZBR[i];
			delete[] ZBROld[i];
			delete[] ZBL[i];
			delete[] ZCond[i];
			delete[] ZFlow[i];
			delete[] vesselZCond[i];
			delete[] pZCON[i];
			delete[] ZOldFlow[i];
			delete[] Zmu[i];
			delete[] pZHem[i];
			delete[] ZTauW[i];
			delete[] ZTauE[i];
			delete[] Prune_AgeZ[i];
			delete[] ConductedStimZ[i];
			delete[] ConvectedStimZ[i];
			delete[] NormFractRBCFlowZ[i];
	}

			delete[] XBR;
			delete[] XBROld;
			delete[] XBL;
			delete[] XCond;
			delete[] XFlow;
			delete[] vesselXCond;
			delete[] pXCON;
			delete[] XOldFlow;
			delete[] Xmu;
			delete[] pXHem;
			delete[] XTauW;
			delete[] XTauE;
			delete[] Prune_AgeX;
			delete[] ConductedStimX;
			delete[] ConvectedStimX;
			delete[] NormFractRBCFlowX;

			delete[] YBR;
			delete[] YBROld;
			delete[] YBL;
			delete[] YCond;
			delete[] YFlow;
			delete[] vesselYCond;
			delete[] pYCON;
			delete[] YOldFlow;
			delete[] Ymu;
			delete[] pYHem;
			delete[] YTauW;
			delete[] YTauE;
			delete[] Prune_AgeY;
			delete[] ConductedStimY;
			delete[] ConvectedStimY;
			delete[] NormFractRBCFlowY;

			delete[] ZBR;
			delete[] ZBROld;
			delete[] ZBL;
			delete[] ZCond;
			delete[] ZFlow;
			delete[] vesselZCond;
			delete[] pZCON;
			delete[] ZOldFlow;
			delete[] Zmu;
			delete[] pZHem;
			delete[] ZTauW;
			delete[] ZTauE;
			delete[] Prune_AgeZ;
			delete[] ConductedStimZ;
			delete[] ConvectedStimZ;
			delete[] NormFractRBCFlowZ;

	//-----------------------------

	for (int i=0;i<m_nx+2;i++)
	{	for (int j=0;j<m_ny+1;j++)
		{
			delete[] XPOS[i][j];
			delete[] YPOS[i][j];
			delete[] ZPOS[i][j];
	}}

	for (int i=0;i<m_nx+2;i++)
	{
			delete[] XPOS[i];
			delete[] YPOS[i];
			delete[] ZPOS[i];
	}
	delete[] XPOS;
	delete[] YPOS;
	delete[] ZPOS;

	//-----------------------------

//--------------------------------------------------------------


	for (int i=1;i<=m_nx+1;i++)
	{
		for (int j=1;j<=m_ny;j++)
		{
			delete[] pTissueNutrientConc[i-1][j-1];
			delete[] pOldTissueNutrientConc[i-1][j-1];
		}
	}

	for (int i=1;i<=m_nx+1;i++)
	{
			delete[] pTissueNutrientConc[i-1];
			delete[] pOldTissueNutrientConc[i-1];
	}

	delete [] pTissueNutrientConc;
	delete [] pOldTissueNutrientConc;

//--------------------------------------------------

	delete [] pVesselNutrientConc;
	delete [] pOldVesselNutrientConc;

	delete [] D_Transmural;
	delete[] Perm_Vessel;
	delete[] pConcDecrement;

	delete [] bFlowIn;
	delete [] bFlowOut;

	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowsIn[i][j];
			delete[] TotalFlowsOut[i][j];
			delete[] TotalMassesIn[i][j];
	}}
	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowsIn[i];
			delete[] TotalFlowsOut[i];
			delete[] TotalMassesIn[i];
	}
			delete[] TotalFlowsIn;
			delete[] TotalFlowsOut;
			delete[] TotalMassesIn;

//----------------------------------------------------------


//-----Tumour Model array deletions--------

	delete [] pXCoord_TumCell;
	delete [] pYCoord_TumCell;
	delete [] pZCoord_TumCell;

	for (int i=0;i<m_nx+1;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] pTumCellPresent[i][j];
		}
	}

	for (int i=0;i<m_nx+1;i++)
	{
		delete[] pTumCellPresent[i];
	}

	delete[] pTumCellPresent;
//-----------------------------------------



//--Pressure arrays-----------------
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] NodalPressures[i][j];
	}}

	for (int i=0;i<m_nx;i++) { delete[] NodalPressures[i];}

	delete[] NodalPressures;

	delete[] ConsecPressures;


	delete[] FalseFlow;
	delete[] pIclusBone;
}


//*****************************************************

//------------------------------------
int CAngioNetDlg::ProcessMessageLoop()	//allows background running
//------------------------------------
{
	BOOL bDoingBackgroundProcessing=TRUE;
//------------------------------------------------------
	while(bDoingBackgroundProcessing)
	{
		MSG msg;
		//-------------------------------------------
		while(::PeekMessage(&msg,NULL,0,0,PM_NOREMOVE))
		{
			if(!AfxGetApp()->PumpMessage())
			{
				bDoingBackgroundProcessing=FALSE;
				::PostQuitMessage(0);
				break;
			}
		}
		//-------------------------------------------

//let MFC do its idle processing

		LONG lIdle=0;
		while(AfxGetApp()->OnIdle(lIdle++))

			//do background processing here

		bDoingBackgroundProcessing=FALSE;
	}

	return 0;

}


//*****************************************************

//==========================
void CAngioNetDlg::OnClose()
//========================== 
{
	// TODO: Add your message handler code here and/or call default
	OnDestroy();
	CDialog::OnClose();
}


//*****************************************************

//==================================
void CAngioNetDlg::AssignViscosity()
//==================================
{

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
				Xmu[i-1][j-1][k-1]=mu_blood;
				Ymu[i-1][j-1][k-1]=mu_blood;
				Zmu[i-1][j-1][k-1]=mu_blood;
			}
	   		int i=m_nx+1;
			Xmu[i-1][j-1][k-1]=mu_blood;
	}}
}


//*****************************************************

//=====================================
void CAngioNetDlg::setRadiiAndLengths()
//=====================================
{

	double randDice;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{

		randDice=float(rand())/float(RAND_MAX); //(0,1)
		XBR[i-1][j-1][k-1]=Rmin+randDice*(Rmax-Rmin);


		randDice=float(rand())/float(RAND_MAX); //(0,1)
		YBR[i-1][j-1][k-1]=Rmin+randDice*(Rmax-Rmin);


		randDice=float(rand())/float(RAND_MAX); //(0,1)
		ZBR[i-1][j-1][k-1]=Rmin+randDice*(Rmax-Rmin);


		//now get capillaries decreasing as they approach tumour
//		XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]-(double)j/m_ny*2.0e-6;
//		YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]-(double)j/m_ny*2.0e-6;
//		ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]-(double)j/m_ny*2.0e-6;

		  }

		int i=m_nx+1;
		randDice=float(rand())/float(RAND_MAX); //(0,1)
		XBR[i-1][j-1][k-1]=Rmin+randDice*(Rmax-Rmin);

		//now get capillaries decreasing as they approach tumour
//		XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]-(double)j/m_ny*2.0e-6;

	}}


	//-------------------------
	  //ReadVasculatureRadii();
	//-------------------------


//-------MODIF A.S.-------------------------------------------
// This part should be modified depending on the new position 
// of the parent vessel for the vasculature considered.

//*********2D Arterial May 2007 FINE****************
		//----- original 2D vasculature------
		for (int k=1;k<=m_nz;k++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				XBR[i-1][0][k-1]=3.0e-6;//artRad;//
		}}

//-----------------------------------------------
		if(b_venousIncluded)  //Venule included
		{

			for (int k=1;k<=m_nz;k++)
			{	for (int i=1;i<=m_nx+1;i++)
				{
					XBR[i-1][m_ny-1-1][k-1]=3.0e-6;//artRad;//
			}}

		}

//---------------------------------------------
//***************************************************


			//**************CURLY 3D VESSEL  BROKEN!!!**********************
/*	int i,j,k,nbxL,nbxR,nbzI,nbzO;
	j=1;

//	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }


//1st quadrant
	for (i=m_nx/2+1;i<=m_nx ;i++)
	{

		k=int(m_nz/2.0-pow(    (m_nz/2.0)*(m_nz/2.0) -  (i-m_nx)*(i-m_nx) ,0.5 )    );

				XBR[i-1][0][k-1]=artRad;
	}


	for (i=m_nx/2+1;i<=m_nx ;i++)
	{

		k=int(m_nz/2.0-pow(    (m_nz/2.0)*(m_nz/2.0) -  (i-m_nx)*(i-m_nx) ,0.5 )    );

				XBR[i-1][0][k-1]=artRad;
	}



//2nd quadrant
	for (i=1;i<=m_nx/2;i++)
	{

		k=int(m_nz/2.0+pow(    (m_nz/2.0)*(m_nz/2.0) -  (i*i) ,0.5 )   ) ;

				XBR[i-1+1][0][k-1]=artRad;
	}
	
	for (i=1;i<=m_nx/2;i++)
	{

		k=int(m_nz/2.0+pow(    (m_nz/2.0)*(m_nz/2.0) -  (i*i) ,0.5 )   ) ;

				XBR[i-1+1][0][k-1]=artRad;
	}
	//******************END CURLY*****************
*/

		//------- vasculature 3d-linear-30-2.txt ----------
/*		for (int i=1;i<=7;i++) 
		{	
			int j=1;
			k=15;
			XBR[i-1][j-1][k-1]=artRad;
		}
		for (k=16;k<=21;k++)
		{
			int j=1;
			i=7;
			ZBR[i-1][j-1][k-1]=artRad;
		}
		for (i=8;i<=m_nx+1;i++)
		{
			int j=1;
			k=21;
			XBR[i-1][j-1][k-1]=artRad;
		}
*/
//------END MODIF A.S.-----------------------------------------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				XBL[i-1][j-1][k-1]=bondLength;
				YBL[i-1][j-1][k-1]=bondLength;
				ZBL[i-1][j-1][k-1]=bondLength;
			}
			int i=m_nx+1;
			XBL[i-1][j-1][k-1]=bondLength;
	 }}



//distortion included now------------=---------------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			if (j==1) 
			{
				YBL[i-1][j-1][k-1]=bondLength*sqrt	(
	                   pow(XPOS[i][1][k]-XPOS[i][m_ny][k],2.0) +
	                   pow(YPOS[i][1][k]-(YPOS[i][m_ny][k]-m_ny),2.0) +
	                   pow(ZPOS[i][1][k]-ZPOS[i][m_ny][k],2.0)
												);
			}
			else
			{
				YBL[i-1][j-1][k-1]=bondLength*sqrt	(
	                   pow(XPOS[i][j][k]-XPOS[i][j-1][k],2.0) +
	                   pow(YPOS[i][j][k]-YPOS[i][j-1][k],2.0) +
	                   pow(ZPOS[i][j][k]-ZPOS[i][j-1][k],2.0)
												);
			}

			if (k==1) 
			{
				ZBL[i-1][j-1][k-1]=bondLength*sqrt	(
	                   pow(XPOS[i][1][k]-XPOS[i][j][m_nz],2.0) +
	                   pow(YPOS[i][1][k]-YPOS[i][j][m_nz],2.0) +
	                   pow(ZPOS[i][1][k]-(ZPOS[i][j][m_nz]-m_nz),2.0)
												);
			}
			else
			{
				ZBL[i-1][j-1][k-1]=bondLength*sqrt	(
	                   pow(XPOS[i][j][k]-XPOS[i][j][k-1],2.0) +
	                   pow(YPOS[i][j][k]-YPOS[i][j][k-1],2.0) +
	                   pow(ZPOS[i][j][k]-ZPOS[i][j][k-1],2.0)
												);
			}

				XBL[i-1][j-1][k-1]=bondLength*sqrt	(
	                   pow(XPOS[i][j][k]-XPOS[i-1][j][k],2.0) +
	                   pow(YPOS[i][j][k]-YPOS[i-1][j][k],2.0) +
	                   pow(ZPOS[i][j][k]-ZPOS[i-1][j][k],2.0)
												);
		  }	//end i loop

		  int i=m_nx+1;

				XBL[i-1][j-1][k-1]=bondLength*sqrt	(
	                   pow(XPOS[i][j][k]-XPOS[i-1][j][k],2.0) +
	                   pow(YPOS[i][j][k]-YPOS[i-1][j][k],2.0) +
	                   pow(ZPOS[i][j][k]-ZPOS[i-1][j][k],2.0)
												);

	   }	//end j
	}	//end k


//---------------------------------------------



}


//*****************************************************

//======================================
void CAngioNetDlg::SetInitialViscosity()
//======================================
{
	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
				

				//SMcD 10/2004 I have changed the / sign to * for mu values when !=10
				if (pFluid[nbx-1]==10) {Xmu[i-1][j-1][k-1]=mu_blood;}
				else				   {Xmu[i-1][j-1][k-1]=1.0*1.0e30;}
				if (pFluid[nby-1]==10) {Ymu[i-1][j-1][k-1]=mu_blood;}
				else				   {Ymu[i-1][j-1][k-1]=1.0*1.0e30;} 
				if (pFluid[nbz-1]==10) {Zmu[i-1][j-1][k-1]=mu_blood;}
				else				   {Zmu[i-1][j-1][k-1]=1.0*1.0e30;}
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10) {Xmu[i-1][j-1][k-1]=mu_blood;}
			else				   {Xmu[i-1][j-1][k-1]=1.0/1.0e30;}
	}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::assignConductivities()
//=======================================
{
	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  XCond[i-1][j-1][k-1]=pi*pow(XBR[i-1][j-1][k-1],4)/(8.0*mu_blood*XBL[i-1][j-1][k-1]);
			  YCond[i-1][j-1][k-1]=pi*pow(YBR[i-1][j-1][k-1],4)/(8.0*mu_blood*YBL[i-1][j-1][k-1]);
			  ZCond[i-1][j-1][k-1]=pi*pow(ZBR[i-1][j-1][k-1],4)/(8.0*mu_blood*ZBL[i-1][j-1][k-1]);
			}
			int i=m_nx+1;
			  XCond[i-1][j-1][k-1]=pi*pow(XBR[i-1][j-1][k-1],4)/(8.0*mu_blood*XBL[i-1][j-1][k-1]);
	}}

//----------------------------------------------------
//--Set conductivities to 0.0 if fluid is 66 label  MAY NEED /10^6 instead
	//if z <6  (for SOR solution-------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 int nbx,nby,nbz;

			 nbx=LabX(i,j,k);
			 nby=LabY(i,j,k);
			 nbz=LabZ(i,j,k);

			 if(pFluid[nbx-1]==66) {XCond[i-1][j-1][k-1]=0.0;}
			 if(pFluid[nby-1]==66) {YCond[i-1][j-1][k-1]=0.0;}
			 if(pFluid[nbz-1]==66) {ZCond[i-1][j-1][k-1]=0.0;}
			}

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if(pFluid[nbx-1]==66) {XCond[i-1][j-1][k-1]=0.0;}
	}}
}


//*****************************************************

//========================================
void CAngioNetDlg::assignConductivities2()
//========================================
{
	double pi=3.141592654;
	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
				
				if (pFluid[nbx-1]==10)
				{	   XCond[i-1][j-1][k-1]=pi*pow(XBR[i-1][j-1][k-1],4)/(8.0*Xmu[i-1][j-1][k-1]*XBL[i-1][j-1][k-1]);}
				else { XCond[i-1][j-1][k-1]=pi*pow(XBR[i-1][j-1][k-1],4)/(8.0*Xmu[i-1][j-1][k-1]*XBL[i-1][j-1][k-1])
					/1.0e20;}	//1e-50;}
		
				if (pFluid[nby-1]==10)
				{	   YCond[i-1][j-1][k-1]=pi*pow(YBR[i-1][j-1][k-1],4)/(8.0*Ymu[i-1][j-1][k-1]*YBL[i-1][j-1][k-1]);}
				else { YCond[i-1][j-1][k-1]=pi*pow(YBR[i-1][j-1][k-1],4)/(8.0*Ymu[i-1][j-1][k-1]*YBL[i-1][j-1][k-1])
					/1.0e20;}	//1e-50;}

				if (pFluid[nbz-1]==10)
				{      ZCond[i-1][j-1][k-1]=pi*pow(ZBR[i-1][j-1][k-1],4)/(8.0*Zmu[i-1][j-1][k-1]*ZBL[i-1][j-1][k-1]);}
				else { ZCond[i-1][j-1][k-1]=pi*pow(ZBR[i-1][j-1][k-1],4)/(8.0*Zmu[i-1][j-1][k-1]*ZBL[i-1][j-1][k-1])
					/1.0e20;}	//1e-50;}
			 }
			 int i=m_nx+1;
			 nbx=LabX(i,j,k);
				
				if (pFluid[nbx-1]==10)
				{	   XCond[i-1][j-1][k-1]=pi*pow(XBR[i-1][j-1][k-1],4)/(8.0*Xmu[i-1][j-1][k-1]*XBL[i-1][j-1][k-1]);}
				else { XCond[i-1][j-1][k-1]=pi*pow(XBR[i-1][j-1][k-1],4)/(8.0*Xmu[i-1][j-1][k-1]*XBL[i-1][j-1][k-1])
					/1.0e20;}	//1e-50;}
	}}
//NBNBNBNBNB  Vesselconductivities used in pressure solver

//--Set conductivities to 0.0 if fluid is 66 label 
	//int nbx,nby,nbz;

/*	for (k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			 nbx=LabX(i,j,k);
			 nby=LabY(i,j,k);
			 nbz=LabZ(i,j,k);

			 if(pFluid[nbx-1]==66) {XCond[i-1][j-1][k-1]=0.0;}
			 if(pFluid[nby-1]==66) {YCond[i-1][j-1][k-1]=0.0;}
			 if(pFluid[nbz-1]==66) {ZCond[i-1][j-1][k-1]=0.0;}
			}
			 i=m_nx+1;
			 nbx=LabX(i,j,k);

			 if(pFluid[nbx-1]==66) {XCond[i-1][j-1][k-1]=0.0;}
	}}
*/
}


//*****************************************************

//=======================================
void CAngioNetDlg::VesselConductivities()
//=======================================
{
//----------output file for debugging---------------
	ofstream outfile2("DebugOutputFiles/conds.txt");
//--------------------------------------------------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  int nbx,nby,nbz;

			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  if(pFluid[nbx-1]!=10) {vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1]/1.0e20;}
			  else			 	    {vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1];}

			  if(pFluid[nby-1]!=10) {vesselYCond[i-1][j-1][k-1]=YCond[i-1][j-1][k-1]/1.0e20;}
			  else					{vesselYCond[i-1][j-1][k-1]=YCond[i-1][j-1][k-1];}


			  if (j==1) {vesselYCond[i-1][j-1][k-1]=0.0;} //Seal boundary

			  if(pFluid[nbz-1]!=10) {vesselZCond[i-1][j-1][k-1]=ZCond[i-1][j-1][k-1]/1.0e20;}
			  else					{vesselZCond[i-1][j-1][k-1]=ZCond[i-1][j-1][k-1];}
		  
			outfile2 << i << "\t" << j << "\t" << vesselXCond[i-1][j-1][k-1] << 
										  "\t" << vesselYCond[i-1][j-1][k-1] << endl;
			}
		  int i=m_nx+1;
		  int nbx=LabX(i,j,k);

		  if(pFluid[nbx-1]!=10) {vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1]/1.0e20;}
		  else					{vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1];}
	}}
}


//*****************************************************

//======================================
void CAngioNetDlg::PerturbationOnRadii()
//======================================
{

	/*//---------------------------------------------------
	// random perturbation on the radii of all the bonds 
	// of the network
	double randDice;
	double pertubCoeff=2e-6; 

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{

			randDice=float(rand())/float(RAND_MAX); //(0,1)
			XBR[i-1][j-1][k-1]=Rmin+randDice*pertubCoeff;


			randDice=float(rand())/float(RAND_MAX); //(0,1)
			YBR[i-1][j-1][k-1]=Rmin+randDice*pertubCoeff;


			randDice=float(rand())/float(RAND_MAX); //(0,1)
			ZBR[i-1][j-1][k-1]=Rmin+randDice*pertubCoeff;
		  }

		  i=m_nx+1;
		  randDice=float(rand())/float(RAND_MAX); //(0,1)
		  XBR[i-1][j-1][k-1]=Rmin+randDice*pertubCoeff;
	}}

	for (k=1;k<=m_nz;k++)
	{	for (int i=1;i<=m_nx+1;i++)
		{
		  XBR[i-1][0][k-1]=artRad;
	}}
	//-------------------------------------------------------*/


	//--------------------------------------------------------
	// local perturbation of the radii of some of the vessels

 	   YBR[17 -1][2 -1][1 -1]=8e-6;
	   YBR[17 -1][3 -1][1 -1]=8e-6; 

	   YBR[30 -1][2 -1][1 -1]=8e-6;
	   YBR[30 -1][3 -1][1 -1]=8e-6;

	   YBR[49 -1][2 -1][1 -1]=8e-6;
	   YBR[49 -1][3 -1][1 -1]=8e-6;

	   //YBR[62 -1][2 -1][1 -1]=8e-6;
	   //YBR[62 -1][3 -1][1 -1]=8e-6;

	   //YBR[83 -1][2 -1][1 -1]=8e-6;
	   //XBR[84 -1][2 -1][1 -1]=8e-6;
	//--------------------------------------------------------

}


//*****************************************************

//=============================================
void CAngioNetDlg::UpdateVesselConductivities()
//=============================================
{

	//ofstream outfileConduc("UpdateConduc.txt");
	double coeffHonda=0.15;
	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  if (pFluid[nbx-1]!=10)
					 { vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1]/1.0e10;}
			  else   { vesselXCond[i-1][j-1][k-1]=vesselXCond[i-1][j-1][k-1]
				              +(coeffHonda*(XFlow[i-1][j-1][k-1]-XOldFlow[i-1][j-1][k-1]));}
					
			  if (pFluid[nby-1]!=10)
					 { vesselYCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1]/1.0e10;}
			  else   { vesselYCond[i-1][j-1][k-1]=vesselYCond[i-1][j-1][k-1]
				              +(coeffHonda*(YFlow[i-1][j-1][k-1]-YOldFlow[i-1][j-1][k-1]));}

			  if (pFluid[nbz-1]!=10)
					 { vesselZCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1]/1.0e10;}
			  else   { vesselZCond[i-1][j-1][k-1]=vesselZCond[i-1][j-1][k-1]
				              +(coeffHonda*(ZFlow[i-1][j-1][k-1]-ZOldFlow[i-1][j-1][k-1]));}
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

		    if (pFluid[nbx-1]!=10)
					{ vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1]/1.0e10;}
		    else    { vesselXCond[i-1][j-1][k-1]=vesselXCond[i-1][j-1][k-1]
				              +(coeffHonda*(XFlow[i-1][j-1][k-1]-XOldFlow[i-1][j-1][k-1]));}
	}}

	// The conductivity of the parent vessel shoul remain unchanged
	int j=1;
	int k=1;
	for (int i=1;i<=m_nx+1;i++)
	{
		vesselXCond[i-1][j-1][k-1]=XCond[i-1][j-1][k-1];
	}

	//outfileConduc << angiotime << "\t" << vesselXCond[50][50][50] << endl;
}


//*****************************************************

//==============================
void CAngioNetDlg::UpdateRadii()
//==============================
{

	//ofstream outfileConduc("UpdateRadii.txt");
	double coeffRadius=2.0e9;
	double coeffShear=5.0e-6;
	double tauRef=0.007; //tauRef=10 (Pa) for the larger arteriolar vessels of the rat
	int nbx,nby,nbz;
	double MeanFlow=1.0e-17;
	double MeanRadius=3.0e-6;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  if (pFluid[nbx-1]==10)
			  { 
				  //XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]
				    //+(coeffRadius*(XFlow[i-1][j-1][k-1]-XOldFlow[i-1][j-1][k-1]));
				  //-------------
				  //XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]*(1.0+angioDeltaT*10*(
					//log((4.0*mu_blood*fabs(XFlow[i-1][j-1][k-1]))/(PI*pow(XBR[i-1][j-1][k-1],3)))//-log(tauRef)));
				   //-log((4.0*mu_blood*MeanFlow)/(PI*pow(Rmin*2.0,3)))));
				  //-------------
			    	XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]
						+coeffShear*( ((4.0*mu_blood*fabs(XFlow[i-1][j-1][k-1]))/(PI*pow(XBR[i-1][j-1][k-1],3))) );
								     //-((4.0*mu_blood*MeanFlow)/(PI*pow(MeanRadius,3))) );
			  }

			  if (pFluid[nby-1]==10)
			  { 
				  //YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]
					//+(coeffRadius*(YFlow[i-1][j-1][k-1]-YOldFlow[i-1][j-1][k-1]));
				  //-------------
				  //YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]*(1.0+angioDeltaT*10*(
					//log((4.0*mu_blood*fabs(YFlow[i-1][j-1][k-1]))/(PI*pow(YBR[i-1][j-1][k-1],3)))//-log(tauRef)));
				   //-log((4.0*mu_blood*MeanFlow)/(PI*pow(Rmin*2.0,3)))));
				  //-------------
				  	YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]
						+coeffShear*( ((4.0*mu_blood*fabs(YFlow[i-1][j-1][k-1]))/(PI*pow(YBR[i-1][j-1][k-1],3))) );
			  					     //-((4.0*mu_blood*MeanFlow)/(PI*pow(MeanRadius,3))) );
			  }

			  if (pFluid[nbz-1]==10)
			  { 
				  //ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]
					//+(coeffRadius*(ZFlow[i-1][j-1][k-1]-ZOldFlow[i-1][j-1][k-1]));
				  //-------------
				   //ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]*(1.0+angioDeltaT*10*(
					//log((4.0*mu_blood*fabs(ZFlow[i-1][j-1][k-1]))/(PI*pow(ZBR[i-1][j-1][k-1],3)))//-log(tauRef)));
				   //-log((4.0*mu_blood*MeanFlow)/(PI*pow(Rmin*2.0,3)))));
				  //-------------
				  	ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]
						+coeffShear*( ((4.0*mu_blood*fabs(ZFlow[i-1][j-1][k-1]))/(PI*pow(ZBR[i-1][j-1][k-1],3))) );
			  					     //-((4.0*mu_blood*MeanFlow)/(PI*pow(MeanRadius,3))) );
			  }
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10)
			{ 
				//XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]
				  //+(coeffRadius*(XFlow[i-1][j-1][k-1]-XOldFlow[i-1][j-1][k-1]));
				//-------------
				//XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]*(1.0+angioDeltaT*10*(
					//log((4.0*mu_blood*fabs(XFlow[i-1][j-1][k-1]))/(PI*pow(XBR[i-1][j-1][k-1],3)))//-log(tauRef)));
				   //-log((4.0*mu_blood*MeanFlow)/(PI*pow(Rmin*2.0,3)))));
				//-------------
				  XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]
					  +coeffShear*( ((4.0*mu_blood*fabs(XFlow[i-1][j-1][k-1]))/(PI*pow(XBR[i-1][j-1][k-1],3))) );
								   //-((4.0*mu_blood*MeanFlow)/(PI*pow(MeanRadius,3))) );
			}	   				
	}}


	//---------------------------------------------------------
	//the radius of the parent vessel should remain unchanged.
	  for (int kk=1;kk<=m_nz;kk++)
	  {
		  for (int i=1;i<=m_nx+1;i++)
		  {
			XBR[i-1][0][kk-1]=artRad;
	  }}
	//---------------------------------------------------------
}

//*****************************************************

//===============================
void CAngioNetDlg::UpdateRadii2()
//===============================
{

	//----------------- Adaptation according to shear stress ------------------------
	int nbx,nby,nbz;
	double coeffks=0.5;  //1.75 (basal shrinking tendency); 0.7
	double TauRef=0.0103; //(Pa)  (1 dyn/cm2 = 0.1 Pa)
	double RadiusLimitInf=2.0e-6;
	double RadiusLimitSup=28.0e-6;
	double RadiusVariation;
	double epsilon=0.06e-6;

	ConvergenceRadius=true;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  if (pFluid[nbx-1]==10)
			  { 
				RadiusVariation=XBR[i-1][j-1][k-1]*angioDeltaT*(log(XTauW[i-1][j-1][k-1]+TauRef)-coeffks);

			    XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]+RadiusVariation;
				if (XBR[i-1][j-1][k-1]<RadiusLimitInf) {XBR[i-1][j-1][k-1]=RadiusLimitInf;}
				if (XBR[i-1][j-1][k-1]>RadiusLimitSup) {XBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}
			  }
			  if (pFluid[nby-1]==10)
			  { 
				RadiusVariation=YBR[i-1][j-1][k-1]*angioDeltaT*(log(YTauW[i-1][j-1][k-1]+TauRef)-coeffks);

			    YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]+RadiusVariation;	
				if (YBR[i-1][j-1][k-1]<RadiusLimitInf) {YBR[i-1][j-1][k-1]=RadiusLimitInf;}	
				if (YBR[i-1][j-1][k-1]>RadiusLimitSup) {YBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}
			  }
			  if (pFluid[nbz-1]==10)
			  { 
				RadiusVariation=ZBR[i-1][j-1][k-1]*angioDeltaT*(log(ZTauW[i-1][j-1][k-1]+TauRef)-coeffks);
				
			    ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]+RadiusVariation;	
				if (ZBR[i-1][j-1][k-1]<RadiusLimitInf) {ZBR[i-1][j-1][k-1]=RadiusLimitInf;}		
				if (ZBR[i-1][j-1][k-1]>RadiusLimitSup) {ZBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}
			  }
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10)
			{ 
				RadiusVariation=XBR[i-1][j-1][k-1]*angioDeltaT*(log(XTauW[i-1][j-1][k-1]+TauRef)-coeffks);	

			    XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]+RadiusVariation;
				if (XBR[i-1][j-1][k-1]<RadiusLimitInf) {XBR[i-1][j-1][k-1]=RadiusLimitInf;}		
				if (XBR[i-1][j-1][k-1]>RadiusLimitSup) {XBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}
			}	   				
	}}

	//---------------------------------------------------------
	//the radius of the parent vessel should remain unchanged.
	  for (int kk=1;kk<=m_nz;kk++)
	  {
		  for (int i=1;i<=m_nx+1;i++)
		  {
			XBR[i-1][0][kk-1]=artRad;
	  }}
	//---------------------------------------------------------

	//CalculateMinMaxMean(XBR,YBR,ZBR);
	//outfileRadius << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;
}


//*****************************************************

//===============================
void CAngioNetDlg::UpdateRadii3()
//===============================
{
	//%%%%%%%%%%%%%%%% DEBUG %%%%%%%%%%%%%%%%
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  XBROld[i-1][j-1][k-1]=XBR[i-1][j-1][k-1];
			  YBROld[i-1][j-1][k-1]=YBR[i-1][j-1][k-1];
			  ZBROld[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1];
			}
			  XBROld[m_nx][j-1][k-1]=XBR[m_nx][j-1][k-1];
	}}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

//Identify flowing vessels and only adapt flowing vessels
	
//	FlowingVessels();

//--------------------------------------

//---Adaptation according to shear stress and intravascular pressure---
	int nbx,nby,nbz;
	double metab;
	//double coeffks=0.5;  //1.75 (basal shrinking tendency);
	//double coeffkp=0.5;  //0.68;
	//double coeffkm=0.03;  //0.03;  
	//double TauRef=0.0103; //(Pa)  (1 dyn/cm2 = 0.1 Pa)
	//double FlowRef=0.2e-12; //m3/s
	//double RadiusLimitInf=2.0e-6;
	//double RadiusLimitSup=28.0e-6;


//	bool b_NewPries=true;//true;

	double coeffks;//=0.35;//1.7;//1.72;//Pries//    0.35; //0.35;  
	double coeffkp;//=0.1;//0.8;//0.1;//25 ;//0.0;//0.136;//Pries//   0.5;//0.5;//0.0;  //0.5;  
	double coeffkm;//=0.07;//0.5;//0.58;//0.6;//0.7;//0.14;//0.07;     //0.14;//Pries//   0.07; //0.12;
	double coeffkc;//=2.25;//2.0;//2.45;//2.9; //Pries ('98)//0.6;
	double SumRef;//=400;
	double TauRef;//=0.103;//0.5;//0.4;//0.103; //(dyn/cm2)
	double FlowRef;//=1.9096e-11; //1.0e-18*6.0e13;//1.9096e-11; //1.0e-18*6.0e13;//1.0e-14;//1.9096e-11; //m3/s (Flow in PV)
	double RadiusLimitInf;//=3.0e-6; //2.0e-6; (changed by Mike 05/09)
	double RadiusLimitSup;//=12.0e-6;
	double RadiusVariation;
	double epsilon;//=0.06e-6;
	//VALUES USED FOR EARLIER Metab MODEL
	if (b_NewPries==false)
	{
	 coeffks=0.35;//1.7;//1.72;//Pries//    0.35; //0.35;  
	 coeffkp=0.1;//0.8;//0.1;//25 ;//0.0;//0.136;//Pries//   0.5;//0.5;//0.0;  //0.5;  
	 coeffkm=0.07;//0.725;//0.5;//0.58;//0.6;//0.7;//0.14;//0.07;     //0.14;//Pries//   0.07; //0.12;
	 coeffkc=2.25;//2.0;//2.45;//2.9; //Pries ('98)//0.6;
	 SumRef=400;
	 TauRef=0.103;//0.5;//0.4;//0.103; //(dyn/cm2)
	 FlowRef=1.9096e-11; //1.5e-13;//1.0e-18*6.0e13;//1.9096e-11; //1.0e-18*6.0e13;//1.0e-14;//1.9096e-11; //m3/s (Flow in PV)
	 RadiusLimitInf=3.0e-6; //2.0e-6; (changed by Mike 05/09)
	 RadiusLimitSup=12.0e-6;
	 RadiusVariation;
	 epsilon=0.06e-6;
	}
	else
	{
	//VALUES NEEDED FOR NEW Conv/Cond PRIES MODEL
	 coeffks=1.7;//0.35;//1.7;//1.72;//Pries//    0.35; //0.35;  
	 coeffkp=0.8;//0.1;//0.8;//0.1;//25 ;//0.0;//0.136;//Pries//   0.5;//0.5;//0.0;  //0.5;  
	 coeffkm=0.5;//0.38;//0.07;//0.5;//0.58;//0.6;//0.7;//0.14;//0.07;     //0.14;//Pries//   0.07; //0.12;
	 coeffkc=2.6;//3.68;//2.25;//2.0;//2.45;//2.9; //Pries ('98)//0.6;
	 SumRef=250;//400
	 TauRef=0.5;//0.103;//0.5;//0.4;//0.103; //(dyn/cm2)
	 FlowRef=1.0e-18*6.0e13;//1.9096e-11; //1.0e-18*6.0e13;//1.9096e-11; //1.0e-18*6.0e13;//1.0e-14;//1.9096e-11; //m3/s (Flow in PV)
	 RadiusLimitInf=3.0e-6; //2.0e-6; (changed by Mike 05/09)
	 RadiusLimitSup=12.0e-6;
	 RadiusVariation;
	 epsilon=0.06e-6;
	}


	ConvergenceRadius=true;
	double remodellingPCFractionStop=1.001;//0.5; 1.001;	changed by Mike 01/09
	double remodellingPCFractionGo=0.0;
	double carryingCapacity;

//-----------------------------------------------
//if (loop%1000==0)
//{
//	outfileDebugStimuli << endl;
//	outfileDebugStimuli << "Time" << "\t" << flowTime << "\t" 
//						<< "S_wss" << "\t" << "S_p" << "\t" << "S_m" << "\t" << "S_c" 
//						<< "\t" << "Hem" << "\t" << "R_t" << "\t" << "DR" << "\t" 
//						<< "R_t+1" //<< "\t" << "P(mmHg)" 
//						//<< "\t" << "TauE(dyne/cm2)" << "\t" << "WSS(dyne/cm2)" << "\t" << "Viscosity" 
//						<< "\t" << "Flow" << endl;
//}

//-----------------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
	
//---x-bonds---
				if (pFluid[nbx-1]==10)
				{ 
					if (XFlow[i-1][j-1][k-1]==0.0 || pXHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
					else {metab=log10((FlowRef/(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]))+1.0);}
					if (b_NewPries) {metab=0.0;} //no metab if new mechanisms included

					RadiusVariation=XBR[i-1][j-1][k-1]*angioDeltaT*(
										log10(10.0*XTauW[i-1][j-1][k-1]+TauRef)
										-coeffkp*log10(10.0*XTauE[i-1][j-1][k-1])
										+coeffkm*metab
										+coeffkm*log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)))
										+coeffkm*coeffkc*(ConductedStimX[i-1][j-1][k-1]/(ConductedStimX[i-1][j-1][k-1]+SumRef))
										-coeffks
										);

					carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);

//					if (!bFlowingVessel[nbx-1]  || //Edited out by Mike 01/09//  //Modify here for remodelling condition
					if (pPericyteDensity[nbx-1] < remodellingPCFractionGo*carryingCapacity 
						|| pPericyteDensity[nbx-1] > remodellingPCFractionStop*carryingCapacity) 
					{RadiusVariation=0.0;}

					XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]+RadiusVariation;
					if (XBR[i-1][j-1][k-1]<RadiusLimitInf) {XBR[i-1][j-1][k-1]=RadiusLimitInf;}
					if (XBR[i-1][j-1][k-1]>RadiusLimitSup) {XBR[i-1][j-1][k-1]=RadiusLimitSup;}
					if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}

//-----------------------------------------------
if (loop%100==0)
{
	outfileDebugStimuli << "X-Vessel" << "\t" << i << "\t" << j << "\t" 
						<< log10(10.0*XTauW[i-1][j-1][k-1]+TauRef) << "\t"
						<< -coeffkp*log10(10.0*XTauE[i-1][j-1][k-1]) << "\t" 
//						<< coeffkm*metab << "\t"
//						<< ConvectedStimX[i-1][j-1][k-1] << "\t" << fabs(XFlow[i-1][j-1][k-1]) << "\t" << ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1])+FlowRef) << "\t" 
						<< coeffkm*log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef))) << "\t"
//						<< "~~~~~" << "\t" << ConductedStimX[i-1][j-1][k-1] << "\t" 
						<< coeffkm*coeffkc*(ConductedStimX[i-1][j-1][k-1]/(ConductedStimX[i-1][j-1][k-1]+SumRef)) << "\t"
//						<< pXHem[i-1][j-1][k-1] << "\t" << XBROld[i-1][j-1][k-1]*1e6 << "\t"
						<< RadiusVariation*1e6 << "\t" << XBR[i-1][j-1][k-1]*1e6 << "\t" 
	     			  //<< pVesselPressure[nbx-1]*0.007501 << "\t"
					  //<< XTauE[i-1][j-1][k-1]*10.0 << "\t" 
					  //<< XTauW[i-1][j-1][k-1]*10.0 << "\t" << Xmu[i-1][j-1][k-1] << "\t"
						<< XFlow[i-1][j-1][k-1] 
						<< endl;
}

//-----------------------------------------------
			  }	//end if pFluid=10

//-----------------------------------------------
//---y-bonds---
				if (pFluid[nby-1]==10)
				{ 
					if (YFlow[i-1][j-1][k-1]==0.0 || pYHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
					else {metab=log10((FlowRef/(fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1]))+1.0);}
					if (b_NewPries) {metab=0.0;} //no metab if new mechanisms included

					RadiusVariation=YBR[i-1][j-1][k-1]*angioDeltaT*(
										log10(10.0*YTauW[i-1][j-1][k-1]+TauRef)
										-coeffkp*log10(10.0*YTauE[i-1][j-1][k-1])
										+coeffkm*metab
										+coeffkm*log10(1+(ConvectedStimY[i-1][j-1][k-1]/(fabs(YFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)))
										+coeffkm*coeffkc*(ConductedStimY[i-1][j-1][k-1]/(ConductedStimY[i-1][j-1][k-1]+SumRef))
										-coeffks
										);

					carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);

//					if (!bFlowingVessel[nby-1] || //Edited out by Mike 01/09//  //Modify here for remodelling condition
					if (pPericyteDensity[nby-1] < remodellingPCFractionGo*carryingCapacity 
						|| pPericyteDensity[nby-1] > remodellingPCFractionStop*carryingCapacity) 
					{RadiusVariation=0.0;}

					YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]+RadiusVariation;	
					if (YBR[i-1][j-1][k-1]<RadiusLimitInf) {YBR[i-1][j-1][k-1]=RadiusLimitInf;}	
					if (YBR[i-1][j-1][k-1]>RadiusLimitSup) {YBR[i-1][j-1][k-1]=RadiusLimitSup;}
					if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}

//-----------------------------------------------
/*if (angiotime > 8.0) 
{
	outfiletest << "Y-Vessel" << "\t" << i << "," << j << "\t" 
				<< log10(10.0*YTauW[i-1][j-1][k-1]+TauRef) << "\t"
				<< -coeffkp*log10(10.0*YTauE[i-1][j-1][k-1]) << "\t" 
				<< coeffkm*metab << "\t"
				<< pYHem[i-1][j-1][k-1] << "\t" << YBROld[i-1][j-1][k-1]*1e6 << "\t"
				<< RadiusVariation*1e6 << "\t" << YBR[i-1][j-1][k-1]*1e6 << "\t" 
				<< pVesselPressure[nby-1]*0.007501 << "\t"
				<< YTauE[i-1][j-1][k-1]*10.0 << "\t" 
				<< YTauW[i-1][j-1][k-1]*10.0 << "\t" << Ymu[i-1][j-1][k-1] << "\t" 
				<< YFlow[i-1][j-1][k-1] << endl;
}*/

//-----------------------------------------------
			  }	//end if pFluid=10

//-----------------------------------------------
//---z-bonds---
				if (pFluid[nbz-1]==10)
				{ 
					if (ZFlow[i-1][j-1][k-1]==0.0 || pZHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
					else {metab=log10((FlowRef/(fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1]))+1.0);}
					if (b_NewPries) {metab=0.0;} //no metab if new mechanisms included

					RadiusVariation=ZBR[i-1][j-1][k-1]*angioDeltaT*(
										log10(10.0*ZTauW[i-1][j-1][k-1]+TauRef)
										-coeffkp*log10(10.0*ZTauE[i-1][j-1][k-1])
										+coeffkm*metab
										+coeffkm*log10(1+(ConvectedStimZ[i-1][j-1][k-1]/(fabs(ZFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)))
										+coeffkm*coeffkc*(ConductedStimZ[i-1][j-1][k-1]/(ConductedStimZ[i-1][j-1][k-1]+SumRef))
										-coeffks
										);

					carryingCapacity=2.0*ZBR[i-1][j-1][k-1]*angioDeltaZ/pow(RadiusPericyte,2);

//					if (!bFlowingVessel[nbz-1] || //Edited out by Mike 01/09//  //Modify here for remodelling condition
					if (pPericyteDensity[nbz-1] < remodellingPCFractionGo*carryingCapacity 
						|| pPericyteDensity[nbz-1] > remodellingPCFractionStop*carryingCapacity)  
					{RadiusVariation=0.0;}

					ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]+RadiusVariation;	
					if (ZBR[i-1][j-1][k-1]<RadiusLimitInf) {ZBR[i-1][j-1][k-1]=RadiusLimitInf;}		
					if (ZBR[i-1][j-1][k-1]>RadiusLimitSup) {ZBR[i-1][j-1][k-1]=RadiusLimitSup;}
					if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}

				}	//end if pFluid=10

//-----------------------------------------------
			}	//end i loop

//-----------------------------------------------
			int i=m_nx+1;
			nbx=LabX(i,j,k);

//---dangling x-bonds---
			if (pFluid[nbx-1]==10)
			{ 
				if (XFlow[i-1][j-1][k-1]==0.0 || pXHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
				else {metab=log10((FlowRef/(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]))+1.0);}
				if (b_NewPries) {metab=0.0;} //no metab if new mechanisms included

				RadiusVariation=XBR[i-1][j-1][k-1]*angioDeltaT*(
									log10(10.0*XTauW[i-1][j-1][k-1]+TauRef)
									-coeffkp*log10(10.0*XTauE[i-1][j-1][k-1])
									+coeffkm*metab
									+coeffkm*log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)))
									+coeffkm*coeffkc*(ConductedStimX[i-1][j-1][k-1]/(ConductedStimX[i-1][j-1][k-1]+SumRef))
									-coeffks
									);	

				carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);

//				if (!bFlowingVessel[nbx-1] || //Edited out by Mike 01/09//  //Modify here for remodelling condition
				if (pPericyteDensity[nbx-1] < remodellingPCFractionGo*carryingCapacity 
					|| pPericyteDensity[nbx-1] > remodellingPCFractionStop*carryingCapacity)  
				{RadiusVariation=0.0;}

			    XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]+RadiusVariation;
				if (XBR[i-1][j-1][k-1]<RadiusLimitInf) {XBR[i-1][j-1][k-1]=RadiusLimitInf;}		
				if (XBR[i-1][j-1][k-1]>RadiusLimitSup) {XBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}

			}	//end if pFluid=10

//-----------------------------------------------
		}	//end j loop
	}	//end k loop

	if (loop%2000==0)
{
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

//				if	(pFluid[nbx-1]!=10)	{outfileWSSMatrix << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfileWSSMatrix << log10(10.0*XTauW[i-1][j-1][k-1]+TauRef) << "\t";}
//				if	(i==m_nx)	{outfileWSSMatrix << endl;}

//				if	(pFluid[nbx-1]!=10)	{outfilePressMatrix << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfilePressMatrix << coeffkp*log10(10.0*XTauE[i-1][j-1][k-1]) << "\t";}
//				if	(i==m_nx)	{outfilePressMatrix << endl;}

				if	(pFluid[nbx-1]!=10)	{outfileConvectMatrix << "\t";}
				if	(pFluid[nbx-1]==10)	{outfileConvectMatrix << coeffkm*log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef))) << "\t";}
				if	(i==m_nx)	{outfileConvectMatrix << endl;}

				if	(pFluid[nbx-1]!=10)	{outfileConductMatrix << "\t";}
				if	(pFluid[nbx-1]==10)	{outfileConductMatrix << coeffkm*coeffkc*(ConductedStimX[i-1][j-1][k-1]/(ConductedStimX[i-1][j-1][k-1]+SumRef)) << "\t";}
				if	(i==m_nx)	{outfileConductMatrix << endl;}

//				if	(pFluid[nbx-1]!=10)	{outfileFlowMatrix << "1.0e-21" << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfileFlowMatrix << fabs(XFlow[i-1][j-1][k-1]) << "\t";}
//				if	(i==m_nx)	{outfileFlowMatrix << endl;}

//				if	(pFluid[nbx-1]!=10)	{outfileRadMatrix << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfileRadMatrix << XBR[i-1][j-1][k-1] << "\t";}
//				if	(i==m_nx)	{outfileRadMatrix << endl;}

//				if	(pFluid[nbx-1]!=10)	{outfileTotalStimMatrix << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfileTotalStimMatrix << log10(10.0*XTauW[i-1][j-1][k-1]+TauRef)
//																	-coeffkp*log10(10.0*XTauE[i-1][j-1][k-1])
//																	+coeffkm*metab
//																	+coeffkm*log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)))
//																	+coeffkm*coeffkc*(ConductedStimX[i-1][j-1][k-1]/(ConductedStimX[i-1][j-1][k-1]+SumRef))
//																	-coeffks
//																	<< "\t";}
//				if	(i==m_nx)	{outfileTotalStimMatrix << endl;}

//				if	(pFluid[nbx-1]!=10)	{outfileNutrientMatrix << "1.0e-23" << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfileNutrientMatrix << fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]
																	//*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2) 
//																<< "\t";}
//				if	(i==m_nx)	{outfileNutrientMatrix << endl;}

//				if	(pFluid[nbx-1]!=10)	{outfileHemMatrix << "\t";}
//				if	(pFluid[nbx-1]==10)	{outfileHemMatrix << pXHem[i-1][j-1][k-1] << "\t";}
//				if	(i==m_nx)	{outfileHemMatrix << endl;}

			}
		}
	}
}
//-----------------------------------------------
	//the radius of the parent vessel(s?) should remain unchanged.
///	  for (int kk=1;kk<=m_nz;kk++)
///	  {

	int kk=1;
	if (m_nz!=1) {kk=m_nz/2;}	//3D arteriole in middle of top face

	for	(int i=1;i<=m_nx+1;i++)	//do an x-scan
	{
//		XBR[i-1][0][kk-1]=artRad;	//Upper PV
//		XBR[i-1][1][kk-1]=artRad;

		if	(b_venousIncluded || b_UU_wound_Model) //venule if required
		{
//			XBR[i-1][m_ny-1-1][kk-1]=artRad;
		}

//------------------------------------------------------
/*		if	(b_UU_wound_Model && (!b_HexNetwork || (b_HexNetwork && b_StraightPVs))) //UU central wound PVs not remodelled
		{
			for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
			{
				if	(
						i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(nCount*m_ny/(nAdditionalCentralPVs+1)-jCentre,2) )
						||
						i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(nCount*m_ny/(nAdditionalCentralPVs+1)-jCentre,2) )
*/
//-----------------------------------------------
//---Allow remodelling at tips of ablated PVs (pericytes killed?)

/*						nCount*m_ny/(nAdditionalCentralPVs+1)<=m_ny/2-iWoundRadius 
						|| 
						nCount*m_ny/(nAdditionalCentralPVs+1)>=m_ny/2+iWoundRadius
						||
						(
							(i<iCentre-(int)sqrt(  pow(iDamagedRadius,2)-pow(nCount*m_ny/(nAdditionalCentralPVs+1)-jCentre,2) ))
							||
							(i>iCentre+(int)sqrt(  pow(iDamagedRadius,2)-pow(nCount*m_ny/(nAdditionalCentralPVs+1)-jCentre,2) ))
						)
*/
//-----------------------------------------------
/*					)

				{
					XBR[i-1][nCount*m_ny/(nAdditionalCentralPVs+1)-1][kk-1]=UU_PV_AdditionalRadius;
				}

//-----------------------------------------------
			}	//end nCount loop
*/
//-----------------------------------------------
/*			if	(
					i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(m_ny-1-jCentre,2) )
					||
					i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(m_ny-1-jCentre,2) )
*/
//-----------------------------------------------
//---Allow remodelling at tips of ablated PVs (pericytes killed?)

/*					nCount*m_ny/(nAdditionalCentralPVs+1)>m_ny/2-iWoundRadius 
					|| 
					nCount*m_ny/(nAdditionalCentralPVs+1)<m_ny/2+iWoundRadius
					||
					(
						(i<iCentre-(int)sqrt(  pow(iDamagedRadius,2)-pow(m_ny-1-jCentre,2) ))
						||
						(i>iCentre+(int)sqrt(  pow(iDamagedRadius,2)-pow(m_ny-1-jCentre,2) ))
					)

//-----------------------------------------------
				)

				{
					XBR[i-1][m_ny-1-1][kk-1]=artRad;	//lower PV
				}

//-----------------------------------------------
		}	//end if UU wound
*/
//-----------------------------------------------
	}	//end i loop

//-----------------------------------------------
/*
	if	(b_UU_wound_Model && b_HexNetwork && !b_StraightPVs)	//hexagonal vasculature
	{
		for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{
			int	j=nCount*m_ny/(nAdditionalCentralPVs+1);//4;

			if	(int(j/2)-double(j/2.0)==0)	//if j even (inlets & outlets on j+1)
			{
				for (i=2;i<=m_nx-2;i+=3)	//stop some upper x-bonds on PVs remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	//stop rest of upper x-bonds on PVs remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

				for (i=1;i<=m_nx;i+=3)	//stop lower x-bonds on PVs remodelling (including inlets)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				i=m_nx+1;	//stop outlets remodelling
		
				if	(
						i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						||
						i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
					)

				{
					XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	//stop y-bonds (tilted to right) remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	//stop y-bonds (tilted to left) remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

						{
							YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
						}
				}

//-----------------------------------------------
			}	//end if j even

//-----------------------------------------------

			else	//if j odd (inlets & outlets on j)
			{
				for (i=1;i<=m_nx;i+=3)	//stop upper x-bonds on PVs remodelling (including inlets)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				i=m_nx+1;	//stop outlets remodelling
		
				if	(
						i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						||
						i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
					)

				{
					XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
				}

//-----------------------------------------------
				j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

				for (i=2;i<=m_nx-2;i+=3)	//stop some lower x-bonds on PVs remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	//stop rest of lower x-bonds on PVs remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	//stop y-bonds (tilted to left) remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	//stop y-bonds (tilted to right) remodelling
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------								
			}	//end if j odd
//-----------------------------------------------

		}	//end nCount loop

	}	//end if hexagonal vasculature
//-----------------------------------------------
*/
	CalculateMinMaxMean(XBR,YBR,ZBR);
	outfileRadius << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

/*		
//%%%%%%%%%%%%%%%%%%%%%%%%%% DEBUG %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if (loop%20==0)
{
	outfiletest << "Time" << "\t" << angiotime << "\t" 
		        << "S_wss" << "\t" << "S_p" << "\t" << "S_m" << "\t" << "Hem" 
				<< "\t" << "R_t" << "\t" << "DR" << "\t" << "R_t+1" << "\t" << "P(mmHg)" 
				<< "\t" << "TauE(dyne/cm2)" << "\t" << "WSS(dyne/cm2)" << "\t" << "Viscosity" << endl;

	//---- X-Vessel (40,1,1) --------
	if (XFlow[40-1][1-1][1-1]==0.0 || pXHem[40-1][1-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(XFlow[40-1][1-1][1-1])*pXHem[40-1][1-1][1-1]))+1.0);}

	  outfiletest << "X-vessel" << "\t" << "40-1-1" << "\t" 
		          <<log10(10.0*XTauW[40-1][1-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*XTauE[40-1][1-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pXHem[40-1][1-1][1-1] << "\t" 
				  << XBROld[40-1][1-1][1-1]*1e6 << "\t"
	  			  << (XBROld[40-1][1-1][1-1]*angioDeltaT*(
									log10(10.0*XTauW[40-1][1-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[40-1][1-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << XBR[40-1][1-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabX(40,1,1)-1]*0.007501 << "\t"
				  << XTauE[40-1][1-1][1-1]*10.0 << "\t" 
				  << XTauW[40-1][1-1][1-1]*10.0 << "\t" << Xmu[40-1][1-1][1-1] << endl;


	//---- Y-Vessel (14,2,1) --------
	if (YFlow[14-1][2-1][1-1]==0.0 || pYHem[14-1][2-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(YFlow[14-1][2-1][1-1])*pYHem[14-1][2-1][1-1]))+1.0);}

	  outfiletest << "Y-vessel" << "\t" << "14-2-x" << "\t" 
		          <<log10(10.0*YTauW[14-1][2-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*YTauE[14-1][2-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pYHem[14-1][2-1][1-1] << "\t" 
				  << YBROld[14-1][2-1][1-1]*1e6 << "\t"
				  << (YBROld[14-1][2-1][1-1]*angioDeltaT*(
									log10(10.0*YTauW[14-1][2-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[14-1][2-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << YBR[14-1][2-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabY(14,2,1)-1]*0.007501 << "\t"
				  << YTauE[14-1][2-1][1-1]*10.0 << "\t" 
				  << YTauW[14-1][2-1][1-1]*10.0 << "\t" << Ymu[14-1][2-1][1-1] << endl;


	//---- X-Vessel (30,43,1) --------
	if (XFlow[30-1][43-1][1-1]==0.0 || pXHem[30-1][43-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(XFlow[30-1][43-1][1-1])*pXHem[30-1][43-1][1-1]))+1.0);}

	  outfiletest << "X-vessel" << "\t" << "30-43-1" << "\t" 
		          <<log10(10.0*XTauW[30-1][43-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*XTauE[30-1][43-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pXHem[30-1][43-1][1-1] << "\t" 
				  << XBROld[30-1][43-1][1-1]*1e6 << "\t" 
	  			  << (XBROld[30-1][43-1][1-1]*angioDeltaT*(
									log10(10.0*XTauW[30-1][43-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[30-1][43-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << XBR[30-1][43-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabX(30,43,1)-1]*0.007501 << "\t"
				  << XTauE[30-1][43-1][1-1]*10.0 << "\t"
				  << XTauW[30-1][43-1][1-1]*10.0 << "\t" << Xmu[30-1][43-1][1-1] << endl;


	//---- Y-Vessel (30,43,1) --------
	if (YFlow[30-1][43-1][1-1]==0.0 || pYHem[30-1][43-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(YFlow[30-1][43-1][1-1])*pYHem[30-1][43-1][1-1]))+1.0);}

	  outfiletest << "Y-vessel" << "\t" << "30-43-1" << "\t" 
		          <<log10(10.0*YTauW[30-1][43-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*YTauE[30-1][43-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pYHem[30-1][43-1][1-1] << "\t"
				  << YBROld[30-1][43-1][1-1]*1e6 << "\t" 
	  	  		  << (YBROld[30-1][43-1][1-1]*angioDeltaT*(
									log10(10.0*YTauW[30-1][43-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[30-1][43-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t"
				  << YBR[30-1][43-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabY(30,43,1)-1]*0.007501 << "\t" 
				  << YTauE[30-1][43-1][1-1]*10.0 << "\t"
				  << YTauW[30-1][43-1][1-1]*10.0 << "\t" << Ymu[30-1][43-1][1-1] << endl;


	//---- X-Vessel (18,70,1) --------
	if (XFlow[18-1][70-1][1-1]==0.0 || pXHem[18-1][70-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(XFlow[18-1][70-1][1-1])*pXHem[18-1][70-1][1-1]))+1.0);}

	  outfiletest << "X-vessel" << "\t" << "18-70-1" << "\t" 
		          <<log10(10.0*XTauW[18-1][70-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*XTauE[18-1][70-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pXHem[18-1][70-1][1-1] << "\t"
				  << XBROld[18-1][70-1][1-1]*1e6 << "\t" 
	  	  		  << (XBROld[18-1][70-1][1-1]*angioDeltaT*(
									log10(10.0*XTauW[18-1][70-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[18-1][70-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t"
				  << XBR[18-1][70-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabX(18,70,1)-1]*0.007501 << "\t"
				  << XTauE[18-1][70-1][1-1]*10.0 << "\t" 
				  << XTauW[18-1][70-1][1-1]*10.0 << "\t" << Xmu[18-1][70-1][1-1] << endl;


	//---- Y-Vessel (18,70,1) --------
	if (YFlow[18-1][70-1][1-1]==0.0 || pYHem[18-1][70-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(YFlow[18-1][70-1][1-1])*pYHem[18-1][70-1][1-1]))+1.0);}

	  outfiletest << "Y-vessel" << "\t" << "18-70-1" << "\t" 
		          <<log10(10.0*YTauW[18-1][70-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*YTauE[18-1][70-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pYHem[18-1][70-1][1-1] << "\t"
				  << YBROld[18-1][70-1][1-1]*1e6 << "\t" 
	  	  	  	  << (YBROld[18-1][70-1][1-1]*angioDeltaT*(
									log10(10.0*YTauW[18-1][70-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[18-1][70-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << YBR[18-1][70-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabY(18,70,1)-1]*0.007501 << "\t"
				  << YTauE[18-1][70-1][1-1]*10.0 << "\t" 
				  << YTauW[18-1][70-1][1-1]*10.0 << "\t" << Ymu[18-1][70-1][1-1] << endl;

}//end if loop ...
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
*/


//====Now change pericyte densities due to relatively fast dilation/constriction

//	double RadiusPericyte=20.0e-6;	//m^2


	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

			  carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);

			  if(pFluid[nbx-1]==10 && pPericyteDensity[nbx-1] > carryingCapacity)
			  {pPericyteDensity[nbx-1]=carryingCapacity;}
//			  {pPericyteDensity[nbx-1]*=XBROld[i-1][j-1][k-1]/XBR[i-1][j-1][k-1];}

			  carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);

			  if(pFluid[nby-1]==10 && pPericyteDensity[nby-1] > carryingCapacity)
			  {pPericyteDensity[nby-1]=carryingCapacity;}
//			  {pPericyteDensity[nby-1]*=YBROld[i-1][j-1][k-1]/YBR[i-1][j-1][k-1];}

			  carryingCapacity=2.0*ZBR[i-1][j-1][k-1]*angioDeltaZ/pow(RadiusPericyte,2);

			  if(pFluid[nbz-1]==10 && pPericyteDensity[nbz-1] > carryingCapacity)
			  {pPericyteDensity[nbz-1]=carryingCapacity;}
//			  {pPericyteDensity[nbz-1]*=ZBROld[i-1][j-1][k-1]/ZBR[i-1][j-1][k-1];;}


			}

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			  carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
			  
			  if(pFluid[nbx-1]==10 && pPericyteDensity[nbx-1] > carryingCapacity)
			  {pPericyteDensity[nbx-1]=carryingCapacity;}

//			  {pPericyteDensity[nbx-1]*=XBROld[i-1][j-1][k-1]/XBR[i-1][j-1][k-1];}

		}
	}

//-----------------------------------------------
}

//***********************************************
//==========================================
void CAngioNetDlg::getPressuresFromSolver()
//==========================================
{
	for (int k=1 ; k<=m_nz; k++)
	{	for (int j=1 ; j<=m_ny; j++)
		{	for (int i=1 ; i<=m_nx; i++)
			{
				NodalPressures[i-1][j-1][k-1]=MySolver.getPressure(i,j,k,m_nx,m_ny,m_nz);

				///pressurefile << NodalPressures[i-1][j-1][k-1] << "\t";
			}
			    ///pressurefile << endl;
		}
	}

				///pressurefile << endl;
//-------------------------------------------------------
}


//*****************************************************

//=====================================
void CAngioNetDlg::getFlows(int ilabel)
//=====================================
{
//calculates flows for pores that have label ilabel only

//----------output file for debugging---------------

//--------------------------------------------------

	double lowerlimit=1.0e-30;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				XFlow[i-1][j-1][k-1]=0.0;
				YFlow[i-1][j-1][k-1]=0.0;
				ZFlow[i-1][j-1][k-1]=0.0;
			}
			int i=m_nx+1;
			XFlow[i-1][j-1][k-1]=0.0;
	}}


	for (int k=1 ;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==ilabel)
				{

					
					if (i==1){XFlow[i-1][j-1][k-1]=
								(Pin/1.-NodalPressures[0][j-1][k-1])*XCond[i-1][j-1][k-1];}

//					if (i==1){XFlow[i-1][j-1][k-1]=
//								(Pin/(1.0+(double(j)-1)*(4.5/(double(m_ny)-1)))-NodalPressures[0][j-1][k-1])*XCond[i-1][j-1][k-1];}
					
//					///2nd artery needs new BCs - same as in Global FormCoeffsMatrix()
//					if (i==1 && j==m_ny-1 && b_venousIncluded){XFlow[i-1][j-1][k-1]=
//								(Pin/5.5-NodalPressures[0][j-1][k-1])*XCond[i-1][j-1][k-1];}
					///------------------------------------------------------

//					if (i==1 && j==m_ny-1 && k==45){XFlow[i-1][j-1][k-1]=
//								(Pin/5.5-NodalPressures[0][j-1][k-1])*XCond[i-1][j-1][k-1];}

					if (i!=1)	{XFlow[i-1][j-1][k-1]=
								(NodalPressures[i-1-1][j-1][k-1]-NodalPressures[i-1][j-1][k-1])*XCond[i-1][j-1][k-1];}
				}

//////				outfile4x << XFlow[i-1][j-1][k-1] << "\t"; 
//				if(fabs(XFlow[i-1][j-1][k-1])<lowerlimit)	//allieviates num effects
//				{XFlow[i-1][j-1][k-1]=0.0;}
			

				if (pFluid[nby-1]==ilabel)
				{
					if (j==1){YFlow[i-1][j-1][k-1]=
								(NodalPressures[i-1][m_ny-1][k-1]-NodalPressures[i-1][j-1][k-1])*YCond[i-1][j-1][k-1];}
					else	 {YFlow[i-1][j-1][k-1]=
								(NodalPressures[i-1][j-1-1][k-1]-NodalPressures[i-1][j-1][k-1])*YCond[i-1][j-1][k-1];}
				}
//////				outfile4y << YFlow[i-1][j-1][k-1] << "\t"; 

//				if(fabs(YFlow[i-1][j-1][k-1])<lowerlimit)	//allieviates num effects
//				{YFlow[i-1][j-1][k-1]=0.0;}
				//------------------------------------

				if (pFluid[nbz-1]==ilabel)
				{
					if (k==1){ZFlow[i-1][j-1][k-1]=
								(NodalPressures[i-1][j-1][k-m_nz-1]-NodalPressures[i-1][j-1][k-1])*ZCond[i-1][j-1][k-1];}
					else	 {ZFlow[i-1][j-1][k-1]=
								(NodalPressures[i-1][j-1][k-1-1]-NodalPressures[i-1][j-1][k-1])*ZCond[i-1][j-1][k-1];}
				}

//				if(fabs(ZFlow[i-1][j-1][k-1])<lowerlimit)	//allieviates num effects
//				{ZFlow[i-1][j-1][k-1]=0.0;}
			
/*				outfile4 << i;
				outfile4 << "\t";
				outfile4 << j;
				outfile4 << "\t";
				outfile4 << XFlow[i-1][j-1][k-1];
				outfile4 << "\t";
				outfile4 << YFlow[i-1][j-1][k-1];
				outfile4 << "\t";
				outfile4 << ZFlow[i-1][j-1][k-1];
				outfile4 << endl;
*/
			}
				int i=m_nx+1;
				int nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==ilabel)
				{
					XFlow[i-1][j-1][k-1]=(NodalPressures[m_nx-1][j-1][k-1]-Pout/1.)*XCond[i-1][j-1][k-1];

//					if (i==1){XFlow[i-1][j-1][k-1]=(NodalPressures[m_nx-1][j-1][k-1]-Pout/(1.0+(double(j)-1)*(0.1/(double(m_ny)-1))))*XCond[i-1][j-1][k-1];}
					
/*					//-2nd artery----
					if (j==m_ny-1 && b_venousIncluded)
					{
						XFlow[i-1][j-1][k-1]=(NodalPressures[m_nx-1][j-1][k-1]-Pout/5.5)*XCond[i-1][j-1][k-1];
					}
*/					//---------------

//					if (j==m_ny-1 && k==45){XFlow[i-1][j-1][k-1]=(NodalPressures[m_nx-1][j-1][k-1]-Pout/5.5)*XCond[i-1][j-1][k-1];}
				}
//////				outfile4x << XFlow[i-1][j-1][k-1];
//////				outfile4x << endl;
//////				outfile4y << endl; 


//				if(fabs(XFlow[i-1][j-1][k-1])<lowerlimit)	//allieviates num effects
//				{XFlow[i-1][j-1][k-1]=0.0;}

	}}


//////				outfile4x << endl;
//////				outfile4y << endl; 

//----------------------------------------------
}


//*****************************************************

//=======================================================
void CAngioNetDlg::calculatePressuresAndFlows(int ilabel)
//=======================================================
{
	MySolver.solvePressures( b_venousIncluded, m_nx, m_ny, m_nz, 
		vesselXCond,vesselYCond,vesselZCond,Pin,Pout); //whole network

	getPressuresFromSolver();	//copy pressures into main app (from solver)
	getFlows(ilabel);			//calculate the elemental flows for labelled bonds

//	MySolver.cleanupPressureArrays(m_nx,m_ny,m_nz);	//clean up press arrays
}


//*****************************************************

//==================================
void CAngioNetDlg::ConnectToTumour()
//==================================
{
	//------------- simple connection -------------------------------
/*	for (int k=1;k<=m_nz;k++) 
	{	for (int i=1;i<=m_nx;i++)
		{

		//---- connection from level -2 ----
		if (pFluid[LabX(i,m_ny-2,k)-1]==10)   {pFluid[LabY(i,m_ny-1,k)-1]=10; }
		if (pFluid[LabY(i,m_ny-2,k)-1]==10)   {pFluid[LabY(i,m_ny-1,k)-1]=10; }
		if (pFluid[LabZ(i,m_ny-2,k)-1]==10)   {pFluid[LabY(i,m_ny-1,k)-1]=10; }

		//---- connection from level -1 ----
		if (pFluid[LabX(i,m_ny-1,k)-1]==10)   {pFluid[LabY(i,m_ny,k)-1]=10; }
		if (pFluid[LabY(i,m_ny-1,k)-1]==10)   {pFluid[LabY(i,m_ny,k)-1]=10; }
		if (pFluid[LabZ(i,m_ny-1,k)-1]==10)   {pFluid[LabY(i,m_ny,k)-1]=10; }

		//pFluid[LabX(i,m_ny,k)-1]=10; 
		//pFluid[LabZ(i,m_ny,k)-1]=10;	
	}}
*/

	//--------------- tumour surface -------------------------------
	for (int k=1;k<=m_nz;k++) 
	{	for (int i=1;i<=m_nx;i++)
		{
			pFluid[LabX(i,m_ny,k)-1]=10;
	}}

	//------------- extended connection -----------------------------
	/*for (int k=1;k<=m_nz;k++)
	{	for (int i=1;i<=m_nx;i++)
		{
			pFluid[LabX(i,m_ny-1,k)-1]=10;
			pFluid[LabZ(i,m_ny-1,k)-1]=10;
			pFluid[LabX(i,m_ny,k)-1]=0;
			pFluid[LabZ(i,m_ny,k)-1]=0;
			pFluid[LabY(i,m_ny,k)-1]=10;
	}}*/

}


//*****************************************************

//========================================
void CAngioNetDlg::calculateConnectivity()
//========================================
{	
	int NbOfNeigh;
	int NbOfVessel=0;
	int compt0,compt1,compt2,compt3,compt4,compt5,compt6;
	

	//--------------------- First Stripe -----------------------------
	compt0=compt1=compt2=compt3=compt4=compt5=compt6=0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=(int)(m_ny/3);j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
			
			  NbOfNeigh=0;

			  if (pFluid[LabX(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabX(i+1,j,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j+1,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k+1)-1]==10) { NbOfNeigh+=1; }

			  if (NbOfNeigh==0) { compt0+=1; }
		      if (NbOfNeigh==1) { compt1+=1; }
			  if (NbOfNeigh==2) { compt2+=1; }
			  if (NbOfNeigh==3) { compt3+=1; }
			  if (NbOfNeigh==4) { compt4+=1; }
			  if (NbOfNeigh==5) { compt5+=1; }
			  if (NbOfNeigh==6) { compt6+=1; }

	}}}
	outfileConnect << "1st Stripe" << endl;
	outfileConnect << "0" << "\t" << compt0 << endl;
	outfileConnect << "1" << "\t" << compt1 << endl;
	outfileConnect << "2" << "\t" << compt2 << endl;
	outfileConnect << "3" << "\t" << compt3 << endl;
	outfileConnect << "4" << "\t" << compt4 << endl;
	outfileConnect << "5" << "\t" << compt5 << endl;
	outfileConnect << "6" << "\t" << compt6 << endl;

	NbOfVessel=compt0+compt1+compt2+compt3+compt4+compt5+compt6;
	outfileConnect << "Bonds" << "\t" << NbOfVessel << endl;

	NbOfVessel=compt1+compt2+compt3+compt4+compt5+compt6;
	outfileConnect << "Vessels" << "\t" << NbOfVessel << endl;

	//--------------------- Second Stripe ----------------------------	
	compt0=compt1=compt2=compt3=compt4=compt5=compt6=0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=(int)(m_ny/3)+1;j<=(int)(2*m_ny/3);j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
			
			  NbOfNeigh=0;

			  if (pFluid[LabX(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabX(i+1,j,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j+1,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k+1)-1]==10) { NbOfNeigh+=1; }

			  if (NbOfNeigh==0) { compt0+=1; }
		      if (NbOfNeigh==1) { compt1+=1; }
			  if (NbOfNeigh==2) { compt2+=1; }
			  if (NbOfNeigh==3) { compt3+=1; }
			  if (NbOfNeigh==4) { compt4+=1; }
			  if (NbOfNeigh==5) { compt5+=1; }
			  if (NbOfNeigh==6) { compt6+=1; }

	}}}
	outfileConnect << "2nd Stripe" << endl;
	outfileConnect << "0" << "\t" << compt0 << endl;
	outfileConnect << "1" << "\t" << compt1 << endl;
	outfileConnect << "2" << "\t" << compt2 << endl;
	outfileConnect << "3" << "\t" << compt3 << endl;
	outfileConnect << "4" << "\t" << compt4 << endl;
	outfileConnect << "5" << "\t" << compt5 << endl;
	outfileConnect << "6" << "\t" << compt6 << endl;

	NbOfVessel=compt0+compt1+compt2+compt3+compt4+compt5+compt6;
	outfileConnect << "Bonds" << "\t" << NbOfVessel << endl;

	NbOfVessel=compt1+compt2+compt3+compt4+compt5+compt6;
	outfileConnect << "Vessels" << "\t" << NbOfVessel << endl;

	//--------------------- Third Stripe -----------------------------
	compt0=compt1=compt2=compt3=compt4=compt5=compt6=0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=(int)(2*m_ny/3);j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
			
			  NbOfNeigh=0;

			  if (pFluid[LabX(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabX(i+1,j,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j+1,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k+1)-1]==10) { NbOfNeigh+=1; }

			  if (NbOfNeigh==0) { compt0+=1; }
		      if (NbOfNeigh==1) { compt1+=1; }
			  if (NbOfNeigh==2) { compt2+=1; }
			  if (NbOfNeigh==3) { compt3+=1; }
			  if (NbOfNeigh==4) { compt4+=1; }
			  if (NbOfNeigh==5) { compt5+=1; }
			  if (NbOfNeigh==6) { compt6+=1; }

	}}}
	outfileConnect << "3rd Stripe" << endl;
	outfileConnect << "0" << "\t" << compt0 << endl;
	outfileConnect << "1" << "\t" << compt1 << endl;
	outfileConnect << "2" << "\t" << compt2 << endl;
	outfileConnect << "3" << "\t" << compt3 << endl;
	outfileConnect << "4" << "\t" << compt4 << endl;
	outfileConnect << "5" << "\t" << compt5 << endl;
	outfileConnect << "6" << "\t" << compt6 << endl;

	NbOfVessel=compt0+compt1+compt2+compt3+compt4+compt5+compt6;
	outfileConnect << "Bonds" << "\t" << NbOfVessel << endl;

	NbOfVessel=compt1+compt2+compt3+compt4+compt5+compt6;
	outfileConnect << "Vessels" << "\t" << NbOfVessel << endl;


}


//*****************************************************

//========================================
void CAngioNetDlg::calculateConnectivity2()
//========================================
{	
	int NbOfNeigh;
	int NbOfVessel;
	int compt0,compt1,compt2,compt3,compt4,compt5,compt6;

	outfileConnect2 << "j" << "\t" << "compt0" << "\t" << "compt1" << "\t" 
				                   << "compt2" << "\t" << "compt3" << "\t" 
								   << "compt4" << "\t" << "compt5" << "\t" 
								   << "compt6" << "\t" << "Vessels" 
											   << "\t" << "Bonds" << endl;
	for (int j=2;j<=m_ny;j++)
	{	
		NbOfVessel=0;
		compt0=compt1=compt2=compt3=compt4=compt5=compt6=0;
		
		for (int i=1;i<=m_nx;i++)
		{	for (int k=1;k<=m_nz;k++)
			{
			  NbOfNeigh=0;
			  
			  if (pFluid[LabX(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k)-1]==10)   { NbOfNeigh+=1; }
			  if (pFluid[LabX(i+1,j,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabY(i,j+1,k)-1]==10) { NbOfNeigh+=1; }
			  if (pFluid[LabZ(i,j,k+1)-1]==10) { NbOfNeigh+=1; }

			  if (NbOfNeigh==0) { compt0+=1; }
		      if (NbOfNeigh==1) { compt1+=1; }
			  if (NbOfNeigh==2) { compt2+=1; }
			  if (NbOfNeigh==3) { compt3+=1; }
			  if (NbOfNeigh==4) { compt4+=1; }
			  if (NbOfNeigh==5) { compt5+=1; }
			  if (NbOfNeigh==6) { compt6+=1; }
		}}

		NbOfVessel=compt1+compt2+compt3+compt4+compt5+compt6;

		outfileConnect2 << j << "\t" << compt0 << "\t" << compt1 << "\t" 
				                     << compt2 << "\t" << compt3 << "\t" 
								     << compt4 << "\t" << compt5 << "\t" 
								     << compt6 << "\t" << NbOfVessel 
											   << "\t" << NbOfVessel+compt0 << endl;	
	}

}


//*****************************************************

//====================================
void CAngioNetDlg::ReadInVasculature()
//====================================
{
//	return;
//	ifstream inputfile1;
//--------------------------------------------
//	if (m_presetNetwork)
//	{
		ifstream inputfilelin ("LINEAR.txt");
//	}

//	if (m_circTumour)
//	{
		ifstream inputfilecirc ("CIRCULAR.txt");
//}



//ofstream output ("test.txt");

//------- START MODIF A.S.---------------------------------------
//	ifstream inputfilelin("VasculatureType/2d-linear-70x70.txt");
//	ifstream inputfilecirc("VasculatureType/3d-linear-30-2.txt");
//------- END MODIF A.S. --------------------------------------


	int iBit;
		 
	int*** iNodeOnPath=NULL;
	iNodeOnPath=new int**[m_nx];

	for (int i=1;i<=m_nx;i++){ iNodeOnPath[i-1]=new int* [m_ny];}
	for (int i=1;i<=m_nx;i++)
	{	for (int j=1;j<=m_ny;j++){ iNodeOnPath[i-1][j-1]=new int [m_nz];
	}}

	for (int k=1;k<=m_nz;k++)
	{	for (int i=1;i<=m_nx;i++)
		{	for (int j=1;j<=m_ny;j++){ iNodeOnPath[i-1][j-1][k-1]=0;
	}}}

	//------------------read the file content ----------------------
	for (int i=1;i<=m_nx;i++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int k=1;k<=m_nz;k++) 
			{                            
				if (m_presetNetwork)	{inputfilelin >> iBit;}
				else					{inputfilecirc >> iBit;}
										

				if (iBit!=0) { iNodeOnPath[i-1][j-1][k-1]=1; }
			}
		}
	}	
//---------------------


//---- BEGIN MODIF A.S. Extraction of a part of an existing network -----
  ofstream outfileExtract("VasculatureType/ExtractOfNetwork.txt"); 

//3D network
/*  for (i=1;i<=70;i++)
  {	  for (int j=1;j<=70;j++)
	 {	  for (k=1;k<=1;k++)
		{
		  outfileExtract << iNodeOnPath[i-1][j-1][k-1] << "\t";
		}
		  //outfileExtract << endl;
	 } outfileExtract << endl;
	}*/

//2D network
/*  for (i=1;i<=40;i++)
  {	  for (int j=1;j<=40;j++)
	 {	 
		  outfileExtract << iNodeOnPath[i-1][j-1][0] << "\t";
	 }
		  outfileExtract << endl;
  }*/
//---- END MODIF A.S. end extraction of a part of the network -----------
		


//-------------------------------------------------------------
//Fill bonds with vessel if nodes on both sides are on path

		int kstart;				  // MODIF A.S.
		if (m_nz==1) {kstart=1;}  // MODIF A.S.
		else {kstart=2;}          // MODIF A.S.

		for (int k=kstart;k<=m_nz;k++) // MODIF A.S.
		{
			for (int i=2;i<=m_nx;i++)
			{
				for (int j=2;j<=m_ny;j++)
				{
					int nbx=LabX(i,j,k);
					int nby=LabY(i,j,k);
					int nbz=LabZ(i,j,k);

//x-pores-----
		if (iNodeOnPath[i-1][j-1][k-1]==1 && 
			iNodeOnPath[i-1-1][j-1][k-1]==1)		{pFluid[nbx-1]=10;}
//y-pores-----
		if (iNodeOnPath[i-1][j-1][k-1]==1 && 
			iNodeOnPath[i-1][j-1-1][k-1]==1)		{pFluid[nby-1]=10;}
//z-pores-----
		if (iNodeOnPath[i-1][j-1][k-1]==1 && 
			iNodeOnPath[i-1][j-1][k-1-1]==1)		{pFluid[nbz-1]=10;}

				}
			}
		}

//-----------------------------------------------



//------------------------------------------------------------
//Additional bonds needed as they missed by Sandy's input file

//Linear Tumour
		if (m_presetNetwork)
		{
		pFluid[ LabY(17,2,1) -1 ]=10;
		pFluid[ LabY(17,3,1) -1 ]=10;
		pFluid[ LabY(30,2,1) -1 ]=10;
		pFluid[ LabY(49,2,1) -1 ]=10;
		pFluid[ LabY(62,2,1) -1 ]=10;
		pFluid[ LabY(83,2,1) -1 ]=10;
		}
//--------------------------------------------------------------------
//Circular Tumour (additional bonds needed)
//		pFluid[ LabY(17,2,1) -1 ]=10;
//		pFluid[ LabY(17,3,1) -1 ]=10;
//		pFluid[ LabY(30,2,1) -1 ]=10;
//		pFluid[ LabY(49,2,1) -1 ]=10;
//		pFluid[ LabY(62,2,1) -1 ]=10;
//		pFluid[ LabY(83,2,1) -1 ]=10;



		if (m_circTumour)
		{
		pFluid[ LabX(18,2,1) -1 ]=10;
		pFluid[ LabX(18,3,1) -1 ]=10;
		pFluid[ LabY(82,3,1) -1 ]=10;
		pFluid[ LabX(83,2,1) -1 ]=10;
		}

//---------------------------------------------------------------

//----ADDITIONAL MANIPULATION OF VASCULATURE-----------------------
//""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		//Remove a fraction of bonds to look at flow behaviour (Tumour at bottom edge--
//		double fractionOut=0.25;	// /2 because we will only remove x-pores
		if(!m_CentralTumour && m_FractOut!=0)
		{
		RemoveFraction(m_FractOut);		//NBNBNB Any bonds that "trapped will not show
										//on black graphics background, so be careful
										//when looking to see if vasculature HAS in
										//fact loaded correctly but is simply not
										//yet fully connected to inlet
		}
		//---Add these to keep connection on RH leg--
 if(m_presetNetwork && !m_CentralTumour)
 {
		pFluid[ LabX(85,43,1) -1 ]=10;
		pFluid[ LabY(85,43,1) -1 ]=10;
		pFluid[ LabX(86,44,1) -1 ]=10;
		pFluid[ LabY(86,44,1) -1 ]=10;
		pFluid[ LabY(87,44,1) -1 ]=10;
		pFluid[ LabY(87,45,1) -1 ]=10;
		pFluid[ LabX(87,46,1) -1 ]=10;
		pFluid[ LabY(87,46,1) -1 ]=10;
		pFluid[ LabX(85,46,1) -1 ]=10;
		pFluid[ LabY(85,46,1) -1 ]=10;
		pFluid[ LabX(85,44,1) -1 ]=10;
		pFluid[ LabY(85,44,1) -1 ]=10;
 }
//"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


//------Put in second arteriole and symmetric network if requested--------
//+++++++++++++++++++++++++++++++++++
		if (m_CentralTumour)
		{
	SymmetricNetwork();
	RemovePoresForTumour(m_FractOut);//(0.05);	//remove a fraction of the pores for poorly
								//perfused tumour.. NB old version had (int) at start
								//of iCoord and jCoord in the RemovePoresForTum()
								//subroutine, so no dead ends were seen. early results
								//come from this early model (see Notebook).
		}
//++++++++++++++++++++++++++++++++++++
//---------Put in Central Tumour--------------------


//-----END OF ADDITIONAL MANIPULATION----------------------


//-----------------------------------------------------------------

	for (int i=0;i<m_nx;i++)
	{
		for (int j=0;j<m_ny;j++)
		{
			delete[] iNodeOnPath[i][j];
		}
	}

	for (int i=0;i<m_nx;i++)
	{
			delete[] iNodeOnPath[i];
	}

			delete[] iNodeOnPath;
//-------------------------------------------------------------


}


//*****************************************************

//=====================================
void CAngioNetDlg::ReadInVasculature2()
//=====================================
{

	// read a vasculature generated by the sofware and previously 
	// saved with SaveVasculature()
   	//ifstream inputfileSaveVasc("VasculatureType/vasc6-2D-70x70.txt");
	//ifstream inputfileSaveVasc("VasculatureType/L80-rho=0.16.txt");
	//ifstream inputfileSaveVasc("VasculatureType/C80-rho=0.18.txt");
	  //ifstream inputfileSaveVasc("VasculatureType/test-40.txt");

	inputfileSaveVasc >> angiotime;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  inputfileSaveVasc >> pFluid[nbx-1];
			  inputfileSaveVasc >> pFluid[nby-1];
			  inputfileSaveVasc >> pFluid[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			inputfileSaveVasc >> pFluid[nbx-1];
	}}

////SMcDJan2005	RemoveFraction(m_FractOut);

/*
	//-------- TEST ------------

	//---- 1st segment --------
	  for (int j=2;j<=20;j++) {pFluid[LabY(10,j,1)-1]=10;}
	  for (int i=1;i<=10;i++) {pFluid[LabX(i,20,1)-1]=10;}

	//---- 2nd segment --------
	  for (j=2;j<=15;j++)	{pFluid[LabY(30,j,1)-1]=10;}
	  for (i=31;i<=41;i++)	{pFluid[LabX(i,15,1)-1]=10;}

	//---- 3rd segment --------
	  for (j=2;j<=10;j++)  {pFluid[LabY(15,j,1)-1]=10;}
	  for (j=2;j<=10;j++)  {pFluid[LabY(25,j,1)-1]=10;}
	  for (i=16;i<=25;i++) {pFluid[LabX(i,10,1)-1]=10;}

	  for (j=2;j<=40;j++)  {pFluid[LabY(13,j,1)-1]=10;}

	//--------------------------
*/
}


//*****************************************************

//==================================
void CAngioNetDlg::SaveVasculature()
//==================================
{
//	ofstream outfileSaveVasc("SaveVasculature2005.txt");

	outfileSaveVasc << angiotime << endl;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  outfileSaveVasc << pFluid[nbx-1] << "\t";
			  outfileSaveVasc << pFluid[nby-1] << "\t";
			  outfileSaveVasc << pFluid[nbz-1] << "\t";
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSaveVasc << pFluid[nbx-1] << "\t";
	}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::SaveVasculatureRadii()
//=======================================
{
// GLOBAL NOW	ofstream outfileSaveVascRad("SaveVasculatureRadii.txt");

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  outfileSaveVascRad << XBR[i-1][j-1][k-1] << "\t";
			  outfileSaveVascRad << YBR[i-1][j-1][k-1] << "\t";
			  outfileSaveVascRad << ZBR[i-1][j-1][k-1] << "\t";
			}
			  int i=m_nx+1;
			  outfileSaveVascRad << XBR[i-1][j-1][k-1] << "\t";
	}}
}


//*****************************************************

//=======================================
void CAngioNetDlg::ReadVasculatureRadii()
//=======================================
{

///	ifstream inputfileSaveVascRad("VasculatureType/VasculatureRadii-L80-t=3.5.txt");

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  inputfileSaveVascRad >> XBR[i-1][j-1][k-1];
			  inputfileSaveVascRad >> YBR[i-1][j-1][k-1];
			  inputfileSaveVascRad >> ZBR[i-1][j-1][k-1];
			}
			  int i=m_nx+1;
			  inputfileSaveVascRad >> XBR[i-1][j-1][k-1];
	}}
}


//*****************************************************

//=============================================
void CAngioNetDlg::CalculateVasculatureVolume()
//=============================================
{
	
	int nbx,nby,nbz;
	double VascVolume=0.0;

	ofstream outfileVascVolume("Results/VasculatureVolume.txt");
	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
					{ VascVolume+=PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]; }

				if (pFluid[nby-1]==10)
					{ VascVolume+=PI*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]; }

				if (pFluid[nbz-1]==10)
					{ VascVolume+=PI*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]; }
			}
				int i=m_nx+1;
				nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
					{ VascVolume+=PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]; }
	}}

	outfileVascVolume << "Vasculature volume = " << "\t" << VascVolume << endl;
}


//*****************************************************

//===========================================
void CAngioNetDlg::CalculateWallShearStress()
//===========================================
{
	//---------- TauW calculated here is in Pascal ---------------------

	int nbx,nby,nbz;
	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{ XTauW[i-1][j-1][k-1]=(4.0*Xmu[i-1][j-1][k-1]*fabs(XFlow[i-1][j-1][k-1]))/
									   (PI*pow(XBR[i-1][j-1][k-1],3.0)); }

				if (pFluid[nby-1]==10)
				{ YTauW[i-1][j-1][k-1]=(4.0*Ymu[i-1][j-1][k-1]*fabs(YFlow[i-1][j-1][k-1]))/
									   (PI*pow(YBR[i-1][j-1][k-1],3.0)); }

				if (pFluid[nbz-1]==10)
				{ ZTauW[i-1][j-1][k-1]=(4.0*Zmu[i-1][j-1][k-1]*fabs(ZFlow[i-1][j-1][k-1]))/
									   (PI*pow(ZBR[i-1][j-1][k-1],3.0)); }
			}
				int i=m_nx+1;
				nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
				{ XTauW[i-1][j-1][k-1]=(4.0*Xmu[i-1][j-1][k-1]*fabs(XFlow[i-1][j-1][k-1]))/
									   (PI*pow(XBR[i-1][j-1][k-1],3.0)); }
	}}

	CalculateMinMaxMean(XTauW,YTauW,ZTauW);
	runningWSSMAX=MaxValue; // used for graphics

	outfileWallShearStress << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;
}


//*****************************************************

//============================================
void CAngioNetDlg::CalculatePressureInVessel()
//============================================
{
	int nbx,nby,nbz;
	int iminus2,jminus2,kminus2;
	int compt,compt2;
	double VPmin,VPmax,VPmean; //Vessel Pressure (VP)
	double NPmin,NPmax,NPmean; //Nodal Pressure (NP)

	compt=0;
	compt2=0;
	VPmin=1e10;
	VPmax=-1e10;
	VPmean=0.0;
	NPmin=1e10;
	NPmax=-1e10;
	NPmean=0.0;


	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{		
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  if (i==1) {iminus2=m_nx-1;} else {iminus2=i-2;}
			  if (j==1) {jminus2=m_ny-1;} else {jminus2=j-2;}
			  if (k==1) {kminus2=m_nz-1;} else {kminus2=k-2;}

			  if (pFluid[nbx-1]==10)
			  {pVesselPressure[nbx-1]=fabs(NodalPressures[i-1][j-1][k-1]+NodalPressures[iminus2][j-1][k-1])/2.0;}

			  if (pFluid[nby-1]==10)
			  {pVesselPressure[nby-1]=fabs(NodalPressures[i-1][j-1][k-1]+NodalPressures[i-1][jminus2][k-1])/2.0;}

			  if (pFluid[nbz-1]==10)
			  {pVesselPressure[nbz-1]=fabs(NodalPressures[i-1][j-1][k-1]+NodalPressures[i-1][j-1][kminus2])/2.0;}
			}
			int i=m_nx+1;

			if (pFluid[nbx-1]==10)
			{pVesselPressure[nbx-1]=fabs(NodalPressures[0][j-1][k-1]+NodalPressures[iminus2][j-1][k-1])/2.0;}
	}}


	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{		
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  if (pFluid[nbx-1]==10)
			  {
				  compt+=1;
				  if (pVesselPressure[nbx-1]<VPmin) {VPmin=pVesselPressure[nbx-1];}
				  if (pVesselPressure[nbx-1]>VPmax) {VPmax=pVesselPressure[nbx-1];}
				  VPmean+=pVesselPressure[nbx-1];
			  }
			  if (pFluid[nby-1]==10)
			  {
			  	  compt+=1;
				  if (pVesselPressure[nby-1]<VPmin) {VPmin=pVesselPressure[nby-1];}
				  if (pVesselPressure[nby-1]>VPmax) {VPmax=pVesselPressure[nby-1];}
				  VPmean+=pVesselPressure[nby-1];
			  }
			  if (pFluid[nbz-1]==10)
			  {
				  compt+=1;
				  if (pVesselPressure[nbz-1]<VPmin) {VPmin=pVesselPressure[nbz-1];}
				  if (pVesselPressure[nbz-1]>VPmax) {VPmax=pVesselPressure[nbz-1];}
				  VPmean+=pVesselPressure[nbz-1];	  
			  }
			}
			  int i=m_nx+1;
			  nbx=LabX(i,j,k);

			  if (pFluid[nbx-1]==10)
			  {
				  compt+=1;
				  if (pVesselPressure[nbx-1]<VPmin) {VPmin=pVesselPressure[nbx-1];}
				  if (pVesselPressure[nbx-1]>VPmax) {VPmax=pVesselPressure[nbx-1];}
				  VPmean+=pVesselPressure[nbx-1];
			  }
	}}

	VPmean=VPmean/compt;
	outfileVesselPressure << angiotime << "\t" << VPmin << "\t" << VPmax << "\t" << VPmean << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  compt2+=1;
			  if (NodalPressures[i-1][j-1][k-1]<NPmin) {NPmin=NodalPressures[i-1][j-1][k-1];}
			  if (NodalPressures[i-1][j-1][k-1]>NPmax) {NPmax=NodalPressures[i-1][j-1][k-1];}
			  NPmean+=NodalPressures[i-1][j-1][k-1];
	}}}
	
	NPmean=NPmean/compt2;
	outfileNodalPressure << angiotime << "\t" << NPmin << "\t" << NPmax << "\t" << NPmean << endl;

}


//*****************************************************

//=================================
void CAngioNetDlg::SproutPressure()
//=================================
{	

	//double TissuePressure = 9000.0; //(Pa)
	//double FlowValue=5.0e-13; 

	outfiletest2 << angiotime << "\t" << XFlow[10][0][0] << "\t" << XFlow[20][0][0] << endl;

	for (int k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
			{	//NodalPressures[i-1][j-1][k-1]=TissuePressure;
				//XFlow[i-1][j-1][k-1]=FlowValue;
				outfiletest2 << "xbond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-1][j-1][k-1] << "\t" << XFlow[i-1][j-1][k-1] << "\t" << pFluid[nbx-1] << endl; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
			{	//NodalPressures[i-1][j-1][k-1]=TissuePressure;
				//YFlow[i-1][j-1][k-1]=FlowValue;
				outfiletest2 << "ybond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-1][j-1][k-1] << "\t" << YFlow[i-1][j-1][k-1] << "\t" << pFluid[nby-1] << endl; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true)
			{	//NodalPressures[i-1][j-1][k-1]=TissuePressure;
				//ZFlow[i-1][j-1][k-1]=FlowValue;
				outfiletest2 << "zbond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-1][j-1][k-1] << "\t" << ZFlow[i-1][j-1][k-1] << "\t" << pFluid[nbz-1] << endl; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1)
			{	//NodalPressures[i-2][j-1][k-1]=TissuePressure;
				//XFlow[i-2][j-1][k-1]=FlowValue;
				outfiletest2 << "xbond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-2][j-1][k-1] << "\t" << XFlow[i-2][j-1][k-1] << "\t" << pFluid[nbx-1] << endl; }
			if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1)
			{	//NodalPressures[i-1][j-2][k-1]=TissuePressure;
				//YFlow[i-1][j-2][k-1]=FlowValue;
				outfiletest2 << "ybond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-1][j-2][k-1] << "\t" << YFlow[i-1][j-2][k-1] << "\t" << pFluid[nby-1] << endl; }
			if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1)
			{	//NodalPressures[i-1][j-1][k-2]=TissuePressure;
				//ZFlow[i-1][j-1][k-2]=FlowValue;
				outfiletest2 << "zbond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-1][j-1][k-2] << "\t" << ZFlow[i-1][j-1][k-2] << "\t" << pFluid[nbz-1] << endl; }
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
			{	//NodalPressures[i-1][j-1][k-1]=TissuePressure;
				//XFlow[i-1][j-1][k-1]=FlowValue;
				outfiletest2 << "xbond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-1][j-1][k-1] << "\t" << XFlow[i-1][j-1][k-1] << "\t" << pFluid[nbx-1] << endl; }
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false)
			{	//NodalPressures[i-2][j-1][k-1]=TissuePressure;
				//XFlow[i-2][j-1][k-1]=FlowValue;
				outfiletest2 << "xbond" << "\t" << i << "\t" << j << "\t" 
							<< NodalPressures[i-2][j-1][k-1] << "\t" << XFlow[i-2][j-1][k-1] << "\t" << pFluid[nbx-1] << endl; }
	}}
}


//*****************************************************

//================================
void CAngioNetDlg::CalculateTauE()
//================================
{
	//--------- TauE calculated here is in Pascal ----------------

	//-----------------------------------IMPORTANT --------------------------------------
	// TauE(P) this law is given for P in mmHg and TauE in dyn/cm2
	// TauE is multiplied by 0.1 in order to convert dyn/cm2 into Pascal (1dyn/cm2=0.1Pa)
	// The pressures (NodalPressures) are multiplied by 0.007501 in order to convert 
	// Pascal into mmHg (1Pa=0.007501mmHg)
		double convPa=0.007501;
	//-----------------------------------------------------------------------------------

	CalculatePressureInVessel();

	int nbx,nby,nbz;
	int iminus2,jminus2,kminus2;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				XTauE[i-1][j-1][k-1]=0.0;
				YTauE[i-1][j-1][k-1]=0.0;
				ZTauE[i-1][j-1][k-1]=0.0;


			    if (i==1) {iminus2=m_nx-1;} else {iminus2=i-2;}
			    if (j==1) {jminus2=m_ny-1;} else {jminus2=j-2;}
			    if (k==1) {kminus2=m_nz-1;} else {kminus2=k-2;}

				if(convPa*pVesselPressure[nbx-1] < 10.0)
				{pVesselPressure[nbx-1]=10.1/convPa;}	//avoids singularities (low P venous system
				if(convPa*pVesselPressure[nby-1] < 10.0)
				{pVesselPressure[nby-1]=10.1/convPa;}	//avoids singularities (low P venous system
				if(convPa*pVesselPressure[nbz-1] < 10.0)
				{pVesselPressure[nbz-1]=10.1/convPa;}	//avoids singularities (low P venous system




				if (pFluid[nbx-1]==10 && convPa*pVesselPressure[nbx-1] >=10.0)//avoid singularity
				{   XTauE[i-1][j-1][k-1]=0.1*(100.0-86.0*exp(-5000.0*pow(log10(log10(convPa*pVesselPressure[nbx-1])),5.4)));}

				if (pFluid[nby-1]==10 && convPa*pVesselPressure[nby-1] >=10.0)
				{   YTauE[i-1][j-1][k-1]=0.1*(100.0-86.0*exp(-5000.0*pow(log10(log10(convPa*pVesselPressure[nby-1])),5.4)));}
				
				if (pFluid[nbz-1]==10 && convPa*pVesselPressure[nbz-1] >=10.0)
				{   ZTauE[i-1][j-1][k-1]=0.1*(100.0-86.0*exp(-5000.0*pow(log10(log10(convPa*pVesselPressure[nbz-1])),5.4)));}
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			XTauE[i-1][j-1][k-1]=0.0;
			if(convPa*pVesselPressure[nbx-1] < 10.0)
			{pVesselPressure[nbx-1]=10.1/convPa;}	//avoids singularities (low P venous system


				if (pFluid[nbx-1]==10 && convPa*pVesselPressure[nbx-1] >=10.0)
				{   XTauE[i-1][j-1][k-1]=0.1*(100.0-86.0*exp(-5000.0*pow(log10(log10(convPa*pVesselPressure[nbx-1])),5.4)));}
	}}
}


//*****************************************************

//==================================
void CAngioNetDlg::UpdateViscosity()
//==================================
{
	int nbx,nby,nbz;

	//------------------ Viscosity as a function of the radius --------------------------------
/*	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{ Xmu[i-1][j-1][k-1]=(pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*XBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*XBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),4))
									*mu_plasma;
				  //Xmu[i-1][j-1][k-1]=mu_blood;
				}
				if (pFluid[nby-1]==10)
				{ Ymu[i-1][j-1][k-1]=(pow((2.0*YBR[i-1][j-1][k-1]*1e6)/(2.0*YBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*YBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*YBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*YBR[i-1][j-1][k-1]*1e6)/(2.0*YBR[i-1][j-1][k-1]*1e6-1.1),4))
									*mu_plasma;
				  //Ymu[i-1][j-1][k-1]=mu_blood;
				}
				if (pFluid[nbz-1]==10)
				{ Zmu[i-1][j-1][k-1]=(pow((2.0*ZBR[i-1][j-1][k-1]*1e6)/(2.0*ZBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*ZBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*ZBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*ZBR[i-1][j-1][k-1]*1e6)/(2.0*ZBR[i-1][j-1][k-1]*1e6-1.1),4))
									*mu_plasma;
				  //Zmu[i-1][j-1][k-1]=mu_blood;
				}
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
				{ Xmu[i-1][j-1][k-1]=(pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*XBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*XBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),4))
									*mu_plasma;
				  //Xmu[i-1][j-1][k-1]=mu_blood;
				}
	}}
*/
	//------------------ Viscosity as a function of the radius and the hematocrit -----------------
	double CoeffX1,CoeffX2,CoeffHt;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{ 
				  if (pXHem[i-1][j-1][k-1]<0.0001) {Xmu[i-1][j-1][k-1]=mu_plasma;}
				  else 
				  {
					CoeffX1=1.0/(1+pow(10,-11)*pow(2.0*XBR[i-1][j-1][k-1],12));
					CoeffX2=(0.8+exp(-0.15*XBR[i-1][j-1][k-1]))*(-1.0+CoeffX1)+CoeffX1;
					CoeffHt=(pow(1.0-pXHem[i-1][j-1][k-1],CoeffX2)-1.0)/(pow(1.0-AverageHt,CoeffX2)-1.0);
					
					Xmu[i-1][j-1][k-1]=(pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*XBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*XBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),4)*CoeffHt)
									*mu_plasma;
				  }
				}
				if (pFluid[nby-1]==10)
				{ 
				  if (pYHem[i-1][j-1][k-1]<0.0001) {Ymu[i-1][j-1][k-1]=mu_plasma;}
				  else
				  {
					CoeffX1=1.0/(1+pow(10,-11)*pow(2.0*YBR[i-1][j-1][k-1],12));
					CoeffX2=(0.8+exp(-0.15*YBR[i-1][j-1][k-1]))*(-1.0+CoeffX1)+CoeffX1;
					CoeffHt=(pow(1.0-pYHem[i-1][j-1][k-1],CoeffX2)-1.0)/(pow(1.0-AverageHt,CoeffX2)-1.0);
					
					Ymu[i-1][j-1][k-1]=(pow((2.0*YBR[i-1][j-1][k-1]*1e6)/(2.0*YBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*YBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*YBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*YBR[i-1][j-1][k-1]*1e6)/(2.0*YBR[i-1][j-1][k-1]*1e6-1.1),4)*CoeffHt)
									*mu_plasma;
				  }
				}
				if (pFluid[nbz-1]==10)
				{ 
				  if (pZHem[i-1][j-1][k-1]<0.0001) {Zmu[i-1][j-1][k-1]=mu_plasma;}
				  else
				  {
					CoeffX1=1.0/(1+pow(10,-11)*pow(2.0*ZBR[i-1][j-1][k-1],12));
					CoeffX2=(0.8+exp(-0.15*ZBR[i-1][j-1][k-1]))*(-1.0+CoeffX1)+CoeffX1;
					CoeffHt=(pow(1.0-pZHem[i-1][j-1][k-1],CoeffX2)-1.0)/(pow(1.0-AverageHt,CoeffX2)-1.0);
					
					Zmu[i-1][j-1][k-1]=(pow((2.0*ZBR[i-1][j-1][k-1]*1e6)/(2.0*ZBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*ZBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*ZBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*ZBR[i-1][j-1][k-1]*1e6)/(2.0*ZBR[i-1][j-1][k-1]*1e6-1.1),4)*CoeffHt)
									*mu_plasma;
				  }
				}
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
				{ 
				  if (pXHem[i-1][j-1][k-1]<0.0001) {Xmu[i-1][j-1][k-1]=mu_plasma;}
				  else
				  {
					CoeffX1=1.0/(1+pow(10,-11)*pow(2.0*XBR[i-1][j-1][k-1],12));
					CoeffX2=(0.8+exp(-0.15*XBR[i-1][j-1][k-1]))*(-1.0+CoeffX1)+CoeffX1;
					CoeffHt=(pow(1.0-pXHem[i-1][j-1][k-1],CoeffX2)-1.0)/(pow(1.0-AverageHt,CoeffX2)-1.0);
					
					Xmu[i-1][j-1][k-1]=(pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),2)
									 +(6.0*exp(-0.17*XBR[i-1][j-1][k-1]*1e6)
									 +3.2-2.4*exp(-0.06*pow(2.0*XBR[i-1][j-1][k-1]*1e6,0.645))-1)*
									 pow((2.0*XBR[i-1][j-1][k-1]*1e6)/(2.0*XBR[i-1][j-1][k-1]*1e6-1.1),4)*CoeffHt)
									*mu_plasma;
				  }
				}
	}}

	//---------------------------------------------------------------------------------------------

	//CalculateMinMaxMean(Xmu,Ymu,Zmu);
	//outfileViscosity << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

}


//*****************************************************

//===============================
void CAngioNetDlg::TumourUptake()
//===============================
{
	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=m_ny-1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				adsorbedmass+=pXCON[i-1][j-1][k-1]*
					(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]);
				adsorbedmass+=pYCON[i-1][j-1][k-1]*
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]);
				adsorbedmass+=pZCON[i-1][j-1][k-1]*
					(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]);

				pXCON[i-1][j-1][k-1]=0.0;
				pYCON[i-1][j-1][k-1]=0.0;
				pZCON[i-1][j-1][k-1]=0.0;

///				pXHem[i-1][j-1][k-1]=0.0;
///				pYHem[i-1][j-1][k-1]=0.0;
///				pZHem[i-1][j-1][k-1]=0.0;
	}}}

	//------------------------------------------------------------
//	 outfileUptake << angiotime << "\t" << adsorbedmass << endl; 
	//------------------------------------------------------------
}


//*****************************************************

//===========================
void CAngioNetDlg::OnLinTum()
//=========================== 
{
	// TODO: Add your control notification handler code here
	//get pointers to the 2 check boxes 

	CButton* pLinTum=(CButton*)GetDlgItem(IDC_CHECK1);
	CButton* pCircTum=(CButton*)GetDlgItem(IDC_CIRCTUM);

	//if one is selected, deselect the other
	if (pLinTum->GetCheck())
	{
		pCircTum->SetCheck(0);
	}
}


//*****************************************************

//============================
void CAngioNetDlg::OnCirctum()
//============================ 
{
	// TODO: Add your control notification handler code here
	CButton* pLinTum=(CButton*)GetDlgItem(IDC_CHECK1);
	CButton* pCircTum=(CButton*)GetDlgItem(IDC_CIRCTUM);

	//if one is selected, deselect the other
	if (pCircTum->GetCheck())
	{
		pLinTum->SetCheck(0);
	}
}


//*****************************************************

//=================================
void CAngioNetDlg::NodalPositions()
//=================================
{
//Updated by Mike 10/09 to allow a hexagonal 
//grid (see written explanation for full details)

//NB here, I use the actual i,j,k for array indices and I do NOT
//decrement them by 1 to account for C++ vs FORTRAN array bounds variation
//(I usually translate the FOR loop from FORTRAN exactly using a < sign
//and decrement each array index by 1 to keep things consistent)

	if	(!b_HexNetwork)	//square grid
	{
//---Initialise nodal positions---
		for	(int knode=1;knode<=m_nz;knode++)
		{
			for (int jnode=1;jnode<=m_ny;jnode++)
			{
				for (int inode=0;inode<=m_nx+1;inode++)
				{
					XPOS[inode][jnode][knode]=inode;
					YPOS[inode][jnode][knode]=jnode;
					ZPOS[inode][jnode][knode]=knode;
				}
			}
		}

//-----------------------------------------------
//---Update these if distort is used---
		for (int knode=1;knode<=m_nz;knode++)
		{
			for (int jnode=1;jnode<=m_ny;jnode++)
			{
				for (int inode=0;inode<=m_nx+1;inode++)
				{
					double randi=float(rand())/float(RAND_MAX); //(0,1)
					double randj=float(rand())/float(RAND_MAX); //(0,1)
					double randk=float(rand())/float(RAND_MAX); //(0,1)

					double rand1=float(rand())/float(RAND_MAX); //(0,1)
	   				if (rand1 > 0.5) 
					{
						XPOS[inode][jnode][knode]=double(inode+m_distort*randi);
					}

					else
					{
						XPOS[inode][jnode][knode]=double(inode-m_distort*randi);
					}

//-----------------------------------------------
					double rand2=float(rand())/float(RAND_MAX); //(0,1)
	   				if (rand2 > 0.5) 
					{
						YPOS[inode][jnode][knode]=double(jnode+m_distort*randj);
					}
				
					else
					{
						YPOS[inode][jnode][knode]=double(jnode-m_distort*randj);
					}

//-----------------------------------------------
					double rand3=float(rand())/float(RAND_MAX); //(0,1)
	   				if (rand3 > 0.5) 
					{
						ZPOS[inode][jnode][knode]=double(knode+m_distort*randk);
					}

					else
					{
						ZPOS[inode][jnode][knode]=double(knode-m_distort*randk);
					}

//-----------------------------------------------
///		DebugNodes << inode << "\t" << jnode << "\t" << knode << "\t" <<
///		XPOS[inode][jnode][knode] << "\t" << YPOS[inode][jnode][knode]
///		<< "\t" << ZPOS[inode][jnode][knode] << endl;

				}	//end i loop

//-----------------------------------------------
//---KEEP INLET and OUTLET FIXED---

				XPOS[0][jnode][knode]=0.0;  
				YPOS[0][jnode][knode]=double(jnode);
				ZPOS[0][jnode][knode]=double(knode);

				XPOS[m_nx+1][jnode][knode]=double(m_nx+1);
				YPOS[m_nx+1][jnode][knode]=double(jnode);
				ZPOS[m_nx+1][jnode][knode]=double(knode);

//-----------------------------------------------
			}	//end j loop
		}		//end k loop

//-----------------------------------------------
	}	//end if !Hex

//-----------------------------------------------
	else	//hexagonal grid
	{
		int inode,jnode,knode;

//---Initialise nodal positions---
		for (knode=1;knode<=m_nz;knode++)
		{
			for (jnode=1;jnode<=m_ny;jnode++)
			{
				for (inode=0;inode<=m_nx+1;inode++)
				{
					XPOS[inode][jnode][knode]=inode;
					YPOS[inode][jnode][knode]=jnode;
					ZPOS[inode][jnode][knode]=knode;
				}
			}
		}

//-----------------------------------------------
//---Move necessary nodes for hexagonal vasculature
		for	(knode=1;knode<=m_nz;knode++)
		{
			for	(jnode=2;jnode<=m_ny;jnode+=2)
			{
				for	(inode=1;inode<=m_nx;inode+=3)
				{
					XPOS[inode][jnode][knode]=double(inode+0.5);	//every 3rd node, on every other j level, 
																	//moved by 1/2 bond in pos i-direction
				}
			}
		}

//-----------------------------------------------
		for	(knode=1;knode<=m_nz;knode++)
		{
			for	(jnode=2;jnode<=m_ny;jnode+=2)
			{
				for	(inode=3;inode<=m_nx-1;inode+=3)
				{
					XPOS[inode][jnode][knode]=double(inode-0.5);	//every 3rd node, on every other j level, 
																	//moved by 1/2 bond in neg i-direction
				}
			}
		}

//-----------------------------------------------
//---Update these if distort is used (only safe to use m_distort<0.5, I think!)---
		for (knode=1;knode<=m_nz;knode++)
		{
			for (jnode=1;jnode<=m_ny;jnode++)
			{
				for (inode=0;inode<=m_nx+1;inode++)
				{
					double randi=float(rand())/float(RAND_MAX); //(0,1)
					double randj=float(rand())/float(RAND_MAX); //(0,1)
					double randk=float(rand())/float(RAND_MAX); //(0,1)

					double rand1=float(rand())/float(RAND_MAX); //(0,1)
	   				if (rand1 > 0.5) 
					{
						XPOS[inode][jnode][knode]+=double(m_distort*randi);
					}

					else
					{
						XPOS[inode][jnode][knode]-=double(m_distort*randi);
					}

//-----------------------------------------------
					double rand2=float(rand())/float(RAND_MAX); //(0,1)
	   				if (rand2 > 0.5) 
					{
						YPOS[inode][jnode][knode]+=double(m_distort*randj);
					}

					else
					{
						YPOS[inode][jnode][knode]-=double(m_distort*randj);
					}

//-----------------------------------------------
					double rand3=float(rand())/float(RAND_MAX); //(0,1)
	   				if (rand3 > 0.5) 
					{
						ZPOS[inode][jnode][knode]+=double(m_distort*randk);
					}
					else
					{
						ZPOS[inode][jnode][knode]-=double(m_distort*randk);
					}
		   
//-----------------------------------------------
///		DebugNodes << inode << "\t" << jnode << "\t" << knode << "\t" <<
///		XPOS[inode][jnode][knode] << "\t" << YPOS[inode][jnode][knode]
///		<< "\t" << ZPOS[inode][jnode][knode] << endl;

				}// end i loop

//-----------------------------------------------
//---KEEP INLET and OUTLET FIXED---

				XPOS[0][jnode][knode]=0.0;  
				YPOS[0][jnode][knode]=double(jnode);
				ZPOS[0][jnode][knode]=double(knode);

				XPOS[m_nx+1][jnode][knode]=double(m_nx+1);
				YPOS[m_nx+1][jnode][knode]=double(jnode);
				ZPOS[m_nx+1][jnode][knode]=double(knode);

			}	//end j loop
		}		//end k loop

//-----------------------------------------------
//---Fill necessary bonds with cement---
		for	(knode=1;knode<=m_nz;knode++)
		{
			for	(jnode=2;jnode<=m_ny;jnode+=2)
			{
				for	(inode=1;inode<=m_nx;inode+=3)
				{
					pFluid[LabX(inode,jnode,knode)-1]=66;	//inlets & outlets with even j's 
				}											//cemented (except bottom art)

				inode=m_nx+1;
				pFluid[LabX(inode,jnode,knode)-1]=66;	
			}
		}

//-----------------------------------------------
		for	(knode=1;knode<=m_nz;knode++)
		{
			for	(jnode=2;jnode<=m_ny;jnode++)
			{
				for	(inode=2;inode<=m_nx-2;inode+=3)
				{
					pFluid[LabY(inode,jnode,knode)-1]=66;	//every 3rd column of y-bonds cemented 
				}
			}
		}

//-----------------------------------------------
		for	(knode=1;knode<=m_nz;knode++)
		{
			for	(jnode=3;jnode<=m_ny-1;jnode+=2)
			{
				for	(inode=2;inode<=m_nx-2;inode+=3)
				{
					pFluid[LabX(inode,jnode,knode)-1]=66;
				}
			}
		}
//-----------------------------------------------
		for	(knode=1;knode<=m_nz;knode++)
		{
			for	(jnode=3;jnode<=m_ny-1;jnode+=2)
			{
				for	(inode=3;inode<=m_nx-1;inode+=3)
				{
					pFluid[LabX(inode,jnode,knode)-1]=66;
				}
			}
		}

//-----------------------------------------------
	}	//end else

//-----------------------------------------------
}

//***********************************************
//==========================================
void CAngioNetDlg::OnTimer(UINT nIDEvent)
//==========================================
{
	// TODO: Add your message handler code here and/or call default
	
	OnDrawIt3();
}


//*********************************************************

//========================
void CAngioNetDlg::Shunt()
//========================
{
	//Put in the arteriole
	int i,j,k,nbx;
	
	j=3,k=1;

	for (i=5;i<=m_nx-5;i++)
	{
			nbx=LabX(i,j,k);
		    pFluid[nbx-1]=10;
	}
}


//************************************************************

//==================================
void CAngioNetDlg::WriteAwayMasses()
//==================================
{

	double totalMass=0.0;

		for (int k=1;k<=m_nz;k++)
		{
			for (int j=1;j<=m_ny;j++)
			{
				for (int i=1;i<=m_nx;i++)
				{
				totalMass+=pXCON[i-1][j-1][k-1]*
					(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]);
				totalMass+=pYCON[i-1][j-1][k-1]*
					(PI*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]);
				totalMass+=pZCON[i-1][j-1][k-1]*
					(PI*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]);
				}

				int i=m_nx+1;
				totalMass+=pXCON[i-1][j-1][k-1]*
					(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]);
			}
		}

	outfileTot << angiotime << "\t" << totalMass << endl;
	outfileUptake << angiotime << "\t" << adsorbedmass << endl; 
}


//*****************************************************

//-------------------------------------------------------------------------
int CAngioNetDlg::Clustering(int *Iclus,int IFluidLabel1, int IFluidLabel2)
//-------------------------------------------------------------------------
{
//----Initialisations-----------------
	int ntemp,newlabel,labtemp,nbx,nby,nbz;
//---------------------------------------------------
	int* NP=NULL;
	NP=new int[Nbond];	//dynamic array of cluster labels
	
	for (int nn=1; nn<=Nbond;nn++)
	{
		Iclus[nn-1]=1000000;
		NP[nn-1]=1000000;
	}
//---------------------------------------------------
	int* Iwwork=NULL;
	Iwwork=new int[10];	//dynamic array of cluster labels
	int* Nwork=NULL;
	Nwork=new int[10];	//dynamic array of cluster labels
	
	for (int nn=1; nn<=10;nn++)
	{
		Iwwork[nn-1]=1000000;
		Nwork[nn-1]=1000000;
	}
//---------------------------------------------------
//-------------End Initialisations--------------------


//-----------------------------------------------------
	for (int nnnn=1; nnnn<=4; nnnn++)	//nnnn Loop *****
	{
//.....................................................
	ntemp=1;

//------X-PORES---------------------------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx+1;i++)
		  {
			nbx=LabX(i,j,k);
//----------------------------------------------
			if (pFluid[nbx-1]==IFluidLabel1)	//if condition X
			{
				NeighX(i,j,k,Iclus,Iwwork,Nwork);
				newlabel=ntemp;
//----------------------------------------------
				for (int nn=1; nn<=10;nn++)
				{
					if(Nwork[nn-1]!=1000000)
					{
						labtemp=min(NP[Nwork[nn-1]-1],ntemp);
						if (labtemp<newlabel) {newlabel=labtemp;}
					}
				}
//----------------------------------------------
				Iclus[nbx-1]=newlabel;
				NP[Iclus[nbx-1]-1]=newlabel;
//----------------------------------------------
				for (int nn=1; nn<=10;nn++)
				{
					if(Nwork[nn-1]!=1000000)
					{
						NP[NP[Nwork[nn-1]-1]-1]=newlabel;
						NP[Nwork[nn-1]-1]=newlabel;
					}
				}
//----------------------------------------------				
				ntemp+=1;
//----------------------------------------------				


			}	//end if condition X

		  }	//end i loop
	   }	//end j loop
	}		//end k loop
//-----------------------------------------------

//------Y-PORES---------------------------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			nby=LabY(i,j,k);
//----------------------------------------------
			if (pFluid[nby-1]==IFluidLabel1)	//if condition Y
			{
				NeighY(i,j,k,Iclus,Iwwork,Nwork);
				newlabel=ntemp;
//----------------------------------------------
				for (int nn=1; nn<=10;nn++)
				{
					if(Nwork[nn-1]!=1000000)
					{
						labtemp=min(NP[Nwork[nn-1]-1],ntemp);
						if (labtemp<newlabel) {newlabel=labtemp;}
					}
				}
//----------------------------------------------
				Iclus[nby-1]=newlabel;
				NP[Iclus[nby-1]-1]=newlabel;
//----------------------------------------------
				for (int nn=1; nn<=10;nn++)
				{
					if(Nwork[nn-1]!=1000000)
					{
						NP[NP[Nwork[nn-1]-1]-1]=newlabel;
						NP[Nwork[nn-1]-1]=newlabel;
					}
				}
//----------------------------------------------				
				ntemp+=1;
//----------------------------------------------				


			}	//end if condition Y

		  }	//end i loop
	   }	//end j loop
	}		//end k loop
//-----------------------------------------------

//------Z-PORES---------------------------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			nbz=LabZ(i,j,k);
//----------------------------------------------
			if (pFluid[nbz-1]==IFluidLabel1)	//if condition Z
			{
				NeighZ(i,j,k,Iclus,Iwwork,Nwork);
				newlabel=ntemp;
//----------------------------------------------
				for (int nn=1; nn<=10;nn++)
				{
					if(Nwork[nn-1]!=1000000)
					{
						labtemp=min(NP[Nwork[nn-1]-1],ntemp);
						if (labtemp<newlabel) {newlabel=labtemp;}
					}
				}
//----------------------------------------------
				Iclus[nbz-1]=newlabel;
				NP[Iclus[nbz-1]-1]=newlabel;
//----------------------------------------------
				for (int nn=1; nn<=10;nn++)
				{
					if(Nwork[nn-1]!=1000000)
					{
						NP[NP[Nwork[nn-1]-1]-1]=newlabel;
						NP[Nwork[nn-1]-1]=newlabel;
					}
				}
//----------------------------------------------				
				ntemp+=1;
//----------------------------------------------				


			}	//end if condition Z

		  }	//end i loop
	   }	//end j loop
	}		//end k loop
//-----------------------------------------------

//.....................................................

	}	//end nnnn loop *****
//--------------------------------------------------



//-----------------------------------------------
//-----------------------------------------------
	int improp;

	for (improp=1; improp<=Nbond; improp++)
	{
		Improper(NP,improp);
	}
//-----------------------------------------------
	Relabel(Iclus,NP,IFluidLabel1,IFluidLabel2);
//-----------------------------------------------
	int Ispan=SpanX(Iclus,IFluidLabel1,IFluidLabel2);
//-----------------------------------------------

//---------------------------------------------------
	delete [] NP;
	delete [] Iwwork;
	delete [] Nwork;
//----------------------------------------------------

//----------output file for debugging-------------
//	ofstream outfile4("clusters.txt");
//	for (int n=1;n<=Nbond;n++)
//	{
//		if (pFluid[n-1]==10)
//		{
//			outfile4 << n << "\t" << Iclus[n-1] << endl;
//		}

//	}

//---------------------------------------------------
	return Ispan;
//----------------------------------------------------
}


//*****************************************************

//==============================================
void CAngioNetDlg::Improper(int *NP, int improp)
//==============================================
{
	int Ms;
	int iprop=improp;
	int N=improp;

label:
	Ms=N;
	N=NP[N-1];
	if (N==1000000||N==200000)	{return;}
	if (Ms!=N) {goto label;}
	NP[iprop-1]=N;

}


//*****************************************************

//=================================================================================
void CAngioNetDlg::Relabel(int *Iclus, int *NP, int IFluidLabel1, int IFluidLabel2)
//=================================================================================
{

	int nbx,nby,nbz,Nb;

//X-PORES----------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx+1;i++)
		  {
			nbx=LabX(i,j,k);
			if (pFluid[nbx-1]==IFluidLabel1||pFluid[nbx-1]==IFluidLabel2)
			{
				Nb=Iclus[nbx-1];
				Nb=NP[Nb-1];
				Iclus[nbx-1]=Nb;
			}
		  }
	   }
	 }
//------------------------
//Y-PORES----------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			nby=LabY(i,j,k);
			if (pFluid[nby-1]==IFluidLabel1||pFluid[nby-1]==IFluidLabel2)
			{
				Nb=Iclus[nby-1];
				Nb=NP[Nb-1];
				Iclus[nby-1]=Nb;
			}
		  }
	   }
	 }
//------------------------
//Z-PORES----------------
	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			nbz=LabZ(i,j,k);
			if (pFluid[nbz-1]==IFluidLabel1||pFluid[nbz-1]==IFluidLabel2)
			{
				Nb=Iclus[nbz-1];
				Nb=NP[Nb-1];
				Iclus[nbz-1]=Nb;
			}
		  }
	   }
	 }

}


//*****************************************************

//-----------------------------------------------------------
int CAngioNetDlg::SpanX(int *Iclus, int IFluid1, int IFluid2)
//-----------------------------------------------------------
{
	int nSpanningClust=0;
	bool bSpanning=FALSE;



//---------------------------------------
	for (int k=1;k<=m_nz;k++)
	{
		for (int j=1;j<=m_ny;j++)
	   {
//------------------------------
			int NinX=LabX(1,j,k);	//inlet pore number

			if (pFluid[NinX-1]==IFluid1 || pFluid[NinX-1]==IFluid2) 
			{
				for (int kk=1;kk<=m_nz;kk++)
				{
					for (int jj=1;jj<=m_ny;jj++)
					{
						int NoutX=LabX(m_nx+1,jj,kk);	//exit pore number
						if ((pFluid[NoutX-1]==IFluid1 || 
							 pFluid[NoutX-1]==IFluid2) &&	//outlet fluid same
							 Iclus[NinX-1]==Iclus[NoutX-1])	//same clusters
						{
							nSpanningClust=Iclus[NinX-1];
							return nSpanningClust;	//the phase spans
						}
					}
				}
			}
//------------------------------------------
		}
	}
//----------------------------------------------
	return 0;	//no span
//-------------------------------------------------
}


//*****************************************************

//========================================================================
void CAngioNetDlg::IsolatedVessel(int iFluidID,int& nVesselTrapped, 
				double& vesselTrappedSat,int* pIclus,bool* pVesselTrapped)
//========================================================================
{
	//----------------------------------------------------
	for (int n=1;n<=Nbond;n++)	{pVesselTrapped[n-1]=TRUE;}  //All set to TRUE
	//----------------------------------------------------


	//Calculate trapped oil pores (All trapped initially, untrap if connected 
	//								to outlet)

	for (int nn=1;nn<=Nbond;nn++)	//Go to each pore
	{
		if (pFluid[nn-1]==iFluidID)	//Is it Oil-filled?
		{

		int nCurrentClus=pIclus[nn-1];

//..........................................

		
		for (int k=1;k<=m_nz;k++)
		{
			for (int j=1;j<=m_ny;j++)
			{
				int i=m_nx+1;
				int nbx=LabX(i,j,k);

//---BULK CONTINUITY TO OUTLET-----------
				if (pFluid[nbx-1]==iFluidID)	//is end-pore oil-filled?
				{
					int nOut=pIclus[nbx-1];
					if (nCurrentClus==nOut)	//Is the cluster number of oil-filled 
										//pore equal to outlet cluster no.?
					{
						pVesselTrapped[nn-1]=FALSE;	//If so, "untrap" the pore
					}

				}	//end if
				
//-----------------------------------------

			}
		}	//end for j,k loop

//..........................................
		}	//end if pFluid condition

	}		//end nn pores loop
//--------------------------------------------------------

}


//******************************************************

//==============================
void CAngioNetDlg::RemoveBonds()
//==============================
{
	pFluid[LabX(18,47,1) -1]=66;
	pFluid[LabX(18,48,1) -1]=66;
	pFluid[LabX(29,47,1) -1]=66;
	pFluid[LabX(30,47,1) -1]=66;
	pFluid[LabY(31,47,1) -1]=66;

	pFluid[LabY(15,46,1) -1]=66;
	pFluid[LabY(15,47,1) -1]=66;
	pFluid[LabY(18,47,1) -1]=66;
	pFluid[LabY(22,50,1) -1]=66;
	pFluid[LabY(27,50,1) -1]=66;
	pFluid[LabY(34,49,1) -1]=66;
	pFluid[LabY(34,48,1) -1]=66;

	pFluid[LabY(42,38,1) -1]=66;
	pFluid[LabY(42,39,1) -1]=66;
}


//******************************************************

//===================================================
void CAngioNetDlg::RemoveFraction(double fractionOut)
//===================================================
{
		int nVesselBonds=0, nToBeRemoved=0,nRemoved=0;

		//Get total no. of vessel bonds
		for (int n=1;n<=Nbond;n++)
		{
			if (pFluid[n-1]==10)	{nVesselBonds+=1;}
		}

		//How many to be removed
		nToBeRemoved=int(fractionOut*nVesselBonds);


		//Remove the requisite no. of bonds
		while (nRemoved < nToBeRemoved)
		{
		//Throw dice to choose bonds in lower half of network (1.3/6 +4.7/6*rand
															//	for circ tum
												//	2.5/6+3.5*rand for lin
		int iCoord=int(m_nx*float(rand())/float(RAND_MAX)) ; //(0,1)
	  //int jCoord=int(2/6.0*m_ny+ 4/6.0*m_ny*float(rand())/float(RAND_MAX)) ; //(0,1)

		// MODIF A.S. for ReadInVasculature2() ------------------------------
		int jCoord=int(5/8.0*m_ny+ 3/8.0*m_ny*float(rand())/float(RAND_MAX)); 
		//-------------------------------------------------------------------

		int nBondToGo;
		double randNo=float(rand())/float(RAND_MAX);

		if (randNo<0.5) {nBondToGo=LabX(iCoord,jCoord,1);}
//		else (randNo>=0.25 && randNo<0.5)	
		else {nBondToGo=LabY(iCoord,jCoord,1);}	//NB ALWAYS TAKING X_PORE NOW
//		else if	(randNo>=0.5 && randNo<0.75)	{nBondToGo=LabX(iCoord+1,jCoord,1);}
//		else									{nBondToGo=LabY(iCoord,jCoord+1,1);}

			if (pFluid[nBondToGo-1]==10)
			{
				pFluid[nBondToGo-1]=66;
				nRemoved+=1;
			}
		}

// MODIF A.S. part removed for ReadInVasculature2() ------------------------------
//need to add a few back for large cut fractions, so that main vessels stay intact
/*	if (fractionOut>0.3)
	{
		for (int i=59;i<=64;i++)
		{
			for (int j=26;j<=28;j++)
			{
				pFluid[LabX(i,j,1)-1]=10;
				pFluid[LabY(i,j,1)-1]=10;
			}
		}

		for ( i=32;i<=34;i++)
		{
			for (int j=30;j<=33;j++)
			{
				pFluid[LabX(i,j,1)-1]=10;
				pFluid[LabY(i,j,1)-1]=10;
			}
		}

	}
*/
//---------------------------------------------------------------
		
		
//""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

//-------------Set isolated vessels to fluid 66----------------------
		Clustering(pIclusO,10,10);
		IsolatedVessel(10,nVesselTrapped,vesselTrappedSat,pIclusO,pVesselTrapped);

		for (int nvessel=1;nvessel<=Nbond;nvessel++)
		{
			if (pFluid[nvessel-1]==10 && pVesselTrapped[nvessel-1]==TRUE)
			{
				pFluid[nvessel-1]=66;
			}

		}
//--------------------------------------------------------------
}


//**********************************************************************

//===================================
void CAngioNetDlg::SymmetricNetwork()
//===================================
{
//Clear lower half of network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=m_ny/2+1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);
			
		  	  if (pFluid[nbx-1]==10) {pFluid[nbx-1]=0;}
			  if (pFluid[nby-1]==10) {pFluid[nby-1]=0;}
			  if (pFluid[nbz-1]==10) {pFluid[nbz-1]=0;}
	}}}

//Build symmetric network by reflecting topmost section--
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny/2;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

			  int nbxReflect=LabX(i,m_ny+1-1-j,k);
			  int nbyReflect=LabY(i,m_ny+1-j,k);
			  int nbzReflect=LabZ(i,m_ny+1-j,k);
			
			  if (pFluid[nbx-1]==10) {pFluid[nbxReflect-1]=10;}
			  if (pFluid[nby-1]==10) {pFluid[nbyReflect-1]=10;}
			  if (pFluid[nbz-1]==10) {pFluid[nbzReflect-1]=10;}
	}}}

//Add end pore
	pFluid[LabX(m_nx+1,m_ny-1,1)-1]=10;

//Add second arteriole
		for (int kk=1;kk<=m_nz;kk++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				XBR[i-1][m_ny-1-1][kk-1]=artRad;
				XCond[i-1][m_ny-1-1][kk-1]=PI*pow(XBR[i-1][m_ny-1-1][kk-1],4)/
							(8.0*mu_blood*XBL[i-1][m_ny-1-1][kk-1]);
				vesselXCond[i-1][m_ny-1-1][kk-1]=XCond[i-1][m_ny-1-1][kk-1];
		}}
}


//*****************************************************

//=========================================================
void CAngioNetDlg::RemovePoresForTumour(double fractionOut)
//=========================================================
{
		int nVesselBonds=0, nToBeRemoved=0,nRemoved=0;

		//Get total no. of vessel bonds
		for (int n=1;n<=Nbond;n++)
		{
			if (pFluid[n-1]==10)	{nVesselBonds+=1;}
		}

		//How many to be removed
		nToBeRemoved=int(fractionOut*nVesselBonds); //TURN OFF FOR RADII CHECK

//-------------------------------
		int tumRad=m_TumRadius;	//radius of tumour (in pore units)
//-------------------------------

		int iCoord,jCoord;

		//Remove the requisite no. of bonds
		while (nRemoved < nToBeRemoved)
		{
		//put in circular region of poor connectivity
		iCoord=int(m_nx/2-tumRad+2*(tumRad*float(rand())/float(RAND_MAX)) +1);//(0,1)
//		jCoord=int(m_ny/2-tumRad+2*int(tumRad*float(rand())/float(RAND_MAX)) +1);//(0,1)
		jCoord=int(m_ny/2-pow((double) tumRad*tumRad-(iCoord-m_nx/2)*(iCoord-m_nx/2),0.5) +
				   2*(pow((double) tumRad*tumRad-(iCoord-m_nx/2)*(iCoord-m_nx/2),0.5)*float(rand())/float(RAND_MAX)) +1); //(0,1)
		int nBondToGo;
		double randNo=float(rand())/float(RAND_MAX);

		if (randNo<0.5) {nBondToGo=LabX(iCoord,jCoord,1);}
		if (randNo>=0.5) {nBondToGo=LabY(iCoord,jCoord,1);}	//NB ALWAYS TAKING X_PORE NOW

			if (pFluid[nBondToGo-1]==10)
			{
				pFluid[nBondToGo-1]=66;
				nRemoved+=1;
			}
		}
//----------Reduce radii-------------------
			for (int iiCoord=m_nx/2-tumRad;iiCoord<=m_nx/2+tumRad;iiCoord++)
			{
				for (int jjCoord=m_ny/2-
					(int)pow((double) tumRad*tumRad-(iiCoord-m_nx/2)*(iiCoord-m_nx/2),0.5);
					jjCoord<=m_ny/2+
					(int)pow((double) tumRad*tumRad-(iiCoord-m_nx/2)*(iiCoord-m_nx/2),0.5);
					jjCoord++)
					{
						XBR[iiCoord-1][jjCoord-1][1-1]*=1.5;//  *=5.0;//shrink/grow radii
						YBR[iiCoord-1][jjCoord-1][1-1]*=1.5;;//  *=5.0;
					}
			}

/*//need to add a few back for large cut fractions, so that main vessels stay intact
	if (fractionOut>0.3)
	{
		for (int i=59;i<=64;i++)
		{
			for (int j=26;j<=28;j++)
			{
				pFluid[LabX(i,j,1)-1]=10;
				pFluid[LabY(i,j,1)-1]=10;
			}
		}

		for ( i=32;i<=34;i++)
		{
			for (int j=30;j<=33;j++)
			{
				pFluid[LabX(i,j,1)-1]=10;
				pFluid[LabY(i,j,1)-1]=10;
			}
		}

	}*/
//---------------------------------------------------------------
		
		
//""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

//-------------Set isolated vessels to fluid 66----------------------
		Clustering(pIclusO,10,10);
		IsolatedVessel(10,nVesselTrapped,vesselTrappedSat,pIclusO,pVesselTrapped);

		for (int nvessel=1;nvessel<=Nbond;nvessel++)
		{
			if (pFluid[nvessel-1]==10 && pVesselTrapped[nvessel-1]==TRUE)
			{
				pFluid[nvessel-1]=66;
			}

		}
//--------------------------------------------------------------
}


//*****************************************************

//=================================
void CAngioNetDlg::WriteAwayConcs()
//=================================
{
		outfileReplayout << angiotime << endl;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
				  outfileReplayout << pXCON[i-1][j-1][k-1] << endl;
				  outfileReplayout << pYCON[i-1][j-1][k-1] << endl;
				}
				int i=m_nx+1;
				outfileReplayout << pXCON[i-1][j-1][k-1] << endl;
		}}
}


//*****************************************************

//===================================
void CAngioNetDlg::ReadInSavedConcs()
//===================================
{
		infileReplayin >> angiotime;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
				  infileReplayin >> pXCON[i-1][j-1][k-1];
				  infileReplayin >> pYCON[i-1][j-1][k-1];
				}
				int i=m_nx+1;
				infileReplayin >> pXCON[i-1][j-1][k-1];
		}}
}


//*****************************************************

//===============================
void CAngioNetDlg::OnReplaytick()
//=============================== 
{
	// TODO: Add your control notification handler code here
	replayOnly=TRUE;	//if this is ticked, then we are replaying old file only
}

//*****************************************************
void CAngioNetDlg::ReadInVasculatureWound()
{

		ifstream inputfilewound ("WoundNetwork2.txt");

//First, put in quadrant parent vessel
		int woundRad=m_nx;	//radius of wound

			for (int iiCoord=1;iiCoord<=woundRad;iiCoord++)
			{
			int jjCoord=
			m_ny-(int)pow((double) woundRad*woundRad-(iiCoord-m_nx)*(iiCoord-m_nx),0.5);
					{
						if (iiCoord !=0 && jjCoord !=0 )
						{
						int nbx=LabX(iiCoord,jjCoord,1);
						int nby=LabY(iiCoord,jjCoord,1);

						pFluid[nbx-1]=10;
						pFluid[nby-1]=10;

						XBR[iiCoord-1][jjCoord-1][0]=artRad;
						YBR[iiCoord-1][jjCoord-1][0]=artRad;
						}

					}
			}


			for (int jjCoord=1;jjCoord<=woundRad;jjCoord++)
			{
			int iiCoord=
			m_nx-(int)pow((double) woundRad*woundRad-(jjCoord-m_ny)*(jjCoord-m_ny),0.5);
					{
						if (iiCoord !=0 && jjCoord !=0 )
						{
						int nbx=LabX(iiCoord,jjCoord,1);
						int nby=LabY(iiCoord,jjCoord,1);

						pFluid[nbx-1]=10;
						pFluid[nby-1]=10;

						XBR[iiCoord-1][jjCoord-1][0]=artRad;
						YBR[iiCoord-1][jjCoord-1][0]=artRad;
						}
					}
			}

	//Additional bonds missed by the above procedure--
			pFluid[LabX(6,70,1)-1]=10;
			pFluid[LabY(6,70,1)-1]=10;
			pFluid[LabX(6,71,1)-1]=10;
			pFluid[LabY(6,71,1)-1]=10;
			pFluid[LabX(6,72,1)-1]=10;
			pFluid[LabY(6,72,1)-1]=10;

			pFluid[LabX(42,20,1)-1]=10;
			pFluid[LabY(42,20,1)-1]=10;

			pFluid[LabX(39,85,1)-1]=10;
			pFluid[LabY(39,85,1)-1]=10;
			pFluid[LabX(40,82,1)-1]=10;
			pFluid[LabY(40,82,1)-1]=10;
			pFluid[LabX(40,83,1)-1]=10;
			pFluid[LabY(40,83,1)-1]=10;


			for (int j=1;j<=38;j++)
			{;
			pFluid[LabY(m_nx-2,j,1)-1]=10;
			}


//Remove old parent vessel from earlier set-up

			for (int i=1;i<=7*m_nx/8-3;i++)
			{;
			pFluid[LabX(i,1,1)-1]=66;
			}

//Remove some i=1 bonds too
			for (int j=m_ny;j>=m_ny-14;j--)
			{;
			pFluid[LabX(1,j,1)-1]=0;
			pFluid[LabY(1,j,1)-1]=0;
			}

//Inlet given arterial radius
			pFluid[LabX(1,m_ny-15,1)-1]=10;
			XBR[1-1][m_ny-15-1][1-1]=artRad;
//----------------------------------------------------------------


	int iBit;
		 
	int*** iNodeOnPath=NULL;
	iNodeOnPath=new int**[m_nx];

	for (int i=1;i<=m_nx;i++){ iNodeOnPath[i-1]=new int* [m_ny];}
	for (int i=1;i<=m_nx;i++)
	{	for (int j=1;j<=m_ny;j++){ iNodeOnPath[i-1][j-1]=new int [m_nz];
	}}

	for (int k=1;k<=m_nz;k++)
	{	for (int i=1;i<=m_nx;i++)
		{	for (int j=1;j<=m_ny;j++){ iNodeOnPath[i-1][j-1][k-1]=0;
	}}}

//FOR READING IN JAMES' FILES ONLY	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++) 
			{                            
				inputfilewound >> iBit;

				if (iBit!=0) { iNodeOnPath[i-1][j-1][k-1]=1; }
			}
			for (int i=1;i<=m_nx;i++) 
			{                            
				inputfilewound >> iBit;	//read in 2nd half of each row but ignore
			}
		}
	}
//----------------------------


//-------------------------------------------------------------
//Fill bonds with vessel if nodes on both sides are on path

		int kstart;				  // MODIF A.S.
		if (m_nz==1) {kstart=1;}  // MODIF A.S.
		else {kstart=2;}          // MODIF A.S.

		for (int k=kstart;k<=m_nz;k++) // MODIF A.S.
		{
			for (int i=2;i<=m_nx;i++)
			{
				for (int j=2;j<=m_ny;j++)
				{
					int nbx=LabX(i,j,k);
					int nby=LabY(i,j,k);
					int nbz=LabZ(i,j,k);

//x-pores-----
		if (iNodeOnPath[i-1][j-1][k-1]==1 && 
			iNodeOnPath[i-1-1][j-1][k-1]==1)		{pFluid[nbx-1]=10;}
//y-pores-----
		if (iNodeOnPath[i-1][j-1][k-1]==1 && 
			iNodeOnPath[i-1][j-1-1][k-1]==1)		{pFluid[nby-1]=10;}
//z-pores-----
		if (iNodeOnPath[i-1][j-1][k-1]==1 && 
			iNodeOnPath[i-1][j-1][k-1-1]==1)		{pFluid[nbz-1]=10;}

				}
			}
		}

//-----------------------------------------------
//Do clustering to remove disconnected network and set these to 66
		RemoveFraction(0.0);		//NBNBNB Any bonds that "trapped will not show
										//on black graphics background, so be careful
										//when looking to see if vasculature HAS in
										//fact loaded correctly but is simply not
										//yet fully connected to inlet
		
//------------------------------------------------------------
//Additional bonds needed as they missed by Sandy's input file

//Clean up arrays----
	for (int i=0;i<m_nx;i++)
	{
		for (int j=0;j<m_ny;j++)
		{
			delete[] iNodeOnPath[i][j];
		}
	}

	for (int i=0;i<m_nx;i++)
	{
			delete[] iNodeOnPath[i];
	}

			delete[] iNodeOnPath;
//-------------------------------------------------------------


}
//*****************************************************

void CAngioNetDlg::UpdateTracerWound()
{
//----------output file for debugging-------------
//----------------------------------------------------
//need to define some arrays first

//	pFluid[888]=10;
//	outfileConc <<"HELP";

		double*** TotalFlowOut=NULL; 
		double*** TotalFlowIn=NULL;
		double*** TotalMassIn=NULL;

		TotalFlowOut=new double**[m_nx];
		TotalFlowIn=new double**[m_nx];
		TotalMassIn=new double**[m_nx];

		for (int i=0;i<m_nx;i++)
		{
			TotalFlowOut[i]=new double* [m_ny];
			TotalFlowIn[i]=new double* [m_ny];
			TotalMassIn[i]=new double* [m_ny];
		}

		for (int i=0;i<m_nx;i++)
		{
			for (int j=0;j<m_ny;j++)
			{
				TotalFlowOut[i][j]=new double [m_nz];
				TotalFlowIn[i][j]=new double [m_nz];
				TotalMassIn[i][j]=new double [m_nz];
			}
		}
//-----------------------------------------------------------------
//			outfileConc <<"HELP2";

//----Updates the tracer conc in each bond-----

	double theminflow=1.0e-30;
	double timestep=1.0e20;

	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------

//x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}
//y-pores
	if ( *(pFluid+nby-1)!=10)	{pYCON[i-1][j-1][k-1]=0.0;}
//z-pores
	if ( *(pFluid+nbz-1)!=10)	{pZCON[i-1][j-1][k-1]=0.0;}

		  }

	int i=m_nx+1;
	int nbx=LabX(i,j,k);

//dangling x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}

	   }
	}
//-------------------------------------------------------------
//		outfileConc << "STEP1";

//Find the min time needed until a pore is completely emptied
//can't go longer than this otherwise mass isn't conserved

	double tempDeltaT;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------
	if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
								fabs(XFlow[i-1][j-1][k-1]);

//	outfile5 << XBR[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << XBL[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << pow(XBR[i-1][j-1][k-1],2);
//	outfile5 << "\t";
//	outfile5 << pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
//								fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << timestep;
//	outfile5 << endl;

		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//----------------------------------------------
	if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/
								fabs(YFlow[i-1][j-1][k-1]);

//	outfile5 << XBR[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << XBL[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << pow(XBR[i-1][j-1][k-1],2);
//	outfile5 << "\t";
//	outfile5 << pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
//								fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << timestep;
//	outfile5 << endl;
//
		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//----------------------------------------------
	if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/
								fabs(ZFlow[i-1][j-1][k-1]);

//	outfile5 << XBR[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << XBL[i-1][j-1][k-1];
//	outfile5 << "\t";
//	outfile5 << fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << pow(XBR[i-1][j-1][k-1],2);
//	outfile5 << "\t";
//	outfile5 << pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
								fabs(XFlow[i-1][j-1][k-1]);
//	outfile5 << "\t";
//	outfile5 << timestep;
//	outfile5 << endl;

		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//------------------------------------------------------------------


		  }

		  int i=m_nx+1;
		  int nbx=LabX(i,j,k);

//----------------------------------------------
	if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
	{
		tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/
								fabs(XFlow[i-1][j-1][k-1]);

		if (tempDeltaT < timestep) {timestep=tempDeltaT;}
	}

//----------------------------------------------

	   }
	}

//----------------------SMcD 10/2004---
	angioDeltaT=timestep/TimeFactor;
//----------------------------------------------------
//------------------------------------------------------
//	outfileConc <<"HELP3";

//Now set the actual sim timestep to the tracer-constrained timestep
//to keep everything consistent
//	if (m_presetNetwork==FALSE && m_circTumour==FALSE)
//	{
//SMcD2004		if (timestep<angioDeltaT) {exit(1);}	//need to change angioDeltaT
//SMcD2004		else	{}//timestep=angioDeltaT*10;}	//set to the smaller angioDeltaT
//	}											//IDEALLY update concs
												//angiodeltaT(in secs)/tmstep
												//times before returning
												//to cycle.
												//Currently, the 2 timescales
												//are not synchronised.
//	else	//we're only doing tracer so no real need to worry about timestep
//	{
//		angioDeltaT=timestep;
//	}

//SMcD2004--------------------------
//		angioDeltaT=timestep;
//		timestep=angioDeltaT;
//SMcD2004--------------------------


		outfileVasc << "UpdateTracer1" << "\t" << angioDeltaT << 
			"\t" << theminflow << endl;

//--------------------------------------------------------


//Now calculate the total flow into and out of nodes--
//initialise first

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalMassIn[i-1][j-1][k-1]=0.0;
		  }
	   }
	}


//--------------------------------------------------------
//Now do the calculation - NB total flow in = total flow out
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {
			  if (j==m_ny) {jp1=1;}
			  else {jp1=j+1;}

			  if (k==m_nz) {kp1=1;}
			  else {kp1=k+1;}

			  TotalFlowIn[i-1][j-1][k-1]=0.5*(
				  fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
				  fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
				  fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

			  TotalFlowOut[i-1][j-1][k-1]=TotalFlowIn[i-1][j-1][k-1];

//			outfile5 << i;
//			outfile5 << "\t";
//			outfile5 << j;
//			outfile5 << "\t";
//			outfile5 << TotalFlowIn[i-1][j-1][k-1];
//			outfile5 << "\t";
//			outfile5 << TotalFlowOut[i-1][j-1][k-1];
//			outfile5 << endl;
		  }
	   }
	}
//-----------------------------------------------------------
//outfileConc << "HERE11" ;

//----------------------------------------------------------------------
//Calculate the total mass flowing into each node.  Be careful about signs--

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {			
			  if (j==m_ny) {jp1=1;}
			  else {jp1=j+1;}

			  if (k==m_nz) {kp1=1;}
			  else {kp1=k+1;}
			  
//-----------------------

			if (XFlow[i-1][j-1][k-1]>0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*
											pXCON[i-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (XFlow[i+1-1][j-1][k-1]<0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1])*
											pXCON[i+1-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (YFlow[i-1][j-1][k-1]>0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*
											pYCON[i-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (YFlow[i-1][jp1-1][k-1]<0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][jp1-1][k-1])*
											pYCON[i-1][jp1-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (ZFlow[i-1][j-1][k-1]>0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*
											pZCON[i-1][j-1][k-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

			if (ZFlow[i-1][j-1][kp1-1]<0.0)
			{
				TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][kp1-1])*
											pZCON[i-1][j-1][kp1-1]*angioDeltaT*TimeFactor;
			}
//-----------------------

		  }
	   }
	}
//-------------------------------------------------------



//-------------------------------------------------------
//Update tracer concentrations----------------------

	int jm1,km1;

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

			  if (j==1) {jm1=m_ny;}
			  else {jm1=j-1;}

			  if (k==1) {km1=m_nz;}
			  else {km1=k-1;}

//-----------------------
//--x-pores----
			  // ***Restore if only one arteriole*** if (i==1 && j==1 && k==1)	//inlet port first
			  if (i==1)
			  {////	

				if(j==m_ny-15 && k==1) //**1st art** 
				//------ MODIF A.S. ------------------------------------
				  //if(j==1 && k==15) // for vasculature 3d-linear-30-2.txt 
				//------------------------------------------------------
			  {//
				if (m_slug==FALSE || (m_slug==TRUE && angiotime<flushtime))
				{
				  pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*ConMax-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;	
				  
				  //pXCON[i-1][j-1][k-1]=ConMax;
				}
				else	//slug in place now do postflush
				{
				 pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*ConMin-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;

				  //pXCON[i-1][j-1][k-1]=ConMin;
				}


			  }//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				if (m_CentralTumour)
				{	////////
				if(j==m_ny-1 && k==1) //**2nd art**
			  {//
				if (m_slug==FALSE || (m_slug==TRUE && angiotime<flushtime))
				{
				  pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*ConMax-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;

				  //pXCON[i-1][j-1][k-1]=ConMax;

				 outfileConc << angiotime << "\t" << pXCON[i-1][j-1][k-1] << endl;
				}
				else	//slug in place now do postflush
				{
				  pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*ConMin-TimeFactor*pXCON[i-1][j-1][k-1])/ConMax;

				  //pXCON[i-1][j-1][k-1]=ConMin;
				}


			  }//
			  }		////////

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			  }////

			  //-------------
			  else	//not the inlet port
			  {////



			  if (TotalFlowOut[i-1][j-1][k-1]>0)
			  {
				if (XFlow[i-1][j-1][k-1]<0.0)
				{
//				outfile5 << "into 1";

				pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXCON[i-1][j-1][k-1]  )/ConMax;
				}
				else if (XFlow[i-1][j-1][k-1]>0.0)
				{
/*				outfile5 << "into 2";
				outfile5 << "\t";
				outfile5 << pXCON[i-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << timestep;
				outfile5 << "\t";
				outfile5 << fabs(XFlow[i-1][j-1][k-1]);
				outfile5 << "\t";
				outfile5 << TotalMassIn[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << TotalFlowOut[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << 
					(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]);
				outfile5 << endl;*/


				pXCON[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1-1][j-1][k-1]/
						   TotalFlowOut[i-1-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXCON[i-1][j-1][k-1]  )/ConMax;
				}
			  }
//			  else
//			  {
//				outfile5 << "into 3";
//				pXCON[i-1][j-1][k-1]=pXCON[i-1][j-1][k-1];
//			  }

			  //--------------------------
			  }//// end x-pores

//			  if(pXCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pXCON[i-1][j-1][k-1]=0.0;}

/*			outfile5 << "x";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << TotalMassIn[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pXCON[i-1][j-1][k-1];
//			outfile5 << "\t";
//			outfile5 << (XFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/


//--y-pores------

			  if (TotalFlowOut[i-1][j-1][k-1]>0)
			  {
				if (YFlow[i-1][j-1][k-1]<0.0)
				{
				pYCON[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pYCON[i-1][j-1][k-1]  )/ConMax;

				/*outfile5 << "into y2";
				outfile5 << "\t";
				outfile5 << pYCON[i-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << timestep;
				outfile5 << "\t";
				outfile5 << fabs(YFlow[i-1][j-1][k-1]);
				outfile5 << "\t";
				outfile5 << TotalMassIn[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << TotalFlowOut[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << 
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]);
				outfile5 << endl;*/
				}
				else if (YFlow[i-1][j-1][k-1]>0.0)
				{
				pYCON[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][jm1-1][k-1]/
						   TotalFlowOut[i-1][jm1-1][k-1]/angioDeltaT-
						   TimeFactor*pYCON[i-1][j-1][k-1]  )/ConMax;

				/*outfile5 << "into y3";
				outfile5 << "\t";
				outfile5 << pYCON[i-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << timestep;
				outfile5 << "\t";
				outfile5 << fabs(YFlow[i-1][j-1][k-1]);
				outfile5 << "\t";
				outfile5 << TotalMassIn[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << TotalFlowOut[i-1-1][j-1][k-1];
				outfile5 << "\t";
				outfile5 << 
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]);
				outfile5 << endl;*/
				}
			  }
//			   else
//			  {
//				pYCON[i-1][j-1][k-1]=pYCON[i-1][j-1][k-1];
//			  }


//			  if(pYCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pYCON[i-1][j-1][k-1]=0.0;}

/*			outfile5 << "y";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pYCON[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << (YFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/
//--z-pores----------

			if (TotalFlowOut[i-1][j-1][k-1]>0)
			{
			  if (ZFlow[i-1][j-1][k-1]<0.0)
			  {
				pZCON[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pZCON[i-1][j-1][k-1]  )/ConMax;
			  }
			  else if (ZFlow[i-1][j-1][k-1]>0.0)
			  {
				pZCON[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][km1-1]/
						   TotalFlowOut[i-1][j-1][km1-1]/angioDeltaT-
						   TimeFactor*pZCON[i-1][j-1][k-1]  )/ConMax;
			  }
			}
//			else
//			{
//				pZCON[i-1][j-1][k-1]=pZCON[i-1][j-1][k-1];
//			}


//			  if(pZCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pZCON[i-1][j-1][k-1]=0.0;}

/*			outfile5 << "z";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pZCON[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << (ZFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/
//----------------------

//-----------------------------------------
		  }


//--x-danglers----

		int i=m_nx+1;

		if (TotalFlowOut[m_nx-1][j-1][k-1]>0)
		{

				pXCON[m_nx+1-1][j-1][k-1]+=
				fabs(XFlow[m_nx+1-1][j-1][k-1])*angioDeltaT/
				(pi*pow(XBR[m_nx+1-1][j-1][k-1],2)*XBL[m_nx+1-1][j-1][k-1]) *
						(  TotalMassIn[m_nx-1][j-1][k-1]/
						   TotalFlowOut[m_nx-1][j-1][k-1]/angioDeltaT-
						   TimeFactor*pXCON[m_nx+1-1][j-1][k-1]  )/ConMax;
		}
//		else
//		{
//				pXCON[m_nx+1-1][j-1][k-1]=pXCON[m_nx+1-1][j-1][k-1];
//		}

//			  if(pXCON[i-1][j-1][k-1]<1.0e-10*ConMax)	//num effects
//			  {pXCON[i-1][j-1][k-1]=0.0;}
		
/*			outfile5 << "xend";
			outfile5 << "\t";
			outfile5 << i;
			outfile5 << "\t";
			outfile5 << j;
			outfile5 << "\t";
			outfile5 << TotalFlowOut[m_nx-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << pXCON[i-1][j-1][k-1];
			outfile5 << "\t";
			outfile5 << (XFlow[i-1][j-1][k-1]);
			outfile5 << endl;*/
//---------------------------------------------
	   }
	}
//-------------------------------------------------------------

//-----------------------------------------------
//Only want tracer in vessels, so set any others to 0.0
//(already done before - just a check)------

	for (int k=1;k<=m_nz;k++)
	{
	   for (int j=1;j<=m_ny;j++)
	   {
	      for (int i=1;i<=m_nx;i++)
		  {

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------

///---------------------------------------------

//x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}
	if ( pXCON[i-1][j-1][k-1]>1.0)	{pXCON[i-1][j-1][k-1]=1.0;}
	if ( pXCON[i-1][j-1][k-1]<0.0)	{MessageBox("X Mass not conserved");}
//y-pores
	if ( *(pFluid+nby-1)!=10)	{pYCON[i-1][j-1][k-1]=0.0;}
	if ( pYCON[i-1][j-1][k-1]>1.0)	{pYCON[i-1][j-1][k-1]=1.0;}
	if ( pYCON[i-1][j-1][k-1]<0.0)	{MessageBox("Y Mass not conserved");}
//z-pores
	if ( *(pFluid+nbz-1)!=10)	{pZCON[i-1][j-1][k-1]=0.0;}
	if ( pZCON[i-1][j-1][k-1]>1.0)	{pZCON[i-1][j-1][k-1]=1.0;}
	if ( pZCON[i-1][j-1][k-1]<0.0)	{MessageBox("Z Mass not conserved");}


		  }

	int i=m_nx+1;
	int nbx=LabX(i,j,k);

//dangling x-pores
	if ( *(pFluid+nbx-1)!=10)	{pXCON[i-1][j-1][k-1]=0.0;}
	if ( pXCON[i-1][j-1][k-1]>1.0)	{pXCON[i-1][j-1][k-1]=1.0;}
	if ( pXCON[i-1][j-1][k-1]<0.0)	{MessageBox("Xend Mass not conserved");}

	   }
	}
//-----------------------------
//-------------------------------------------------------------



//--------------------------------------------------------
//Clear up arrays----
	for (int i=0;i<m_nx;i++)
	{
		for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowIn[i][j];
			delete[] TotalFlowOut[i][j];
			delete[] TotalMassIn[i][j];
		}
	}

	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowIn[i];
			delete[] TotalFlowOut[i];
			delete[] TotalMassIn[i];
	}

			delete[] TotalFlowIn;
			delete[] TotalFlowOut;
			delete[] TotalMassIn;
//------------------------------------------
}
//*****************************************************
//===================================
void CAngioNetDlg::UpdateHematocritWound()
//===================================
{
	double*** TotalFlowOut=NULL; 
	double*** TotalFlowIn=NULL;
	double*** TotalMassIn=NULL;

	TotalFlowOut=new double**[m_nx];
	TotalFlowIn=new double**[m_nx];
	TotalMassIn=new double**[m_nx];

	for (int i=0;i<m_nx;i++)
	{
		TotalFlowOut[i]=new double* [m_ny];
		TotalFlowIn[i]=new double* [m_ny];
		TotalMassIn[i]=new double* [m_ny];
	}
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			TotalFlowOut[i][j]=new double [m_nz];
			TotalFlowIn[i][j]=new double [m_nz];
			TotalMassIn[i][j]=new double [m_nz];
	}}


//----Updates the Hematocrit in each bond-----

	double theminflow=1.0e-30;
	double timestep=1.0e20;

	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXHem[i-1][j-1][k-1]=0.0;}
			if (pFluid[nby-1]!=10)	{pYHem[i-1][j-1][k-1]=0.0;}
			if (pFluid[nbz-1]!=10)	{pZHem[i-1][j-1][k-1]=0.0;}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXHem[i-1][j-1][k-1]=0.0;}
	}}


//Find the min time needed until a pore is completely emptied
//can't go longer than this otherwise mass isn't conserved

	double tempDeltaT;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			}
			if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/fabs(YFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			}
			if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/fabs(ZFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT;}
			}
	}}


//Now set the actual sim timestep to the tracer-constrained timestep
//to keep everything consistent
	if (m_presetNetwork==FALSE && m_circTumour==FALSE)
	{
		if (timestep<angioDeltaT) {exit(1);}	//need to change angioDeltaT
		else	{}//timestep=angioDeltaT*10;}	//set to the smaller angioDeltaT
	}											//IDEALLY update concs
												//angiodeltaT(in secs)/tmstep
												//times before returning
												//to cycle.
												//Currently, the 2 timescales
												//are not synchronised.
	else	//we're only doing tracer so no real need to worry about timestep
	{
//		angioDeltaT=timestep;
	}

	//---SMcD 10/2004
	angioDeltaT=timestep/TimeFactor;
	//------------------

//Now calculate the total flow into and out of nodes--
//initialise first

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalMassIn[i-1][j-1][k-1]=0.0;
	}}}


//Now do the calculation - NB total flow in = total flow out
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
			  if (k==m_nz) {kp1=1;} else {kp1=k+1;}

			  TotalFlowIn[i-1][j-1][k-1]=0.5*(
				  fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
				  fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
				  fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

			  TotalFlowOut[i-1][j-1][k-1]=TotalFlowIn[i-1][j-1][k-1];
	}}}


//Calculate the total mass flowing into each node.  Be careful about signs--

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{			
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
			  if (k==m_nz) {kp1=1;} else {kp1=k+1;}

			  if (XFlow[i-1][j-1][k-1]>0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (XFlow[i+1-1][j-1][k-1]<0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1])*pXHem[i+1-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (YFlow[i-1][j-1][k-1]>0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

			  if (YFlow[i-1][jp1-1][k-1]<0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][jp1-1][k-1])*pYHem[i-1][jp1-1][k-1]*angioDeltaT*TimeFactor;}

			  if (ZFlow[i-1][j-1][k-1]>0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;}

		  	  if (ZFlow[i-1][j-1][kp1-1]<0.0)
			  {TotalMassIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][kp1-1])*pZHem[i-1][j-1][kp1-1]*angioDeltaT*TimeFactor;}
	}}}

//Update tracer concentrations----------------------

	int jm1,km1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (j==1) {jm1=m_ny;} else {jm1=j-1;}
			  if (k==1) {km1=m_nz;} else {km1=k-1;}
//--x-pores----
			  // ***Restore if only one arteriole*** if (i==1 && j==1 && k==1)	//inlet port first
			  //if (i==1)
			  //{	  if(j==1 && k==1) //**1st art** 
			  //	  {
			  //		pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*timestep/
			  //		(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
			  //		(AverageHt-pXHem[i-1][j-1][k-1]);				
			  //	  }

			  if (i==1 && j==m_ny-15 && k==1)	//SMcD 10/2004
			  {
				  //pXHem[i-1][j-1][k-1]=AverageHt;
				  pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
			  }
			  else	//not the inlet port
			  {
				if (TotalFlowOut[i-1][j-1][k-1]>0)
				{
					if (XFlow[i-1][j-1][k-1]<0.0)
					{
						pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1][j-1][k-1]/
						   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-TimeFactor*pXHem[i-1][j-1][k-1]  )/MaxHt;
					}
					else if (XFlow[i-1][j-1][k-1]>0.0)
					{
						pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
						(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
						(  TotalMassIn[i-1-1][j-1][k-1]/
						   TotalFlowOut[i-1-1][j-1][k-1]/angioDeltaT-TimeFactor*pXHem[i-1][j-1][k-1]  )/MaxHt;
			  }}}
//--y-pores------
			  if (TotalFlowOut[i-1][j-1][k-1]>0)
			  {
				if (YFlow[i-1][j-1][k-1]<0.0)
				{
					pYHem[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
					(  TotalMassIn[i-1][j-1][k-1]/
					   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-TimeFactor*pYHem[i-1][j-1][k-1]  )/MaxHt;
				}
				else if (YFlow[i-1][j-1][k-1]>0.0)
				{
					pYHem[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1])*angioDeltaT/
					(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]) *
					(  TotalMassIn[i-1][jm1-1][k-1]/
					   TotalFlowOut[i-1][jm1-1][k-1]/angioDeltaT-TimeFactor*pYHem[i-1][j-1][k-1]  )/MaxHt;
			  }}
//--z-pores----------
			if (TotalFlowOut[i-1][j-1][k-1]>0)
			{
			  if (ZFlow[i-1][j-1][k-1]<0.0)
			  {
					pZHem[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
					(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
					(  TotalMassIn[i-1][j-1][k-1]/
					   TotalFlowOut[i-1][j-1][k-1]/angioDeltaT-TimeFactor*pZHem[i-1][j-1][k-1]  )/MaxHt;
			  }
			  else if (ZFlow[i-1][j-1][k-1]>0.0)
			  {
					pZHem[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT/
					(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]) *
					(  TotalMassIn[i-1][j-1][km1-1]/
					   TotalFlowOut[i-1][j-1][km1-1]/angioDeltaT-TimeFactor*pZHem[i-1][j-1][k-1]  )/MaxHt;
			}}
		  }// end i-loop
//--x-danglers----
		int i=m_nx+1;
		if (TotalFlowOut[m_nx-1][j-1][k-1]>0)
		{
			pXHem[m_nx+1-1][j-1][k-1]+=fabs(XFlow[m_nx+1-1][j-1][k-1])*angioDeltaT/
				(pi*pow(XBR[m_nx+1-1][j-1][k-1],2)*XBL[m_nx+1-1][j-1][k-1]) *
				(  TotalMassIn[m_nx-1][j-1][k-1]/
				   TotalFlowOut[m_nx-1][j-1][k-1]/angioDeltaT-TimeFactor*pXHem[m_nx+1-1][j-1][k-1]  )/MaxHt;
		}
	}}// end j- and k-loops



	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if ( pXHem[i-1][j-1][k-1]>1.0)	{pXHem[i-1][j-1][k-1]=1.0;}
			if ( pXHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}

			if ( pYHem[i-1][j-1][k-1]>1.0)	{pYHem[i-1][j-1][k-1]=1.0;}
			if ( pYHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}

			if ( pZHem[i-1][j-1][k-1]>1.0)	{pZHem[i-1][j-1][k-1]=1.0;}
			if ( pZHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if ( pXHem[i-1][j-1][k-1]>1.0)	{pXHem[i-1][j-1][k-1]=1.0;}
			if ( pXHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}
	}}


//Clear up arrays
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowIn[i][j];
			delete[] TotalFlowOut[i][j];
			delete[] TotalMassIn[i][j];
	}}
	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowIn[i];
			delete[] TotalFlowOut[i];
			delete[] TotalMassIn[i];
	}
			delete[] TotalFlowIn;
			delete[] TotalFlowOut;
			delete[] TotalMassIn;
}


//*****************************************************

void CAngioNetDlg::AdaptVasculatureWound()
{
     UpdateHematocritWound();
      UpdateViscosity();

	outfileVasc << "after update visc" << endl;

	  CalculateWallShearStress();
	  CalculateTauE();

	outfileVasc << "after TauE" << endl;

	  UpdateRadiiWound();

	  	outfileVasc << "after TauE" << endl;

//--------------------------------------
	  assignConductivities2();
	  VesselConductivities();
	  calculatePressuresAndFlows(10);
//--------------------------------------
	  //SproutPressure();
	  CalculatePressureInVessel();
	outfileVasc << "after calcpressflowsinvessel" << endl;

/*
	if (loop%10==0) {

CalculateMinMaxMean(pXHem,pYHem,pZHem);
outfileHem << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

CalculateMinMaxMean(Xmu,Ymu,Zmu);
outfileViscosity << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

CalculateMinMaxMean(XTauW,YTauW,ZTauW);
outfileWallShearStress << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

CalculateMinMaxMean(XTauE,YTauE,ZTauE);
outfileTauE << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

CalculateMinMaxMean(XBR,YBR,ZBR);
outfileRadius << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(XCond,YCond,ZCond);
//outfiletest << "Conductivity" << "\t" << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

//CalculateMinMaxMean(vesselXCond,vesselYCond,vesselZCond);
//outfileVesselCond << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

CalculateMinMaxMean(XFlow,YFlow,ZFlow);
outfileFlow << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

	}
*/
}
//********************************************************
void CAngioNetDlg::UpdateRadiiWound()
{
	//%%%%%%%%%%%%%%%% DEBUG %%%%%%%%%%%%%%%%
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  XBROld[i-1][j-1][k-1]=XBR[i-1][j-1][k-1];
			  YBROld[i-1][j-1][k-1]=YBR[i-1][j-1][k-1];
			  ZBROld[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1];
			}
			  XBROld[m_nx][j-1][k-1]=XBR[m_nx][j-1][k-1];
	}}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	//----------Adaptation according to shear stress and intravascular pressure--------
	int nbx,nby,nbz;
	double metab;
	//double coeffks=0.5;  //1.75 (basal shrinking tendency);
	//double coeffkp=0.5;  //0.68;
	//double coeffkm=0.03;  //0.03;  
	//double TauRef=0.0103; //(Pa)  (1 dyn/cm2 = 0.1 Pa)
	//double FlowRef=0.2e-12; //m3/s
	//double RadiusLimitInf=2.0e-6;
	//double RadiusLimitSup=28.0e-6;

	double coeffks=0.35; //0.35;  
	double coeffkp=0.0;  //0.5;  
	double coeffkm=0.07; //0.12;    
	double TauRef=0.103; //(dyn/cm2)
	double FlowRef=1.9096e-11; //m3/s (Flow in PV)
	double RadiusLimitInf=2.0e-6;
	double RadiusLimitSup=12.0e-6;
	double RadiusVariation;
	double epsilon=0.06e-6;

	ConvergenceRadius=true;


//------------------------------------------------------------------------------------------------------
/*if (angiotime > 8.0)
{	outfiletest << "Time" << "\t" << angiotime << "\t" 
				<< "S_wss" << "\t" << "S_p" << "\t" << "S_m" << "\t" << "Hem" 
				<< "\t" << "R_t" << "\t" << "DR" << "\t" << "R_t+1" << "\t" << "P(mmHg)" 
				<< "\t" << "TauE(dyne/cm2)" << "\t" << "WSS(dyne/cm2)" << "\t" << "Viscosity" 
				<< "\t" << "Flow" << endl;
}*/
//------------------------------------------------------------------------------------------------------


	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  //---------xbond-----------
			  if (pFluid[nbx-1]==10)
			  { 
				if (XFlow[i-1][j-1][k-1]==0.0 || pXHem[i-1][j-1][k-1]<0.0001) {metab=0.0;} 
				else {metab=log10((FlowRef/(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]))+1.0);}

				RadiusVariation=XBR[i-1][j-1][k-1]*angioDeltaT*(
								    log10(10.0*XTauW[i-1][j-1][k-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[i-1][j-1][k-1])
						   +coeffkm*metab
						   -coeffks);

			    XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]+RadiusVariation;
				if (XBR[i-1][j-1][k-1]<RadiusLimitInf) {XBR[i-1][j-1][k-1]=RadiusLimitInf;}
				if (XBR[i-1][j-1][k-1]>RadiusLimitSup) {XBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}

				//--------------------------------------------------------------------------------
				/*if (angiotime > 8.0)
				{
				outfiletest << "X-Vessel" << "\t" << i << "," << j << "\t" 
							<< log10(10.0*XTauW[i-1][j-1][k-1]+TauRef) << "\t"
							<< -coeffkp*log10(10.0*XTauE[i-1][j-1][k-1]) << "\t" 
							<< coeffkm*metab << "\t"
							<< pXHem[i-1][j-1][k-1] << "\t" << XBROld[i-1][j-1][k-1]*1e6 << "\t"
							<< RadiusVariation*1e6 << "\t" << XBR[i-1][j-1][k-1]*1e6 << "\t" 
							<< pVesselPressure[nbx-1]*0.007501 << "\t"
							<< XTauE[i-1][j-1][k-1]*10.0 << "\t" 
							<< XTauW[i-1][j-1][k-1]*10.0 << "\t" << Xmu[i-1][j-1][k-1] << "\t"
							<< XFlow[i-1][j-1][k-1] << endl;
				}*/
				//---------------------------------------------------------------------------------
			  }
			  //---------ybond-----------
			  if (pFluid[nby-1]==10)
			  { 
				if (YFlow[i-1][j-1][k-1]==0.0 || pYHem[i-1][j-1][k-1]<0.0001) {metab=0.0;} 
				else {metab=log10((FlowRef/(fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1]))+1.0);}

				RadiusVariation=YBR[i-1][j-1][k-1]*angioDeltaT*(
									log10(10.0*YTauW[i-1][j-1][k-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[i-1][j-1][k-1])
						   +coeffkm*metab
						   -coeffks);

			    YBR[i-1][j-1][k-1]=YBR[i-1][j-1][k-1]+RadiusVariation;	
				if (YBR[i-1][j-1][k-1]<RadiusLimitInf) {YBR[i-1][j-1][k-1]=RadiusLimitInf;}	
				if (YBR[i-1][j-1][k-1]>RadiusLimitSup) {YBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}

				//--------------------------------------------------------------------------------
				/*if (angiotime > 8.0) 
				{
				outfiletest << "Y-Vessel" << "\t" << i << "," << j << "\t" 
							<< log10(10.0*YTauW[i-1][j-1][k-1]+TauRef) << "\t"
							<< -coeffkp*log10(10.0*YTauE[i-1][j-1][k-1]) << "\t" 
							<< coeffkm*metab << "\t"
							<< pYHem[i-1][j-1][k-1] << "\t" << YBROld[i-1][j-1][k-1]*1e6 << "\t"
							<< RadiusVariation*1e6 << "\t" << YBR[i-1][j-1][k-1]*1e6 << "\t" 
							<< pVesselPressure[nby-1]*0.007501 << "\t"
							<< YTauE[i-1][j-1][k-1]*10.0 << "\t" 
							<< YTauW[i-1][j-1][k-1]*10.0 << "\t" << Ymu[i-1][j-1][k-1] << "\t" 
							<< YFlow[i-1][j-1][k-1] << endl;
				}*/
				//---------------------------------------------------------------------------------

			  }
			  //---------zbond-----------
			  if (pFluid[nbz-1]==10)
			  { 
				if (ZFlow[i-1][j-1][k-1]==0.0 || pZHem[i-1][j-1][k-1]<0.0001) {metab=0.0;} 
				else {metab=log10((FlowRef/(fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1]))+1.0);}

				RadiusVariation=ZBR[i-1][j-1][k-1]*angioDeltaT*(
									log10(10.0*ZTauW[i-1][j-1][k-1]+TauRef)
						   -coeffkp*log10(10.0*ZTauE[i-1][j-1][k-1])
				           +coeffkm*metab
						   -coeffks);
				
			    ZBR[i-1][j-1][k-1]=ZBR[i-1][j-1][k-1]+RadiusVariation;	
				if (ZBR[i-1][j-1][k-1]<RadiusLimitInf) {ZBR[i-1][j-1][k-1]=RadiusLimitInf;}		
				if (ZBR[i-1][j-1][k-1]>RadiusLimitSup) {ZBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}
			  }
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);
			//-------dangling xbond-------
			if (pFluid[nbx-1]==10)
			{ 
				if (XFlow[i-1][j-1][k-1]==0.0 || pXHem[i-1][j-1][k-1]<0.0001) {metab=0.0;} 
				else {metab=log10((FlowRef/(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]))+1.0);}

				RadiusVariation=XBR[i-1][j-1][k-1]*angioDeltaT*(
									log10(10.0*XTauW[i-1][j-1][k-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[i-1][j-1][k-1])
					       +coeffkm*metab
						   -coeffks);	

			    XBR[i-1][j-1][k-1]=XBR[i-1][j-1][k-1]+RadiusVariation;
				if (XBR[i-1][j-1][k-1]<RadiusLimitInf) {XBR[i-1][j-1][k-1]=RadiusLimitInf;}		
				if (XBR[i-1][j-1][k-1]>RadiusLimitSup) {XBR[i-1][j-1][k-1]=RadiusLimitSup;}
				if (fabs(RadiusVariation)>epsilon) {ConvergenceRadius=false;}
			}	   				
	}}

	//---------------------------------------------------------
	//the radius of the parent vessel should remain unchanged.
//First, put in quadrant parent vessel
		int woundRad=m_nx;	//radius of wound

			for (int iiCoord=1;iiCoord<=woundRad;iiCoord++)
			{
			int jjCoord=
			m_ny-(int)pow((double) woundRad*woundRad-(iiCoord-m_nx)*(iiCoord-m_nx),0.5);
					{
						if (iiCoord !=0 && jjCoord !=0 )
						{
						int nbx=LabX(iiCoord,jjCoord,1);
						int nby=LabY(iiCoord,jjCoord,1);

						XBR[iiCoord-1][jjCoord-1][0]=artRad;
						YBR[iiCoord-1][jjCoord-1][0]=artRad;
						}

					}
			}


			for (int jjCoord=1;jjCoord<=woundRad;jjCoord++)
			{
			int iiCoord=
			m_nx-(int)pow((double) woundRad*woundRad-(jjCoord-m_ny)*(jjCoord-m_ny),0.5);
					{
						if (iiCoord !=0 && jjCoord !=0 )
						{
						int nbx=LabX(iiCoord,jjCoord,1);
						int nby=LabY(iiCoord,jjCoord,1);

						XBR[iiCoord-1][jjCoord-1][0]=artRad;
						YBR[iiCoord-1][jjCoord-1][0]=artRad;
						}
					}
			}

//Inlet given arterial radius
			XBR[1-1][m_ny-15-1][1-1]=artRad;
	//---------------------------------------------------------

	CalculateMinMaxMean(XBR,YBR,ZBR);
	outfileRadius << angiotime << "\t" << MinValue << "\t" << MaxValue << "\t" << MeanValue << endl;

/*		
//%%%%%%%%%%%%%%%%%%%%%%%%%% DEBUG %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if (loop%20==0)
{
	outfiletest << "Time" << "\t" << angiotime << "\t" 
		        << "S_wss" << "\t" << "S_p" << "\t" << "S_m" << "\t" << "Hem" 
				<< "\t" << "R_t" << "\t" << "DR" << "\t" << "R_t+1" << "\t" << "P(mmHg)" 
				<< "\t" << "TauE(dyne/cm2)" << "\t" << "WSS(dyne/cm2)" << "\t" << "Viscosity" << endl;

	//---- X-Vessel (40,1,1) --------
	if (XFlow[40-1][1-1][1-1]==0.0 || pXHem[40-1][1-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(XFlow[40-1][1-1][1-1])*pXHem[40-1][1-1][1-1]))+1.0);}

	  outfiletest << "X-vessel" << "\t" << "40-1-1" << "\t" 
		          <<log10(10.0*XTauW[40-1][1-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*XTauE[40-1][1-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pXHem[40-1][1-1][1-1] << "\t" 
				  << XBROld[40-1][1-1][1-1]*1e6 << "\t"
	  			  << (XBROld[40-1][1-1][1-1]*angioDeltaT*(
									log10(10.0*XTauW[40-1][1-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[40-1][1-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << XBR[40-1][1-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabX(40,1,1)-1]*0.007501 << "\t"
				  << XTauE[40-1][1-1][1-1]*10.0 << "\t" 
				  << XTauW[40-1][1-1][1-1]*10.0 << "\t" << Xmu[40-1][1-1][1-1] << endl;


	//---- Y-Vessel (14,2,1) --------
	if (YFlow[14-1][2-1][1-1]==0.0 || pYHem[14-1][2-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(YFlow[14-1][2-1][1-1])*pYHem[14-1][2-1][1-1]))+1.0);}

	  outfiletest << "Y-vessel" << "\t" << "14-2-x" << "\t" 
		          <<log10(10.0*YTauW[14-1][2-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*YTauE[14-1][2-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pYHem[14-1][2-1][1-1] << "\t" 
				  << YBROld[14-1][2-1][1-1]*1e6 << "\t"
				  << (YBROld[14-1][2-1][1-1]*angioDeltaT*(
									log10(10.0*YTauW[14-1][2-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[14-1][2-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << YBR[14-1][2-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabY(14,2,1)-1]*0.007501 << "\t"
				  << YTauE[14-1][2-1][1-1]*10.0 << "\t" 
				  << YTauW[14-1][2-1][1-1]*10.0 << "\t" << Ymu[14-1][2-1][1-1] << endl;


	//---- X-Vessel (30,43,1) --------
	if (XFlow[30-1][43-1][1-1]==0.0 || pXHem[30-1][43-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(XFlow[30-1][43-1][1-1])*pXHem[30-1][43-1][1-1]))+1.0);}

	  outfiletest << "X-vessel" << "\t" << "30-43-1" << "\t" 
		          <<log10(10.0*XTauW[30-1][43-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*XTauE[30-1][43-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pXHem[30-1][43-1][1-1] << "\t" 
				  << XBROld[30-1][43-1][1-1]*1e6 << "\t" 
	  			  << (XBROld[30-1][43-1][1-1]*angioDeltaT*(
									log10(10.0*XTauW[30-1][43-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[30-1][43-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << XBR[30-1][43-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabX(30,43,1)-1]*0.007501 << "\t"
				  << XTauE[30-1][43-1][1-1]*10.0 << "\t"
				  << XTauW[30-1][43-1][1-1]*10.0 << "\t" << Xmu[30-1][43-1][1-1] << endl;


	//---- Y-Vessel (30,43,1) --------
	if (YFlow[30-1][43-1][1-1]==0.0 || pYHem[30-1][43-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(YFlow[30-1][43-1][1-1])*pYHem[30-1][43-1][1-1]))+1.0);}

	  outfiletest << "Y-vessel" << "\t" << "30-43-1" << "\t" 
		          <<log10(10.0*YTauW[30-1][43-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*YTauE[30-1][43-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pYHem[30-1][43-1][1-1] << "\t"
				  << YBROld[30-1][43-1][1-1]*1e6 << "\t" 
	  	  		  << (YBROld[30-1][43-1][1-1]*angioDeltaT*(
									log10(10.0*YTauW[30-1][43-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[30-1][43-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t"
				  << YBR[30-1][43-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabY(30,43,1)-1]*0.007501 << "\t" 
				  << YTauE[30-1][43-1][1-1]*10.0 << "\t"
				  << YTauW[30-1][43-1][1-1]*10.0 << "\t" << Ymu[30-1][43-1][1-1] << endl;


	//---- X-Vessel (18,70,1) --------
	if (XFlow[18-1][70-1][1-1]==0.0 || pXHem[18-1][70-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(XFlow[18-1][70-1][1-1])*pXHem[18-1][70-1][1-1]))+1.0);}

	  outfiletest << "X-vessel" << "\t" << "18-70-1" << "\t" 
		          <<log10(10.0*XTauW[18-1][70-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*XTauE[18-1][70-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pXHem[18-1][70-1][1-1] << "\t"
				  << XBROld[18-1][70-1][1-1]*1e6 << "\t" 
	  	  		  << (XBROld[18-1][70-1][1-1]*angioDeltaT*(
									log10(10.0*XTauW[18-1][70-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*XTauE[18-1][70-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t"
				  << XBR[18-1][70-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabX(18,70,1)-1]*0.007501 << "\t"
				  << XTauE[18-1][70-1][1-1]*10.0 << "\t" 
				  << XTauW[18-1][70-1][1-1]*10.0 << "\t" << Xmu[18-1][70-1][1-1] << endl;


	//---- Y-Vessel (18,70,1) --------
	if (YFlow[18-1][70-1][1-1]==0.0 || pYHem[18-1][70-1][1-1]<0.0001) {metab=0.0;} 
	else {metab=log((FlowRef/(fabs(YFlow[18-1][70-1][1-1])*pYHem[18-1][70-1][1-1]))+1.0);}

	  outfiletest << "Y-vessel" << "\t" << "18-70-1" << "\t" 
		          <<log10(10.0*YTauW[18-1][70-1][1-1]+TauRef) << "\t" 
	    		  << -coeffkp*log10(10.0*YTauE[18-1][70-1][1-1]) << "\t" 
			 	  << coeffkm*metab << "\t" << pYHem[18-1][70-1][1-1] << "\t"
				  << YBROld[18-1][70-1][1-1]*1e6 << "\t" 
	  	  	  	  << (YBROld[18-1][70-1][1-1]*angioDeltaT*(
									log10(10.0*YTauW[18-1][70-1][1-1]+TauRef)
						   -coeffkp*log10(10.0*YTauE[18-1][70-1][1-1])
					       +coeffkm*metab
						   -coeffks))*1e6 << "\t" 
				  << YBR[18-1][70-1][1-1]*1e6 << "\t"
				  << pVesselPressure[LabY(18,70,1)-1]*0.007501 << "\t"
				  << YTauE[18-1][70-1][1-1]*10.0 << "\t" 
				  << YTauW[18-1][70-1][1-1]*10.0 << "\t" << Ymu[18-1][70-1][1-1] << endl;

}//end if loop ...
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
*/
}
//***********************************************
//==========================================
void CAngioNetDlg::LocaliseVesselNutrients()
//==========================================
{
	//sets nutrient concs in vessels

//----------------------------------------------------
	//Used initially to put in nutrient wherever vessels are found

/*	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{	
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}

				if (pFluid[nby-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}

				if (pFluid[nbz-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}
			}//i loop
				 i=m_nx+1;
				int nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}
	}}//j and k loop
*/
//---------------------------------------------------------

	//OR central tumour nutrient only

/*	for (int k=1;k<=m_nz;k++)
	{	for (int j=m_ny/2-m_TumRadius;j<=m_ny/2+m_TumRadius;j++)
		{	for (int i=m_nx/2-(int)sqrt(  pow(m_TumRadius,2)-pow(j-m_ny/2,2)  );
					 i<=m_nx/2+(int)sqrt(  pow(m_TumRadius,2)-pow(j-m_ny/2,2)  );i++)
			//for (int i=m_nx/2-m_TumRadius;i<=m_nx/2+m_TumRadius;i++)
			{	
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}

				if (pFluid[nby-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}

				if (pFluid[nbz-1]==10)
				{	
					pTissueNutrientConc[i-1][j-1][k-1]=1.0;
					pOldTissueNutrientConc[i-1][j-1][k-1]=1.0;
				}
			}//i loop
	}}//j and k loop

*/


/*
//-Vessels filled with nutrient----------------------

	double D_TM=0.000005;//0.0000005;//     0.000005;
	double Haem_crit=0.1;//control transmural O2 wrt Haematocrit


//	for (int k=1;k<=m_nz;k++)
	for (int k=m_nz;k<=m_nz;k++)  //used to set values in 2D and 2D for retina
	{	for (int j=1;j<=m_ny;j++)	//not PV
		{	for (int i=1;i<=m_nx;i++)
			{	

			//-----------flag for allowing PVs to leak (seal X bonds only)-----------
			bool b_allowTransmuralTransport=true;

			if ( j==1)	//upper PV
			{
				b_allowTransmuralTransport=false;
			}

			if ( (b_venousIncluded || b_UU_wound_Model) && j==m_ny-1)	//lower PV if venous system or UU_WoundHeal
			{
				b_allowTransmuralTransport=false;
			}



			for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
			{

			if ( b_UU_wound_Model && j==nCount*m_ny/(nAdditionalCentralPVs+1) 
				&&
			(  i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			   ||
			   i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )  )
			   ) //end if bracket
			{
				b_allowTransmuralTransport=false;
			}

			}	//end for nCount loop



				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{	
					pVesselNutrientConc[nbx-1]=1.0;
					pOldVesselNutrientConc[nbx-1]=1.0;
					//Trey only TIP produced PDGF
					if (pArterialVenousID[nbx-1]>0 &&
						//pXHem[i-1][j-1][k-1]>Haem_crit &&
						b_allowTransmuralTransport)// && pSprout[nbx-1]==1)//arterial side
					{
						D_Transmural[nbx-1]=D_TM;
					}
					else	//venous side
					{
						D_Transmural[nbx-1]=0.0;//D_TM;//5*D_TM;
					}
					
				}

				if (pFluid[nby-1]==10)
				{	
					pVesselNutrientConc[nby-1]=1.0;
					pOldVesselNutrientConc[nby-1]=1.0;
					if (pArterialVenousID[nby-1]>0 &&
						//pYHem[i-1][j-1][k-1]>Haem_crit &&
						b_allowTransmuralTransport)// && pSprout[nby-1]==1)//arterial side
					{
						D_Transmural[nby-1]=D_TM;
					}
					else	//venous side
					{
						D_Transmural[nby-1]=0.0;//D_TM;//5*D_TM;
					}
				}

				if (pFluid[nbz-1]==10)
				{	
					pVesselNutrientConc[nbz-1]=1.0;
					pOldVesselNutrientConc[nbz-1]=1.0;
					if (pArterialVenousID[nbz-1]>0 &&
						//pZHem[i-1][j-1][k-1]>Haem_crit &&
						b_allowTransmuralTransport)// && pSprout[nbz-1]==1)//arterial side
					{
						D_Transmural[nbz-1]=D_TM;
					}
					else	//venous side
					{
						D_Transmural[nbz-1]=0.0;//D_TM;//5*D_TM;
					}
				}
			}//i loop



				 i=m_nx+1;

			//-----------flag for allowing PVs to leak (seal X bonds only)-----------
			bool b_allowTransmuralTransport=true;
			if ( (j==1 || j==m_ny/4 || j==2*m_ny/4 || j==3*m_ny/4 || j==m_ny-1) 
				&&
			(  i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			   ||
			   i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )  )
			   ) //end if bracket
			{
				b_allowTransmuralTransport=false;
			}


				int nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10)
				{	
					pVesselNutrientConc[nbx-1]=1.0;
					pOldVesselNutrientConc[nbx-1]=1.0;
					if (pArterialVenousID[nbx-1]>0 && 
						b_allowTransmuralTransport)// && pSprout[nbx-1]==1)//arterial side
					{
						D_Transmural[nbx-1]=D_TM;
					}
					else	//venous side
					{
						D_Transmural[nbx-1]=0.0;//D_TM;//5*D_TM;
					}
				}
	}}//j and k loop
*/
//---------------------------------------------------------
	//Vary central tumour vessel permeability

/*	if (m_CentralTumour)
	{
	for (int nvessel=1;nvessel<=Nbond;nvessel++)
	{
		D_Transmural[nvessel-1]=0.0;//D_TM/1000;//0.0;
	}

	for ( k=1;k<=m_nz;k++)
	{	for (int j=m_ny/2-m_TumRadius;j<=m_ny/2+m_TumRadius;j++)
		{	for (int i=m_nx/2-(int)sqrt(  pow(m_TumRadius,2)-pow(j-m_ny/2,2)  );
					 i<=m_nx/2+(int)sqrt(  pow(m_TumRadius,2)-pow(j-m_ny/2,2)  );i++)
			//for (int i=m_nx/2-m_TumRadius;i<=m_nx/2+m_TumRadius;i++)
			{	
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pFluid[nbx-1]==10)
				{	
					D_Transmural[nbx-1]=D_TM;
				}

				if (pFluid[nby-1]==10)
				{	
					D_Transmural[nbx-1]=D_TM;
				}

				if (pFluid[nbz-1]==10)
				{	
					D_Transmural[nbx-1]=D_TM;
				}
			}//i loop
	}}//j and k loop
	

	}	//end if CentralTumour
//---------------------------------------------------------------
*/

//Calculate TotalFlowsIn & TotalFlowsOut
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalFlowsIn[i-1][j-1][k-1]=0.5*(
					fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
					fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
					fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

				TotalFlowsOut[i-1][j-1][k-1]=TotalFlowsIn[i-1][j-1][k-1];
	}}}

//Calculate bFlowIn, bFlowOut & NormFractRBC if not already done in UpdateHem2()
	if	(!bSkimming)
	{
		int jp1,kp1;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (j==m_ny) {jp1=1;} else {jp1=j+1;}
					if (k==m_nz) {kp1=1;} else {kp1=k+1;}

					//x-bond to left
					if	(XFlow[i-1][j-1][k-1]>0.0)
					{
						bFlowIn[LabX(i,j,k)-1]=true;	//indicates flow into parent node
					}

					else if	(XFlow[i-1][j-1][k-1]<0.0)
					{
						bFlowOut[LabX(i,j,k)-1]=true;	//indicates flow out of parent node
					}

					//x-bond to right
					if	(XFlow[i+1-1][j-1][k-1]>0.0)
					{
						bFlowIn[LabX(i+1,j,k)-1]=true;
					}

					else if	(XFlow[i+1-1][j-1][k-1]<0.0)
					{
						bFlowOut[LabX(i+1,j,k)-1]=true;
					}
						
					//y-bond above
					if	(YFlow[i-1][j-1][k-1]>0.0)
					{
						bFlowIn[LabY(i,j,k)-1]=true;
					}

					else if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						bFlowOut[LabY(i,j,k)-1]=true;
					}

					//y-bond below
					if	(YFlow[i-1][jp1-1][k-1]>0.0)
					{
						bFlowIn[LabY(i,jp1,k)-1]=true;
					}

					else if	(YFlow[i-1][jp1-1][k-1]<0.0)
					{
						bFlowOut[LabY(i,jp1,k)-1]=true;
					}

					if	(m_nz!=1)
					{
						//z-bond out of screen
						if	(ZFlow[i-1][j-1][k-1]>0.0)
						{
							bFlowIn[LabZ(i,j,k)-1]=true;
						}

						else if	(ZFlow[i-1][j-1][k-1]<0.0)
						{
							bFlowOut[LabZ(i,j,k)-1]=true;
						}

						//z-bond into screen
						if	(ZFlow[i-1][j-1][kp1-1]>0.0)
						{
							bFlowIn[LabZ(i,j,kp1)-1]=true;
						}

						else if	(ZFlow[i-1][j-1][kp1-1]<0.0)
						{
							bFlowOut[LabZ(i,j,kp1)-1]=true;
						}
					}
		}}}

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (j==m_ny) {jp1=1;} else {jp1=j+1;}
					if (k==m_nz) {kp1=1;} else {kp1=k+1;}

					if	(TotalFlowsOut[i-1][j-1][k-1]>0.0)
					{
						if	(XFlow[i-1][j-1][k-1]<0.0)
						{
							NormFractRBCFlowX[i-1][j-1][k-1]=fabs(XFlow[i-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
						}

						if	(XFlow[i+1-1][j-1][k-1]>0.0)
						{
							NormFractRBCFlowX[i+1-1][j-1][k-1]=fabs(XFlow[i+1-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
						}

						if	(YFlow[i-1][j-1][k-1]<0.0)
						{
							NormFractRBCFlowY[i-1][j-1][k-1]=fabs(YFlow[i-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
						}

						if	(YFlow[i-1][jp1-1][k-1]>0.0)
						{
							NormFractRBCFlowY[i-1][jp1-1][k-1]=fabs(YFlow[i-1][j+1-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
						}

						if	(m_nz!=1)
						{
							if	(ZFlow[i-1][j-1][k-1]<0.0)
							{
								NormFractRBCFlowZ[i-1][j-1][k-1]=fabs(ZFlow[i-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
							}

							if	(ZFlow[i-1][j-1][kp1-1]>0.0)
							{
								NormFractRBCFlowZ[i-1][j-1][kp1-1]=fabs(ZFlow[i-1][j-1][kp1-1])/TotalFlowsOut[i-1][j-1][k-1];
							}
						}
					}
		}}}
	}	//end if !bSkimming


//---Assign nutrient carriers and sources--------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)	
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				//---flag for allowing vessels to carry nutrient---
				bAllowNutrientTransport[nbx-1]=false;
				bAllowNutrientTransport[nby-1]=false;
				bAllowNutrientTransport[nbz-1]=false;

				if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1])>1.0e-18 && pXHem[i-1][j-1][k-1]>0.01)
				{	
					if	(FalseFlow[nbx-1]==false)
					{
						bAllowNutrientTransport[nbx-1]=true;
						Perm_Vessel[nbx-1]=vesselPerm;
						DimPerm_Vessel[nbx-1]=DimVesselPerm;

						if	(b_UU_wound_Model && (j==1 || j==m_ny-1))
						{
							Perm_Vessel[nbx-1]=0.0;
							DimPerm_Vessel[nbx-1]=0.0;
						}
//						outfileVasc << "x-bond got here" << "\t" << i << "\t" << j << "\t" << endl;
					}
					
				}

				if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1])>1.0e-18 && pYHem[i-1][j-1][k-1]>0.01)
				{	
					if	(FalseFlow[nby-1]==false)
					{
						bAllowNutrientTransport[nby-1]=true;
						Perm_Vessel[nby-1]=vesselPerm;
						DimPerm_Vessel[nby-1]=DimVesselPerm;
						
//						outfileVasc << "y-bond got here" << "\t" << i << "\t" << j << "\t" << endl;
					}
				}

				if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1])>1.0e-18 && pZHem[i-1][j-1][k-1]>0.01)
				{	
					if	(FalseFlow[nbz-1]==false)
					{
						bAllowNutrientTransport[nbz-1]=true;
						Perm_Vessel[nbz-1]=vesselPerm;
						DimPerm_Vessel[nbz-1]=DimVesselPerm;
					}
				}
//-----------------------------------------------
			}//i loop

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			//---flag for allowing vessels to carry nutrient---
			bAllowNutrientTransport[nbx-1]=false;

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1])>1.0e-18 && pXHem[i-1][j-1][k-1]>0.01)
			{	
				if	(FalseFlow[nbx-1]==false)
				{
					bAllowNutrientTransport[nbx-1]=true;
					Perm_Vessel[nbx-1]=vesselPerm;
					DimPerm_Vessel[nbx-1]=DimVesselPerm;

					if	(b_UU_wound_Model && (j==1 || j==m_ny-1))
					{
						Perm_Vessel[nbx-1]=0.0;
						DimPerm_Vessel[nbx-1]=0.0;
					}
//					outfileVasc << "x-dangler got here" << "\t" << i << "\t" << j << "\t" << endl;
				}
			}
//-----------------------------------------------
	}}//j and k loop
}
//***********************************************
//===============================================
void CAngioNetDlg::UpdateTissueNutrientConcs()
//===============================================
{
	//Cannibalises MDF algorithm, so ignore MDF references here - replace with nutrient
	// Print out some stuff
	// Get a device context first
	CClientDC graphicsDC(this);

//---------------------------------------------------------
	//--Keeps a total of how much "conc" has to be removed from each vessel
	//--These are updated in Source() for all vessels at end of the gridblock nutrient updates

	for (int n=1;n<=Nbond;n++) { pConcDecrement[n-1]=0.0; }

	//------------------------------------------------------

	double*** pStoredOldTissueConc=NULL;
	pStoredOldTissueConc=new double** [m_nx+1]; //m_nx+1 tissue blocks

	for (int i=0;i<=m_nx;i++)
	{    
		pStoredOldTissueConc[i]=new double* [m_ny];
	}

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	 
			pStoredOldTissueConc[i][j]=new double [m_nz];
		}
	}

//-----------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				pStoredOldTissueConc[i-1][j-1][k-1]=0.0;
			}
		}
	}
//-----------------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				pStoredOldTissueConc[i-1][j-1][k-1]=pOldTissueNutrientConc[i-1][j-1][k-1];
			}
		}
	}
//--------------------------------------------------

	// Print the loop variable
	CString myString;
	int yval=200; // ?

	int iplus,iminus,jplus,jminus,kplus,kminus;

	double subAngioDeltaT;

	if (m_nz==1) { subAngioDeltaT=oxyDeltaT/2.0; } // for a 2D network
		else     { subAngioDeltaT=oxyDeltaT/3.0; } // for a 3D network
 
	//NB D_Transmural is set in LocaliseNutrient..() and defines
	//magnitude of Source terms (in Source())
	//double diffCoeffTissue=0.0005;//(Mike 07/10)0.000005;//0.0000025;//0.000005;//10e-6;	//intratissue diffusion coefficient
	//Modified value 14_4_2008 SMcD
	//double sigma=0.00015;//(Mike 07/10)0.1;//0.01;				//decay constant
	double sig_Uptake=0.0;//0.1; //same as TAF uptake rate by ECs. Is this OK?

	double diffCoeff_bone=diffCoeffNutrient/1.0e10;

	double diffCoeff_left, diffCoeff_right, diffCoeff_up, diffCoeff_down, diffCoeff_back, diffCoeff_front;

//*************************************
/*	double LeftBoundaryConc=0.1;//0.3;
	double RightBoundaryConc=0.1;//0.3;
	double TopBoundaryConc=0.0;//0.3;
	double BottomBoundaryConc=0.0;//0.3;

	double WoundRad=(double)(iWoundRadius)/(double)(m_nx)*2.0;//
	double sigma_Wound=0.000167;
	double sigma_Basal=0.000167;
*/
//*************************************

//	double lambdaX=(diffCoeffNutrient*subAngioDeltaT)/(pow(angioDeltaX,2));//XX Not m_Diff, eps
//	double lambdaY=(diffCoeffNutrient*subAngioDeltaT)/(pow(angioDeltaY,2));
	
	angioDeltaZ=angioDeltaY;

//	double lambdaZ=(diffCoeffNutrient*subAngioDeltaT)/(pow(angioDeltaZ,2));
	//or angioDeltaZ=angioDeltaY to avoid a division by zero (see InitVariables())

    double* coeffA;
	double* coeffB; 
	double* coeffC;
	double* coeffD;

//---------------------------------------------------------------------------
// calculation of the variables in the x-direction time=[t,t+subAngioDeltaT]
//---------------------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nx+1];
	coeffB=new double[m_nx+1];
    coeffC=new double[m_nx+1];
	coeffD=new double[m_nx+1];

	//-----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{  //----------------------------
		
			for (int i=0;i<=m_nx;i++) 
			{	
		
		
		//---Impose zero-flux BCs---
					if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
					if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
					if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
					if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

					if (m_nz==1)	{kminus=k; kplus=k;}

					else 
					{
						if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
						if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
					}

//---Assign D for flux in each direction---
					if	(bBoneTissue[i][j][k]==FALSE)
					{
						if	(i!=0)
						{
							if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=diffCoeff_bone;}	else	{diffCoeff_left=diffCoeffNutrient;}
						}

						if	(i!=m_nx)
						{
							if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=diffCoeff_bone;}	else	{diffCoeff_right=diffCoeffNutrient;}
						}

						if	(j!=0)
						{
							if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=diffCoeff_bone;}	else	{diffCoeff_up=diffCoeffNutrient;}
						}

						if	(j!=m_ny-1)
						{
							if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=diffCoeff_bone;}	else	{diffCoeff_down=diffCoeffNutrient;}
						}

						if	(k!=0)
						{
							if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=diffCoeff_bone;}	else	{diffCoeff_back=diffCoeffNutrient;}
						}

						if	(k!=m_nz-1)
						{
							if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=diffCoeff_bone;}	else	{diffCoeff_front=diffCoeffNutrient;}
						}
					}

					else
					{
						diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=diffCoeff_bone;
					}
				
//---Match up D values for consistent BCs---
					if	(i==0)		{diffCoeff_left=diffCoeff_right;}
					if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
					if	(j==0)		{diffCoeff_up=diffCoeff_down;}
					if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
					if	(m_nz!=1)
					{
						if	(k==0)		{diffCoeff_back=diffCoeff_front;}
						if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
					}

					else
					{
						diffCoeff_back=diffCoeff_front=diffCoeffNutrient;
					}
			

	//=========Check to see if uptake by PC is needed	
		
		int PC_Present=0;	//no pericyte at the site yet

		int nbx=LabX(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nby=LabY(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nbz=LabZ(i+1,j+1,k+1);	//add 1 to get into correct range for LabX

		if (bDiscretePericyte[nbx-1] || bDiscretePericyte[nby-1] ||
			bDiscretePericyte[nbz-1]) {PC_Present=1;}	//add uptake term if
														// PC is present
														//(active or not)
	//===============================================

//*************************************
/*		if	(b_UU_wound_Model)
		{
			double distFromCentre=2.0*sqrt(pow(0.5-(double)(((double)(i+0.5))/m_nx),2.0)+pow(0.5-(double)(((double)(j+0.5))/m_ny),2.0));
		
			if	(distFromCentre<=WoundRad)		{sigma_Nutrient=sigma_Wound;}
			else if	(distFromCentre>WoundRad)	{sigma_Nutrient=sigma_Basal;}
		}
*/
/*		if	(b_UU_wound_Model)
		{
			double distFromCentre=2.0*sqrt(pow(0.5-(double)(((double)(i+0.5))/m_nx),2.0)+pow(0.5-(double)(((double)(j+0.5))/m_ny),2.0));
		
//			if	(distFromCentre<=1.0)		{sigma_Nutrient=sigma_Wound*exp(-(pow(distFromCentre,6.0)/0.209));}
//			else if	(distFromCentre>1.0)	{sigma_Nutrient=sigma_Basal;}

			sigma_Nutrient=sigma_Wound-0.00695*distFromCentre;
		}
*/
//*************************************

	// update Matrix Degradation Factor (MDF)
		coeffA[i]=-diffCoeff_left*subAngioDeltaT/angioDeltaX/angioDeltaX;
		coeffB[i]=1.0+(diffCoeff_left+diffCoeff_right)*subAngioDeltaT/angioDeltaX/angioDeltaX;
		coeffC[i]=-diffCoeff_right*subAngioDeltaT/angioDeltaX/angioDeltaX;

		coeffD[i]=	pOldTissueNutrientConc[i][j][k]
					+	subAngioDeltaT*	( 
												Source(i,j,k)-sigma_Nutrient*pOldTissueNutrientConc[i][j][k]-sig_Uptake*pOldTissueNutrientConc[i][j][k]*PC_Present
											+	(diffCoeff_up*pOldTissueNutrientConc[i][jminus][k]-(diffCoeff_up+diffCoeff_down)*pOldTissueNutrientConc[i][j][k]
													+diffCoeff_down*pOldTissueNutrientConc[i][jplus][k])/angioDeltaY/angioDeltaY
											+	(diffCoeff_back*pOldTissueNutrientConc[i][j][kminus]-(diffCoeff_back+diffCoeff_front)*pOldTissueNutrientConc[i][j][k]
													+diffCoeff_front*pOldTissueNutrientConc[i][j][kplus])/angioDeltaZ/angioDeltaZ
										);

//*************************************
/*		 if	(i==0 && j!=0 && j!=m_ny-1)		{coeffD[i]+=max(0.0,lambdaX*(LeftBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
		 if	(i==m_nx && j!=0 && j!=m_ny-1)	{coeffD[i]+=max(0.0,lambdaX*(RightBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
		 if	(j==0)							{coeffD[i]+=max(0.0,lambdaY*(TopBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
		 if	(j==m_ny-1)						{coeffD[i]+=max(0.0,lambdaY*(BottomBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
*/
//*************************************

////		pTissueNutrientConc[i][j][k]=pTissueNutrientConc[i][j][k]-
////			angioDeltaT*sigma*pOldTissueNutrientConc[i][j][k];

		} // end loop i


		SolveTridiagTissX(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);

	
	}} // end loops j and k



//--------------------------------------------------------------------------------------------
// calculation of the variables in the y-direction time=[t+subAngioDeltaT,t+2*subAngioDeltaT]
//--------------------------------------------------------------------------------------------

	//=======================
	  OverWriteOldWithNewTiss();
	//=======================
		//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------


	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_ny];
	coeffB=new double[m_ny];
    coeffC=new double[m_ny];
	coeffD=new double[m_ny];
 
	//----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{   for ( int i=0;i<=m_nx;i++)
		{  //----------------------------
		
			for (int j=0;j<=m_ny-1;j++) 
			{

		//---Impose zero-flux BCs---
					if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
					if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
					if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
					if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

					if (m_nz==1)	{kminus=k; kplus=k;}

					else 
					{
						if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
						if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
					}

//---Assign D for flux in each direction---
					if	(bBoneTissue[i][j][k]==FALSE)
					{
						if	(i!=0)
						{
							if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=diffCoeff_bone;}	else	{diffCoeff_left=diffCoeffNutrient;}
						}

						if	(i!=m_nx)
						{
							if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=diffCoeff_bone;}	else	{diffCoeff_right=diffCoeffNutrient;}
						}

						if	(j!=0)
						{
							if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=diffCoeff_bone;}	else	{diffCoeff_up=diffCoeffNutrient;}
						}

						if	(j!=m_ny-1)
						{
							if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=diffCoeff_bone;}	else	{diffCoeff_down=diffCoeffNutrient;}
						}

						if	(k!=0)
						{
							if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=diffCoeff_bone;}	else	{diffCoeff_back=diffCoeffNutrient;}
						}

						if	(k!=m_nz-1)
						{
							if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=diffCoeff_bone;}	else	{diffCoeff_front=diffCoeffNutrient;}
						}
					}

					else
					{
						diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=diffCoeff_bone;
					}
				
//---Match up D values for consistent BCs---
					if	(i==0)		{diffCoeff_left=diffCoeff_right;}
					if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
					if	(j==0)		{diffCoeff_up=diffCoeff_down;}
					if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
					if	(m_nz!=1)
					{
						if	(k==0)		{diffCoeff_back=diffCoeff_front;}
						if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
					}

					else
					{
						diffCoeff_back=diffCoeff_front=diffCoeffNutrient;
					}

		//=========Check to see if uptake by PC is needed	
		
		int PC_Present=0;	//no pericyte at the site yet

		int nbx=LabX(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nby=LabY(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nbz=LabZ(i+1,j+1,k+1);	//add 1 to get into correct range for LabX

		if (bDiscretePericyte[nbx-1] || bDiscretePericyte[nby-1] ||
			bDiscretePericyte[nbz-1]) {PC_Present=1;}  //add uptake term
	//===============================================

//*************************************
/*		if	(b_UU_wound_Model)
		{
			double distFromCentre=2.0*sqrt(pow(0.5-(double)(((double)(i+0.5))/m_nx),2.0)+pow(0.5-(double)(((double)(j+0.5))/m_ny),2.0));
		
			if	(distFromCentre<=WoundRad)		{sigma_Nutrient=sigma_Wound;}
			else if	(distFromCentre>WoundRad)	{sigma_Nutrient=sigma_Basal;}
		}
*/
/*		if	(b_UU_wound_Model)
		{
			double distFromCentre=2.0*sqrt(pow(0.5-(double)(((double)(i+0.5))/m_nx),2.0)+pow(0.5-(double)(((double)(j+0.5))/m_ny),2.0));
		
//			if	(distFromCentre<=1.0)		{sigma_Nutrient=sigma_Wound*exp(-(pow(distFromCentre,6.0)/0.209));}
//			else if	(distFromCentre>1.0)	{sigma_Nutrient=sigma_Basal;}

			sigma_Nutrient=sigma_Wound-0.00695*distFromCentre;
		}*/
//*************************************

	// update Matrix Degradation Factor (MDF)
		coeffA[j]=-diffCoeff_up*subAngioDeltaT/angioDeltaY/angioDeltaY;
		coeffB[j]=1.0+(diffCoeff_up+diffCoeff_down)*subAngioDeltaT/angioDeltaY/angioDeltaY;
		coeffC[j]=-diffCoeff_down*subAngioDeltaT/angioDeltaY/angioDeltaY;

		coeffD[j]=	pOldTissueNutrientConc[i][j][k]
					+	subAngioDeltaT*	( 
												Source(i,j,k)-sigma_Nutrient*pOldTissueNutrientConc[i][j][k]-sig_Uptake*pOldTissueNutrientConc[i][j][k]*PC_Present
											+	(diffCoeff_left*pOldTissueNutrientConc[iminus][j][k]-(diffCoeff_left+diffCoeff_right)*pOldTissueNutrientConc[i][j][k]
													+diffCoeff_right*pOldTissueNutrientConc[iplus][j][k])/angioDeltaX/angioDeltaX
											+	(diffCoeff_back*pOldTissueNutrientConc[i][j][kminus]-(diffCoeff_back+diffCoeff_front)*pOldTissueNutrientConc[i][j][k]
													+diffCoeff_front*pOldTissueNutrientConc[i][j][kplus])/angioDeltaZ/angioDeltaZ
										);

//*************************************		
/*		 if	(i==0 && j!=0 && j!=m_ny-1)		{coeffD[j]+=max(0.0,lambdaX*(LeftBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
		 if	(i==m_nx && j!=0 && j!=m_ny-1)	{coeffD[j]+=max(0.0,lambdaX*(RightBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
		 if	(j==0)							{coeffD[j]+=max(0.0,lambdaY*(TopBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
		 if	(j==m_ny-1)						{coeffD[j]+=max(0.0,lambdaY*(BottomBoundaryConc-pOldTissueNutrientConc[i][j][k]));}
*/
//*************************************

		} // end loop j

		SolveTridiagTissY(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and k
 

	//=======================
	  OverWriteOldWithNewTiss();	///SMcD  $$$$  SHOULD WE NOT CALL THIS HERE TOO 
								////   (if  nz=1 then the y-values are not overwritten)
	//=======================
		//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------
//-----------------------------------------------------------------------------------------
// calculation of the variables in the z-direction time=[t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz is not equal to 1 (i.e. 3D network)
//------------------------------------------------------------------------------------------


	if (m_nz!=1) { //=====================================================================


	//=======================
	////SMcD  OverWriteOldWithNewMDF();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nz];
	coeffB=new double[m_nz];
    coeffC=new double[m_nz];
	coeffD=new double[m_nz];

	//-----------------------------
	for (int i=0;i<=m_nx;i++)
	{   for (int j=0;j<=m_ny-1;j++)
		{   //----------------------------
		
			for (int k=0;k<=m_nz-1;k++) 
			{	
		
		//---Impose zero-flux BCs---
					if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
					if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
					if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
					if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

					if (m_nz==1)	{kminus=k; kplus=k;}

					else 
					{
						if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
						if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
					}

//---Assign D for flux in each direction---
					if	(bBoneTissue[i][j][k]==FALSE)
					{
						if	(i!=0)
						{
							if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=diffCoeff_bone;}	else	{diffCoeff_left=diffCoeffNutrient;}
						}

						if	(i!=m_nx)
						{
							if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=diffCoeff_bone;}	else	{diffCoeff_right=diffCoeffNutrient;}
						}

						if	(j!=0)
						{
							if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=diffCoeff_bone;}	else	{diffCoeff_up=diffCoeffNutrient;}
						}

						if	(j!=m_ny-1)
						{
							if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=diffCoeff_bone;}	else	{diffCoeff_down=diffCoeffNutrient;}
						}

						if	(k!=0)
						{
							if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=diffCoeff_bone;}	else	{diffCoeff_back=diffCoeffNutrient;}
						}

						if	(k!=m_nz-1)
						{
							if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=diffCoeff_bone;}	else	{diffCoeff_front=diffCoeffNutrient;}
						}
					}

					else
					{
						diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=diffCoeff_bone;
					}
				
//---Match up D values for consistent BCs---
					if	(i==0)		{diffCoeff_left=diffCoeff_right;}
					if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
					if	(j==0)		{diffCoeff_up=diffCoeff_down;}
					if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
					if	(m_nz!=1)
					{
						if	(k==0)		{diffCoeff_back=diffCoeff_front;}
						if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
					}

					else
					{
						diffCoeff_back=diffCoeff_front=diffCoeffNutrient;
					}

	//=========Check to see if uptake by PC is needed	
		
		int PC_Present=0;	//no pericyte at the site yet

		int nbx=LabX(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nby=LabY(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nbz=LabZ(i+1,j+1,k+1);	//add 1 to get into correct range for LabX

		if (bDiscretePericyte[nbx-1] || bDiscretePericyte[nby-1] ||
			bDiscretePericyte[nbz-1]) {PC_Present=1;}  //add uptake term
	//===============================================


	// update EndoCellDensity
		coeffA[k]=-diffCoeff_back*subAngioDeltaT/angioDeltaZ/angioDeltaZ;
		coeffB[k]=1.0+(diffCoeff_back+diffCoeff_front)*subAngioDeltaT/angioDeltaZ/angioDeltaZ;
		coeffC[k]=-diffCoeff_front*subAngioDeltaT/angioDeltaZ/angioDeltaZ;

		coeffD[k]=	pOldTissueNutrientConc[i][j][k]
					+	subAngioDeltaT*	( 
												Source(i,j,k)-sigma_Nutrient*pOldTissueNutrientConc[i][j][k]-sig_Uptake*pOldTissueNutrientConc[i][j][k]*PC_Present
											+	(diffCoeff_left*pOldTissueNutrientConc[iminus][j][k]-(diffCoeff_left+diffCoeff_right)*pOldTissueNutrientConc[i][j][k]
													+diffCoeff_right*pOldTissueNutrientConc[iplus][j][k])/angioDeltaX/angioDeltaX
											+	(diffCoeff_up*pOldTissueNutrientConc[i][jminus][k]-(diffCoeff_up+diffCoeff_down)*pOldTissueNutrientConc[i][j][k]
													+diffCoeff_down*pOldTissueNutrientConc[i][jplus][k])/angioDeltaY/angioDeltaY
										);

  		} // end loop k

		SolveTridiagTissZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and j



	OverWriteOldWithNewTiss();	//SMcD put this in

		//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------

	} // end if (m_nz!=1) =============================================================





	// Now get new running TissueConc maximum
	runningTissConcMAX=0.0; // used for graphics

	if	(oxyTime>10.0 && RateNutChangeMAX<=2.5e-5)//if	(loop%25000==0 || angiotime>m_angiotimeMax)
	{

//		double TotalOxygen=0.0;
//		int nTissueBlocks=0;

		for (int k=0;k<=m_nz-1;k++)
		{	for (int j=0;j<=m_ny-1;j++)
			{	for (int i=0;i<=m_nx;i++)
				{
					if (pTissueNutrientConc[i][j][k]>runningTissConcMAX)
					{	
						runningTissConcMAX=pTissueNutrientConc[i][j][k];
					}

/*					if	(
							(i>=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) ) && i<iCentre)
							||
							(i<=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) ) && i>iCentre)
						)
					{
						TotalOxygen+=pTissueNutrientConc[i][j][k];
						nTissueBlocks+=1;
					}

//					int nbx=LabX(i+1,j+1,k+1);	
//					int nby=LabY(i+1,j+1,k+1);

//					if (pFluid[nbx-1]==10)	{outfileFlows << i << "\t" << j << "\t" << XFlow[i][j][k] << "\t" << pXHem[i][j][k] << endl;}
//					if (pFluid[nby-1]==10)	{outfileFlows << i << "\t" << j << "\t" << YFlow[i][j][k] << "\t" << pYHem[i][j][k] << endl;}
*/			
		}}}

//		outfileWoundOxygen << TotalOxygen << "\t" << nTissueBlocks << endl;

//-----------------------------------------------

//*************************************
/*		int i,j,n,p,q;

		double* CircOxygen;	//sum of oxy concs within each circle
		double* RegOxygen;	//sum of oxy concs within each corresponding region
		double* CircRadius;	//fraction of wound radius used to define each circle
		int* CircBlocks;	//no. of tissue blocks within each circle 

		CircOxygen=NULL;
		RegOxygen=NULL;
		CircRadius=NULL;
		CircBlocks=NULL;

		CircOxygen=new double[9];
		RegOxygen=new double[5];	
		CircRadius=new double[9];
		CircBlocks=new int[9];

		for (i=0;i<=8;i++)	{CircOxygen[i]=0.0;	CircRadius[i]=0.0;	CircBlocks[i]=0;}				
		for (i=0;i<=4;i++)	{RegOxygen[i]=0.0;}

		CircRadius[1]=2.0/15.0;
		CircRadius[8]=1.0;									
													
		for (p=1;p<=3;p++)									
		{												
			CircRadius[2*p]=CircRadius[2*p-1]+3.0/20.0;	
			CircRadius[2*p+1]=CircRadius[2*p]+4.0/15.0;	
		}												

		for (n=1;n<=8;n++)
		{
			for (int k=1;k<=m_nz;k++)
			{	
				for (j=1;j<=m_ny;j++)
				{	
					for (i=1;i<=m_nx;i++)
					{					
//--------------------------------------------------

						if	(
								i>iCentre-(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )  
								&&                                                           
								i<iCentre+(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )
							)
						{
							CircOxygen[n]+=pTissueNutrientConc[i-1][j-1][k-1];
							CircBlocks[n]+=1;
						}
					}
				}
			}
		}

		for (q=1;q<=4;q++)
		{					
			RegOxygen[q]=(CircOxygen[2*q-1]-CircOxygen[2*q-2]);
		}

		outfileRegionOxygen << RegOxygen[1] << "\t" << CircBlocks[1] << endl;
		outfileRegionOxygen << RegOxygen[2] << "\t" << CircBlocks[3]-CircBlocks[2] << endl;
		outfileRegionOxygen << RegOxygen[3] << "\t" << CircBlocks[5]-CircBlocks[4] << endl;
		outfileRegionOxygen << RegOxygen[4] << "\t" << CircBlocks[7]-CircBlocks[6] << endl;

		delete [] CircOxygen;			
		delete [] RegOxygen;
		delete [] CircRadius;

		SaveNutrient();

		while(1)
		{
			OnDrawIt3();	//KEEP GRAPHICS ALIVE AFTER LAST LOOP IN REPLAY
			ProcessMessageLoop();
			UpdateData();
		}
*/	}
//	outfileFlows << "loop finished" << endl;

//*************************************

	double RateNutChange=0.0;
	RateNutChangeMAX=0.0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				RateNutChange=fabs(pStoredOldTissueConc[i-1][j-1][k-1]-pTissueNutrientConc[i-1][j-1][k-1])/oxyDeltaT;

				if	(RateNutChange>RateNutChangeMAX)	{RateNutChangeMAX=RateNutChange;}
			}
		}
	}

	outfileNutConverge << angiotime << "\t" << RateNutChangeMAX << endl;

//---------------------------------------------------------------
	for (int i=1;i<=m_nx+1;i++)
	{	for (int j=1;j<=m_ny;j++)
		{
			delete[] pStoredOldTissueConc[i-1][j-1];
		}
	}

	for (int i=1;i<=m_nx+1;i++)
	{
		delete[] pStoredOldTissueConc[i-1];
	}

	delete [] pStoredOldTissueConc;

//--------------------------------------------------

//---------------------------------------------------------------

//--Finally, modify the vessel concentrations----

//	for ( n=1;n<=Nbond;n++)
//	{
//
//		pVesselNutrientConc[n-1]=pOldVesselNutrientConc[n-1]-pConcDecrement[n-1];
//	}

//--------------------------------------
//CALCULATE TOTAL MASS IN TO EACH NODE
//NB - ONLY THOSE CARRYING RBCS
//--------------------------------------

	int jp1,kp1;
	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalMassesIn[i-1][j-1][k-1]=0.0;

				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabX(i,j,k)-1]*CharTime*oxyDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabX(i+1,j,k)-1]*fabs(XFlow[i+1-1][j-1][k-1])*pOldVesselNutrientConc[LabX(i+1,j,k)-1]*CharTime*oxyDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabY(i,j,k)-1]*CharTime*oxyDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabY(i,jp1,k)-1]*fabs(YFlow[i-1][jp1-1][k-1])*pOldVesselNutrientConc[LabY(i,jp1,k)-1]*CharTime*oxyDeltaT;

				if	(m_nz!=1)
				{
					TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabZ(i,j,k)-1]*CharTime*oxyDeltaT;

		  			TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabZ(i,j,kp1)-1]*fabs(ZFlow[i-1][j-1][kp1-1])*pOldVesselNutrientConc[LabZ(i,j,kp1)-1]*CharTime*oxyDeltaT;
				}
	
	}}}

//--------------------------------
//UPDATE NUTRIENT IN EACH VESSEL
//--------------------------------
	int zpos,jm1,km1;
	int nCount=1;//0;//

	if (m_nz==1) {zpos=1;} else {zpos=int(m_nz/2);}
//outfileDebugOxyTracer << flowTime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==1) {jm1=m_ny;} else {jm1=j-1;}
				if (k==1) {km1=m_nz;} else {km1=k-1;}

				
//---x-pores---
				if	(i==1)	//inlet nodes
				{	  
					if	(
							!b_TestNetwork && 
//							(
								(j==1 && (k==4 || k==10 || k==16 || k==22 || k==29 || k==35 || k==41 || k==47))//(k==7 || k==19 || k==32 || k==44))//k==int(m_nz/10))//5)//(j==1 && k==zpos)//	(j==1 && k==zpos)	
								|| 
//								(b_venousIncluded && j==m_ny-1 && k==zpos)
//								|| 
								(b_UU_wound_Model && j==nCount*m_ny/(nAdditionalCentralPVs+1) && k==zpos && j!=100)
//								|| 
//								(b_UU_wound_Model && j==m_ny-1 && k==zpos)
//							)
						)//**arts** 

						{
							if	(!b_HexNetwork || (b_HexNetwork && b_StraightPVs))	//square network or hex network with straight PVs
							{
								pVesselNutrientConc[LabX(i,j,k)-1]+=fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT/
																		(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])*
																			(InputNutConc-pOldVesselNutrientConc[LabX(i,j,k)-1]);

								nCount++;
							}

//-----------------------------------------------						
							else if	(b_HexNetwork && !b_StraightPVs)	//hexagonal network	
							{
								if	(int(j/2)-double(j/2.0)==0)	//j even, inlets at j+1
								{
									pVesselNutrientConc[LabX(i,j+1,k)-1]+=fabs(XFlow[i-1][j+1-1][k-1])*oxyDeltaT/
																			(PI*pow(XBR[i-1][j+1-1][k-1],2)*XBL[i-1][j+1-1][k-1])*
																				(InputNutConc-pOldVesselNutrientConc[LabX(i,j+1,k)-1]);
								}

								else	//j odd, inlets at j
								{
									pVesselNutrientConc[LabX(i,j,k)-1]+=fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT/
																			(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])*
																				(InputNutConc-pOldVesselNutrientConc[LabX(i,j,k)-1]);
								}

								nCount++;	//step to next additional PV

							}	//end if hexagonal network

//-----------------------------------------------
						}	//end if j=...

//-----------------------------------------------											
								//pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06

			  					//pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*timestep/
			  					//(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
			  					//(AverageHt-pXHem[i-1][j-1][k-1]);				
					
//-----------------------------------------------

					if	(b_TestNetwork)
					{
						if	(
								(j==51 && pFluid[LabX(i,51,k)-1]==10)	//one inlet at centre for branching networks
								||
								(j==2 && pFluid[LabX(i,2,k)-1]==10)		//one inlet at top for retina network
							)
						{
							pVesselNutrientConc[LabX(i,j,k)-1]+=fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT/
																	(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])*
																		(InputNutConc-pOldVesselNutrientConc[LabX(i,j,k)-1]);
						}
					}
					
//-----------------------------------------------
			  //2nd arteriole
			  //if (j==m_ny-1 && k==1) //**2nd art** //Updated SMcD 07.11.06
				//	{
				  //pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
				//		(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
				//		(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
				  
			//		pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06
			//		}

//-----------------------------------------------
				}  //end if i=1

//-----------------------------------------------

				else	//not the inlet port
				{
					if	(TotalFlowsOut[i-1][j-1][k-1]>0)
					{
						if	(
								XFlow[i-1][j-1][k-1]<0.0 
								&& 
								(bAllowNutrientTransport[LabX(i,j,k)-1] || j==2)
							)
						{
							pVesselNutrientConc[LabX(i,j,k)-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][k-1])
																	-(pOldVesselNutrientConc[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]))
																			-pConcDecrement[LabX(i,j,k)-1];
						}

						else if (
									XFlow[i-1][j-1][k-1]>0.0 
									&& 
									(bAllowNutrientTransport[LabX(i,j,k)-1] || j==2)
								)
						{
							pVesselNutrientConc[LabX(i,j,k)-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassesIn[i-1-1][j-1][k-1])
																	-(pOldVesselNutrientConc[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]))
																			-pConcDecrement[LabX(i,j,k)-1];
//outfileDebugOxyTracer << i << "\t" << j << "\t" << NormFractRBCFlowX[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1-1][j-1][k-1] << "\t" << pOldVesselNutrientConc[LabX(i,j,k)-1] << "\t" << fabs(XFlow[i-1][j-1][k-1]) << "\t" << pConcDecrement[LabX(i,j,k)-1] << endl;  
						}

//-----------------------------------------------
					}	//end if TotalFlowOut>0

				}	//end if i!=1

//-----------------------------------------------
//---y-pores---

				if	(TotalFlowsOut[i-1][j-1][k-1]>0)
				{
					if	(
							YFlow[i-1][j-1][k-1]<0.0 
							&& 
							bAllowNutrientTransport[LabY(i,j,k)-1]
						)
					{
						pVesselNutrientConc[LabY(i,j,k)-1]+=(((NormFractRBCFlowY[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][k-1])
																-(pOldVesselNutrientConc[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																	/(PI*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]))
																		-pConcDecrement[LabY(i,j,k)-1];
					}

					else if (
								YFlow[i-1][j-1][k-1]>0.0 
								&& 
								bAllowNutrientTransport[LabY(i,j,k)-1]
							)
					{
						pVesselNutrientConc[LabY(i,j,k)-1]+=(((NormFractRBCFlowY[i-1][j-1][k-1]*TotalMassesIn[i-1][jm1-1][k-1])
																-(pOldVesselNutrientConc[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																	/(PI*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]))
																		-pConcDecrement[LabY(i,j,k)-1];
					}

//-----------------------------------------------
				}	//end if TotalFlowOut>0

//-----------------------------------------------
//---z-pores---
				if	(m_nz!=1)
				{
					if	(TotalFlowsOut[i-1][j-1][k-1]>0)
					{
						if	(
								ZFlow[i-1][j-1][k-1]<0.0 
								&& 
								bAllowNutrientTransport[LabZ(i,j,k)-1]
							)
						{
							pVesselNutrientConc[LabZ(i,j,k)-1]+=((NormFractRBCFlowZ[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][k-1])
																	-(pOldVesselNutrientConc[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1])
																			-pConcDecrement[LabZ(i,j,k)-1];
						}

						else if	(
									ZFlow[i-1][j-1][k-1]>0.0 
									&& 
									bAllowNutrientTransport[LabZ(i,j,k)-1]
								)
						{
							pVesselNutrientConc[LabZ(i,j,k)-1]+=(((NormFractRBCFlowZ[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][km1-1])
																	-(pOldVesselNutrientConc[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]))
																			-pConcDecrement[LabZ(i,j,k)-1];
						}

//-----------------------------------------------
					}	//end if TotalflowOut>0
				}
//-----------------------------------------------
			}	// end i-loop

//-----------------------------------------------
//---x-danglers---
			int i=m_nx+1;

			if	(
					TotalFlowsOut[i-1-1][j-1][k-1]>0
					&&
					bAllowNutrientTransport[LabX(i,j,k)-1]
				)
			{
				pVesselNutrientConc[LabX(i,j,k)-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassesIn[i-1-1][j-1][k-1])
														-(pOldVesselNutrientConc[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
															/(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]))
																-pConcDecrement[LabX(i,j,k)-1];
			}

//-----------------------------------------------
		}	//end j loop
	}	//end k loop

//-----------------------------------------------

//---------------------------------------------------------------
}
//*****************************************************************
//****************************************************************

void CAngioNetDlg::SolveTridiagTissX(int m_nx, int m_ny, int m_nz, int j, int k, 
									 double *coeffA, double *coeffB, double *coeffC, double *coeffD)
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nx+1]; // indice: 0 to m_nx
	q=new double[m_nx+1];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int i=1;i<=m_nx;i++)
	{
		p[i]=coeffC[i]/(coeffB[i]-coeffA[i]*p[i-1]);
		q[i]=(coeffD[i]-coeffA[i]*q[i-1])/(coeffB[i]-coeffA[i]*p[i-1]);
	}

	//calculation of the function for the next time step (iteration)
	pTissueNutrientConc[m_nx][j][k]=(q[m_nx]-p[m_nx]*q[m_nx-1])/(1.0-p[m_nx]*p[m_nx-1]);

	int i=m_nx-1;
	while(i>-1)
    {
		pTissueNutrientConc[i][j][k]=q[i]-pTissueNutrientConc[i+1][j][k]*p[i];
		i=i-1;
	}

	//----------
	delete [] p;
	delete [] q;


}
//****************************************************************

void CAngioNetDlg::SolveTridiagTissY(int m_nx, int m_ny, int m_nz, int i, int k, 
									 double *coeffA, double *coeffB, double *coeffC, double *coeffD)
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_ny]; // indice: 0 to m_ny-1
	q=new double[m_ny];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int j=1;j<=m_ny-1;j++)
	{
		p[j]=coeffC[j]/(coeffB[j]-coeffA[j]*p[j-1]);
		q[j]=(coeffD[j]-coeffA[j]*q[j-1])/(coeffB[j]-coeffA[j]*p[j-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	pTissueNutrientConc[i][m_ny-1][k]=(q[m_ny-1]-p[m_ny-1]*q[m_ny-2])/(1.0-p[m_ny-1]*p[m_ny-2]);

	int j=m_ny-2;
	while(j>-1)
    {
		pTissueNutrientConc[i][j][k]=q[j]-pTissueNutrientConc[i][j+1][k]*p[j];
		j=j-1;
	}

	//----------
	delete [] p;
	delete [] q;
}
//****************************************************************

void CAngioNetDlg::SolveTridiagTissZ(int m_nx, int m_ny, int m_nz, int i, int j, 
									 double *coeffA, double *coeffB, double *coeffC, double *coeffD)
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nz]; // indice: 0 to m_nz-1
	q=new double[m_nz];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int k=1;k<=m_nz-1;k++)
	{
		p[k]=coeffC[k]/(coeffB[k]-coeffA[k]*p[k-1]);
		q[k]=(coeffD[k]-coeffA[k]*q[k-1])/(coeffB[k]-coeffA[k]*p[k-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	pTissueNutrientConc[i][j][m_nz-1]=(q[m_nz-1]-p[m_nz-1]*q[m_nz-2])/(1.0-p[m_nz-1]*p[m_nz-2]);

	int k=m_nz-2;
	while(k>-1)
    {
		pTissueNutrientConc[i][j][k]=q[k]-pTissueNutrientConc[i][j][k+1]*p[k];
		k=k-1;
	}
	//----------
	delete [] p;
	delete [] q;
}
//****************************************************************

void CAngioNetDlg::OverWriteOldWithNewTiss()
{
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int i=0;i<=m_nx;i++)
			{
			 pOldTissueNutrientConc[i][j][k]=pTissueNutrientConc[i][j][k];
	}}}
}
//****************************************************************

double CAngioNetDlg::Source(int i, int j, int k)
{
//-----------------------------------
	double sourceConc=0.0;
//	double Rmaximum=12.0e-6;

	double subAngioDeltaT;

	if (m_nz==1) { subAngioDeltaT=oxyDeltaT/2.0; } // for a 2D network
		else     { subAngioDeltaT=oxyDeltaT/3.0; } // for a 3D network
//-----------------------------------

	i++;	//Need to account for the fact that loop in calling routine
	j++;	//goes from 0,nx, 0,ny-1, and 0,nz-1
	k++;

//---Bone Model----------------------------------
//---Nutrient must be defined at nodes to--------
//---prevent diffusion into bone tissue----------
	if (b_Bone_model)
	{
//-----2D case-----------------------------------
		if (m_nz==1)	//2D
		{
			int labelx1=LabX(i,j,k);	//LH vessel		
			int labely1=LabY(i,j,k);	//Upper vessel
		
			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					if	(bAllowNutrientTransport[labelx1-1])
					{
						sourceConc+=vesselPerm*(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
										/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

						pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT/XBR[i-1][j-1][k-1]
													*(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
					}
				}
			}
//-----------------------------------------------
			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					if	(bAllowNutrientTransport[labely1-1])
					{
						sourceConc+=vesselPerm*(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
										/angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;

						pConcDecrement[labely1-1]+=DimVesselPerm*CharTime*subAngioDeltaT/YBR[i-1][j-1][k-1]
													*(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
					}
				}
			}
//-----------------------------------------------
			if (i!=m_nx+1)
			{
				int labelx2=LabX(i+1,j,k);	//RH vessel

				if (pFluid[labelx2-1]==10)
				{
					if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						if	(bAllowNutrientTransport[labelx2-1])
						{
							sourceConc+=vesselPerm*(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
											/angioDeltaY*XBR[i+1-1][j-1][k-1]/Rmaximum;

							pConcDecrement[labelx2-1]+=DimVesselPerm*CharTime*subAngioDeltaT/XBR[i+1-1][j-1][k-1]
														*(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
						}
					}
				}
			}
//-----------------------------------------------
			if (j!=m_ny)
			{
				int labely2=LabY(i,j+1,k);	//Lower vessel

				if (pFluid[labely2-1]==10)
				{
					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						if	(bAllowNutrientTransport[labely2-1])
						{
							sourceConc+=vesselPerm*(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
											/angioDeltaX*YBR[i-1][j+1-1][k-1]/Rmaximum;

							pConcDecrement[labely2-1]+=DimVesselPerm*CharTime*subAngioDeltaT/YBR[i-1][j+1-1][k-1]
														*(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
						}
					}
				}
			}
//-----------------------------------------------

		}	//end 2D
//-----------------------------------------------

//===============================================

//---3D case-------------------------------------
		if (m_nz!=1)
		{
			int labelx1=LabX(i,j,k);			//6 sources now
			int labely1=LabY(i,j,k);	
			int labelz1=LabZ(i,j,k);

			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					if	(bAllowNutrientTransport[labelx1-1])
					{
						sourceConc+=vesselPerm*(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
										/angioDeltaY/angioDeltaZ*PI*XBR[i-1][j-1][k-1]/CharLength;

						pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT/XBR[i-1][j-1][k-1]
													*(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
					}
				}
			}
//-----------------------------------------------
			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					if	(bAllowNutrientTransport[labely1-1])
					{
						sourceConc+=vesselPerm*(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
										/angioDeltaX/angioDeltaZ*PI*YBR[i-1][j-1][k-1]/CharLength;

						pConcDecrement[labely1-1]+=DimVesselPerm*CharTime*subAngioDeltaT/YBR[i-1][j-1][k-1]
													*(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
					}
				}
			}
//-----------------------------------------------
			if (pFluid[labelz1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					if	(bAllowNutrientTransport[labelz1-1])
					{
						sourceConc+=vesselPerm*(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
										/angioDeltaX/angioDeltaY*PI*ZBR[i-1][j-1][k-1]/CharLength;

						pConcDecrement[labelz1-1]+=DimVesselPerm*CharTime*subAngioDeltaT/ZBR[i-1][j-1][k-1]
													*(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
					}
				}
			}
//-----------------------------------------------
			if (i!=m_nx+1)
			{
				int labelx2=LabX(i+1,j,k);

				if (pFluid[labelx2-1]==10)
				{
					if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						if	(bAllowNutrientTransport[labelx2-1])
						{
							sourceConc+=vesselPerm*(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
											/angioDeltaY/angioDeltaZ*PI*XBR[i+1-1][j-1][k-1]/CharLength;

							pConcDecrement[labelx2-1]+=DimVesselPerm*CharTime*subAngioDeltaT/XBR[i+1-1][j-1][k-1]
														*(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
						}
					}
				}
			}
//-----------------------------------------------
			if (j!=m_ny)
			{
				int labely2=LabY(i,j+1,k);

				if (pFluid[labely2-1]==10)
				{
					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						if	(bAllowNutrientTransport[labely2-1])
						{
							sourceConc+=vesselPerm*(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
											/angioDeltaX/angioDeltaZ*PI*YBR[i-1][j+1-1][k-1]/CharLength;

							pConcDecrement[labely2-1]+=DimVesselPerm*CharTime*subAngioDeltaT/YBR[i-1][j+1-1][k-1]
														*(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
						}
					}
				}
			}
//-----------------------------------------------
			if (k!=m_nz)
			{
				int labelz2=LabZ(i,j,k+1);

				if (pFluid[labelz2-1]==10)
				{
					if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						if	(bAllowNutrientTransport[labelz2-1])
						{
							sourceConc+=vesselPerm*(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])
											/angioDeltaX/angioDeltaY*PI*ZBR[i-1][j-1][k+1-1]/CharLength;

							pConcDecrement[labelz2-1]+=DimVesselPerm*CharTime*subAngioDeltaT/ZBR[i-1][j-1][k+1-1]
														*(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1]);
						}
					}
				}
			}
//-----------------------------------------------

		}	//end 3D
//-----------------------------------------------
	}

//---No Bone-------------------------------------
//---Nutrient defined at centres of voids--------
//---between potential vessel positions----------
	else
	{
//-----2D case-------------------
	if (m_nz==1)	//2D
	{
		if (i==1)
		{
			if (j==1)	//bottom LH corner block
			{
						
			int labelx1=LabX(i,j,k);	//top edge of block		
			int labely1=LabY(i,j,k);	//rh edge

			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx1-1])
				{
					sourceConc+=vesselPerm*														
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1][k-1];
				}
				}

//			sourceConc+=D_Transmural[labelx1-1]*2.0*	//  *2.0 because we don't need to 
//														//partition - the maths shows this
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;	
				
											//NB Fluxes taken care of naturally
											//i.e. could get nutrient LEAVING tissue
											//and going into vessel.  
											//Fluxes denote flow INTO block and so -ve
											//values indicate flow back into vessel

//				pConcDecrement[labelx1-1]+=2.0*D_Transmural[labelx1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1][k-1];
			}

			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely1-1]*2.0*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely1-1]+=2.0*D_Transmural[labely1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1][j-1][k-1];
			}

			}
			else	//Other LH edge blocks
			{
						

			int labelx1=LabX(i,j,k);	//top edge of block		
			int labelx2=LabX(i,j-1,k);	//bottom edge
			int labely1=LabY(i,j,k);	//rh edge


			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx1-1]*2.0*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;
				
											//NB Fluxes taken care of naturally
											//i.e. could get nutrient LEAVING tissue
											//and going into vessel.  
											//Fluxes denote flow INTO block and so -ve
											//values indicate flow back into vessel

//				pConcDecrement[labelx1-1]+=2.0*D_Transmural[labelx1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1][k-1];
			}


			if (pFluid[labelx2-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1-1][k-1]/Rmaximum;

					pConcDecrement[labelx2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx2-1]*2.0*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1-1][k-1]/Rmaximum;
				
				
//				pConcDecrement[labelx2-1]+=2.0*D_Transmural[labelx2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1-1][k-1];
			}


			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely1-1]*2.0*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely1-1]+=2.0*D_Transmural[labely1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1][j-1][k-1];
			}



			}
		}

//---------------------------------------

		if (i==m_nx+1)
		{
			if (j==1)	//bottom RH corner block
			{
						
			int labelx1=LabX(i,j,k);	//top edge of block		
			int labely2=LabY(i-1,j,k);	//ls edge


			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx1-1]*2.0*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;
				
											//NB Fluxes taken care of naturally
											//i.e. could get nutrient LEAVING tissue
											//and going into vessel.  
											//Fluxes denote flow INTO block and so -ve
											//values indicate flow back into vessel
			
//				pConcDecrement[labelx1-1]+=2.0*D_Transmural[labelx1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1][k-1];
			}



			if (pFluid[labely2-1]==10)
			{
				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1-1][j-1][k-1];
				}
				}
				
//				sourceConc+=D_Transmural[labely2-1]*2.0*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely2-1]+=2.0*D_Transmural[labely2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1-1][j-1][k-1];
			}



			}
			else	//Other RH edge blocks
			{
						
			int labelx1=LabX(i,j,k);	//top edge of block		
			int labelx2=LabX(i,j-1,k);	//bottom edge
			int labely2=LabY(i-1,j,k);	//ls edge


			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx1-1]*2.0*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;
				
											//NB Fluxes taken care of naturally
											//i.e. could get nutrient LEAVING tissue
											//and going into vessel.  
											//Fluxes denote flow INTO block and so -ve

//				pConcDecrement[labelx1-1]+=2.0*D_Transmural[labelx1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1][k-1];						//values indicate flow back into vessel
			}



			if (pFluid[labelx2-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1-1][k-1]/Rmaximum;

					pConcDecrement[labelx2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1-1][k-1];
				}
				}
				
//				sourceConc+=D_Transmural[labelx2-1]*2.0*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1-1][k-1]/Rmaximum;
				

//				pConcDecrement[labelx2-1]+=2.0*D_Transmural[labelx2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1-1][k-1];
			}


			if (pFluid[labely2-1]==10)
			{
				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely2-1]*2.0*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely2-1]+=2.0*D_Transmural[labely2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1-1][j-1][k-1];
			}


			}

		}
//---------------------------------------

		if (j==1 && i!=1 && i!=m_nx+1)
		{//Bottom edge blocks excluding the 2 corner blocks already done
			
						
			int labelx1=LabX(i,j,k);	//top edge of block		
			int labely1=LabY(i,j,k);	//rh edge
			int labely2=LabY(i-1,j,k);	//ls edge
			
			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx1-1]*2.0*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;
				
											//NB Fluxes taken care of naturally
											//i.e. could get nutrient LEAVING tissue
											//and going into vessel.  
											//Fluxes denote flow INTO block and so -ve
											//values indicate flow back into vessel

//				pConcDecrement[labelx1-1]+=2.0*D_Transmural[labelx1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1][k-1];
			}

						
			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely1-1]*2.0*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely1-1]+=2.0*D_Transmural[labely1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1][j-1][k-1];
			}


			if (pFluid[labely2-1]==10)
			{
				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely2-1]*2.0*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely2-1]+=2.0*D_Transmural[labely2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1-1][j-1][k-1];
			}

		}

//---------------------------------------

		if (i!=1 && i!=m_nx+1 && j!=1)		//internal block
		{

			int labelx1=LabX(i,j,k);	//top edge of block		
			int labelx2=LabX(i,j-1,k);	//bottom edge
			int labely1=LabY(i,j,k);	//rh edge
			int labely2=LabY(i-1,j,k);	//ls edge


			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labelx1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx1-1]*2.0*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1][k-1]/Rmaximum;
				
											//NB Fluxes taken care of naturally
											//i.e. could get nutrient LEAVING tissue
											//and going into vessel.  
											//Fluxes denote flow INTO block and so -ve
											//values indicate flow back into vessel

//				pConcDecrement[labelx1-1]+=2.0*D_Transmural[labelx1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1][k-1];
			}


			if (pFluid[labelx2-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labelx2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaY*XBR[i-1][j-1-1][k-1]/Rmaximum;

					pConcDecrement[labelx2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							XBR[i-1][j-1-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labelx2-1]*2.0*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaY*XBR[i-1][j-1-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely1-1]+=2.0*D_Transmural[labely1-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1][j-1][k-1];
			}

			
			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely1-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely1-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely1-1]*2.0*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labely2-1]+=2.0*D_Transmural[labely2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/YBR[i-1-1][j-1][k-1];
			}


			if (pFluid[labely2-1]==10)
			{
				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
				if	(bAllowNutrientTransport[labely2-1])
				{
					sourceConc+=vesselPerm*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;

					pConcDecrement[labely2-1]+=DimVesselPerm*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							YBR[i-1-1][j-1][k-1];
				}
				}
//				sourceConc+=D_Transmural[labely2-1]*2.0*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaX*YBR[i-1-1][j-1][k-1]/Rmaximum;
				

//				pConcDecrement[labelx2-1]+=2.0*D_Transmural[labelx2-1]*subAngioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/XBR[i-1][j-1-1][k-1];
			}


		}

//---------------------------------------

	}	//end 2D
//--------------------------------


//================================
//===============================
//-----3D case-------------------
	if (m_nz!=1)
	{				

//------LH FACE--------------------------------------
//---Bottom LH nearside corner and bottom LH edge (LH horizontal going into page)----
		if (i==1)
		{
			if (j==1)	
			{
				if (k==1) //nearside, bottom LH corner block
				{
					int labelx1=LabX(i,j,k);		//only 3 sources	
					int labely1=LabY(i,j,k);	
					int labelz1=LabZ(i,j,k);
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got to top lh corner" << endl;}
					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx1-1]*PI*	
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
					}
											
					if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely1-1]*PI*	
							(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz1-1]*PI*	
							(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;
					}


//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely1-1]*PI*	
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];
//
//
//			sourceConc+=D_Transmural[labelz1-1]*PI*	
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1][j-1][k-1];
					}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];

//				}//end i==1, j==1, k==1, bottom LH nearside corner

				}
				else	//i==1 and j==1 but k!=1, bottom LH edge
				{
					int labelx1=LabX(i,j,k);		//only 5 sources	
					int labely1=LabY(i,j,k);	
					int labelz1=LabZ(i,j,k);
					int labelx3=LabX(i,j,k-1);	
					int labely3=LabY(i,j,k-1);
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got to top lh edge" << endl;}
					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx1-1]*PI*	
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
					}
	
					if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely1-1]*PI*	
							(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz1-1]*PI*	
							(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx3-1]*PI*	
							(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaZ/angioDeltaY*XBR[i-1][j-1][k-1-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely3-1]*PI*	
							(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaZ/angioDeltaX*YBR[i-1][j-1][k-1-1]/CharLength;
					}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely1-1]*PI*	
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz1-1]*PI*	
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelx3-1]*PI*	
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaZ/angioDeltaY/sqrt(pow(angioDeltaZ,2)+pow(angioDeltaY,2))
//				*XBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labely3-1]*PI*	
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaZ/angioDeltaX/sqrt(pow(angioDeltaZ,2)+pow(angioDeltaX,2))
//				*YBR[i-1][j-1][k-1-1];

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx3-1]+=DimPerm_Vessel[labelx3-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1-1];
					}

					if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely3-1]+=DimPerm_Vessel[labely3-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1][j-1][k-1-1];
					}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelx3-1]+=D_Transmural[labelx3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaZ,2)+pow(angioDeltaY,2))/XBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labely3-1]+=D_Transmural[labely3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaZ,2)+pow(angioDeltaX,2))/YBR[i-1][j-1][k-1-1];

				}
			}
		}

//-----------------------------------------

//--Nearside LH vertical edge -------
		if (i==1)
		{//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past i==1" << endl;}
			if (j!=1)	
			{//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past j!=1" << endl;}
				if (k==1) //nearside, LH edge
				{//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past k==1" << endl;}
					int labelx1=LabX(i,j,k);		//only 5 sources
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past labelx1" << endl;}
					int labely1=LabY(i,j,k);
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past labely1" << endl;}
					int labelz1=LabZ(i,j,k);
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past labelz1" << endl;}
					int labelx2=LabX(i,j-1,k);			
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past labelx2" << endl;}
					int labelz2=LabZ(i,j-1,k);
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past labelz2" << endl;}
					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx1-1]*PI*	
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;	
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}	
					if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely1-1]*PI*	
							(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz1-1]*PI*	
							(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx2-1]*PI*	
							(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1]/CharLength;
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz2-1]*PI*	
							(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1-1][k-1]/CharLength;
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely1-1]*PI*	
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz1-1]*PI*	
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelx2-1]*PI*	
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labelz2-1]*PI*	
//				(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1-1][k-1];

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1];
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1][j-1][k-1];
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1][j-1][k-1];
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx2-1]+=DimPerm_Vessel[labelx2-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1-1][k-1];
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
					if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz2-1]+=DimPerm_Vessel[labelz2-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1][j-1-1][k-1];
					}
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got here" << endl;}
//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelx2-1]+=D_Transmural[labelx2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1];
//
//			pConcDecrement[labelz2-1]+=D_Transmural[labelz2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1-1][k-1];

				}
			}
		}
//---------------------------------------

//--LH face excluding edges  -------
		if (i==1)
		{
			if (j!=1 && k!=1)	
			{//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got to lh face" << endl;}
				int labelx1=LabX(i,j,k);		//only 8 sources	
				int labely1=LabY(i,j,k);	
				int labelz1=LabZ(i,j,k);
				int labelx2=LabX(i,j-1,k);			
				int labely3=LabY(i,j,k-1);
				int labelx3=LabX(i,j,k-1);
				int labelx4=LabX(i,j-1,k-1);
				int labelz2=LabZ(i,j-1,k);

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx1-1]*PI*	
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;	
				}
	
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely1-1]*PI*	
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz1-1]*PI*	
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx2-1]*PI*	
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz2-1]*PI*	
						(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely3-1]*PI*	
						(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx3-1]*PI*	
						(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx4-1]*PI*	
						(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1-1]/CharLength;
				}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely1-1]*PI*	
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz1-1]*PI*	
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelx2-1]*PI*	
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labelz2-1]*PI*	
//				(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labely3-1]*PI*	
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labelx3-1]*PI*	
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labelx4-1]*PI*	
//				(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1-1];

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx2-1]+=DimPerm_Vessel[labelx2-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz2-1]+=DimPerm_Vessel[labelz2-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1][j-1-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely3-1]+=DimPerm_Vessel[labely3-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1][j-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx3-1]+=DimPerm_Vessel[labelx3-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labelx4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx4-1]+=DimPerm_Vessel[labelx4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1-1][k-1-1];
				}


//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelx2-1]+=D_Transmural[labelx2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1];
//
//			pConcDecrement[labelz2-1]+=D_Transmural[labelz2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1-1][k-1];
//
//			pConcDecrement[labely3-1]+=D_Transmural[labely3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labelx3-1]+=D_Transmural[labelx3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
///				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labelx4-1]+=D_Transmural[labelx4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1-1];

			}
		}
//-------------END LH FACE---------------------------
//if	(i==1 && j==141)	{//if(oxyTime>8.0) {outfileTracerOxy << "got past lh face" << endl;}
//-------------------RH FACE--------------------------------------
//---Bottom RH nearside corner and bottom RH edge (RH horizontal going into page)----
		if (i==m_nx+1)
		{
			if (j==1)	
			{
				if (k==1) //nearside, bottom RH corner block
				{
					int labelx1=LabX(i,j,k);		//only 3 sources	
					int labely2=LabY(i-1,j,k);	
					int labelz4=LabZ(i-1,j,k);

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx1-1]*PI*	
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
					}
	
					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely2-1]*PI*	
							(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz4-1]*PI*	
							(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
					}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];
//
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1-1][j-1][k-1];
					}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];

//				}//end i==1, j==1, k==1, bottom RH nearside corner

				}
				else	//i==m_nx+1 and j==1 but k!=1, bottom RH edge
				{
					int labelx1=LabX(i,j,k);		//only 5 sources	
					int labely2=LabY(i-1,j,k);	
					int labelz4=LabZ(i-1,j,k);	
					int labelx3=LabX(i,j,k-1);
					int labely4=LabY(i-1,j,k-1);

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx1-1]*PI*	
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
					}
	
					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely2-1]*PI*	
							(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz4-1]*PI*	
							(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx3-1]*PI*	
							(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely4-1]*PI*	
							(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1-1]/CharLength;
					}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelx3-1]*PI*	
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labely4-1]*PI*	
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1-1];

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx3-1]+=DimPerm_Vessel[labelx3-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1-1];
					}

					if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely4-1]+=DimPerm_Vessel[labely4-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1-1][j-1][k-1-1];
					}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelx3-1]+=D_Transmural[labelx3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labely4-1]+=D_Transmural[labely4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1-1];

				}
			}
		}

//-----------------------------------------
//--Nearside RH vertical edge -------
		if (i==m_nx+1)
		{
			if (j!=1)	
			{
				if (k==1) //nearside, RH edge
				{
					int labelx1=LabX(i,j,k);		//only 5 sources	
					int labely2=LabY(i-1,j,k);	
					int labelz3=LabZ(i-1,j-1,k);
					int labelx2=LabX(i,j-1,k);			
					int labelz4=LabZ(i-1,j,k);

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx1-1]*PI*	
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;	
					}

					if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelx2-1]*PI*	
							(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labely2-1]*PI*	
							(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz4-1]*PI*	
							(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
					}

					if	(pOldVesselNutrientConc[labelz3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						sourceConc+=Perm_Vessel[labelz3-1]*PI*	
							(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1-1][k-1]/CharLength;
					}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//
//			sourceConc+=D_Transmural[labelx2-1]*PI*	
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz3-1]*PI*	
//				(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1-1][k-1];

					if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelx2-1]+=DimPerm_Vessel[labelx2-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/XBR[i-1][j-1-1][k-1];
					}

					if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/YBR[i-1-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1-1][j-1][k-1];
					}

					if	(pOldVesselNutrientConc[labelz3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
					{
						pConcDecrement[labelz3-1]+=DimPerm_Vessel[labelz3-1]*CharTime*subAngioDeltaT*
							(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
								2/ZBR[i-1-1][j-1-1][k-1];
					}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelx2-1]+=D_Transmural[labelx2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelz3-1]+=D_Transmural[labelz3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1-1][k-1];
				
				}
			}
		}
//---------------------------------------

//--RH face excluding edges  -------
		if (i==m_nx+1)
		{
			if (j!=1 && k!=1)	
			{
				int labelx1=LabX(i,j,k);		//only 8 sources	
				int labelx2=LabX(i,j-1,k);			
				int labelx3=LabX(i,j,k-1);
				int labelx4=LabX(i,j-1,k-1);
				int labely2=LabY(i-1,j,k);
				int labely4=LabY(i-1,j,k-1);
				int labelz3=LabZ(i-1,j-1,k);
				int labelz4=LabZ(i-1,j,k);

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx1-1]*PI*	
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx2-1]*PI*	
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{	
					sourceConc+=Perm_Vessel[labelx3-1]*PI*	
						(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx4-1]*PI*	
						(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz4-1]*PI*	
						(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz3-1]*PI*	
						(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely4-1]*PI*	
						(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely2-1]*PI*	
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
				}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//
//			sourceConc+=D_Transmural[labelx2-1]*PI*	
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labelx3-1]*PI*	
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labelx4-1]*PI*	
//				(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1-1];
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz3-1]*PI*	
//				(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labely4-1]*PI*	
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx2-1]+=DimPerm_Vessel[labelx2-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx3-1]+=DimPerm_Vessel[labelx3-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labelx4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx4-1]+=DimPerm_Vessel[labelx4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz3-1]+=DimPerm_Vessel[labelz3-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1-1][j-1-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely4-1]+=DimPerm_Vessel[labely4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1-1][j-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1-1][j-1][k-1];
				}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelx2-1]+=D_Transmural[labelx2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1];
//
//			pConcDecrement[labelx3-1]+=D_Transmural[labelx3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labelx4-1]+=D_Transmural[labelx4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelz3-1]+=D_Transmural[labelz3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1-1][k-1];
//
//			pConcDecrement[labely4-1]+=D_Transmural[labely4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];

			}
		}
//-------------END RH FACE---------------------------

//---BOTTOM FACE-----------
//---------------------------------------

		if (j==1 && i!=1 && i!=m_nx+1)
		{	
			if (k==1)	//Bottom edge blocks excluding the 2 corner blocks already done
			{
				int labelx1=LabX(i,j,k);			
				int labely1=LabY(i,j,k);	
				int labelz1=LabZ(i,j,k);
				int labely2=LabY(i-1,j,k);	
				int labelz4=LabZ(i-1,j,k);

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx1-1]*PI*	
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
				}
	
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely1-1]*PI*	
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz1-1]*PI*	
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely2-1]*PI*	
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz4-1]*PI*	
						(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
				}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely1-1]*PI*	
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz1-1]*PI*	
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1-1][j-1][k-1];
				}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];

			}
			else	//j==1, i!=1, i!=nx+1, k!=1
					//bottom face blocks away from 3 bottom edges
			{
				int labelx1=LabX(i,j,k);			
				int labely1=LabY(i,j,k);	
				int labelz1=LabZ(i,j,k);
				int labely2=LabY(i-1,j,k);	
				int labelz4=LabZ(i-1,j,k); 
				int labelx3=LabX(i,j,k-1);	
				int labely3=LabY(i,j,k-1);
				int labely4=LabY(i-1,j,k-1);

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx1-1]*PI*	
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;
				}
	
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely1-1]*PI*	
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz1-1]*PI*	
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely2-1]*PI*	
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz4-1]*PI*	
						(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx3-1]*PI*	
						(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1-1]/CharLength;
				}
	
				if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{	
					sourceConc+=Perm_Vessel[labely3-1]*PI*	
						(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1-1]/CharLength;
				}

				if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely4-1]*PI*	
						(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1-1]/CharLength;
				}

//			sourceConc+=D_Transmural[labelx1-1]*PI*	
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel
//	
//			sourceConc+=D_Transmural[labely1-1]*PI*	
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz1-1]*PI*	
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelx3-1]*PI*	
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1-1];
//	
//			sourceConc+=D_Transmural[labely3-1]*PI*	
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labely4-1]*PI*	
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1-1];

				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1-1][j-1][k-1];
				}

				if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labelx3-1]+=DimPerm_Vessel[labelx3-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely3-1]+=DimPerm_Vessel[labely3-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1][j-1][k-1-1];
				}

				if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					pConcDecrement[labely4-1]+=DimPerm_Vessel[labely4-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1-1][j-1][k-1-1];
				}

//			pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
//
//			pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelx3-1]+=D_Transmural[labelx3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labely3-1]+=D_Transmural[labely3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labely4-1]+=D_Transmural[labely4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1-1];

			}

		}
//---------------------------------------

		if (i!=1 && i!=m_nx+1 && j!=1 && k!=1)		//internal block
		{
			int labelx1=LabX(i,j,k);			//12 sources now
			int labely1=LabY(i,j,k);	
			int labelz1=LabZ(i,j,k);

			int labelx2=LabX(i,j-1,k);
			int labely2=LabY(i-1,j,k);	
			int labelz2=LabZ(i,j-1,k); 

			int labelx3=LabX(i,j,k-1);
			int labely3=LabY(i,j,k-1);
			int labelz3=LabZ(i-1,j-1,k);

			int labelx4=LabX(i,j-1,k-1);
			int labely4=LabY(i-1,j,k-1);
			int labelz4=LabZ(i-1,j,k);

			if (pFluid[labelx1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelx1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelx1-1]*PI*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1]/CharLength;

//if(oxyTime>8.0) {outfileTracerOxy << "x1: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelx1-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelx1-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;} 

//				sourceConc+=D_Transmural[labelx1-1]*PI*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1];	
//											//NB Fluxes taken care of naturally
//											//i.e. could get nutrient LEAVING tissue
//											//and going into vessel.  
//											//Fluxes denote flow INTO block and so -ve
//											//values indicate flow back into vessel

					pConcDecrement[labelx1-1]+=DimPerm_Vessel[labelx1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/XBR[i-1][j-1][k-1];

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelx1-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelx1-1] << endl;}

//				pConcDecrement[labelx1-1]+=D_Transmural[labelx1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1];
				}
						
			}
	
			if (pFluid[labely1-1]==10)
			{
				if	(pOldVesselNutrientConc[labely1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labely1-1]*PI*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1]/CharLength;

//if(oxyTime>8.0) {outfileTracerOxy << "y1: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labely1-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labely1-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

//				sourceConc+=D_Transmural[labely1-1]*PI*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1];

					pConcDecrement[labely1-1]+=DimPerm_Vessel[labely1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/YBR[i-1][j-1][k-1];

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labely1-1] << "\t" << "Decrement = " << 
//	pConcDecrement[labely1-1] << endl;

//				pConcDecrement[labely1-1]+=D_Transmural[labely1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1];
				}
			}
				
			if (pFluid[labelz1-1]==10)
			{
				if	(pOldVesselNutrientConc[labelz1-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
				{
					sourceConc+=Perm_Vessel[labelz1-1]*PI*
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1][k-1]/CharLength;

//if(oxyTime>8.0) {outfileTracerOxy << "z1: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelz1-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelz1-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

//				sourceConc+=D_Transmural[labelz1-1]*PI*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1][k-1];

					pConcDecrement[labelz1-1]+=DimPerm_Vessel[labelz1-1]*CharTime*subAngioDeltaT*
						(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
							2/ZBR[i-1][j-1][k-1];

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelz1-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelz1-1] << endl;}

//				pConcDecrement[labelz1-1]+=D_Transmural[labelz1-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz1-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1][k-1];
				}
			}

//------------------
			if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labelx2-1]*PI*	
					(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "x2: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelx2-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelx2-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

			if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labely2-1]*PI*	
					(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "y2: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labely2-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labely2-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

			if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labelz2-1]*PI*	
					(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaX/angioDeltaY*ZBR[i-1][j-1-1][k-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "z2: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelz2-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelz2-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

//			sourceConc+=D_Transmural[labelx2-1]*PI*	
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1];
//
//			sourceConc+=D_Transmural[labely2-1]*PI*	
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1];
//
//			sourceConc+=D_Transmural[labelz2-1]*PI*	
//				(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1][j-1-1][k-1];

//-------------------
			if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labelx3-1]*PI*	
					(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1][k-1-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "x3: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelx3-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelx3-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

			if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labely3-1]*PI*	
					(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaX/angioDeltaZ*YBR[i-1][j-1][k-1-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "y3: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labely3-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labely3-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

			if	(pOldVesselNutrientConc[labelz3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labelz3-1]*PI*	
					(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1-1][k-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "z3: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelz3-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelz3-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

//			sourceConc+=D_Transmural[labelx3-1]*PI*	
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1][k-1-1];			
//
//			sourceConc+=D_Transmural[labely3-1]*PI*	
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labelz3-1]*PI*	
//				(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1-1][k-1];

//-------------------
			if	(pOldVesselNutrientConc[labelx4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labelx4-1]*PI*	
					(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaY/angioDeltaZ*XBR[i-1][j-1-1][k-1-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "x4: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelx4-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelx4-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

			if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labely4-1]*PI*	
					(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaX/angioDeltaZ*YBR[i-1-1][j-1][k-1-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "y4: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labely4-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labely4-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

			if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				sourceConc+=Perm_Vessel[labelz4-1]*PI*	
					(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/angioDeltaX/angioDeltaY*ZBR[i-1-1][j-1][k-1]/CharLength;
			}

//if(oxyTime>8.0) {outfileTracerOxy << "z4: (" << i << "," << j << "," << k << ")" << "\t" << "Perm = " << 
//	Perm_Vessel[labelz4-1] << "\t" << "Vess Conc = " << pOldVesselNutrientConc[labelz4-1] << "\t" << 
//	"Tiss Conc = " << pOldTissueNutrientConc[i-1][j-1][k-1] << "\t" << "Source = " << sourceConc << endl;}

//			sourceConc+=D_Transmural[labelx4-1]*PI*	
//				(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaY/angioDeltaZ/sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))
//				*XBR[i-1][j-1-1][k-1-1];
//
//			sourceConc+=D_Transmural[labely4-1]*PI*	
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaZ/sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))
//				*YBR[i-1-1][j-1][k-1-1];
//
//			sourceConc+=D_Transmural[labelz4-1]*PI*	
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				angioDeltaX/angioDeltaY/sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))
//				*ZBR[i-1-1][j-1][k-1];

//------------------

//------------------------
			if	(pOldVesselNutrientConc[labelx2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labelx2-1]+=DimPerm_Vessel[labelx2-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/XBR[i-1][j-1-1][k-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelx2-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelx2-1] << endl;}

			if	(pOldVesselNutrientConc[labely2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labely2-1]+=DimPerm_Vessel[labely2-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/YBR[i-1-1][j-1][k-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labely2-1] << "\t" << "Decrement = " << 
//pConcDecrement[labely2-1] << endl;}

			if	(pOldVesselNutrientConc[labelz2-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labelz2-1]+=DimPerm_Vessel[labelz2-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/ZBR[i-1][j-1-1][k-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelz2-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelz2-1] << endl;}

//			pConcDecrement[labelx2-1]+=D_Transmural[labelx2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1];
//
//			pConcDecrement[labely2-1]+=D_Transmural[labely2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1];
//
//			pConcDecrement[labelz2-1]+=D_Transmural[labelz2-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz2-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1][j-1-1][k-1];

//---------------------
			if	(pOldVesselNutrientConc[labelx3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labelx3-1]+=DimPerm_Vessel[labelx3-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/XBR[i-1][j-1][k-1-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelx3-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelx3-1] << endl;}

			if	(pOldVesselNutrientConc[labely3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labely3-1]+=DimPerm_Vessel[labely3-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/YBR[i-1][j-1][k-1-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labely3-1] << "\t" << "Decrement = " << 
//pConcDecrement[labely3-1] << endl;}

			if	(pOldVesselNutrientConc[labelz3-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labelz3-1]+=DimPerm_Vessel[labelz3-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/ZBR[i-1-1][j-1-1][k-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelz3-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelz3-1] << endl;}

//			pConcDecrement[labelx3-1]+=D_Transmural[labelx3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labely3-1]+=D_Transmural[labely3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1][j-1][k-1-1];
//
//			pConcDecrement[labelz3-1]+=D_Transmural[labelz3-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz3-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1-1][k-1];

//-----------------
			if	(pOldVesselNutrientConc[labelx4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labelx4-1]+=DimPerm_Vessel[labelx4-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/XBR[i-1][j-1-1][k-1-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelx4-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelx4-1] << endl;}

			if	(pOldVesselNutrientConc[labely4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labely4-1]+=DimPerm_Vessel[labely4-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/YBR[i-1-1][j-1][k-1-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labely4-1] << "\t" << "Decrement = " << 
//pConcDecrement[labely4-1] << endl;}

			if	(pOldVesselNutrientConc[labelz4-1]>pOldTissueNutrientConc[i-1][j-1][k-1])
			{
				pConcDecrement[labelz4-1]+=DimPerm_Vessel[labelz4-1]*CharTime*subAngioDeltaT*
					(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
						2/ZBR[i-1-1][j-1][k-1];
			}

//if(oxyTime>8.0) {outfileTracerOxy << "Dim Perm = " << DimPerm_Vessel[labelz4-1] << "\t" << "Decrement = " << 
//pConcDecrement[labelz4-1] << endl;}

//			pConcDecrement[labelx4-1]+=D_Transmural[labelx4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelx4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaY,2)+pow(angioDeltaZ,2))/XBR[i-1][j-1-1][k-1-1];
//
//			pConcDecrement[labely4-1]+=D_Transmural[labely4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labely4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaZ,2))/YBR[i-1-1][j-1][k-1-1];
//
//			pConcDecrement[labelz4-1]+=D_Transmural[labelz4-1]*angioDeltaT*
//				(pOldVesselNutrientConc[labelz4-1]-pOldTissueNutrientConc[i-1][j-1][k-1])/
//				sqrt(pow(angioDeltaX,2)+pow(angioDeltaY,2))/ZBR[i-1-1][j-1][k-1];

//------------------

		}
//---------------------------------------

	}	//end 3D
//--------------------------------
	}	//end no bone

//-----------------------------
	return sourceConc;
//-----------------------------
}

//****************************************************************

void CAngioNetDlg::OverWriteOldWithNewVesselConcs()
{


	for (int n=1;n<=Nbond;n++)
	{
		pOldVesselNutrientConc[n-1]=pVesselNutrientConc[n-1];
	}


//--------------------------------------------------------------
}
//****************************************************************
//*****************************************************
void CAngioNetDlg::TransMuralGraphics(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
{
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,100,100),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);

	COLORREF purple0=RGB(0,0,100),//RGB(100,0,100),
			 purple1=RGB(50,0,100),//RGB(128,0,128),
			 purple2=RGB(100,0,100),//RGB(150,0,150),
			 purple3=RGB(175,0,100),//RGB(200,0,200),
			 purple4=RGB(255,0,0);//RGB(255,0,255);
	//COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,2,pink);
	CPen penGreen(PS_SOLID,2,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,2,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,2,Grey1);
	CPen penColour(PS_SOLID,1,colour);
	CPen penGrey2(PS_SOLID,1,Grey1);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);


//-----------------Grid up the domain----------------------
/*		CPen gridPen(PS_SOLID,1,RGB(0,100,0));
		memDC.SelectObject(&gridPen);

		for (int i=1;i<=m_nx;i++)
		{
			memDC.MoveTo(xMin+int(deltaX)+(i)*networkWidth/m_nx,
			yMin+int(deltaY)+0*networkWidth/m_ny);
			memDC.LineTo(xMin+int(deltaX)+(i)*networkWidth/m_nx,
			yMin+int(deltaY)+m_ny*networkWidth/m_ny);
		}


		for (int j=1;j<=m_ny;j++)
		{
			memDC.MoveTo(xMin+int(deltaX)+0*networkWidth/m_nx,
			yMin+int(deltaY)+j*networkWidth/m_ny);
			memDC.LineTo(xMin+int(deltaX)+(m_nx+1)*networkWidth/m_nx,
			yMin+int(deltaY)+j*networkWidth/m_ny);
		}

		//Draw a test square
		*/
//-----------------------------
	CBrush brushRed(red);
	CBrush brushPink(pink);
	CBrush brushLightBlue(LightBlue);
	CBrush brushDarkBlue(DarkBlue);
	CBrush brushWhite(White);
	CBrush brushBlack(Black);
	CBrush brushGreen(green);
	CBrush brushGrey1(Grey1);
//--------------------------------


//---------------------------------------------------------
//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("OXY TIME %f",oxyTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
//	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
//	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}



//	memDC.SelectObject(&penBlack);



//Draw the network ----2D

	//---2D----
//	if (m_nz==1)
//
//	{

	for (int k=25;k<=25;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
			
	//int nbx=LabX(i,j,k);
	//int nby=LabY(i,j,k);
	//int nbz=LabZ(i,j,k);

//-----------------------------------------------
/*			//Mike 07/10
			int Shade=int(255*pTissueNutrientConc[i-1][j-1][k-1]/0.5);

			COLORREF BlockShade=RGB(Shade,Shade,Shade);

			CPen penBlockShade(PS_SOLID,2,BlockShade);
			CBrush brushBlockShade(BlockShade);

			if (pTissueNutrientConc[i-1][j-1][k-1] <= 0.001)//*runningTissConcMAX)
			{
				memDC.SelectObject(&brushBlockShade);memDC.SelectObject(&penBlockShade);
			}
			else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.001)//*runningTissConcMAX)
			{
				memDC.SelectObject(&brushBlockShade);memDC.SelectObject(&penBlockShade);
			}
*/
//-----------------------------------------------
/*			//Mike 09/10
			int RedShade=255-int(255*fabs(pTissueNutrientConc[i-1][j-1][k-1])/0.351);
			int GreenShade=255-int(255*fabs(pTissueNutrientConc[i-1][j-1][k-1])/0.351);

//outfileDebugOxyGraphics << i << "\t" << j << "\t" << k << "\t" << pTissueNutrientConc[i-1][j-1][k-1] << "\t" << Shade << endl;
			
				COLORREF BlockShade1=RGB(255,RedShade,RedShade);
				COLORREF BlockShade2=RGB(GreenShade,255,GreenShade);
				CPen penBlockShade1(PS_SOLID,2,BlockShade1);
				CBrush brushBlockShade1(BlockShade1);
				CPen penBlockShade2(PS_SOLID,2,BlockShade2);
				CBrush brushBlockShade2(BlockShade2);
			
			if (pTissueNutrientConc[i-1][j-1][k-1]<=0.0)//*runningTissConcMAX)
			{
				memDC.SelectObject(&brushBlockShade2);memDC.SelectObject(&penBlockShade2);
			}
			else if (pTissueNutrientConc[i-1][j-1][k-1]>0.0)//*runningTissConcMAX)
			{
				memDC.SelectObject(&brushBlockShade1);memDC.SelectObject(&penBlockShade1);
			}
*/
//-----------------------------------------------	

////SMcD	memDC.SelectObject(&penBlack);
	//choiceColour=Black;

	//if (vEndoCellDensity[i-1][j-1][k-1] <= 0.25*runningEndoCellMAX)
	//{
	//	memDC.SelectObject(&penDarkBlue);
		//choiceColour=DarkBlue;
	//}vFibronectinConc[i][j][k]

	if (pTissueNutrientConc[i-1][j-1][k-1] <= 0.01)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushBlack);memDC.SelectObject(&penBlack);
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.01 &&//*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.12)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushGreen);memDC.SelectObject(&penGreen);
		//choiceColour=LightBlue;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.12 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.24)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushGrey1);memDC.SelectObject(&penGrey1);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.24 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.36)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushPink);memDC.SelectObject(&penPink);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.36)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushWhite);memDC.SelectObject(&penWhite);
		//choiceColour=pink;
	}



	//if (pFluid[nbx-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nby-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nbz-1]==66) { graphicsDC.SelectObject(&penBlack); }

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
////SMcD	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
////SMcD					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
////SMcD	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
////SMcD					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
////SMcD	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
////SMcD					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
////SMcD	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
////SMcD					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the z-direction
////SMcD	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
////SMcD					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
////SMcD	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
////SMcD					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
		
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	


	//Draw filled block as well as network vessels in 2D
	//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//	if (m_nz==1)
//	{
		memDC.Rectangle(xMin+int(deltaX)+(i-1)*networkWidth/m_nx,			//NO offset
								yMin+int(deltaY)+(j-1)*networkWidth/m_ny,	//NO offset

								xMin+int(deltaX)+(i)*networkWidth/m_nx,		//NO offset
								yMin+int(deltaY)+(j)*networkWidth/m_ny);	//NO offset
//	}
	//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

/*		memDC.Rectangle(xMin+int(deltaX)+(i-1)*networkWidth/m_nx,			//NO offset
								yMin+int(deltaY)+(k-1)*networkWidth/m_ny,	//NO offset

								xMin+int(deltaX)+(i)*networkWidth/m_nx,		//NO offset
								yMin+int(deltaY)+(k)*networkWidth/m_ny);	//NO offset
	
*/	
	
	
	}}}	//end i,j,k loop

//	}	//end 2D Graphics
//---------------------------------------------------




//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
// if (m_nz==1)
// {	
	memDC.SelectObject(&penGrey2);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
// }




//Draw the network---3D--
//---- draw the frame for 3D networks ------------
/* if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey2);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }

*/
//-----Draw Wound Margin if applicable-----------
/* 	CBrush brGrey(RGB(0,0,0));	//transparent??

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);
			memDC.SelectObject(&penGrey2);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}
*/
//---------------------------------------


//----3D----

/* if (m_nz!=1)
 {
*/
/*	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//	memDC.SelectObject(&penBlack);

	if (pTissueNutrientConc[i-1][j-1][k-1] <= 0.001)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penBlack);//
		//memDC.SelectObject(&penGrey1);
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.001 &&//*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.25)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penGreen);
		//choiceColour=LightBlue;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.25 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.5)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penGrey1);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.5 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.75)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penPink);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.75)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penWhite);
		//choiceColour=pink;
	}

	//if (pFluid[nbx-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nby-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nbz-1]==66) { graphicsDC.SelectObject(&penBlack); }

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);



	if (pTissueNutrientConc[i-1][j-1][k-1] > 0.001)
	{
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the z-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
		

	}
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	

	//======================
	
			}}}		//end i j k loops
//----------------------------
*/
/*	 //Draw the network
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (pTissueNutrientConc[i-1][j-1][k-1]>0.01)
					{
						if (pTissueNutrientConc[i-1][j-1][k-1]>0.01 &&
								pTissueNutrientConc[i-1][j-1][k-1]<=0.12)	{memDC.SelectObject(&brushGreen);}

						else if (pTissueNutrientConc[i-1][j-1][k-1]>0.12 &&
									pTissueNutrientConc[i-1][j-1][k-1]<=0.24)	{memDC.SelectObject(&brushGrey1);}

						else if (pTissueNutrientConc[i-1][j-1][k-1]>0.24 &&
									pTissueNutrientConc[i-1][j-1][k-1]<=0.36)	{memDC.SelectObject(&brushPink);}

						else if (pTissueNutrientConc[i-1][j-1][k-1]>0.36)	{memDC.SelectObject(&brushWhite);}

//-----------------------------------------------

						CPoint cubePts[5];	

						//---Top Face------------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Side Face-----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Front Face----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();
					}
		}}}
	}	//end if m_nz!=1
*/




//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}
//*****************************************************

void CAngioNetDlg::AssignInitialTumCells()
{
	//Set x,y,z, coords of each tumour cell and set pTumCellPresent=TRUE at the position

	//Example to put a tumour cell within a central spherical tumour mass

		//Loop for nTum=1 to m_nTumCells
		//pXCoord_TumCell[nTum-1]=int(m_nx/2)+ or - random radius;
		//pYCoord_TumCell[nTum-1]=int(m_ny/2)+ or - random radius;
		//pZCoord_TumCell[nTum-1]=int(m_nz/2)+ or - random radius;
		//pTumCellPresent[i-1,j-1,k-1]=true;

}
//*****************************************************

void CAngioNetDlg::GetProbsPericytes()
{
	// Initialisation of the probabilities to zero
	//--------------------------------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				probP0[i][j][k]=0.0;
				probP1[i][j][k]=0.0;
				probP2[i][j][k]=0.0;
				probP3[i][j][k]=0.0;
				probP4[i][j][k]=0.0;
				probP5[i][j][k]=0.0;
				probP6[i][j][k]=0.0;
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=0.0;
				R1inf[i][j][k]=0.0;
				R1sup[i][j][k]=0.0;
				R2inf[i][j][k]=0.0;
				R2sup[i][j][k]=0.0;
				R3inf[i][j][k]=0.0;
				R3sup[i][j][k]=0.0;
				R4inf[i][j][k]=0.0;
				R4sup[i][j][k]=0.0;
				R5inf[i][j][k]=0.0;
				R5sup[i][j][k]=0.0;
				R6inf[i][j][k]=0.0;
				R6sup[i][j][k]=0.0;			
	}}}

    
	// Calculation of the probabilities P0 to P6 for each point (i,j,k)
    //-----------------------------------------------------------------

	 angioDeltaZ=angioDeltaX;

	//---------- switch 2D / 3D ---------------
	  int coeffZ;
	  if (m_nz==1) {coeffZ=0;} else {coeffZ=1;}
	//-----------------------------------------

	int iminus,iplus,jminus,jplus,kminus,kplus;

    for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
		
		if (i==0) {iminus=1;} else  {iminus=i-1;}
		if (j==0) {jminus=1;} else  {jminus=j-1;}
		if (k==0) {kminus=1;} else  {kminus=k-1;}
		if (i==m_nx  ) {iplus=m_nx-1;} else  {iplus=i+1;}
		if (j==m_ny-1) {jplus=m_ny-2;} else  {jplus=j+1;}
		if (k==m_nz-1) {kplus=m_nz-2;} else  {kplus=k+1;}

		if (m_nz==1) {k=0; kminus=0;kplus=0;}


	//----------------------------------------------
	// P0 = Probability to remain stationary (i,j,k)
	//----------------------------------------------


//=========================================
//SMcD 10/2004 NEED TO CHANGE DIFFUSION COEFF
	double diffCoeffPC=m_diffCoeff;
//SMcD Jan 2008 Turn off haptotaxis for now
	double m_rhoPC=0*m_rho;  //effectively turn off hapto for PCs
	double m_chiPC=0*m_chi;  //effectively turn up PC response to PDGF
//=========================================
	double diffPrefactor=0.0;
	if (m_nz==1)	{diffPrefactor=4.0;}	//2D
	else			{diffPrefactor=6.0;}	//3D


    probP0[i][j][k]=
	
	1.0-diffPrefactor*diffCoeffPC*angioDeltaT*
	( (1.0/pow(angioDeltaX,2))+(1.0/pow(angioDeltaY,2))+(1.0/pow(angioDeltaZ,2))*coeffZ )

    + ((m_chiPC*m_alpha*angioDeltaT)/pow((1.0+m_alpha*pTissueNutrientConc[i][j][k]),2))
	*( (pow((pTissueNutrientConc[iplus][j][k]-pTissueNutrientConc[iminus][j][k]),2)/pow((2.0*angioDeltaX),2))
	  +(pow((pTissueNutrientConc[i][jplus][k]-pTissueNutrientConc[i][jminus][k]),2)/pow((2.0*angioDeltaY),2))   
	  +(pow((pTissueNutrientConc[i][j][kplus]-pTissueNutrientConc[i][j][kminus]),2)/pow((2.0*angioDeltaZ),2))*coeffZ ) 

	- ((m_chiPC*angioDeltaT)/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))
	*( ((pTissueNutrientConc[iplus][j][k]-2.0*pTissueNutrientConc[i][j][k]+pTissueNutrientConc[iminus][j][k])/pow(angioDeltaX,2))
      +((pTissueNutrientConc[i][jplus][k]-2.0*pTissueNutrientConc[i][j][k]+pTissueNutrientConc[i][jminus][k])/pow(angioDeltaY,2))  
	  +((pTissueNutrientConc[i][j][kplus]-2.0*pTissueNutrientConc[i][j][k]+pTissueNutrientConc[i][j][kminus])/pow(angioDeltaZ,2))*coeffZ )

	- m_rhoPC*angioDeltaT
	*( ((vFibronectinConc[iplus][j][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[iminus][j][k])/pow(angioDeltaX,2))
	  +((vFibronectinConc[i][jplus][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][jminus][k])/pow(angioDeltaY,2))   
	  +((vFibronectinConc[i][j][kplus]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][j][kminus])/pow(angioDeltaZ,2))*coeffZ );


	//------------------------------------------------
    // P1 = Probability to move to the right (i+1,j,k)
	//------------------------------------------------

	//probP1[i][j][k]=0.0;

	if (i==m_nx || i==m_nx-1)  { probP1[i][j][k]= 0.0; }
	else {
				    probP1[i][j][k]= (diffCoeffPC*angioDeltaT)/pow(angioDeltaX,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaX,2)))
		*( (m_chiPC/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))*(pTissueNutrientConc[iplus][j][k]-pTissueNutrientConc[iminus][j][k])
		  + m_rhoPC*(vFibronectinConc[iplus][j][k]-vFibronectinConc[iminus][j][k]) );
	}

//probP1[i][j][k]=1.0e-3;
	//-----------------------------------------------
	// P2 = Probability to move to the left (i-1,j,k)
	//-----------------------------------------------

	//probP2[i][j][k]=0.0;

	if (i==0 || i<=2)    { probP2[i][j][k]= 0.0; }
	else {
				   probP2[i][j][k]= (diffCoeffPC*angioDeltaT)/pow(angioDeltaX,2)

		- (angioDeltaT/(4.0*pow(angioDeltaX,2)))
		*( (m_chiPC/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))*(pTissueNutrientConc[iplus][j][k]-pTissueNutrientConc[iminus][j][k])
		  + m_rhoPC*(vFibronectinConc[iplus][j][k]-vFibronectinConc[iminus][j][k]) );
	}

//probP2[i][j][k]=1.0e-3;

	//----------------------------------------
	// P3 = Probability to move down (i,j+1,k)
	//----------------------------------------

	//probP3[i][j][k]=1.0;

	if (j==m_ny-1) { probP3[i][j][k]=0.0; }
	else {	
					 probP3[i][j][k]= (diffCoeffPC*angioDeltaT)/pow(angioDeltaY,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaY,2)))
		*( (m_chiPC/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))*(pTissueNutrientConc[i][jplus][k]-pTissueNutrientConc[i][jminus][k])
	      + m_rhoPC*(vFibronectinConc[i][jplus][k]-vFibronectinConc[i][jminus][k]) );
	}

//probP3[i][j][k]=1.0e-3;
	//--------------------------------------
	// P4 = Probability to move up (i,j-1,k)
	//--------------------------------------

	probP4[i][j][k]=0.0;

	if (j==0 || j==1)    { probP4[i][j][k]=0.0; }
	else {
				   probP4[i][j][k]= (diffCoeffPC*angioDeltaT)/pow(angioDeltaY,2)

		- (angioDeltaT/(4.0*pow(angioDeltaY,2)))
		*( (m_chiPC/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))*(pTissueNutrientConc[i][jplus][k]-pTissueNutrientConc[i][jminus][k])
		  + m_rhoPC*(vFibronectinConc[i][jplus][k]-vFibronectinConc[i][jminus][k]) );
	}

//probP4[i][j][k]=1.0e-3;
	//------------------------------------------------
	// P5 = Probability to move to the front (i,j,k+1)
	//------------------------------------------------

	//probP5[i][j][k]=0.0;
	
	if (k==m_nz-1 || coeffZ==0) { probP5[i][j][k]=0.0; }
	else {
					probP5[i][j][k]= (diffCoeffPC*angioDeltaT)/pow(angioDeltaZ,2)

		+ (angioDeltaT/(4.0*pow(angioDeltaZ,2)))
		*( (m_chiPC/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))*(pTissueNutrientConc[i][j][kplus]-pTissueNutrientConc[i][j][kminus])
		  + m_rhoPC*(vFibronectinConc[i][j][kplus]-vFibronectinConc[i][j][kminus]) );
	}

//probP5[i][j][k]=1.0e-3;
	//----------------------------------------
	// P6 = Probability to move back (i,j,k-1)
	//----------------------------------------

	//probP6[i][j][k]=0.0;

	if (k==0 || coeffZ==0)    { probP6[i][j][k]=0.0; }
	else {	
				probP6[i][j][k]= (diffCoeffPC*angioDeltaT)/pow(angioDeltaZ,2)

		- (angioDeltaT/(4.0*pow(angioDeltaZ,2)))
		*( (m_chiPC/(1.0+m_alpha*pTissueNutrientConc[i][j][k]))*(pTissueNutrientConc[i][j][kplus]-pTissueNutrientConc[i][j][kminus])
		  + m_rhoPC*(vFibronectinConc[i][j][kplus]-vFibronectinConc[i][j][kminus]) );
	}

//probP6[i][j][k]=1.0e-3;
	}}}


	
	// Probability that a sprout grows on itself is null
	//---------------------------------------------------




	// Probability that a sprout grows on bond already occupied is null
	//------------------------------------------------------------------



	// If the probability to move in one direction is negative
	// then this contribution is added to the growth probability in 
	// the opposite direction
	//--------------------------------------------------------------

	double add1,add2,add3,add4,add5,add6;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				add1=0.0;
				add2=0.0;
				add3=0.0;
				add4=0.0;
				add5=0.0;
				add6=0.0;

				if (probP0[i][j][k]<0.0) { probP0[i][j][k]=0.0; }
				if (probP1[i][j][k]<0.0) { add1=fabs(probP1[i][j][k]);
										   probP1[i][j][k]=0.0; }
				if (probP2[i][j][k]<0.0) { add2=fabs(probP2[i][j][k]); 
										   probP2[i][j][k]=0.0; }
				if (probP3[i][j][k]<0.0) { add3=fabs(probP3[i][j][k]); 
										   probP3[i][j][k]=0.0; }
				if (probP4[i][j][k]<0.0) { add4=fabs(probP4[i][j][k]); 
										   probP4[i][j][k]=0.0; }
				if (probP5[i][j][k]<0.0) { add5=fabs(probP5[i][j][k]); 
										   probP5[i][j][k]=0.0; }
				if (probP6[i][j][k]<0.0) { add6=fabs(probP6[i][j][k]); 
										   probP6[i][j][k]=0.0; }

				probP1[i][j][k]=probP1[i][j][k]+add2;
				probP2[i][j][k]=probP2[i][j][k]+add1;
				probP3[i][j][k]=probP3[i][j][k]+add4;
				probP4[i][j][k]=probP4[i][j][k]+add3;
				probP5[i][j][k]=probP5[i][j][k]+add6;
				probP6[i][j][k]=probP6[i][j][k]+add5;
	}}}



	// Normalisation of the probabilities
	//------------------------------------

	double probTot;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				probTot = 0.0;
				probTot = fabs(probP0[i][j][k])
					     +fabs(probP1[i][j][k])+fabs(probP2[i][j][k])
						 +fabs(probP3[i][j][k])+fabs(probP4[i][j][k])
				         +fabs(probP5[i][j][k])+fabs(probP6[i][j][k]);  

				if (probTot!=0.0)
				{
					probP0[i][j][k]=fabs(probP0[i][j][k])/probTot;
					probP1[i][j][k]=fabs(probP1[i][j][k])/probTot;
					probP2[i][j][k]=fabs(probP2[i][j][k])/probTot;
					probP3[i][j][k]=fabs(probP3[i][j][k])/probTot;
					probP4[i][j][k]=fabs(probP4[i][j][k])/probTot;
					probP5[i][j][k]=fabs(probP5[i][j][k])/probTot;
					probP6[i][j][k]=fabs(probP6[i][j][k])/probTot;
				}


/*	probsOut << i << "\t"
			 << j << "\t"
			 << probP0[i][j][k] << "\t"
			 << probP1[i][j][k] << "\t"
			 << probP2[i][j][k] << "\t"
			 << probP3[i][j][k] << "\t"
			 << probP4[i][j][k] << "\t"
			 << probP5[i][j][k] << "\t"
			 << probP6[i][j][k] << endl;
*/
	}}}

//----------------------------------------------



	
	// Calculation of the probability ranges
	//---------------------------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=probP0[i][j][k];
				R1inf[i][j][k]=R0sup[i][j][k];
				R1sup[i][j][k]=R0sup[i][j][k]+probP1[i][j][k];
				R2inf[i][j][k]=R1sup[i][j][k];
				R2sup[i][j][k]=R1sup[i][j][k]+probP2[i][j][k];
				R3inf[i][j][k]=R2sup[i][j][k];
				R3sup[i][j][k]=R2sup[i][j][k]+probP3[i][j][k];
				R4inf[i][j][k]=R3sup[i][j][k];
				R4sup[i][j][k]=R3sup[i][j][k]+probP4[i][j][k];
				R5inf[i][j][k]=R4sup[i][j][k];
				R5sup[i][j][k]=R4sup[i][j][k]+probP5[i][j][k];
				R6inf[i][j][k]=R5sup[i][j][k];
				R6sup[i][j][k]=R5sup[i][j][k]+probP6[i][j][k];
	}}}



//-----------------------------------------------------------------------------------

}
//******************************************************

void CAngioNetDlg::SetInitialMDFConcs_TumModel()
{

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{   
	         vMDFConc[i-1][j-1][k-1]=0.0; 
	}}}
	//-------------------------------------


	// Now set Old values to new values (initialisation only)
    for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 vOldMDFConc[i][j][k]=vMDFConc[i][j][k];
	}}}
}
//******************************************************

void CAngioNetDlg::MovePericytes()
{
	//Use the probabilities to move the cells. Cf GrowVasculatureMDF()
	
	//-----------------------------------------------------------------
	// Throw dice and decide which way to go for each PC according 
	// to the probabilities ranges Rj=[Rjinf-Rjsup] with j=0 to 6
	//-----------------------------------------------------------------

//-----------------------------------

    double throwDice;

	int move,moveRight,moveLeft,moveDown,moveUp,moveFront,moveBack;
	int nID,iCoord,jCoord,kCoord;
//------------------------------------




//===========================================================
	for (int nCell=1;nCell<=nPericytes;nCell++)
	{
				
	//PC is at position (pPCXCoord[0;nPericytes-1],pPCYCoord[0;nPericytes-1],pPCZCoord[0;nPericytes-1])
	//Orientation is in array pPCOrientationID[0;nPericytes-1]

		if (pPCOrientationID[nCell-1]==1)	//xOrientated
		{
			nID=LabX(pPCXCoord[nCell-1],pPCYCoord[nCell-1],pPCZCoord[nCell-1]);
		}
		else 
		if (pPCOrientationID[nCell-1]==2)	//yOrientated
		{
			nID=LabY(pPCXCoord[nCell-1],pPCYCoord[nCell-1],pPCZCoord[nCell-1]);
		}
		else
		if (pPCOrientationID[nCell-1]==3)	//zOrientated
		{
			nID=LabZ(pPCXCoord[nCell-1],pPCYCoord[nCell-1],pPCZCoord[nCell-1]);
		}


		//NEED TO THROW DICE HERE TO REPRODUCE SAME NETWORK WITH OR WITHOUT PDGF
		//i.e. if cells are moving then this can affect when a dice is thrown
		//and this will affect EC migration dice later. So ALWAYS throw a dice here

		throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1
//----------------------------------------------------------	
	  if (bDiscretePericyte[nID-1]==true &&	//Pericyte present at this location
		  PC_StillActive[nID-1]==true)		//and is still active (not immobilised on vessel
	  { 
			iCoord=pPCXCoord[nCell-1];
			jCoord=pPCYCoord[nCell-1];
			kCoord=pPCZCoord[nCell-1];

		bool bStayedPutR=false,bStayedPutL=false,bStayedPutU=false,
			 bStayedPutD=false,bStayedPutF=false,bStayedPutB=false,
			 bStayedPut=true;

			//look out for array overshoots or undershoots
			if (iCoord+1<=m_nx+1)
			{moveRight=LabX(iCoord+1,jCoord,kCoord);}
			else
			{moveRight=LabX(iCoord,jCoord,kCoord);bStayedPutR=true;}	//stay in place for now

			if (iCoord-1>=1)
			{moveLeft=LabX(iCoord-1,jCoord,kCoord);}
			else
			{moveLeft=LabX(iCoord,jCoord,kCoord);bStayedPutL=true;}	//stay in place for now

			if (jCoord+1<=m_ny)
			{moveDown=LabY(iCoord,jCoord+1,kCoord);}
			else
			{moveDown=LabY(iCoord,jCoord,kCoord);bStayedPutD=true;}	//stay in place for now

			if (jCoord-1>=1)
			{moveUp=LabY(iCoord,jCoord-1,kCoord);}
			else
			{moveUp=LabY(iCoord,jCoord,kCoord);bStayedPutU=true;}	//stay in place for now

			if (kCoord+1<=m_nz)
			{moveFront=LabZ(iCoord,jCoord,kCoord+1);}
			else
			{moveFront=LabZ(iCoord,jCoord,kCoord);bStayedPutF=true;}//stay in place for now

			if (kCoord-1>=1)
			{moveBack=LabZ(iCoord,jCoord,kCoord-1);}
			else
			{moveBack=LabZ(iCoord,jCoord,kCoord);bStayedPutB=true;}


			//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

			if (throwDice>=R0inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R0sup[iCoord-1][jCoord-1][kCoord-1]) {move=0;}
				//outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R1inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R1sup[iCoord-1][jCoord-1][kCoord-1]) {move=moveRight;}
				//outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R2inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R2sup[iCoord-1][jCoord-1][kCoord-1]) {move=moveLeft;}
				//outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R3inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R3sup[iCoord-1][jCoord-1][kCoord-1]) {move=moveDown;}
				//outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R4inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R4sup[iCoord-1][jCoord-1][kCoord-1]) {move=moveUp;}
				//outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
			if (throwDice>=R5inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R5sup[iCoord-1][jCoord-1][kCoord-1]) {move=moveFront;}
				//outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
			if (throwDice>=R6inf[iCoord-1][jCoord-1][kCoord-1] && throwDice<R6sup[iCoord-1][jCoord-1][kCoord-1]) {move=moveBack;}
				//outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

//-----------------------------------------
			if (move!=0)// && bStayedPut==false) //the PC HAS moved, so update position
			{


					//Now update the coordinate and orientation info
					if (move==moveRight && bStayedPutR==false && 
						bDiscretePericyte[move-1]==false) //no overlap	
					{
						pPCXCoord[nCell-1]=iCoord+1;
						pPCYCoord[nCell-1]=jCoord;
						pPCZCoord[nCell-1]=kCoord;
						pPCOrientationID[nCell-1]=1;	//xOrientated
						bStayedPut=false;
					}
					else
					if (move==moveLeft && bStayedPutL==false && 
						bDiscretePericyte[move-1]==false)	
					{
						pPCXCoord[nCell-1]=iCoord-1;
						pPCYCoord[nCell-1]=jCoord;
						pPCZCoord[nCell-1]=kCoord;
						pPCOrientationID[nCell-1]=1;	//xOrientated
						bStayedPut=false;
					}				
					else
					if (move==moveDown && bStayedPutD==false && 
						bDiscretePericyte[move-1]==false)	
					{
						pPCXCoord[nCell-1]=iCoord;
						pPCYCoord[nCell-1]=jCoord+1;
						pPCZCoord[nCell-1]=kCoord;
						pPCOrientationID[nCell-1]=2;	//yOrientated
						bStayedPut=false;
					}	
					else
					if (move==moveUp && bStayedPutU==false && 
						bDiscretePericyte[move-1]==false)	
					{
						pPCXCoord[nCell-1]=iCoord;
						pPCYCoord[nCell-1]=jCoord-1;
						pPCZCoord[nCell-1]=kCoord;
						pPCOrientationID[nCell-1]=2;	//yOrientated
						bStayedPut=false;
					}	
					else
					if (move==moveFront && bStayedPutF==false && 
						bDiscretePericyte[move-1]==false)	
					{
						pPCXCoord[nCell-1]=iCoord;
						pPCYCoord[nCell-1]=jCoord;
						pPCZCoord[nCell-1]=kCoord+1;
						pPCOrientationID[nCell-1]=3;	//zOrientated
						bStayedPut=false;
					}	
					else
					if (move==moveBack && bStayedPutB==false && 
						bDiscretePericyte[move-1]==false)
					{
						pPCXCoord[nCell-1]=iCoord;
						pPCYCoord[nCell-1]=jCoord;
						pPCZCoord[nCell-1]=kCoord-1;
						pPCOrientationID[nCell-1]=3;	//zOrientated
						bStayedPut=false;
					}	

//------------------------------------------------------------
					//update the existence flag for PC if it moved
					if (move!=0 && bStayedPut==false)	//the PC moved
					{
						bDiscretePericyte[nID-1]=false;	
						bDiscretePericyte[move-1]=true;
						PC_StillActive[nID-1]=false;
						PC_StillActive[move-1]=true;

						if (pFluid[move-1]==10)	//pericyte has landed on a vessel
						{
							PC_StillActive[move-1]=false;
							nPericytesAttached++;
						}

					}	//end if stayedput
//Use for attaching to vessels - Do this later
//					if (pArterialVenousID[nbx-1]>0)
//					{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
//					else 
//					{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

			}	//end if move!=0
//-----------------------------------------
			

	  }//end if pDiscretePericyte[nbx-1]==true 
//-----------------------------------------------------



	}	//end nCell loop
//====================================================




	// The sprouts which have just reached the boundaries are killed
	//---------------------------------------------------------------


	PCsAttached << angiotime << "\t" << nPericytesAttached << endl;

	//outfileGrowVasc << endl;
}
//******************************************************

void CAngioNetDlg::ReadInPreFormedVasc()
{
//------------------------------------------------------
	for (int ii=1;ii<=m_nReplayLoops;ii++)	//need this looping to get 
											//LAST rad and vasc distributions
	{										//then I can comment this loop out to
											//just read in the final vasc for treatment, say
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
	PreFormedVasc >> angiotime;  

//Architecture first  //The file name is "InputVasc2007.txt"
	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int  i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  PreFormedVasc >> pFluid[nbx-1];
			  PreFormedVasc >> pFluid[nby-1];
			  PreFormedVasc >> pFluid[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			PreFormedVasc >> pFluid[nbx-1];
	}}

/*	for (int k=1;k<=m_nz;k++)
	{	for (int j=49;j<=148;j++)
		{	for (int i=49;i<=148;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  PreFormedVasc >> pFluid[nbx-1];
			  PreFormedVasc >> pFluid[nby-1];
			  PreFormedVasc >> pFluid[nbz-1];

			  if	(j==49 || j==147)	{pFluid[nbx-1]=0;}
			  if	(j==148)			{pFluid[nbx-1]=10;}
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			PreFormedVasc >> pFluid[nbx-1];

			if	(j==49 || j==147)	{pFluid[nbx-1]=0;}
			if	(j==148)			{pFluid[nbx-1]=10;}
	}}*/
//------------------------------------------------------
//Now radii  //The file name is "InputRadii2007.txt"

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for ( int i=1;i<=m_nx;i++)
			{
			  PreFormedRad >> XBR[i-1][j-1][k-1];
			  PreFormedRad >> YBR[i-1][j-1][k-1];
			  PreFormedRad >> ZBR[i-1][j-1][k-1];
			}
			  int i=m_nx+1;
			  PreFormedRad >> XBR[i-1][j-1][k-1];
	}}
//------------------------------------------------------
//Now hematocrit	//The file name is "InputHem2007.txt"

	PreFormedHem >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				PreFormedHem >> i;
				PreFormedHem >> j;
				PreFormedHem >> k;
				PreFormedHem >> pXHem[i-1][j-1][k-1];
				PreFormedHem >> pYHem[i-1][j-1][k-1];
				PreFormedHem >> pZHem[i-1][j-1][k-1];
			}

			int i=m_nx+1;

			PreFormedHem >> i;
			PreFormedHem >> j;
			PreFormedHem >> k;
			PreFormedHem >> pXHem[i-1][j-1][k-1];
	}}
//-----------------------------------------------
//Now flows  //The file name is "InputFlows2007.txt"

	PreFormedFlow >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for ( int i=1;i<=m_nx;i++)
			{
			  PreFormedFlow >> XFlow[i-1][j-1][k-1];
			  PreFormedFlow >> YFlow[i-1][j-1][k-1];
			  PreFormedFlow >> ZFlow[i-1][j-1][k-1];
			}
			  int i=m_nx+1;
			  PreFormedFlow >> XFlow[i-1][j-1][k-1];
	}}

//-----------------------------------------------
//Now false flows  //The file name is "InputFalseFlows2007.txt"

	PreFormedFalseFlow >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int  i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  PreFormedFalseFlow >> FalseFlow[nbx-1];
			  PreFormedFalseFlow >> FalseFlow[nby-1];
			  PreFormedFalseFlow >> FalseFlow[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			PreFormedFalseFlow >> FalseFlow[nbx-1];
	}}

//-----------------------------------------------
//Now FQEs  //The file name is "InputFQE2007.txt"

	PreFormedFQE >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for ( int i=1;i<=m_nx;i++)
			{
			  PreFormedFQE >> NormFractRBCFlowX[i-1][j-1][k-1];
			  PreFormedFQE >> NormFractRBCFlowY[i-1][j-1][k-1];
			  PreFormedFQE >> NormFractRBCFlowZ[i-1][j-1][k-1];
			}
			  int i=m_nx+1;
			  PreFormedFQE >> NormFractRBCFlowX[i-1][j-1][k-1];
	}}
//-----------------------------------------------------------
//Now bFlowIn  //The file name is "InputbFlowIn2007.txt"

	PreFormedbFlowIn >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int  i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  PreFormedbFlowIn >> bFlowIn[nbx-1];
			  PreFormedbFlowIn >> bFlowIn[nby-1];
			  PreFormedbFlowIn >> bFlowIn[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			PreFormedbFlowIn >> bFlowIn[nbx-1];
	}}
//-----------------------------------------------------------
//Now bFlowIn  //The file name is "InputbFlowIn2007.txt"

	PreFormedbFlowOut >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int  i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  PreFormedbFlowOut >> bFlowOut[nbx-1];
			  PreFormedbFlowOut >> bFlowOut[nby-1];
			  PreFormedbFlowOut >> bFlowOut[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			PreFormedbFlowOut >> bFlowOut[nbx-1];
	}}
//-----------------------------------------------
	}
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
	//NOW SAVE LAST "PICTURE" SO I DON'T HAVE TO RE-READ EVERYTHING AGAIN
/*		outfileSaveVascLast << angiotime << endl;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)   //File name is "FinalVasc.txt"
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);	
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  outfileSaveVascLast << pFluid[nbx-1] << "\t";
			  outfileSaveVascLast << pFluid[nby-1] << "\t";
			  outfileSaveVascLast << pFluid[nbz-1] << "\t";
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSaveVascLast << pFluid[nbx-1] << "\t";
	}}

		for ( k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)  //File name is "FinalRad.txt"
			{
			  outfileSaveRadLast << XBR[i-1][j-1][k-1]<< "\t";
			  outfileSaveRadLast << YBR[i-1][j-1][k-1] << "\t";
			  outfileSaveRadLast << ZBR[i-1][j-1][k-1] << "\t";
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSaveRadLast << XBR[i-1][j-1][k-1] << endl;
	}}

	for ( k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)  //File name is "FinalHem.txt"
			{
			  outfileSaveHemLast << pXHem[i-1][j-1][k-1]<< "\t";
			  outfileSaveHemLast << pYHem[i-1][j-1][k-1] << "\t";
			  outfileSaveHemLast << pZHem[i-1][j-1][k-1] << "\t";
			}
			i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSaveHemLast << pXHem[i-1][j-1][k-1] << endl;
	}}
*/

	angiotime=0.0; //reset after reading this in from files
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

//	CalculateFlowTimeStep();

/*
//Now calculate TotalFlowsIn, TotalFlowsOut & TotalMassesIn
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalFlowsIn[i-1][j-1][k-1]=0.5*(
					fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
					fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
					fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

				TotalFlowsOut[i-1][j-1][k-1]=TotalFlowsIn[i-1][j-1][k-1];
	}}}

//This section is only required if we are not using Phase Separation

if	(!bSkimming)
{
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				//x-bond to left
				if	(XFlow[i-1][j-1][k-1]>0.0)
				{
					bFlowIn[LabX(i,j,k)-1]=true;	//indicates flow into parent node
				}

				else if	(XFlow[i-1][j-1][k-1]<0.0)
				{
					bFlowOut[LabX(i,j,k)-1]=true;	//indicates flow out of parent node
				}

				//x-bond to right
				if	(XFlow[i+1-1][j-1][k-1]>0.0)
				{
					bFlowIn[LabX(i+1,j,k)-1]=true;
				}

				else if	(XFlow[i+1-1][j-1][k-1]<0.0)
				{
					bFlowOut[LabX(i+1,j,k)-1]=true;
				}
						
				//y-bond above
				if	(YFlow[i-1][j-1][k-1]>0.0)
				{
					bFlowIn[LabY(i,j,k)-1]=true;
				}

				else if	(YFlow[i-1][j-1][k-1]<0.0)
				{
					bFlowOut[LabY(i,j,k)-1]=true;
				}

				//y-bond below
				if	(YFlow[i-1][jp1-1][k-1]>0.0)
				{
					bFlowIn[LabY(i,jp1,k)-1]=true;
				}

				else if	(YFlow[i-1][jp1-1][k-1]<0.0)
				{
					bFlowOut[LabY(i,jp1,k)-1]=true;
				}

				if	(m_nz!=1)
				{
					//z-bond out of screen
					if	(ZFlow[i-1][j-1][k-1]>0.0)
					{
						bFlowIn[LabZ(i,j,k)-1]=true;
					}

					else if	(ZFlow[i-1][j-1][k-1]<0.0)
					{
						bFlowOut[LabZ(i,j,k)-1]=true;
					}

					//z-bond into screen
					if	(ZFlow[i-1][j-1][kp1-1]>0.0)
					{
						bFlowIn[LabZ(i,j,kp1)-1]=true;
					}

					else if	(ZFlow[i-1][j-1][kp1-1]<0.0)
					{
						bFlowOut[LabZ(i,j,kp1)-1]=true;
					}
				}
	}}}

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				if	(TotalFlowsOut[i-1][j-1][k-1]>0.0)
				{
					if	(XFlow[i-1][j-1][k-1]<0.0)
					{
						NormFractRBCFlowX[i-1][j-1][k-1]=fabs(XFlow[i-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
					}

					if	(XFlow[i+1-1][j-1][k-1]>0.0)
					{
						NormFractRBCFlowX[i+1-1][j-1][k-1]=fabs(XFlow[i+1-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
					}

					if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						NormFractRBCFlowY[i-1][j-1][k-1]=fabs(YFlow[i-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
					}

					if	(YFlow[i-1][jp1-1][k-1]>0.0)
					{
						NormFractRBCFlowY[i-1][jp1-1][k-1]=fabs(YFlow[i-1][j+1-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
					}

					if	(m_nz!=1)
					{
						if	(ZFlow[i-1][j-1][k-1]<0.0)
						{
							NormFractRBCFlowZ[i-1][j-1][k-1]=fabs(ZFlow[i-1][j-1][k-1])/TotalFlowsOut[i-1][j-1][k-1];
						}

						if	(ZFlow[i-1][j-1][kp1-1]>0.0)
						{
							NormFractRBCFlowZ[i-1][j-1][kp1-1]=fabs(ZFlow[i-1][j-1][kp1-1])/TotalFlowsOut[i-1][j-1][k-1];
						}
					}
				}
	}}}
}
*/
/*	//Now in UpdateTissNutConc (need to update each timestep)
//--------------------------------------
//CALCULATE TOTAL MASS IN TO EACH NODE
//NB - ONLY THOSE CARRYING RBCS
//--------------------------------------
	
	for ( k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalMassesIn[i-1][j-1][k-1]=0.0;

				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabX(i,j,k)-1]*CharTime*angioDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabX(i+1,j,k)-1]*fabs(XFlow[i+1-1][j-1][k-1])*pOldVesselNutrientConc[LabX(i+1,j,k)-1]*CharTime*angioDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabY(i,j,k)-1]*CharTime*angioDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabY(i,jp1,k)-1]*fabs(YFlow[i-1][jp1-1][k-1])*pOldVesselNutrientConc[LabY(i,jp1,k)-1]*CharTime*angioDeltaT;

				if	(m_nz!=1)
				{
					TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabZ(i,j,k)-1]*CharTime*angioDeltaT;

		  			TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabZ(i,j,kp1)-1]*fabs(ZFlow[i-1][j-1][kp1-1])*pOldVesselNutrientConc[LabZ(i,j,kp1)-1]*CharTime*angioDeltaT;
				}
	
	}}}
*/
//-----------------------------------------------

}
//******************************************************

void CAngioNetDlg::SaveMDE()
{

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			  outfileSaveMDE << vMDFConc[i][j][k] << "\t";

			}
		}
	}

//---------------------------------------------------
}
//******************************************************

void CAngioNetDlg::ReadInMDE()
{
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			  infileMDE >> vMDFConc[i][j][k];

			}
		}
	}

//---------------------------------------------------
}
//******************************************************

void CAngioNetDlg::ReadInPreFormedVascAllRad6()
{
////	for (int i=1;i<=m_nReplayLoops;i++)	//need this looping to get 
											//LAST rad and vasc distributions
////	{
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
	double dummytime;
	PreFormedVasc >> dummytime;

//Architecture first
	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  PreFormedVasc >> pFluid[nbx-1];
			  PreFormedVasc >> pFluid[nby-1];
			  PreFormedVasc >> pFluid[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			PreFormedVasc >> pFluid[nbx-1];
	}}
//------------------------------------------------------

////	}//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


}
//***********************************************
//==========================================
void CAngioNetDlg::UpdatePericyteDensity()
//==========================================
{
	//This update pericytes during growth - the density changes due to 
	//.

	double growthrate=0.05;	//changed by Mike 01/09; 0.0075;	//don't know what size this should be yet
	double carryingCapacity=0.0;	//This must be assigned at each time and for each vessel
									//as it grows.  If this 
//	double RadiusPericyte=20.0e-6;	//m^2


	//NOTE pPericyteDensity is NUMBER of pericytes (not really a density - 
	//graphics converts to density)
	//This equation is dimensional at the moment but tau timescale is used

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

			  carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);	//Swapped by
//			  carryingCapacity=2.0*7.0e-6*angioDeltaX/pow(RadiusPericyte,2);				//Mike 01/09

			  if(pFluid[nbx-1]==10)	//Edited out by Mike 01/09// && bFlowingVessel[nbx-1]) //pericytes recruited to FLOWING vessels??
			  {pPericyteDensity[nbx-1]+=angioDeltaT*growthrate*  //XBR[i-1][j-1][k-1]/Rmax*
			  pPericyteDensity[nbx-1]*(carryingCapacity-pPericyteDensity[nbx-1]);}
				
			  carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);	//Swapped by
//			  carryingCapacity=2.0*7.0e-6*angioDeltaX/pow(RadiusPericyte,2);				//Mike 01/09

			  if(pFluid[nby-1]==10) //Edited out by Mike 01/09// && bFlowingVessel[nby-1])
			  {pPericyteDensity[nby-1]+=angioDeltaT*growthrate*  //YBR[i-1][j-1][k-1]/Rmax*
			  pPericyteDensity[nby-1]*(carryingCapacity-pPericyteDensity[nby-1]);}

			  carryingCapacity=2.0*ZBR[i-1][j-1][k-1]*angioDeltaZ/pow(RadiusPericyte,2);	//Swapped by
//			  carryingCapacity=2.0*7.0e-6*angioDeltaX/pow(RadiusPericyte,2);				//Mike 01/09

			  if(pFluid[nbz-1]==10) //Edited out by Mike 01/09// && bFlowingVessel[nbz-1])
			  {pPericyteDensity[nbz-1]+=angioDeltaT*growthrate*  //ZBR[i-1][j-1][k-1]/Rmax*
			  pPericyteDensity[nbz-1]*(carryingCapacity-pPericyteDensity[nbz-1]);}


			}

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			  carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);	//Swapped by
//			  carryingCapacity=2.0*7.0e-6*angioDeltaX/pow(RadiusPericyte,2);				//Mike 01/09

			  if(pFluid[nbx-1]==10) //Edited out by Mike 01/09// && bFlowingVessel[nbx-1])
			  {pPericyteDensity[nbx-1]+=angioDeltaT*growthrate*  //XBR[i-1][j-1][k-1]/Rmax*
			  pPericyteDensity[nbx-1]*(carryingCapacity-pPericyteDensity[nbx-1]);}

		}
	}

//-----------------------------------------------

//-----------------------------------------------
//---PVs are fully coated with pericytes---

	int	j=1;	//Top PV
	int k;

	if (m_nz==1) {k=1; } else {k=int(m_nz/2); }

	for (int i=1;i<=m_nx+1;i++)
	{
		int nbx=LabX(i,j,k);
		carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
		pPericyteDensity[nbx-1]=carryingCapacity;
	}

//-------------------------------------
	if	(b_venousIncluded)	//Venous PV included if requested
	{
		j=m_ny-1;

		if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

		for (int i=1;i<=m_nx+1;i++)
		{
			int nbx=LabX(i,j,k);
			carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
			pPericyteDensity[nbx-1]=carryingCapacity;
		}
	}

//-------------------------------------
	if	(b_UU_wound_Model)	//Additional PVs for wound model included if requested	//Mike 01/09 
	{
		int i,j,k,nbx,nby;

		for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{
			j=nCount*m_ny/(nAdditionalCentralPVs+1);

			if	(m_nz==1) { k=1; } else { k=int(m_nz/2); }

//-----------------------------------------------
			if	(!b_HexNetwork || (b_HexNetwork && !b_StraightPVs))	//square network or hex network with straight PVs
			{
				for (i=1;i<=m_nx+1;i++)
				{
					if (
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
						pPericyteDensity[nbx-1]=carryingCapacity;
					}
				}	
			}	//end if square network

//-----------------------------------------------
			else if	(b_HexNetwork && !b_StraightPVs)	//hex network with wiggly PVs	
			{
				if	(int(j/2)-double(j/2.0)==0)	//if j even (inlets & outlets at j+1)
				{
					for (i=2;i<=m_nx-2;i+=3)	//some upper x-bonds fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
							pPericyteDensity[nbx-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					for (i=3;i<=m_nx-1;i+=3)	//rest of upper x-bonds fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
							pPericyteDensity[nbx-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

					for (i=1;i<=m_nx;i+=3)	//lower x-bonds (including inlets) fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
							pPericyteDensity[nbx-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					i=m_nx+1;	//outlets fully coated
		
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
						pPericyteDensity[nbx-1]=carryingCapacity;
					}

//-----------------------------------------------
					for (i=1;i<=m_nx-3;i+=3)	//y-bonds (tilted to right) fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nby=LabY(i,j,k);
							carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);
							pPericyteDensity[nby-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					for (i=3;i<=m_nx-1;i+=3)	//y-bonds (tilted to left) fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nby=LabY(i,j,k);
							carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);
							pPericyteDensity[nby-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
				}	//end if j even

//-----------------------------------------------
				else	//if j odd (inlets & outlets on j)	
				{
					for (i=1;i<=m_nx;i+=3)	//upper x-bonds (including inlets) fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
							pPericyteDensity[nbx-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					i=m_nx+1;	//outlets fully coated
		
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
						pPericyteDensity[nbx-1]=carryingCapacity;
					}

//-----------------------------------------------
					j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

					for (i=2;i<=m_nx-2;i+=3)	//some lower x-bonds fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
							pPericyteDensity[nbx-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					for (i=3;i<=m_nx-1;i+=3)	//rest of lower x-bonds fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);
							pPericyteDensity[nbx-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
                    for (i=1;i<=m_nx-3;i+=3)	//y-bonds (tilted to left) fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nby=LabY(i,j,k);
							carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);
							pPericyteDensity[nby-1]=carryingCapacity;
						}
					}

//-----------------------------------------------
					for (i=3;i<=m_nx-1;i+=3)	//y-bonds (tilted to right) fully coated
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nby=LabY(i,j,k);
							carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);
							pPericyteDensity[nby-1]=carryingCapacity;
						}
					}

//-----------------------------------------------								
				}	//end if j odd

//-----------------------------------------------
			}	//end if hexagonal vasculature

		}	//end nCount loop

//-----------------------------------------------
	}	//end if wound model

//-----------------------------------------------

}

//***********************************************
//================================
void CAngioNetDlg::SavePericytes()
//================================
{

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);

			  outfileSavePericyte << pPericyteDensity[nbx-1] << "\t";
			  outfileSavePericyte << pPericyteDensity[nby-1] << "\t";
			  outfileSavePericyte << pPericyteDensity[nbz-1] << "\t";
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSavePericyte << pPericyteDensity[nbx-1] << "\t";
	}}
//--------------------------------------------------------------
}
//**************************************************************************

void CAngioNetDlg::ReadInPericytes()
{
//	inputfileSavePericytes >> angiotime;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  nbx=LabX(i,j,k);
			  nby=LabY(i,j,k);
			  nbz=LabZ(i,j,k);
	
			  inputfileSavePericytes >> pPericyteDensity[nbx-1];
			  inputfileSavePericytes >> pPericyteDensity[nby-1];
			  inputfileSavePericytes >> pPericyteDensity[nbz-1];
			}
			int i=m_nx+1;
			nbx=LabX(i,j,k);

			inputfileSavePericytes >> pPericyteDensity[nbx-1];
	}}
}
//**************************************************************************

void CAngioNetDlg::FlowingVessels()
{

//Try a cluster based approach----------------

	//First remove PV cluster to isolate branch structure
		int i,j,k,nbx;
	j=1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=44;
			bFlowingVessel[nbx-1]=true;
	}

//-------------------------------------
	if (b_venousIncluded)
	{//Venous PV included if requested
	j=m_ny-1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=44;
			bFlowingVessel[nbx-1]=true;
	}

	}//////////////

//=============Do clustering and identify flowing vessels in branches========
	int zpos;
	if (m_nz==1) { zpos=1; } else {zpos=int(m_nz/2); }

		Clustering(pIclusO,10,10);	//Get vessel cluster numbers

	int iSprout1=(int)floor(1.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout2=(int)floor(2.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout3=(int)floor(3.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout4=(int)floor(4.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout5=(int)floor(5.0*(m_nx+1)/6.0+0.5);	//NINT


	int LabelSprout1=LabY(iSprout1,2,zpos);
	int LabelSprout2=LabY(iSprout2,2,zpos);
	int LabelSprout3=LabY(iSprout3,2,zpos);
	int LabelSprout4=LabY(iSprout4,2,zpos);
	int LabelSprout5=LabY(iSprout5,2,zpos);

	for (int n=1;n<=Nbond;n++)
	{
		int branchCount=0;
		bFlowingVessel[n-1]=false;

		if(pIclusO[n-1]==pIclusO[LabelSprout1-1]) {branchCount++;}
		if(pIclusO[n-1]==pIclusO[LabelSprout2-1]) {branchCount++;}
		if(pIclusO[n-1]==pIclusO[LabelSprout3-1]) {branchCount++;}
		if(pIclusO[n-1]==pIclusO[LabelSprout4-1]) {branchCount++;}
		if(pIclusO[n-1]==pIclusO[LabelSprout5-1]) {branchCount++;}
	
		if (branchCount>=2) {bFlowingVessel[n-1]=true;}
	}

//PUT IN HERE!!!!!!!

//===========================================================================

	//Put pFluid label back now that clustering is done---------------
	j=1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			bFlowingVessel[nbx-1]=true;
	}

//-------------------------------------
	if (b_venousIncluded)
	{//Venous PV included if requested
	j=m_ny-1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			bFlowingVessel[nbx-1]=true;
	}

	}//////////////

//--END Cluster based approach---------------------------

	return;

/////*********!!!LEAVING THE CALCLATION OF FLOWING BONDS HERE!!!!!*********


//====Flow based approach to identifying flowing vessels-=======================
//---------------------------------------------------------
	double FlowMax=0.0;
	double FlowTol=1.0e-5;
//---------------------------------------------------------------
	for ( k=1;k<=m_nz;k++)
	{	
		for ( j=1;j<=m_ny;j++)
		{	
			for ( i=1;i<=m_nx;i++) 
			{

				if (XFlow[i-1][j-1][k-1] > FlowMax) {FlowMax=XFlow[i-1][j-1][k-1];}
				if (YFlow[i-1][j-1][k-1] > FlowMax) {FlowMax=YFlow[i-1][j-1][k-1];}
				if (ZFlow[i-1][j-1][k-1] > FlowMax) {FlowMax=ZFlow[i-1][j-1][k-1];}
			}
			 i=m_nx+1;
				if (XFlow[i-1][j-1][k-1] > FlowMax) {FlowMax=XFlow[i-1][j-1][k-1];}
		}
	}
//---------------------------------------------------------------
	for ( k=1;k<=m_nz;k++)
	{	
		for ( j=1;j<=m_ny;j++)
		{	
			for ( i=1;i<=m_nx;i++) //away from PV?
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);

				bFlowingVessel[nbx-1]=false;
				bFlowingVessel[nby-1]=false;
				bFlowingVessel[nbz-1]=false;


				if (XFlow[i-1][j-1][k-1] > FlowMax*FlowTol) {bFlowingVessel[nbx-1]=true;}
				if (YFlow[i-1][j-1][k-1] > FlowMax*FlowTol) {bFlowingVessel[nby-1]=true;}
				if (ZFlow[i-1][j-1][k-1] > FlowMax*FlowTol) {bFlowingVessel[nbz-1]=true;}
			}

			i=m_nx+1;
			int nbx=LabX(i,j,k);

				bFlowingVessel[nbx-1]=false;

				if (XFlow[i-1][j-1][k-1] > FlowMax*FlowTol) {bFlowingVessel[nbx-1]=true;}
		}
	}

	//=End of flow based approach==========================


//-------------------------------------------------------------
}
//**************************************************************************

void CAngioNetDlg::UpdateTAFWithDiffusion()
{


	int iplus,iminus,jplus,jminus,kplus,kminus;

	double subAngioDeltaT;

	if (m_nz==1) { subAngioDeltaT=angioDeltaT/2.0; } // for a 2D network
		else     { subAngioDeltaT=angioDeltaT/3.0; } // for a 3D network
 
	double nu=5.1;//3.0; //normalised decay
	double eta=0.1;	//normalised UPTAKE by ECs
	double epsilon=1.0;//0.01;  //normalised TAF diffusion coeff  //0.00035;
	double TAF_Prod=800.0;	//normalised TAF production from tumour boundary
	double lambdaX=(epsilon*subAngioDeltaT)/(pow(angioDeltaX,2));
	double lambdaY=(epsilon*subAngioDeltaT)/(pow(angioDeltaY,2));
	
	angioDeltaZ=angioDeltaY;
	double lambdaZ=(epsilon*subAngioDeltaT)/(pow(angioDeltaZ,2));
	//or angioDeltaZ=angioDeltaY to avoid a division by zero (see InitVariables())

    double* coeffA;
	double* coeffB; 
	double* coeffC;
	double* coeffD;

//---------------------------------------------------------------------------
// calculation of the variables in the x-direction time=[t,t+subAngioDeltaT]
//---------------------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nx+1];
	coeffB=new double[m_nx+1];
    coeffC=new double[m_nx+1];
	coeffD=new double[m_nx+1];

	//-----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{  //----------------------------
		
			for (int i=0;i<=m_nx;i++) 
			{	
				//==============TAF Production at Tum boundary
				double P_TAF=0.0;
				if (j==m_ny-1) {P_TAF=TAF_Prod;}
				//===============
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}
			

	// update Matrix Degradation Factor (MDF)
		coeffA[i]=-lambdaX;
		coeffB[i]=1.0+2.0*lambdaX;
		coeffC[i]=-lambdaX;

		coeffD[i]=vOldTAFConc[i][j][k]+subAngioDeltaT*(P_TAF 

	     -eta*vSproutsTips[i][j][k]*vOldTAFConc[i][j][k]-nu*vOldTAFConc[i][j][k]
		
	   + epsilon*(//--------------------------------------------------------------

		((vOldTAFConc[i][jplus][k]-2.0*vOldTAFConc[i][j][k]+
		  vOldTAFConc[i][jminus][k])/pow(angioDeltaY,2)) 

	   +((vOldTAFConc[i][j][kplus]-2.0*vOldTAFConc[i][j][k]+
		  vOldTAFConc[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close epsilon-------------------------------------------------------

		); //close subAngioDeltaT


		} // end loop i


		SolveTridiagTAFX(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);
	
	
	}} // end loops j and k

	

//--------------------------------------------------------------------------------------------
// calculation of the variables in the y-direction time=[t+subAngioDeltaT,t+2*subAngioDeltaT]
//--------------------------------------------------------------------------------------------

	//=======================
	  OverWriteOldWithNewTAF();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_ny];
	coeffB=new double[m_ny];
    coeffC=new double[m_ny];
	coeffD=new double[m_ny];
 
	//----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{   for ( int i=0;i<=m_nx;i++)
		{  //----------------------------
		
			for (int j=0;j<=m_ny-1;j++) 
			{
				//==============TAF Production at Tum boundary
				double P_TAF=0.0;
				if (j==m_ny-1) {P_TAF=TAF_Prod;}
				//===============

		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}

			    

	// update Matrix Degradation Factor (MDF)
		coeffA[j]=-lambdaY;
		coeffB[j]=1.0+2.0*lambdaY;
		coeffC[j]=-lambdaY;

		coeffD[j]=vOldTAFConc[i][j][k]+subAngioDeltaT*(P_TAF 

		 -eta*vSproutsTips[i][j][k]*vOldTAFConc[i][j][k]-nu*vOldTAFConc[i][j][k]
			
	   + epsilon*(//--------------------------------------------------------------

		((vOldTAFConc[iplus][j][k]-2.0*vOldTAFConc[i][j][k]+
		  vOldTAFConc[iminus][j][k])/pow(angioDeltaX,2))

	   +((vOldTAFConc[i][j][kplus]-2.0*vOldTAFConc[i][j][k]+
		  vOldTAFConc[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close epsilon-------------------------------------------------------

		); //close subAngioDeltaT

		} // end loop j

		SolveTridiagTAFY(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and k
 

	//=======================
	  OverWriteOldWithNewTAF();	///SMcD  $$$$  SHOULD WE NOT CALL THIS HERE TOO 
								
	//=======================
//-----------------------------------------------------------------------------------------
// calculation of the variables in the z-direction time=[t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz is not equal to 1 (i.e. 3D network)
//------------------------------------------------------------------------------------------


	if (m_nz!=1) { //=====================================================================


	//=======================
	  ////SMcD here and commented this out  
//		OverWriteOldWithNewMDF();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nz];
	coeffB=new double[m_nz];
    coeffC=new double[m_nz];
	coeffD=new double[m_nz];

	//-----------------------------
	for (int i=0;i<=m_nx;i++)
	{   for (int j=0;j<=m_ny-1;j++)
		{   //----------------------------
		
			for (int k=0;k<=m_nz-1;k++) 
			{	
				//==============TAF Production at Tum boundary
				double P_TAF=0.0;
				if (j==m_ny-1) {P_TAF=TAF_Prod;}
				//===============

		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}


	// update EndoCellDensity
		coeffA[k]=-lambdaZ;
		coeffB[k]=1.0+2.0*lambdaZ;
		coeffC[k]=-lambdaZ;
		
        coeffD[k]=vOldTAFConc[i][j][k]+subAngioDeltaT*(P_TAF 
			
		-eta*vSproutsTips[i][j][k]*vOldTAFConc[i][j][k]-nu*vOldTAFConc[i][j][k]

	  + epsilon*(//--------------------------------------------------------------

		((vOldTAFConc[iplus][j][k]-2.0*vOldTAFConc[i][j][k]+
		  vOldTAFConc[iminus][j][k])/pow(angioDeltaX,2))

	   +((vOldTAFConc[i][jplus][k]-2.0*vOldTAFConc[i][j][k]+
		  vOldTAFConc[i][jminus][k])/pow(angioDeltaY,2))

		  ) //close epsilon-------------------------------------------------------
		 
		); //close subAngioDeltaT

		} // end loop k

		SolveTridiagTAFZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and j

	} // end if (m_nz!=1) =============================================================

	//=======================
	  OverWriteOldWithNewTAF();	///SMcD  $$$$  SHOULD WE NOT CALL THIS HERE TOO 
								////   (if  nz=1 then the y-values are not overwritten)
	//=======================


	// Now get new running MDFConc maximum
	runningTAFConcMAX=0.0; // used for graphics

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 if (vOldTAFConc[i][j][k]>runningTAFConcMAX)
			 {	
				 runningTAFConcMAX=vOldTAFConc[i][j][k];
			 }		
	}}}


//----------------------------------------------
	//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------



}
//**************************************************************************

void CAngioNetDlg::OverWriteOldWithNewTAF()
{
for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
			 vOldTAFConc[i][j][k]=vTAFConc[i][j][k];

//			 if(j==24){outfileDebugBone<<i+1<<"\t"<<j+1<<"\t"<<k+1<<"\t"<<vTAFConc[i][j][k]<<endl;}
	}}}
//outfileDebugBone<<endl;
}
//**************************************************************************

void CAngioNetDlg::SolveTridiagTAFX(int m_nx, int m_ny, int m_nz, int j, int k, double *coeffA, double *coeffB, double *coeffC, double *coeffD)
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nx+1]; // indice: 0 to m_nx
	q=new double[m_nx+1];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int i=1;i<=m_nx;i++)
	{
		p[i]=coeffC[i]/(coeffB[i]-coeffA[i]*p[i-1]);
		q[i]=(coeffD[i]-coeffA[i]*q[i-1])/(coeffB[i]-coeffA[i]*p[i-1]);
	}

	//calculation of the function for the next time step (iteration)
	vTAFConc[m_nx][j][k]=(q[m_nx]-p[m_nx]*q[m_nx-1])/(1.0-p[m_nx]*p[m_nx-1]);

	int i=m_nx-1;
	while(i>-1)
    {
		vTAFConc[i][j][k]=q[i]-vTAFConc[i+1][j][k]*p[i];
		i=i-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}
//**************************************************************************

void CAngioNetDlg::SolveTridiagTAFY(int m_nx, int m_ny, int m_nz, int i, int k, double *coeffA, double *coeffB, double *coeffC, double *coeffD)
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_ny]; // indice: 0 to m_ny-1
	q=new double[m_ny];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int j=1;j<=m_ny-1;j++)
	{
		p[j]=coeffC[j]/(coeffB[j]-coeffA[j]*p[j-1]);
		q[j]=(coeffD[j]-coeffA[j]*q[j-1])/(coeffB[j]-coeffA[j]*p[j-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	vTAFConc[i][m_ny-1][k]=(q[m_ny-1]-p[m_ny-1]*q[m_ny-2])/(1.0-p[m_ny-1]*p[m_ny-2]);

	int j=m_ny-2;
	while(j>-1)
    {
		vTAFConc[i][j][k]=q[j]-vTAFConc[i][j+1][k]*p[j];
		j=j-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}
//**************************************************************************

void CAngioNetDlg::SolveTridiagTAFZ(int m_nx, int m_ny, int m_nz, int i, int j, double *coeffA, double *coeffB, double *coeffC, double *coeffD)
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nz]; // indice: 0 to m_nz-1
	q=new double[m_nz];

	//calculation of the matrix coefficients
    p[0]=(coeffA[0]+coeffC[0])/coeffB[0];
	q[0]=coeffD[0]/coeffB[0];
	for (int k=1;k<=m_nz-1;k++)
	{
		p[k]=coeffC[k]/(coeffB[k]-coeffA[k]*p[k-1]);
		q[k]=(coeffD[k]-coeffA[k]*q[k-1])/(coeffB[k]-coeffA[k]*p[k-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	vTAFConc[i][j][m_nz-1]=(q[m_nz-1]-p[m_nz-1]*q[m_nz-2])/(1.0-p[m_nz-1]*p[m_nz-2]);

	int k=m_nz-2;
	while(k>-1)
    {
		vTAFConc[i][j][k]=q[k]-vTAFConc[i][j][k+1]*p[k];
		k=k-1;
	}

	//--------------------
	delete [] p;
	delete [] q;
	//--------------------
}
//**************************************************************************

void CAngioNetDlg::ArtVenGraphics(int xMin, int xMax, int yMin, int yMax, int networkWidth, double deltaX, double deltaY)
{
	//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 DarkGreen=RGB(0,128,64),Yellow=RGB(255,255,0),
			 Orange=RGB(255,128,0),Grey1=RGB(128,128,128);

//Define the pens 
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penPink(PS_SOLID,1,pink);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penDarkGreen(PS_SOLID,1,DarkGreen);
	CPen penGreen(PS_SOLID,1,green);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,2,Orange);
	CPen penRed(PS_SOLID,3,red);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(520,24,myString);


//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


	//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(50,50,50));

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------


//------------------------------------------
//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);
//----------------------------------------------
//z-pores--
/*
	//if      (ZBR[i-1][j-1][k-1]>0 && ZBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (ZBR[i-1][j-1][k-1]>0.0  && ZBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (ZBR[i-1][j-1][k-1]>10e-6 && ZBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (ZBR[i-1][j-1][k-1]>15e-6 && ZBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (ZBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/
	if      (pArterialVenousID[nbz-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nbz-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbz-1]!=10) { memDC.SelectObject(&penBlack);}

//	if (pFluid[nbz-1]!=10) { memDC.SelectObject(&penDarkGreen);}

	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
			
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}


//x-pores--
/*
	//if      (XBR[i-1][j-1][k-1]>0.0 && XBR[i-1][j-1][k-1]<=2e-6)  { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/
	if      (pArterialVenousID[nbx-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nbx-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--
/*
	//if      (YBR[i-1][j-1][k-1]>0 && YBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (YBR[i-1][j-1][k-1]>0.0  && YBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (YBR[i-1][j-1][k-1]>10e-6 && YBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (YBR[i-1][j-1][k-1]>15e-6 && YBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (YBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/	
	
	if      (pArterialVenousID[nby-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nby-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nby-1]!=10) { memDC.SelectObject(&penBlack);}

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}


//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	int i=m_nx+1;

	int nbx=LabX(i,j,k);
/*	
	//if      (XBR[i-1][j-1][k-1]>0 && XBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/
	if      (pArterialVenousID[nbx-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nbx-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penBlack);}

//	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penDarkGreen);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

	   }	//end j loop
	}		// end k loop

//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }

//------------------------------------------------

//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}
//**************************************************************************

//**************************************************************************
void CAngioNetDlg::PericyteGraphicsDiscrete(int xMin, int xMax, int yMin, int yMax, int networkWidth, double deltaX, double deltaY)
{
//------------------Plot FBs----------------------------
//Get a device context first
	CClientDC graphicsDC(this);
	
//	DrawBackground();
	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Yellow=RGB(255,255,0),
			 Grey1=RGB(128,128,128),Grey2=RGB(190,190,190);

//Define the pens 
	CPen penRed(PS_SOLID,3,red);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGreen(PS_SOLID,3,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penGrey2(PS_SOLID,1,Grey2);
	CPen penYellow(PS_SOLID,2,Yellow);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=graphicsDC.SelectObject(&penRed);


//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);

//select a brush
	CBrush brFB(RGB(255,255,80));
	CBrush brATT(RGB(0,255,80));
	CBrush brZ(RGB(255,0,80));


	memDC.SelectObject(&brFB);

//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }
//========================================================
//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//------------------------------------------------

//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(50,50,50));
	memDC.SelectObject(&penBlack);

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------

//------------------------------------------
//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);
//----------------------------------------------


//x-pores--
/*
	//if      (XBR[i-1][j-1][k-1]>0.0 && XBR[i-1][j-1][k-1]<=2e-6)  { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/
	if      (pArterialVenousID[nbx-1]>0) { memDC.SelectObject(&penRed);}
	//if		(pArterialVenousID[nbx-1]>0 && j==1) { memDC.SelectObject(&penGreen);}
	else if (pArterialVenousID[nbx-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penBlack);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)((XPOS[i][j][k]-1)*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores--
/*
	//if      (YBR[i-1][j-1][k-1]>0 && YBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (YBR[i-1][j-1][k-1]>0.0  && YBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (YBR[i-1][j-1][k-1]>10e-6 && YBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (YBR[i-1][j-1][k-1]>15e-6 && YBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (YBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/	
	
	if      (pArterialVenousID[nby-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nby-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nby-1]!=10) { memDC.SelectObject(&penBlack);}

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//z-pores--
/*
	//if      (ZBR[i-1][j-1][k-1]>0 && ZBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (ZBR[i-1][j-1][k-1]>0.0  && ZBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (ZBR[i-1][j-1][k-1]>10e-6 && ZBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (ZBR[i-1][j-1][k-1]>15e-6 && ZBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (ZBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/
	if      (pArterialVenousID[nbz-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nbz-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbz-1]!=10) { memDC.SelectObject(&penBlack);}

//	if (pFluid[nbz-1]!=10) { graphicsDC.SelectObject(&penDarkGreen);}

	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
			
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}

	}

//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	int i=m_nx+1;

	int nbx=LabX(i,j,k);
/*	
	//if      (XBR[i-1][j-1][k-1]>0 && XBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}
*/
	if      (pArterialVenousID[nbx-1]>0) { memDC.SelectObject(&penRed);}
	else if (pArterialVenousID[nbx-1]<0) { memDC.SelectObject(&penDarkBlue);}

//	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penBlack);}

//	if (pFluid[nbx-1]!=10) { graphicsDC.SelectObject(&penDarkGreen);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

	   }	//end j loop
	}		// end k loop



	// draw colour segment in the x-direction
/*	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the z-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
		
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

*/

//------------------------------------------



		for (int nCell=1;nCell<=nPericytes;nCell++)	//PUTBACK FOR ALL FBs Shown
	{



		//Change brush colour if PC is attached
			if (pPCOrientationID[nCell-1]==1)
			{
				int ID=LabX(pPCXCoord[nCell-1],pPCYCoord[nCell-1],pPCZCoord[nCell-1]);
				if (PC_StillActive[ID-1])
				{memDC.SelectObject(&brFB);}
				else
				{memDC.SelectObject(&brATT);}
			}

				if (pPCOrientationID[nCell-1]==2)
			{
				int ID=LabY(pPCXCoord[nCell-1],pPCYCoord[nCell-1],pPCZCoord[nCell-1]);
				if (PC_StillActive[ID-1])
				{memDC.SelectObject(&brFB);}
				else
				{memDC.SelectObject(&brATT);}
			}

				if (pPCOrientationID[nCell-1]==3)
			{
				int ID=LabZ(pPCXCoord[nCell-1],pPCYCoord[nCell-1],pPCZCoord[nCell-1]);
				if (PC_StillActive[ID-1])
				{memDC.SelectObject(&brFB);}
				else
				{memDC.SelectObject(&brATT);}
			}
//----xOrientated-----------------------------------------------
			if (pPCOrientationID[nCell-1]==1)
			{
			
			int k=pPCZCoord[nCell-1];	//3D graphics 
			memDC.Ellipse(
							(int)((k-1)*iOffset*cos(dAngle))+xMin+
			(int)deltaX+(int)pPCXCoord[nCell-1]*networkWidth/m_nx + 4,//int(1.0*networkWidth/m_nx/2.),
							(int)((k-1)*iOffset*sin(dAngle))+yMin+
			(int)deltaY+(int)pPCYCoord[nCell-1]*networkWidth/m_ny + 3,
							(int)((k-1)*iOffset*cos(dAngle))+xMin+
			(int)deltaX+(int)pPCXCoord[nCell-1]*networkWidth/m_nx - 4,//int(1.0*networkWidth/m_nx/2.),
							(int)((k-1)*iOffset*sin(dAngle))+yMin+
			(int)deltaY+(int)pPCYCoord[nCell-1]*networkWidth/m_ny - 3
			);

			}
		
//--------------------------------------------------------------
//----yOrientated-----------------------------------------------
			if (pPCOrientationID[nCell-1]==2)
			{
			int k=pPCZCoord[nCell-1];	//3D graphics 

			memDC.Ellipse(
							(int)((k-1)*iOffset*cos(dAngle))+xMin+
			(int)deltaX+(int)pPCXCoord[nCell-1]*networkWidth/m_nx + 3,
							(int)((k-1)*iOffset*sin(dAngle))+yMin+
			(int)deltaY+(int)pPCYCoord[nCell-1]*networkWidth/m_ny + 4,//int(1.0*networkWidth/m_ny/2.),
							(int)((k-1)*iOffset*cos(dAngle))+xMin+
			(int)deltaX+(int)pPCXCoord[nCell-1]*networkWidth/m_nx - 3,
							(int)((k-1)*iOffset*sin(dAngle))+yMin+
			(int)deltaY+(int)pPCYCoord[nCell-1]*networkWidth/m_ny - 4//int(1.0*networkWidth/m_ny/2.)
			);

			}


//----zOrientated-----------------------------------------------
			if (pPCOrientationID[nCell-1]==3)
			{
			int k=pPCZCoord[nCell-1];	//3D graphics ZOK??????

			memDC.Ellipse(
							(int)((k-1)*iOffset*cos(dAngle))+xMin+
			(int)deltaX+(int)pPCXCoord[nCell-1]*networkWidth/m_nx + 3,
							(int)((k-1)*iOffset*sin(dAngle))+yMin+
			(int)deltaY+(int)pPCYCoord[nCell-1]*networkWidth/m_ny + 3,//int(1.0*networkWidth/m_ny/2.),
							(int)((k-1)*iOffset*cos(dAngle))+xMin+
			(int)deltaX+(int)pPCXCoord[nCell-1]*networkWidth/m_nx - 3,
							(int)((k-1)*iOffset*sin(dAngle))+yMin+
			(int)deltaY+(int)pPCYCoord[nCell-1]*networkWidth/m_ny - 3//int(1.0*networkWidth/m_ny/2.)
			);

			}

//---------------------------------
	} //end do loop over nCell values








//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);
//------------------------------------------------


}
//**************************************************************************



//**************************************************************************

void CAngioNetDlg::InitialisePericytes(void)
{
// Sets the initial Pericyte positions
	int PC_Counter=0;	//NB PV pericyte number is included in nPericytes parameter
	int PC_ID,iCoord,jCoord,kCoord,randDice;


//----------------------------------------------
//Assign PV pericytes first
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{

//----------------------------------------------
	int nbx=LabX(i,j,k);	//PVs only in x-direction at present
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);
//----------------------------------------------
		if (pFluid[nbx-1]==10)	//vessel present (i.e. PVs at present)
		{
			bDiscretePericyte[nbx-1]=true;	//PC present
			PC_StillActive[nbx-1]=false;	//but inactive

			pPCXCoord[PC_Counter]=i;	//these refer to an array that is only 
			pPCYCoord[PC_Counter]=j;	//nPericytes in size (0,nPericytes-1)
			pPCZCoord[PC_Counter]=k;
			pPCOrientationID[PC_Counter]=1; //calculates orientation

			PC_Counter++;
		}
//----------------------------------------------

		if (pFluid[nby-1]==10)	//vessel present (i.e. PVs at present)
		{
			bDiscretePericyte[nby-1]=true;	//PC present
			PC_StillActive[nby-1]=false;	//but inactive

			pPCXCoord[PC_Counter]=i;	//these refer to an array that is only 
			pPCYCoord[PC_Counter]=j;	//nPericytes in size (0,nPericytes-1)
			pPCZCoord[PC_Counter]=k;
			pPCOrientationID[PC_Counter]=2; //calculates orientation

			PC_Counter++;
		}
//--------------------------------------------

		if (pFluid[nbz-1]==10)	//vessel present (i.e. PVs at present)
		{
			bDiscretePericyte[nbz-1]=true;	//PC present
			PC_StillActive[nbz-1]=false;	//but inactive

			pPCXCoord[PC_Counter]=i;	//these refer to an array that is only 
			pPCYCoord[PC_Counter]=j;	//nPericytes in size (0,nPericytes-1)
			pPCZCoord[PC_Counter]=k;
			pPCOrientationID[PC_Counter]=3; //calculates orientation

			PC_Counter++;
		}
//-----------------------------------------------
			}	//end i loop
//-------------------------------------------------

		int i=m_nx+1;
		int nbx=LabX(i,j,k);

		if (pFluid[nbx-1]==10)	//vessel present (i.e. PVs at present)
		{
			bDiscretePericyte[nbx-1]=true;	//PC present
			PC_StillActive[nbx-1]=false;	//but inactive

			pPCXCoord[PC_Counter]=i;	//these refer to an array that is only 
			pPCYCoord[PC_Counter]=j;	//nPericytes in size (0,nPericytes-1)
			pPCZCoord[PC_Counter]=k;
			pPCOrientationID[PC_Counter]=1; //calculates orientation

			PC_Counter++;
		}
//----------------------------------------------
	   }
	}

//-----------------------------------------



//Now assign free PCs
	while (PC_Counter<nPericytes) 
	{ 
		 iCoord=1+int(m_nx*float(rand())/float(RAND_MAX)); //(1,nx)
		 jCoord=2+int((m_ny-3)*float(rand())/float(RAND_MAX)); //(2,ny-3)
		 kCoord=1+int(m_nz*float(rand())/float(RAND_MAX)); //(1,nz)
	

//		 randDice=1+int(2*float(rand())/float(RAND_MAX)); //(1,2) for i,j direction
		 randDice=1+int(3*float(rand())/float(RAND_MAX)); //(1,3) for i,j direction

		if (randDice==1) {PC_ID=LabX(iCoord,jCoord,kCoord);}	//x direction chosen
		if (randDice==2) {PC_ID=LabY(iCoord,jCoord,kCoord);}	//y direction chosen		
		if (randDice==3) {PC_ID=LabZ(iCoord,jCoord,kCoord);}	//z direction chosen

		if (bDiscretePericyte[PC_ID-1]==false) //not already assigned
		{
			bDiscretePericyte[PC_ID-1]=true;
			PC_StillActive[PC_ID-1]=true;

			pPCXCoord[PC_Counter]=iCoord;	//these refer to an array that is only 
			pPCYCoord[PC_Counter]=jCoord;	//nPericytes in size (0,nPericytes-1)
			pPCZCoord[PC_Counter]=kCoord;
			pPCOrientationID[PC_Counter]=randDice; //calculates orientation

			PC_Counter++;
		}

	}
//-----------------------------------------------

}

//***********************************************
//====================================================
void CAngioNetDlg::PutInAdditionalArterioles(void)
//====================================================
{

//Already have main PV present, so add nAdditionalCentralPVs AND bottom PV

	int i,j,k;
	int	nbx,nby;
	int icoord1;
	int icoord2;

	if	(!b_HexNetwork || (b_HexNetwork && b_StraightPVs))	//square network or hex network with straight PVs
	{
        for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{
			j=nCount*m_ny/(nAdditionalCentralPVs+1);//4;

			if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

			if	(nCount<nAdditionalCentralPVs) 
			{
/*				if	((j>=4 && j<=48) || (j>=148 && j<=192))
				{
					icoord1=2+(int)((double)(m_nx-2-2)*float(rand())/float(RAND_MAX));
					icoord2=icoord1+100+(int)((double)(m_nx-2-100)*float(rand())/float(RAND_MAX));
				}

				if	(j>48 && j<148)
				{
					icoord1=2+(int)((double)(48-2)*float(rand())/float(RAND_MAX));
					icoord2=149+(int)((double)(m_nx-149-2)*float(rand())/float(RAND_MAX));
				}
*/
				if	((j>=4 && j<=32) || (j>=132 && j<=160))
				{
					icoord1=2+(int)((double)(m_nx-2-2)*float(rand())/float(RAND_MAX));
					icoord2=icoord1+100+(int)((double)(m_nx-2-100)*float(rand())/float(RAND_MAX));
				}

				if	(j>32 && j<132)
				{
					icoord1=2+(int)((double)(32-2)*float(rand())/float(RAND_MAX));
					icoord2=132+(int)((double)(m_nx-132-2)*float(rand())/float(RAND_MAX));
				}
			}

			for (i=1;i<=m_nx+1;i++)
			{
//				if	(
//						i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
//						||
//						i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
//					)
//
//					{
						nbx=LabX(i,j,k);
						pFluid[nbx-1]=10;
						pPericyteDensity[nbx-1]=1.0;
						pArterialVenousID[nbx-1]=1;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;

						if	(nCount<nAdditionalCentralPVs && (i==icoord1 || i==icoord2))
						{
							nby=LabY(i,j+1,k);
							pFluid[nby-1]=10;
							pPericyteDensity[nby-1]=1.0;
							pArterialVenousID[nby-1]=1;
							YBR[i-1][j+1-1][k-1]=UU_PV_AdditionalRadius;

							nby=LabY(i,j+2,k);
							pFluid[nby-1]=10;
							pPericyteDensity[nby-1]=1.0;
							pArterialVenousID[nby-1]=1;
							YBR[i-1][j+2-1][k-1]=UU_PV_AdditionalRadius;

							nby=LabY(i,j+3,k);
							pFluid[nby-1]=10;
							pPericyteDensity[nby-1]=1.0;
							pArterialVenousID[nby-1]=1;
							YBR[i-1][j+3-1][k-1]=UU_PV_AdditionalRadius;

							nby=LabY(i,j+4,k);
							pFluid[nby-1]=10;
							pPericyteDensity[nby-1]=1.0;
							pArterialVenousID[nby-1]=1;
							YBR[i-1][j+4-1][k-1]=UU_PV_AdditionalRadius;
						}

//---Set initial Prune Age at tips of broken vessels (i.e. tips damaged & may be pruned)---
//---Initial age should correspond to time between wounding & beginning of simulation---
/*						if	(
								j>m_ny/2-iWoundRadius 
								&& 
								j<m_ny/2+iWoundRadius
								&&
								(
									(i>=iCentre-(int)sqrt(  pow(iDamagedRadius,2)-pow(j-jCentre,2) ) && i<iCentre)
									||
									(i<=iCentre+(int)sqrt(  pow(iDamagedRadius,2)-pow(j-jCentre,2) ) && i>iCentre)
								)
							)

							{
								Prune_AgeX[i-1][j-1][k-1]=1.3;	//~2.1 days
							}
*/
//					}	//end if not ablated

//-----------------------------------------------
			}	//end i loop
		}	//end nCount loop

//-----------------------------------------------
	}	//end if square network

	
	else if	(b_HexNetwork && !b_StraightPVs)	//hex network with wiggly PVs	
	{	
		for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{
			j=nCount*m_ny/(nAdditionalCentralPVs+1);//4;

			if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

//-----------------------------------------------

//---Here we need to distinguish between j being even or odd---
//---(i.e. inlet & outlet bonds only exist for odd j values)---

			if	(int(j/2)-double(j/2.0)==0)	//if j even
			{
				for (i=2;i<=m_nx-2;i+=3)	//put in some x-bonds on upper part of PV
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						pFluid[nbx-1]=10;
						pPericyteDensity[nbx-1]=1.0;
						pArterialVenousID[nbx-1]=1;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

				for (i=3;i<=m_nx-1;i+=3)	//put in rest of x-bonds on upper part of PV
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						pFluid[nbx-1]=10;
						pPericyteDensity[nbx-1]=1.0;
						pArterialVenousID[nbx-1]=1;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				j=j+1;	//increment j to put in lower x-bonds & connecting y-bonds

				for (i=1;i<=m_nx;i+=3)	//put in lower x-bonds (includes inlets)
					{
						if	(
								i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
								||
								i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							)

						{
							nbx=LabX(i,j,k);
							pFluid[nbx-1]=10;
							pPericyteDensity[nbx-1]=1.0;
							pArterialVenousID[nbx-1]=1;
							XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
						}
					}

				i=m_nx+1;	//put in outlets 
		
				if	(
						i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						||
						i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
					)

				{
					nbx=LabX(i,j,k);
					pFluid[nbx-1]=10;
					pPericyteDensity[nbx-1]=1.0;
					pArterialVenousID[nbx-1]=1;
					XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	//put in y-bonds (tilted to right)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nby=LabY(i,j,k);
						pFluid[nby-1]=10;
						pPericyteDensity[nby-1]=1.0;
						pArterialVenousID[nby-1]=1;
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

				for (i=3;i<=m_nx-1;i+=3)	//put in y-bonds (tilted to left)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nby=LabY(i,j,k);
						pFluid[nby-1]=10;
						pPericyteDensity[nby-1]=1.0;
						pArterialVenousID[nby-1]=1;
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
			}	//end if j even	

			else	//if j odd
			{
				for (i=1;i<=m_nx;i+=3)	//put in upper x-bonds (includes inlets)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						pFluid[nbx-1]=10;
						pPericyteDensity[nbx-1]=1.0;
						pArterialVenousID[nbx-1]=1;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

				i=m_nx+1;	//put in outlets
		
				if	(
						i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						||
						i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
					)

				{
					nbx=LabX(i,j,k);
					pFluid[nbx-1]=10;
					pPericyteDensity[nbx-1]=1.0;
					pArterialVenousID[nbx-1]=1;
					XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
				}

//-----------------------------------------------
				j=j+1;	//increment j to put in lower x-bonds & connecting y-bonds

				for (i=2;i<=m_nx-2;i+=3)	//put in some x-bonds on lower part of PV
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						pFluid[nbx-1]=10;
						pPericyteDensity[nbx-1]=1.0;
						pArterialVenousID[nbx-1]=1;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

				for (i=3;i<=m_nx-1;i+=3)	//put in rest of x-bonds on lower part of PV
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nbx=LabX(i,j,k);
						pFluid[nbx-1]=10;
						pPericyteDensity[nbx-1]=1.0;
						pArterialVenousID[nbx-1]=1;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	//put in y-bonds (tilted to left)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nby=LabY(i,j,k);
						pFluid[nby-1]=10;
						pPericyteDensity[nby-1]=1.0;
						pArterialVenousID[nby-1]=1;
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}

				for (i=3;i<=m_nx-1;i+=3)	//put in y-bonds (tilted to right)
				{
					if	(
							i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
							||
							i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
						)

					{
						nby=LabY(i,j,k);
						pFluid[nby-1]=10;
						pPericyteDensity[nby-1]=1.0;
						pArterialVenousID[nby-1]=1;
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
					}
				}
								
			}	//end if j odd
		}	//end nCount loop

//-----------------------------------------------
	}	//end if hexagonal network

//-----------------------------------------------

/*	j=2*m_ny/4;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
		if (
			i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			||
			i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			)
		{	
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
		}
	}
//-------------------------------------
	j=3*m_ny/4;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
		if (
			i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			||
			i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			)
		{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
		}
	}
*/

//-------------------------------------
	j=m_ny-1;

	if (m_nz==1) { k=1; } else { k=int(m_nz/2); }

	for (i=1;i<=m_nx+1;i++)
	{
		if (
			i<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			||
			i>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) )
			)
		{
			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=artRad;
		}
	}

//-----------------------------------------------
}

//***********************************************
//====================================================
void CAngioNetDlg::AssignInitialSprouts_UU_Wound(void)
//====================================================
{
//----------No sprouts initially---------------
	for (int nn=1;nn<=Nbond;nn++) { pSprout[nn-1]=0; }

//--------Now assign sprout tips----------------

	int zpos;
	if (m_nz==1) { zpos=1; } else {zpos=int(m_nz/2); }
	
//--------------------------------------------

//i coord positions----------------------------
/*
	int iSprout1=(int)floor(1.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout2=(int)floor(2.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout3=(int)floor(3.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout4=(int)floor(4.0*(m_nx+1)/6.0+0.5);	//NINT
	int iSprout5=(int)floor(5.0*(m_nx+1)/6.0+0.5);	//NINT
*/

//=======================================================

	TAF_Trigger=0.4*TAFConcMAX;//0.34;	// changed by Mike 10/08

	int first_sprout_pos=10;	//ideal position for first sprout (equal to delX for original set-up)
	int delX=10;//5;			//(changed by Mike 10/08) spacing of sprouts in no. of bonds

	if	(b_HexNetwork)	{
							delX=9;	//must be a multiple of 3
							first_sprout_pos=6;	//must be 3,4,6,7,9,10,12,...
						}

	int nSprout_per_PV=((m_nx-first_sprout_pos)/delX)+1;	//no. of potential sprouts per parent vessel

//	int SproutCountAlongPV=1;


//---Put in sprouts on upper PV------------------------------------------------
	int jcoord=2;

//------------------------------------------------
	for (int nSproutCount=1; nSproutCount<=nSprout_per_PV; nSproutCount++)
	{
//=======================================

		int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel


	if	(
			vTAFConc[icoord-1][jcoord-1][1-1] > TAF_Trigger &&
			(
				icoord<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
				||
				icoord>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) ) 
			)
		)

		{
			pFluid[LabY(icoord,jcoord,zpos)-1]=10;
			pSprout[LabY(icoord,jcoord,zpos)-1]=1;
			poleSprout[LabY(icoord,jcoord,zpos)-1]=true;
			pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
			pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;
		}
//=================================================
	}	//end for nSproutCount
//=================================================


/*	if (vTAFConc[iSprout2-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout3-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout4-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout5-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}
	*/
//===================================================================


//Now put in sprouts on all other nAdditionalCentralPVs

	for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{

//---------------------------------------------
			int jcoord=nCount*m_ny/(nAdditionalCentralPVs+1);//4;

//	jcoord=m_ny/4;

//------------------------------------------------
			for (int nSproutCount=1;nSproutCount<=nSprout_per_PV;nSproutCount++)
				{
					int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

					if	(
							vTAFConc[icoord-1][jcoord-1][1-1] > TAF_Trigger &&
							(
								icoord<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
								||
								icoord>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )  
							)
						)

						{
							pFluid[LabY(icoord,jcoord,zpos)-1]=10;
							pSprout[LabY(icoord,jcoord,zpos)-1]=1;
							poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
							pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
							pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;

//---Prevent sprouting in the periphery of the wound edge (i.e. surviving tips damaged)---

/*							if	(
									jcoord>m_ny/2-iWoundRadius 
									&& 
									jcoord<m_ny/2+iWoundRadius
									&&
									(
										(icoord>=iCentre-(int)sqrt(  pow(iDamagedRadius,2)-pow(jcoord-jCentre,2) ) && icoord<iCentre)
										||
										(icoord<=iCentre+(int)sqrt(  pow(iDamagedRadius,2)-pow(jcoord-jCentre,2) ) && icoord>iCentre)
									)
								)

								{
									pFluid[LabY(icoord,jcoord,zpos)-1]=0;
									pSprout[LabY(icoord,jcoord,zpos)-1]=0;
									poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
									pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=0.0;
									pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=0;
								}
*/

						}	//end if TAF Conc > Trigger

//---add missing sprouts (TNP-470 model)---

/*					if (jcoord==57 && icoord==80)	{
														pFluid[LabY(icoord,jcoord,zpos)-1]=10;
														pSprout[LabY(icoord,jcoord,zpos)-1]=1;
														poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
														pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
														pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;
													}
*/

//---add missing sprouts (wound model)---

					if (jcoord==71 && icoord==70)	{
														pFluid[LabY(icoord,jcoord,zpos)-1]=10;
														pSprout[LabY(icoord,jcoord,zpos)-1]=1;
														poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
														pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
														pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;
													}


				}	//end nSprout loop

/*
	if (vTAFConc[iSprout2-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout3-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout4-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout5-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}

*/

//===============================================
			jcoord=jcoord+1;

			if	(b_HexNetwork && !b_StraightPVs)	{jcoord=jcoord+1;}	//in hex network with wiggly PVs sprouts
																	//placed on j,j+2 bonds (rather than j,j+1)

//===============================================

			for (int nSproutCount=1;nSproutCount<=nSprout_per_PV;nSproutCount++)
				{
					int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

					if	(
							vTAFConc[icoord-1][jcoord-1][1-1] > TAF_Trigger &&
							(
								icoord<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
								||
								icoord>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
							)
						)

						{
							pFluid[LabY(icoord,jcoord,zpos)-1]=10;
							pSprout[LabY(icoord,jcoord,zpos)-1]=1;
							poleSprout[LabY(icoord,jcoord,zpos)-1]=true;
							pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
							pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;

//---Prevent sprouting in the periphery of the wound edge (i.e. surviving tips damaged)---

/*							if	(
									jcoord>m_ny/2-iWoundRadius 
									&& 
									jcoord<m_ny/2+iWoundRadius
									&&
									(
										(icoord>=iCentre-(int)sqrt(  pow(iDamagedRadius,2)-pow(jcoord-jCentre,2) ) && icoord<iCentre)
										||
										(icoord<=iCentre+(int)sqrt(  pow(iDamagedRadius,2)-pow(jcoord-jCentre,2) ) && icoord>iCentre)
									)
								)

								{
									pFluid[LabY(icoord,jcoord,zpos)-1]=0;
									pSprout[LabY(icoord,jcoord,zpos)-1]=0;
									poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
									pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=0.0;
									pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=0;
								}
*/

						}	//end if TAF > Trigger

//---remove sprouts not attached to PVs (TNP-470 model)---

/*					if	(
							(jcoord==81 && icoord==40) 
							|| 
							(jcoord==58 && icoord==20)
						)	
						
						{
							pFluid[LabY(icoord,jcoord,zpos)-1]=0;
							pSprout[LabY(icoord,jcoord,zpos)-1]=0;
							poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
							pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=0.0;
							pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=0;
						}
*/

//---add missing sprouts (TNP-470 model)---

/*					if	(
							(jcoord==43 && icoord==20) 
							|| 
							(jcoord==20 && (icoord==40 || icoord==60)) 
							|| 
							(jcoord==43 && icoord==80) 
							|| 
							(jcoord==62 && icoord==80)
						)
						
						{
							pFluid[LabY(icoord,jcoord,zpos)-1]=10;
							pSprout[LabY(icoord,jcoord,zpos)-1]=1;
							poleSprout[LabY(icoord,jcoord,zpos)-1]=true;
							pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
							pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;
						}
*/

//---remove sprouts not attached to PVs (wound model)---

					if (jcoord==72 && icoord==30)	{
														pFluid[LabY(icoord,jcoord,zpos)-1]=0;
														pSprout[LabY(icoord,jcoord,zpos)-1]=0;
														poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
														pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=0.0;
														pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=0;
													}


//---add missing sprouts (wound model)---

					if (jcoord==29 && (icoord==30 || icoord==70))	{
																		pFluid[LabY(icoord,jcoord,zpos)-1]=10;
																		pSprout[LabY(icoord,jcoord,zpos)-1]=1;
																		poleSprout[LabY(icoord,jcoord,zpos)-1]=true;
																		pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
																		pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;
																	}

				}	//end nSprout loop


/*	if (vTAFConc[iSprout2-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout3-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout4-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout5-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}

//-------------------------------------------------
*/

		}	//end nCount loop

//===================================================================
/*	jcoord=2*m_ny/4;

	if (
		iSprout1<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout1>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout1,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout1,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout1,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout1,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout1,jcoord,zpos)-1]=1;
	}


	if (
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}
//===================================================================
	jcoord=2*m_ny/4+1;

	if (
		iSprout1<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout1>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout1,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout1,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout1,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout1,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout1,jcoord,zpos)-1]=1;
	}


	if (
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}
//===================================================================
	jcoord=3*m_ny/4;

	if (
		iSprout1<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout1>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout1,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout1,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout1,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout1,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout1,jcoord,zpos)-1]=1;
	}


	if (
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}
//===================================================================
	jcoord=3*m_ny/4+1;

	if (
		iSprout1<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout1>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout1,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout1,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout1,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout1,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout1,jcoord,zpos)-1]=1;
	}


	if (
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=true;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}

*/
//===============================================

//----Finally put in a LOWER set of sprouts

	jcoord=m_ny-1;

	for	(int nSproutCount=1;nSproutCount<=nSprout_per_PV;nSproutCount++)
		{
			int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

			if	(
					vTAFConc[icoord-1][jcoord-1][1-1] > TAF_Trigger &&
					(
						icoord<iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
						||
						icoord>iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
					)
				)

				{
					pFluid[LabY(icoord,jcoord,zpos)-1]=10;
					pSprout[LabY(icoord,jcoord,zpos)-1]=1;
					poleSprout[LabY(icoord,jcoord,zpos)-1]=false;
					pPericyteDensity[LabY(icoord,jcoord,zpos)-1]=PericyteDensityInit;
					pArterialVenousID[LabY(icoord,jcoord,zpos)-1]=1;
				}

		}	//end nSprout loop

/*
	if (vTAFConc[iSprout2-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout2<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout2>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout2,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout2,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout2,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout2,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout2,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout3-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout3<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout3>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout3,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout3,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout3,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout3,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout3,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout4-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout4<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout4>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout4,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout4,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout4,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout4,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout4,jcoord,zpos)-1]=1;
	}


	if (vTAFConc[iSprout5-1][jcoord-1][1-1] > TAF_Trigger &&
		(
		iSprout5<=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		||
		iSprout5>=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(jcoord-jCentre,2) )
		)

		)

	{
	pFluid[LabY(iSprout5,jcoord,zpos)-1]=10;
	pSprout[LabY(iSprout5,jcoord,zpos)-1]=1;
	poleSprout[LabY(iSprout5,jcoord,zpos)-1]=false;
	pPericyteDensity[LabY(iSprout5,jcoord,zpos)-1]=PericyteDensityInit;
	pArterialVenousID[LabY(iSprout5,jcoord,zpos)-1]=1;
	}
*/

//===================================================================

}

//***********************************************
//==========================================
void CAngioNetDlg::SaveDiscretePCs(void)
//==========================================
{
	for (int nCell=1;nCell<=nPericytes;nCell++)	
	{
		outfileSaveDiscretePCs  << 	pPCXCoord[nCell-1] << "\t";
		outfileSaveDiscretePCs  << 	pPCYCoord[nCell-1] << "\t";
		outfileSaveDiscretePCs  << 	pPCZCoord[nCell-1] << "\t";
		outfileSaveDiscretePCs  << 	pPCOrientationID[nCell-1] << endl;
	}

	for (int nn=1;nn<=Nbond;nn++)	
	{
		outfileSaveDiscretePCs  << PC_StillActive[nn-1] << "\t";
		outfileSaveDiscretePCs  << pArterialVenousID[nn-1] <<  "\t";
	}

	outfileSaveDiscretePCs  << endl;
//-----------------------------------------------------

}
//**************************************************************************


//**************************************************************************
void CAngioNetDlg::ReadInDiscretePCs(void)
{
	for (int nCell=1;nCell<=nPericytes;nCell++)	
	{
		infileDiscretePCs  >> 	pPCXCoord[nCell-1];
		infileDiscretePCs  >> 	pPCYCoord[nCell-1];
		infileDiscretePCs  >> 	pPCZCoord[nCell-1];
		infileDiscretePCs  >> 	pPCOrientationID[nCell-1];
	}

	for (int nn=1;nn<=Nbond;nn++)	
	{
		infileDiscretePCs  >> 	PC_StillActive[nn-1];
		infileDiscretePCs  >> 	pArterialVenousID[nn-1];
	}

//-----------------------------------------------------
	
}
//**************************************************************************
void CAngioNetDlg::SaveNutrient(void)
{

	outfileSaveNutrient << angiotime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				outfileSaveNutrient << i << "\t"; 
				outfileSaveNutrient << j << "\t"; 
				outfileSaveNutrient << k << "\t";


				//Avoid data corruption by setting ~e-308 values 
				//(i.e. underflow) to zero

				if (pTissueNutrientConc[i-1][j-1][k-1]<0.0000001)
				{
					outfileSaveNutrient << 0.0 << endl;
				}
				else
				{
					outfileSaveNutrient << pTissueNutrientConc[i-1][j-1][k-1] << endl;
				}
				
				
			}
		}
	}

		outfileSaveNutrient << endl;
//			  outfileSaveNutrient << endl;
//---------------------------------------------------

	outfileSaveVascNut << angiotime << endl;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				outfileSaveVascNut << i << "\t"; 
				outfileSaveVascNut << j << "\t"; 
				outfileSaveVascNut << k << "\t";

				if (pVesselNutrientConc[nbx-1]>1.0e-100)	{outfileSaveVascNut << pVesselNutrientConc[nbx-1] << "\t";}
				else	{outfileSaveVascNut << 0.0 << "\t";}
				if (pVesselNutrientConc[nby-1]>1.0e-100)	{outfileSaveVascNut << pVesselNutrientConc[nby-1] << "\t";}
				else	{outfileSaveVascNut << 0.0 << "\t";}
				if (pVesselNutrientConc[nbz-1]>1.0e-100)	{outfileSaveVascNut << pVesselNutrientConc[nbz-1] << endl;}
				else	{outfileSaveVascNut << 0.0 << endl;}
			}

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pVesselNutrientConc[nbx-1]>1.0e-100)	{outfileSaveVascNut << pVesselNutrientConc[nbx-1] << endl;}
			else	{outfileSaveVascNut << 0.0 << endl;}
	}}

	outfileSaveVascNut << endl;
}
//**************************************************************************

//**************************************************************************
void CAngioNetDlg::ReadInNutrient(void)
{
NutrientOutFile<<"got here"<<endl;
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				pTissueNutrientConc[i-1][j-1][k-1] = 0.0;
			}
		}
	}



	infileNut >> angiotime;
//	NutrientOutFile << angiotime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				infileNut >> i;
//				NutrientOutFile << i << "\t";
				infileNut >> j;
//				NutrientOutFile << j << "\t";
				infileNut >> k;
//				NutrientOutFile << k << "\t";
				infileNut >> pTissueNutrientConc[i-1][j-1][k-1];
//				NutrientOutFile << pTissueNutrientConc[i-1][j-1][k-1] << endl;
				//pTissueNutrientConc[i][j][k]=0.25;
			}
		}
	}
//				NutrientOutFile << endl;
//---------------------------------------------------
}
//**************************************************************************

//=============================================
void CAngioNetDlg::WoundVesselCount(void)
//=============================================
//Mike 11/08 - calculates vessel densities in regions around 0, 250, 500, and 750
//microns from the wound centre, and also various results for the wound as a whole 

{

int i,j,k,nbx,nby;
int n,p,q;
int a,b,c,d;

double WoundVessels;				//no. of vessels within wound
double WoundArea;					//area of wound (square microns)
double WoundVesselLength;			//total length of vessels in wound (microns)
double WoundVesselDensity;			//vessel density in wound (microns/1,000,000 square microns)
double WoundCSVesselArea;			//total cross-sectional area of vessels in wound (square microns)
double WoundCSVesselAreaDensity;	//cross-sectional vessel area/wound area
double WoundVesselVolume;			//total volume of vessels in wound (cubic microns)

int* CircVessels;				//no. of vessels within each circle
int* RegVessels;				//no. of vessels within each corresponding region
double* CircTotalVesselLength;	//total length of vessels in each circle (microns)
double* RegTotalVesselLength;	//total length of vessels in each corresponding region (microns) 
double* RegVesselDensity;		//vessel density in each region (microns/1,000,000 square microns)

double* CircRadius;				//fraction of wound radius used to define each circle
double* CircArea;				//area of each circle (square microns)
double* RegArea;				//corresponding area of each region (square microns)

double* CircCSVesselArea;		//total cross-sectional area of vessels in each circle (square microns)
double* RegCSVesselArea;		//total cross-sectional area of vessels in each corresponding region (square microns)
double* RegCSVesselAreaDensity;	//cross-sectional vessel area/region area
double* CircVesselVolume;		//total volume of vessels in each circle (cubic microns)
double* RegVesselVolume;		//total volume of vessels in each corresponding region (cubic microns)

CircVessels=RegVessels=NULL;
RegArea=CircArea=CircTotalVesselLength=RegTotalVesselLength=RegVesselDensity=CircRadius=RegCSVesselArea=
CircCSVesselArea=RegCSVesselAreaDensity=CircVesselVolume=RegVesselVolume=NULL;

CircVessels=new int[9];					//first component in each array is always zero 
										//allowing the use of a general formula (see below)
RegVessels=new int[5];

RegVesselDensity=new double[5];

CircRadius=new double[9];
CircArea=new double[9];
CircCSVesselArea=new double[9];
CircVesselVolume=new double[9];
CircTotalVesselLength=new double[9];

RegArea=new double[5];
RegCSVesselArea=new double[5];
RegCSVesselAreaDensity=new double[5];
RegVesselVolume=new double[5];
RegTotalVesselLength=new double[5];


for (a=0;a<=4;a++) 
	{RegArea[a]=RegTotalVesselLength[a]=RegVesselDensity[a]=RegCSVesselArea[a]=
	 RegCSVesselAreaDensity[a]=RegVesselVolume[a]=RegTotalVesselLength[a]=0;}

for (b=0;b<=4;b++) 
	{RegVessels[b]=0;}

for (c=0;c<=8;c++)
	{CircVessels[c]=0;}

for (d=0;d<=8;d++)
	{CircArea[d]=CircRadius[d]=CircCSVesselArea[d]=
	 CircVesselVolume[d]=CircTotalVesselLength[d]=0;}


CircRadius[1]=(double)2/15;	//fraction of wound radius which corresponds to circle 
							//of radius 80 microns (ie region used for at 0)

CircRadius[8]=1.0;	//used for all whole wound results

for (p=1;p<=3;p++)									//fraction of wound radius required to 
	{												//define circles with radius 80 microns 
	CircRadius[2*p]=CircRadius[2*p-1]+(double)3/20;	//below and above 250, 500, 750 microns 
	CircRadius[2*p+1]=CircRadius[2*p]+(double)4/15;	//(ie regions between each pair of circles 
	}												//used for results at 250, 500, 750)


for (n=1;n<=8;n++)
	{
	for (k=1;k<=m_nz;k++)
		{	
		for (j=1;j<=m_ny;j++)
			{	
			for (i=1;i<=m_nx;i++)
				{		
//--------------------------------------------------

CircArea[n]=PI*double (pow(double(i_UU_WoundRad*bondLength*1.0e6*CircRadius[n]),2));


				if (
						i>iCentre-(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )
					)

					{
						nbx=LabX(i,j,k);  
						nby=LabY(i,j,k);  
		
						if (pFluid[nbx-1]==10) {
												CircVessels[n]+=1;
												CircTotalVesselLength[n]+=(double)(XBL[i-1][j-1][k-1]*1.0e6);
												CircCSVesselArea[n]+=(double)(1.0e6*XBL[i-1][j-1][k-1]*2.0*1.0e6*XBR[i-1][j-1][k-1]);
												CircVesselVolume[n]+=(double)(PI*1.0e6*XBL[i-1][j-1][k-1]*(double)(pow(1.0e6*XBR[i-1][j-1][k-1],2)));
												}
												
																						                                                  
						if (pFluid[nby-1]==10) {
												CircVessels[n]+=1;
												CircTotalVesselLength[n]+=(double)(YBL[i-1][j-1][k-1]*1.0e6);
												CircCSVesselArea[n]+=double(1.0e6*YBL[i-1][j-1][k-1]*2.0*1.0e6*YBR[i-1][j-1][k-1]);
												CircVesselVolume[n]+=(double)(PI*1.0e6*YBL[i-1][j-1][k-1]*(double)(pow(1.0e6*YBR[i-1][j-1][k-1],2)));
												}
							
					}
//--------------------------------------------------

				}
			}
		}
	
	for (q=1;q<=4;q++)
		{

		RegVessels[q]=CircVessels[2*q-1]-CircVessels[2*q-2];								//results in each region calculated by subtracting 
																							//results in the larger circle from results in
		RegArea[q]=CircArea[2*q-1]-CircArea[2*q-2];											//smaller circle (note use of first element of arrays 
																							//to calculate results at 0 since in this case there  
		RegTotalVesselLength[q]=CircTotalVesselLength[2*q-1]-CircTotalVesselLength[2*q-2];	//is no smaller circle)

		RegVesselDensity[q]=RegTotalVesselLength[q]/RegArea[q]*1.0e6;

		RegCSVesselArea[q]=CircCSVesselArea[2*q-1]-CircCSVesselArea[2*q-2];	

		RegCSVesselAreaDensity[q]=RegCSVesselArea[q]/RegArea[q];

		RegVesselVolume[q]=CircVesselVolume[2*q-1]-CircVesselVolume[2*q-2];

		}

WoundVessels=CircVessels[8];										//results for wound as a whole calculated separately 
WoundArea=CircArea[8];												//since loop equations not satisfied in this case
WoundVesselLength=CircTotalVesselLength[8];
WoundVesselDensity=WoundVesselLength/CircArea[8]*1.0e6;
WoundCSVesselArea=CircCSVesselArea[8];
WoundCSVesselAreaDensity=WoundCSVesselArea/CircArea[8];
WoundVesselVolume=CircVesselVolume[8];

	}

	
outfileVesselDensity << angiotime << "\t" << RegVesselDensity[1] << "\t" <<
RegVesselDensity[2] << "\t" << RegVesselDensity[3] << "\t" << RegVesselDensity[4] << endl;

outfileVesselArea << angiotime << "\t" << RegCSVesselArea[1] << "\t" << RegCSVesselArea[2] << "\t" << 
RegCSVesselArea[3] << "\t" << RegCSVesselArea[4] << endl;

outfileVesselAreaDensity << angiotime << "\t" << RegCSVesselAreaDensity[1] << "\t" << 
RegCSVesselAreaDensity[2] << "\t" << RegCSVesselAreaDensity[3] << "\t" << RegCSVesselAreaDensity[4] << endl;

outfileVesselVolume << angiotime << "\t" << RegVesselVolume[1] << "\t" << RegVesselVolume[2] << "\t" << 
RegVesselVolume[3] << "\t" << RegVesselVolume[4] << endl;

outfileWoundResults << angiotime << "\t" << WoundVessels << "\t" << WoundArea << "\t" << 
WoundVesselLength << "\t" << WoundVesselDensity << "\t" << WoundCSVesselArea << "\t" <<
WoundCSVesselAreaDensity << "\t" << WoundVesselVolume << "\t";


delete [] CircVessels;			//delete arrays to prevent memory leak
delete [] RegVessels;			
delete [] CircTotalVesselLength;
delete [] RegTotalVesselLength;
delete [] RegVesselDensity;
delete [] CircRadius;
delete [] RegArea;
delete [] CircArea;
delete [] RegCSVesselArea;
delete [] CircCSVesselArea;
delete [] RegCSVesselAreaDensity;
delete [] CircVesselVolume;
delete [] RegVesselVolume;

/*
int i,j,k,n,nbx,nby;
int p,q;
int NumWoundRegions;
int* CircVessels;
int* RegVessels;

double WoundArea;
double RegionArea;
double* TotalVesselLength;
double* VesselDensity;

NumWoundRegions=3;	//defines no. of regions into which wound will be split

WoundArea=PI*double (pow(double(iWoundRadius*20),2));	//defines area of wound (square microns)

RegionArea=double(WoundArea/NumWoundRegions);	//defines area of each region (square microns)
																
CircVessels=NULL;
RegVessels=NULL;
TotalVesselLength=NULL;
VesselDensity=NULL;

CircVessels=new int[NumWoundRegions+3];	//array containing no. of vessels counted in each concentric circle

RegVessels=new int[NumWoundRegions+3];	//array containing no. of vessels in each corresponding region

TotalVesselLength=new double[NumWoundRegions+3];	//array containing combined length of 
													//all vessels in each region (microns)

VesselDensity=new double[NumWoundRegions+3];	//array containing density of vessels in each 
												//region (microns per 1,000,000 square microns)

for (p=0;p<=NumWoundRegions+2;p++) 
	{CircVessels[p]=RegVessels[p]=0;}

for (q=0;q<=NumWoundRegions+2;q++)
	{TotalVesselLength[q]=VesselDensity[q]=0;}

for (k=1;k<=m_nz;k++)
	{	
	for (j=1;j<=m_ny;j++)
		{	
		for (i=1;i<=m_nx;i++)
			{		
			for (n=1;n<=NumWoundRegions+2;n++)
				{
//--------------------------------------------------
				if (
						i>iCentre-(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )
					)

					{
						nbx=LabX(i,j,k);  
						nby=LabY(i,j,k);  
		
						if (pFluid[nbx-1]==10) {CircVessels[n]+=1;}
										                                                  
						if (pFluid[nby-1]==10) {CircVessels[n]+=1;}
							
					}
//--------------------------------------------------

				RegVessels[n]=CircVessels[n]-CircVessels[n-1];

				TotalVesselLength[n]=20*RegVessels[n];

				VesselDensity[n]=TotalVesselLength[n]/RegionArea*1000000;

				}

//--------------------------------------------------
			}
		}
	}

outfileVesselDensity << angiotime << "\t" << VesselDensity[1] << "\t" << VesselDensity[2]
<< "\t" << VesselDensity[3] << "\t" << VesselDensity[4] << "\t" << VesselDensity[5] << endl;

delete [] CircVessels;			//delete arrays to prevent memory leak
delete [] RegVessels;			
delete [] TotalVesselLength;	
delete [] VesselDensity;
*/
}
//**************************************************	

//============================================
void CAngioNetDlg::WoundConnectivity(void)
//============================================
//Mike 10/08 - calculates connectivity at each node in  
//regions around 0, 250, 500, and 750 microns from the wound centre

{
int i,j,k;
int n,p,q;
int a,b,c;

int NumNeigh;		//no. of connected "neighbours" at each node
int WoundCon0=0;		//no. of nodes in wound with 0 neighbours
int WoundCon1=0;		//no. of nodes in wound with 1 neighbours
int WoundCon2=0;		//no. of nodes in wound with 2 neighbours
int WoundCon3=0;		//no. of nodes in wound with 3 neighbours
int WoundCon4=0;		//no. of nodes in wound with 4 neighbours

int* CircCon0;		//arrays containing no. of nodes with   	
int* CircCon1;		//0,1,2,3 or 4 neighbours
int* CircCon2;		//in each concentric circle
int* CircCon3;	
int* CircCon4;

int* RegCon0;		//arrays containing no. of nodes with
int* RegCon1;		//0,1,2,3 or 4 neighbours
int* RegCon2;		//in each corresponding region
int* RegCon3;	
int* RegCon4;

double* CircRadius;	//fraction of wound radius used to define each circle

CircCon0=CircCon1=CircCon2=CircCon3=CircCon4
=RegCon0=RegCon1=RegCon2=RegCon3=RegCon4=NULL;

CircRadius=NULL;

CircCon0=new int[9];	//see WoundVesselCount
CircCon1=new int[9];	//for explanation
CircCon2=new int[9];
CircCon3=new int[9];
CircCon4=new int[9];

RegCon0=new int[5];
RegCon1=new int[5];
RegCon2=new int[5];
RegCon3=new int[5];
RegCon4=new int[5];

CircRadius=new double[9];

for (a=0;a<=7;a++)			
	{CircCon0[a]=CircCon1[a]=CircCon2[a]=CircCon3[a]=CircCon4[a]=0;}

for (b=0;b<=4;b++)
	{RegCon0[b]=RegCon1[b]=RegCon2[b]=RegCon3[b]=RegCon4[b]=0;}

for (c=0;c<=8;c++)
	{CircRadius[c]=0;}


CircRadius[1]=(double)2/15;
CircRadius[8]=1.0;									//see WoundVesselCount
													//for explanation
for (p=1;p<=3;p++)									//
	{												//
	CircRadius[2*p]=CircRadius[2*p-1]+(double)3/20;	//
	CircRadius[2*p+1]=CircRadius[2*p]+(double)4/15;	//
	}												//

for (n=1;n<=8;n++)
	{
	for (k=1;k<=m_nz;k++)
		{	
		for (j=1;j<=m_ny;j++)
			{	
			for (i=1;i<=m_nx;i++)
				{					
//--------------------------------------------------
				if (
						i>iCentre-(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )
					
					)
						{
							NumNeigh=0;

//--------------------------------------------------
							if (pFluid[LabX(i,j,k)-1]==10)   { NumNeigh+=1; }
							if (pFluid[LabY(i,j,k)-1]==10)   { NumNeigh+=1; }
							if (pFluid[LabX(i+1,j,k)-1]==10) { NumNeigh+=1; }
							if (pFluid[LabY(i,j+1,k)-1]==10) { NumNeigh+=1; }		

//--------------------------------------------------									
							if (NumNeigh==0) { CircCon0[n]+=1; }
							if (NumNeigh==1) { CircCon1[n]+=1; }
							if (NumNeigh==2) { CircCon2[n]+=1; }
							if (NumNeigh==3) { CircCon3[n]+=1; }
							if (NumNeigh==4) { CircCon4[n]+=1; }

//--------------------------------------------------
						}

				else	{NumNeigh=10;}	//value 10 is insignificant, merely diverts 
										//attention away from nodes outwith wound
				}
			}
		}
	}

	for (q=1;q<=4;q++)
		{
			RegCon0[q]=CircCon0[2*q-1]-CircCon0[2*q-2];	//see WoundVesselCount 
			RegCon1[q]=CircCon1[2*q-1]-CircCon1[2*q-2];	//for explanation
			RegCon2[q]=CircCon2[2*q-1]-CircCon2[2*q-2];	//
			RegCon3[q]=CircCon3[2*q-1]-CircCon3[2*q-2];	//
			RegCon4[q]=CircCon4[2*q-1]-CircCon4[2*q-2];	//
		}
//--------------------------------------------------

	WoundCon0=CircCon0[8];
	WoundCon1=CircCon1[8];
	WoundCon2=CircCon2[8];
	WoundCon3=CircCon3[8];
	WoundCon4=CircCon4[8];
//--------------------------------------------------

outfileWoundConnect0 << angiotime << "\t" << RegCon0[1] << "\t" << RegCon0[2] << "\t" 
<< RegCon0[3] << "\t" << RegCon0[4] << "\t" << WoundCon0 << endl;

outfileWoundConnect1 << angiotime << "\t" << RegCon1[1] << "\t" << RegCon1[2] << "\t" 
<< RegCon1[3] << "\t" << RegCon1[4] << "\t" << WoundCon1 << endl;

outfileWoundConnect2 << angiotime << "\t" << RegCon2[1] << "\t" << RegCon2[2] << "\t" 
<< RegCon2[3] << "\t" << RegCon2[4] << "\t" << WoundCon2 << endl;

outfileWoundConnect3 << angiotime << "\t" << RegCon3[1] << "\t" << RegCon3[2] << "\t" 
<< RegCon3[3] << "\t" << RegCon3[4] << "\t" << WoundCon3 << endl;

outfileWoundConnect4 << angiotime << "\t" << RegCon4[1] << "\t" << RegCon4[2] << "\t" 
<< RegCon4[3] << "\t" << RegCon4[4] << "\t" << WoundCon4 << endl;

delete [] CircCon0;		//delete arrays to prevent memory leak
delete [] CircCon1;
delete [] CircCon2;
delete [] CircCon3;
delete [] CircCon4;
delete [] RegCon0;
delete [] RegCon1;
delete [] RegCon2;
delete [] RegCon3;
delete [] RegCon4;
delete [] CircRadius;

/*
int i,j,k,n,p;

int NumNeigh;			//no. of connected "neighbours" at each node

int NumWoundRegions;	//no. of regions into which wound will be split		

int* CircCon0;	//arrays containing no. of nodes with   	
int* CircCon1;	//0,1,2,3 or 4 neighbours
int* CircCon2;	//in each concentric circle
int* CircCon3;	
int* CircCon4;

int* RegCon0;	//arrays containing no. of nodes with
int* RegCon1;	//0,1,2,3 or 4 neighbours
int* RegCon2;	//in each corresponding region
int* RegCon3;	
int* RegCon4;

NumWoundRegions=3;

CircCon0=CircCon1=CircCon2=CircCon3=CircCon4
=RegCon0=RegCon1=RegCon2=RegCon3=RegCon4=NULL;

CircCon0=new int[NumWoundRegions+3];
CircCon1=new int[NumWoundRegions+3];
CircCon2=new int[NumWoundRegions+3];
CircCon3=new int[NumWoundRegions+3];
CircCon4=new int[NumWoundRegions+3];

RegCon0=new int[NumWoundRegions+3];
RegCon1=new int[NumWoundRegions+3];
RegCon2=new int[NumWoundRegions+3];
RegCon3=new int[NumWoundRegions+3];
RegCon4=new int[NumWoundRegions+3];

for (p=0;p<=NumWoundRegions+2;p++)			
	{CircCon0[p]=CircCon1[p]=CircCon2[p]
	=CircCon3[p]=CircCon4[p]=RegCon0[p]=RegCon1[p]=RegCon2[p]
	=RegCon3[p]=RegCon4[p]=0;}

for (k=1;k<=m_nz;k++)
	{	
	for (j=1;j<=m_ny;j++)
		{	
		for (i=1;i<=m_nx;i++)
			{		
			for (n=1;n<=NumWoundRegions+2;n++)
				{
//--------------------------------------------------
				if (
						i>iCentre-(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )
					
					)
						{
							NumNeigh=0;

//--------------------------------------------------
							if (pFluid[LabX(i,j,k)-1]==10)   { NumNeigh+=1; }
							if (pFluid[LabY(i,j,k)-1]==10)   { NumNeigh+=1; }
							if (pFluid[LabX(i+1,j,k)-1]==10) { NumNeigh+=1; }
							if (pFluid[LabY(i,j+1,k)-1]==10) { NumNeigh+=1; }		

//--------------------------------------------------									
							if (NumNeigh==0) { CircCon0[n]+=1; }
							if (NumNeigh==1) { CircCon1[n]+=1; }
							if (NumNeigh==2) { CircCon2[n]+=1; }
							if (NumNeigh==3) { CircCon3[n]+=1; }
							if (NumNeigh==4) { CircCon4[n]+=1; }

							RegCon0[n]=CircCon0[n]-CircCon0[n-1];
							RegCon1[n]=CircCon1[n]-CircCon1[n-1];
							RegCon2[n]=CircCon2[n]-CircCon2[n-1];
							RegCon3[n]=CircCon3[n]-CircCon3[n-1];
							RegCon4[n]=CircCon4[n]-CircCon4[n-1];
						
//--------------------------------------------------
						}

				else	{NumNeigh=10;}	//value 10 is insignificant, merely diverts 
										//attention away from nodes outwith wound

				}

//--------------------------------------------------
			}
		}
	}

outfileWoundConnect0 << angiotime << "\t" << RegCon0[1] << "\t" << RegCon0[2] << "\t" 
<< RegCon0[3] << "\t" << RegCon0[4] << "\t" << RegCon0[5] << endl;

outfileWoundConnect1 << angiotime << "\t" << RegCon1[1] << "\t" << RegCon1[2] << "\t" 
<< RegCon1[3] << "\t" << RegCon1[4] << "\t" << RegCon1[5] << endl;

outfileWoundConnect2 << angiotime << "\t" << RegCon2[1] << "\t" << RegCon2[2] << "\t" 
<< RegCon2[3] << "\t" << RegCon2[4] << "\t" << RegCon2[5] << endl;

outfileWoundConnect3 << angiotime << "\t" << RegCon3[1] << "\t" << RegCon3[2] << "\t" 
<< RegCon3[3] << "\t" << RegCon3[4] << "\t" << RegCon3[5] << endl;

outfileWoundConnect4 << angiotime << "\t" << RegCon4[1] << "\t" << RegCon4[2] << "\t" 
<< RegCon4[3] << "\t" << RegCon4[4] << "\t" << RegCon4[5] << endl;

delete [] CircCon0;
delete [] CircCon1;
delete [] CircCon2;
delete [] CircCon3;
delete [] CircCon4;
delete [] RegCon0;
delete [] RegCon1;
delete [] RegCon2;
delete [] RegCon3;
delete [] RegCon4;
*/
}
//**************************************************	

//============================================
void CAngioNetDlg::WoundVesselRadius(void)
//============================================
//Mike 09/08 - counts total no. of vessels in each region
//and sums radii of all these vessels to allow calculation 
//of average vessel diameter in each region

{
int i,j,k,nbx,nby;
int n,p,q;
int a,b,c,d;

double WoundVessels;			//no. of vessels within wound
double WoundAvgVesselDiameter;	//average vessel diameter in wound (microns)
double SumRadiiWound;			//sum of radii of all vessels in wound (microns)

int* CircVessels;			//no. of vessels within each circle
int* RegVessels;			//no. of vessels within each corresponding region

double* SumCircRadii;		//sum of radii of all vessels in each circle (microns)
double* SumRegRadii;		//sum of radii of all vessels in each corresponding region (microns)

double* AvgVesselDiameter;	//average vessel diameter in each region (microns)

double* CircRadius;			//fraction of wound radius used to define each circle

SumCircRadii=NULL;
SumRegRadii=NULL;
CircVessels=NULL;
RegVessels=NULL;
AvgVesselDiameter=NULL;
CircRadius=NULL;

CircVessels=new int[9];				//see WoundVesselCount
									//for explanation
RegVessels=new int[5];

SumCircRadii=new double[9];

SumRegRadii=new double[5];

AvgVesselDiameter=new double[5];	

CircRadius=new double[9];

for (a=0;a<=8;a++)	
	{CircVessels[a]=0;}				

for (b=0;b<=4;b++) 
	{RegVessels[b]=0;}

for (c=0;c<=8;c++) 
	{SumCircRadii[c]=CircRadius[c]=0;}

for (d=0;d<=4;d++) 
	{SumRegRadii[d]=AvgVesselDiameter[d]=0;}


CircRadius[1]=(double)2/15;
CircRadius[8]=1.0;									//see WoundVesselCount
													//for explanation
for (p=1;p<=3;p++)									//
	{												//
	CircRadius[2*p]=CircRadius[2*p-1]+(double)3/20;	//
	CircRadius[2*p+1]=CircRadius[2*p]+(double)4/15;	//
	}												//

for (n=1;n<=8;n++)
	{
	for (k=1;k<=m_nz;k++)
		{	
		for (j=1;j<=m_ny;j++)
			{	
			for (i=1;i<=m_nx;i++)
				{					
//--------------------------------------------------
				if (
						i>iCentre-(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )
					
					)
						{
							nbx=LabX(i,j,k);  
							nby=LabY(i,j,k);  
		
							if (pFluid[nbx-1]==10) {CircVessels[n]+=1; SumCircRadii[n]+=(double)(1.0e6*XBR[i-1][j-1][k-1]);}
										                                                  
							if (pFluid[nby-1]==10) {CircVessels[n]+=1; SumCircRadii[n]+=(double)(1.0e6*YBR[i-1][j-1][k-1]);}

						}

//--------------------------------------------------
					for (q=1;q<=4;q++)
						{					

						RegVessels[q]=CircVessels[2*q-1]-CircVessels[2*q-2];	//see WoundVesselCount
						SumRegRadii[q]=SumCircRadii[2*q-1]-SumCircRadii[2*q-2];	//for explanation

						if	(RegVessels[q]==0)

							{AvgVesselDiameter[q]=0;} //prevents division by 0

						else 

							{AvgVesselDiameter[q]=double(double (2.0*SumRegRadii[q])/RegVessels[q]);}

						}

WoundVessels=CircVessels[8];
SumRadiiWound=SumCircRadii[8];

						if	(WoundVessels==0)

							{WoundAvgVesselDiameter=0;} //prevents division by 0

						else 

							{WoundAvgVesselDiameter=double(double (2.0*SumRadiiWound)/WoundVessels);}

						

				}

			}
		}
	}

outfileVesselDiameter << angiotime << "\t" << AvgVesselDiameter[1] << "\t" << AvgVesselDiameter[2] <<
"\t" << AvgVesselDiameter[3] << "\t" << AvgVesselDiameter[4] << endl;

outfileWoundResults << WoundAvgVesselDiameter << endl;

delete [] CircVessels;			
delete [] RegVessels;
delete [] SumCircRadii;
delete [] SumRegRadii;
delete [] AvgVesselDiameter;

/*
int i,j,k,n,nbx,nby;
int p,q;
int NumWoundRegions;
int* CircVessels;
int* RegVessels;

double* SumCircRadii;		//sum of radii of all vessels in each concentric circle (in metres)

double* SumRegRadii;		//sum of radii of all vessels in each corresponding region (in metres)

double* AvgVesselDiameter;	//average vessel diameter in each region (in microns)

NumWoundRegions=3;

SumCircRadii=NULL;
SumRegRadii=NULL;
CircVessels=NULL;
RegVessels=NULL;
AvgVesselDiameter=NULL;

CircVessels=new int[NumWoundRegions+3];	
RegVessels=new int[NumWoundRegions+3];

SumCircRadii=new double[NumWoundRegions+3];
SumRegRadii=new double[NumWoundRegions+3];
AvgVesselDiameter=new double[NumWoundRegions+3];

for (p=0;p<=NumWoundRegions+2;p++)	
	{CircVessels[p]=RegVessels[p]=0;}				

for (q=0;q<=NumWoundRegions+2;q++) 
	{SumCircRadii[q]=SumRegRadii[q]=AvgVesselDiameter[q]=0;}


for (k=1;k<=m_nz;k++)
	{	
	for (j=1;j<=m_ny;j++)
		{	
		for (i=1;i<=m_nx;i++)
			{		
			for (n=1;n<=NumWoundRegions+2;n++)
				{
					
//--------------------------------------------------
				if (
						i>iCentre-(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )
					)
						{
							nbx=LabX(i,j,k);  
							nby=LabY(i,j,k);  
		
							if (pFluid[nbx-1]==10) {CircVessels[n]+=1; SumCircRadii[n]+=XBR[i-1][j-1][k-1];}
										                                                  
							if (pFluid[nby-1]==10) {CircVessels[n]+=1; SumCircRadii[n]+=YBR[i-1][j-1][k-1];}

						}

//--------------------------------------------------
						

				RegVessels[n]=CircVessels[n]-CircVessels[n-1];
				SumRegRadii[n]=SumCircRadii[n]-SumCircRadii[n-1];

				if (RegVessels[n]==0)

					{AvgVesselDiameter[n]=0;} //prevents division by 0
				else 

					{AvgVesselDiameter[n]=double(double (2.0*SumRegRadii[n])/RegVessels[n])*1000000;}

				
				}

			}
		}
	}

outfileVesselDiameter << angiotime << "\t" << AvgVesselDiameter[1] << "\t" << AvgVesselDiameter[2] <<
"\t" << AvgVesselDiameter[3] << "\t" << AvgVesselDiameter[4] << "\t" << AvgVesselDiameter[5] << endl;

delete [] CircVessels;			
delete [] RegVessels;
delete [] SumCircRadii;
delete [] SumRegRadii;
delete [] AvgVesselDiameter;
*/
}

//**************************************************

//===========================================
void CAngioNetDlg::WoundRemodelling(void)
//===========================================
//Mike 10/08 - calculates the average flow in the network 
//then removes vessels with small flows, where the flow
//required to survive increases with time

{
/*
int i,j,k;
int n,p;
int nbx,nby;

int NumVessels;				//no. of vessels in region up to 80 microns beyond 750
int NumFlowPeriods;			//no. of times network is flowed

double SumFlows;			//sum of all flows in region up to 80 microns beyond 750
double AvgFlow;				//average flow for all vessels in region up to 80 microns beyond 750

double* FlowThreshold;		//array containing numbers which define the fraction of average  
							//flow required to survive after each flow period

double InitialThreshold;	//define the two values between which the 
double FinalThreshold;		//elements of FlowThreshold will vary


NumFlowPeriods=int(m_angiotimeMax/m_GrowthInterval);

InitialThreshold=0.0;
FinalThreshold=0.005;	

FlowThreshold=NULL;

FlowThreshold=new double[NumFlowPeriods+1];

for (p=0;p<=NumFlowPeriods;p++)	
	{FlowThreshold[p]=0;}


for (n=1;n<=NumFlowPeriods;n++)
	{

	NumVessels=0;
	SumFlows=AvgFlow=0.0;

//--------------------------------------------------
	if (angiotime > double(double(n*m_GrowthInterval)+angioDeltaT) &&				//all remodelling occurs at the first timestep 
		angiotime <= double(double(n*m_GrowthInterval)+double(2.0*angioDeltaT)))	//after the network returns to a growth period
	
		{
			for (k=1;k<=m_nz;k++)
				{	
				for (j=1;j<=m_ny;j++)
					{	
					for (i=1;i<=m_nx;i++)
						{		
			
						if (

								i>iCentre-(int)sqrt( (double)(pow(iWoundRadius*(double)17/12,2))-pow(j-jCentre,2) )

								&&

								i<iCentre+(int)sqrt( (double)(pow(iWoundRadius*(double)17/12,2))-pow(j-jCentre,2) )

							)
								{
									nbx=LabX(i,j,k);  
									nby=LabY(i,j,k);  

									if (pFluid[nbx-1]==10) 
										
										{
											NumVessels+=1;
											SumFlows+=fabs(XFlow[i-1][j-1][k-1]);
											
										}
										                                                  
									if (pFluid[nby-1]==10) 

										{
											NumVessels+=1;
											SumFlows+=fabs(YFlow[i-1][j-1][k-1]);
											
										}


AvgFlow=double(SumFlows/NumVessels);
//--------------------------------------------------

									if (n<=int(NumFlowPeriods/((double)124/100)))	//defines the number of flow periods for which the 	
																					//flow threshold remains at its initial value (usually 
																					//zero) - 124/100 causes a change after approx 3.4	//7/5;	133/100;
										{FlowThreshold[n]=InitialThreshold;}

									else 
									
									{
										FlowThreshold[n]=double(InitialThreshold														//defines the increase in the flow threshold 
															+((double(double(double(FinalThreshold-InitialThreshold))					//from initial to final value up to the final 
																*(pow(n-int(NumFlowPeriods/((double)124/100)),2)))))					//flow period (varying the power changes the 
																	/(pow(NumFlowPeriods-int(NumFlowPeriods/((double)124/100)),2)));	//rate of the increase - linear, quadratic, cubic...)
										
									}
//--------------------------------------------------

									if (pFluid[nbx-1]==10 && 
											fabs(XFlow[i-1][j-1][k-1]) < double(FlowThreshold[n]*AvgFlow) &&
												pAgeOfVessel[nbx-1] > 0.2)	
										{
											pSprout[nbx-1]=0;				//vessels older than 0.2 (required so that  
											pFluid[nbx-1]=0;				//sprout tips not immediately removed) with 
											pPericyteDensity[nbx-1]=0.0;	//small flows are killed
											pArterialVenousID[nbx-1]=0;		//
											pAgeOfSprout[nbx-1]=0.0;		//
										}

									if (pFluid[nby-1]==10 && 
											fabs(YFlow[i-1][j-1][k-1]) < double(FlowThreshold[n]*AvgFlow) &&
												pAgeOfVessel[nby-1] > 0.2)	

										{
											pSprout[nby-1]=0;				//vessels older than 0.2 (required so that  
											pFluid[nby-1]=0;				//sprout tips not immediately removed) with
											pPericyteDensity[nby-1]=0.0;	//small flows are killed
											pArterialVenousID[nby-1]=0;		//
											pAgeOfSprout[nby-1]=0.0;		//
										}
								}

//--------------------------------------------------
								

						}
					}
				}
outfileRemodelling << AvgFlow << endl;

		}		
//--------------------------------------------------

	}



delete [] FlowThreshold;
*/
	int i,j,k;
	int nbx,nby,nbz;

	double Prune_Threshold=3.85;//~6 days

	for (k=1;k<=m_nz;k++)
	{	
		for (j=1;j<=m_ny;j++)
		{	
			for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				//x-bonds
				if		(pFluid[nbx-1]==10 //&& XBR[i-1][j-1][k-1]<=3.0e-6 
					&& pXHem[i-1][j-1][k-1]<0.02)
						{
							Prune_AgeX[i-1][j-1][k-1]+=angioDeltaT;
						}

				else	{
							Prune_AgeX[i-1][j-1][k-1]=0.0;
						}

				if	(Prune_AgeX[i-1][j-1][k-1]>Prune_Threshold)
					{
						pSprout[nbx-1]=0;				  
						pFluid[nbx-1]=0;				
						pPericyteDensity[nbx-1]=0.0;	
						pArterialVenousID[nbx-1]=0;		
						pAgeOfSprout[nbx-1]=0.0;
						XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;	//if new vessel grows in it will have appropriate size
					}
	//-------------------------------------------

				//y-bonds
				if		(pFluid[nby-1]==10 //&& YBR[i-1][j-1][k-1]<=3.0e-6 
					&& pYHem[i-1][j-1][k-1]<0.02)
						{
							Prune_AgeY[i-1][j-1][k-1]+=angioDeltaT;
						}

				else	{
							Prune_AgeY[i-1][j-1][k-1]=0.0;
						}

				if	(Prune_AgeY[i-1][j-1][k-1]>Prune_Threshold)
					{
						pSprout[nby-1]=0;				  
						pFluid[nby-1]=0;				
						pPericyteDensity[nby-1]=0.0;	
						pArterialVenousID[nby-1]=0;		
						pAgeOfSprout[nby-1]=0.0;
						YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;	//if new vessel grows in it will have appropriate size
					}
	//-------------------------------------------

				//z-bonds
				if		(pFluid[nbz-1]==10 //&& ZBR[i-1][j-1][k-1]<=3.0e-6 
					&& pZHem[i-1][j-1][k-1]<0.02)
						{
							Prune_AgeZ[i-1][j-1][k-1]+=angioDeltaT;
						}

				else	{
							Prune_AgeZ[i-1][j-1][k-1]=0.0;
						}

				if	(Prune_AgeZ[i-1][j-1][k-1]>Prune_Threshold)
					{
						pSprout[nbz-1]=0;				  
						pFluid[nbz-1]=0;				
						pPericyteDensity[nbz-1]=0.0;	
						pArterialVenousID[nbz-1]=0;		
						pAgeOfSprout[nbz-1]=0.0;
						ZBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;	//if new vessel grows in it will have appropriate size
					}
	//-------------------------------------------

			}//end i-loop
			
			i=m_nx+1;

			//x-danglers
			if		(pFluid[nbx-1]==10 //&& XBR[i-1][j-1][k-1]<=3.0e-6 
				&& pXHem[i-1][j-1][k-1]<0.02)
					{
						Prune_AgeX[i-1][j-1][k-1]+=angioDeltaT;
					}

			else	{
						Prune_AgeX[i-1][j-1][k-1]=0.0;
					}

			if	(Prune_AgeX[i-1][j-1][k-1]>Prune_Threshold)
				{
					pSprout[nbx-1]=0;				  
					pFluid[nbx-1]=0;				
					pPericyteDensity[nbx-1]=0.0;	
					pArterialVenousID[nbx-1]=0;		
					pAgeOfSprout[nbx-1]=0.0;
					XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;	//if new vessel grows in it will have appropriate size
				}
	//-------------------------------------------

		}//end j-loop
	}//end k-loop
	
}

//**************************************************

//==========================================
void CAngioNetDlg::WoundBranchPoints(void)
//==========================================
//Mike 10/08
{
int i,j,k;
int n,p,q;
int a,b;

double WoundBranchPoints;	//no. of branch points in wound (per 1,000,000 square microns)
double WoundArea;			//area of wound (square microns)

double* CircBranchPoints;	//array containing no. of branch points 
							//counted in each concentric circle
  
double* RegBranchPoints;	//array containing no. of branch points (per 1,000,000  
							//square microns) in each corresponding region

double* CircRadius;			//fraction of wound radius used to define each circle
double* CircArea;			//area of each circle (square microns)
double* RegArea;			//corresponding area of each region (square microns)

CircBranchPoints=RegBranchPoints=CircRadius=RegArea=CircArea=NULL;

CircBranchPoints=new double[9];	//see WoundVesselCount
								//for explanation
RegBranchPoints=new double[5];

CircRadius=new double[9];

RegArea=new double[5];

CircArea=new double[9];

for (a=0;a<=4;a++)
	{RegArea[a]=RegBranchPoints[a]=0;}

for (b=0;b<=8;b++)
	{CircBranchPoints[b]=CircRadius[b]=CircArea[b]=0;}


CircRadius[1]=(double)2/15;
CircRadius[8]=1.0;									//see WoundVesselCount 
													//for explanation
for (p=1;p<=3;p++)									//
	{												//
	CircRadius[2*p]=CircRadius[2*p-1]+(double)3/20;	//
	CircRadius[2*p+1]=CircRadius[2*p]+(double)4/15;	//
	}												//


for (n=1;n<=8;n++)
	{
	for (k=1;k<=m_nz;k++)
		{	
		for (j=1;j<=m_ny;j++)
			{	
			for (i=1;i<=m_nx;i++)
				{		
//--------------------------------------------------

CircArea[n]=PI*double (pow(double(i_UU_WoundRad*bondLength*1.0e6*CircRadius[n]),2));


				if (
						i>iCentre-(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )
					)
						{
//Branch point defined to be any node which has either 1 vessel growing in and 2 or 3 growing out (determined
//by sprout polarities) or 2 growing in and 2 growing out.  Each if statement is designed to cover all
//possible cases without any double counting.

							if (pFluid[LabX(i,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==0 && 
								poleSprout[LabX(i,j,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabY(i,j+1,k)-1]==1)
						
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==0 && 
								poleSprout[LabX(i,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && 
								poleSprout[LabX(i,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==0 && 
								poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && 
								poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==0 && 
								poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==0 &&
								poleSprout[LabY(i,j,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 &&
								poleSprout[LabY(i,j,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==0 &&
								poleSprout[LabY(i,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==0 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==0 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 &&
								poleSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==1)

							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==1)

							{CircBranchPoints[n]+=1;}

						}
				}
			}
		}

	for (q=1;q<=4;q++)
		{

		RegArea[q]=CircArea[2*q-1]-CircArea[2*q-2];													//see WoundVesselCount
																									//for explanation
		RegBranchPoints[q]=(CircBranchPoints[2*q-1]-CircBranchPoints[2*q-2])/RegArea[q]*1.0e6;

		}

WoundArea=CircArea[8];
WoundBranchPoints=CircBranchPoints[8]/WoundArea*1.0e6;

	}
				
outfileBranchPoints << angiotime << "\t" << RegBranchPoints[1] << "\t" << RegBranchPoints[2] <<
"\t" << RegBranchPoints[3] << "\t" << RegBranchPoints[4] << endl;

outfileWoundResults << WoundBranchPoints << "\t";

delete [] CircBranchPoints;
delete [] RegBranchPoints;
delete [] CircRadius;
delete [] RegArea;
delete [] CircArea;

/*
int i,j,k,n,q;

int NumWoundRegions;	//no. of regions into which wound will be split

double* CircBranchPoints;	//array containing no. of branch points 
							//counted in each concentric circle
  
double* RegBranchPoints;	//array containing no. of branch points (per 1,000,000  
							//square microns) in each corresponding region

double WoundArea;
double RegionArea;

NumWoundRegions=3;

WoundArea=PI*double (pow(double(iWoundRadius*20),2));	//defines area of wound (square microns)

RegionArea=double(WoundArea/NumWoundRegions);	//defines area of each region (square microns)

CircBranchPoints=RegBranchPoints=NULL;

CircBranchPoints=new double[NumWoundRegions+3];
RegBranchPoints=new double[NumWoundRegions+3];

for (q=0;q<=NumWoundRegions+2;q++)
	{CircBranchPoints[q]=RegBranchPoints[q]=0;}

for (k=1;k<=m_nz;k++)
	{	
	for (j=1;j<=m_ny;j++)
		{	
		for (i=1;i<=m_nx;i++)
			{		
			for (n=1;n<=NumWoundRegions+2;n++)
				{
//--------------------------------------------------
				if (
						i>iCentre-(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )  
						&&                                                           
						i<iCentre+(int)sqrt( (double)(pow(iWoundRadius,2)*((double)n/NumWoundRegions))-pow(j-jCentre,2) )
					
					)
						{
							if (pFluid[LabX(i,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==0 && 
								poleSprout[LabX(i,j,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabY(i,j+1,k)-1]==1)
						
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==0 && 
								poleSprout[LabX(i,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && 
								poleSprout[LabX(i,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==0 && 
								poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && 
								poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==0 && 
								poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==0 &&
								poleSprout[LabY(i,j,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 &&
								poleSprout[LabY(i,j,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==0 &&
								poleSprout[LabY(i,j,k)-1]==1 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabY(i,j+1,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==0 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==0)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==0 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1)
				
							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 &&
								poleSprout[LabY(i,j+1,k)-1]==1 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==0 && poleSprout[LabX(i,j,k)-1]==1)

							{CircBranchPoints[n]+=1;}

							if (pFluid[LabY(i,j+1,k)-1]==10 && pFluid[LabY(i,j,k)-1]==10 && pFluid[LabX(i+1,j,k)-1]==10 && pFluid[LabX(i,j,k)-1]==10 &&
								poleSprout[LabY(i,j+1,k)-1]==0 && poleSprout[LabY(i,j,k)-1]==0 && poleSprout[LabX(i+1,j,k)-1]==1 && poleSprout[LabX(i,j,k)-1]==1)

							{CircBranchPoints[n]+=1;}
				

							RegBranchPoints[n]=(CircBranchPoints[n]-CircBranchPoints[n-1])/RegionArea*1000000;
						
						}

				}

//--------------------------------------------------
			}
		}
	}

outfileBranchPoints << angiotime << "\t" << RegBranchPoints[1] << "\t" << RegBranchPoints[2] <<
"\t" << RegBranchPoints[3] << "\t" << RegBranchPoints[4] << "\t" << RegBranchPoints[5] << endl;

delete [] CircBranchPoints;
delete [] RegBranchPoints;
*/
}
//************************************************************

//============================================================================
void CAngioNetDlg::TransmuralGraphicsStick(int xMin, int xMax, int yMin, 
								 int yMax, int networkWidth, 
								 double deltaX, double deltaY)
//============================================================================

{
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,100,100),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);

	COLORREF purple0=RGB(0,0,100),//RGB(100,0,100),
			 purple1=RGB(50,0,100),//RGB(128,0,128),
			 purple2=RGB(100,0,100),//RGB(150,0,150),
			 purple3=RGB(175,0,100),//RGB(200,0,200),
			 purple4=RGB(255,0,0);//RGB(255,0,255);
	//COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penPink(PS_SOLID,2,pink);
	CPen penGreen(PS_SOLID,2,green);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,2,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penGrey1(PS_SOLID,2,Grey1);
	CPen penColour(PS_SOLID,1,colour);
	CPen penGrey2(PS_SOLID,1,Grey1);


//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);


//-----------------Grid up the domain----------------------
/*		CPen gridPen(PS_SOLID,1,RGB(0,100,0));
		memDC.SelectObject(&gridPen);

		for (int i=1;i<=m_nx;i++)
		{
			memDC.MoveTo(xMin+int(deltaX)+(i)*networkWidth/m_nx,
			yMin+int(deltaY)+0*networkWidth/m_ny);
			memDC.LineTo(xMin+int(deltaX)+(i)*networkWidth/m_nx,
			yMin+int(deltaY)+m_ny*networkWidth/m_ny);
		}


		for (int j=1;j<=m_ny;j++)
		{
			memDC.MoveTo(xMin+int(deltaX)+0*networkWidth/m_nx,
			yMin+int(deltaY)+j*networkWidth/m_ny);
			memDC.LineTo(xMin+int(deltaX)+(m_nx+1)*networkWidth/m_nx,
			yMin+int(deltaY)+j*networkWidth/m_ny);
		}

		//Draw a test square
		*/
//-----------------------------
	CBrush brushRed(red);
	CBrush brushPink(pink);
	CBrush brushLightBlue(LightBlue);
	CBrush brushDarkBlue(DarkBlue);
	CBrush brushWhite(White);
	CBrush brushBlack(Black);
	CBrush brushGreen(green);
	CBrush brushGrey1(Grey1);
//--------------------------------


//---------------------------------------------------------
//Print the loop variable
	CString myString;
	myString.Format("TIME %f",angiotime);
	memDC.TextOut(520,24,myString);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}



//	memDC.SelectObject(&penBlack);



//Draw the network ----2D

	//-------


	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	//int nbx=LabX(i,j,k);
	//int nby=LabY(i,j,k);
	//int nbz=LabZ(i,j,k);

////SMcD	memDC.SelectObject(&penBlack);
	//choiceColour=Black;

	//if (vEndoCellDensity[i-1][j-1][k-1] <= 0.25*runningEndoCellMAX)
	//{
	//	memDC.SelectObject(&penDarkBlue);
		//choiceColour=DarkBlue;
	//}vFibronectinConc[i][j][k]
	if (pTissueNutrientConc[i-1][j-1][k-1] <= 0.001)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushBlack);memDC.SelectObject(&penBlack);
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.001 &&//*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.25)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushGreen);memDC.SelectObject(&penGreen);
		//choiceColour=LightBlue;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.25 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.5)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushGrey1);memDC.SelectObject(&penGrey1);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.5 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.75)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushPink);memDC.SelectObject(&penPink);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.75)//*runningTissConcMAX)
	{
		memDC.SelectObject(&brushWhite);memDC.SelectObject(&penWhite);
		//choiceColour=pink;
	}



	//if (pFluid[nbx-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nby-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nbz-1]==66) { graphicsDC.SelectObject(&penBlack); }

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);

	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	// draw colour segment in the y-direction
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}

	// draw colour segment in the z-direction
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}

	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	


	//Draw filled block as well as network vessels in 2D
	//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//	if (m_nz==1)
//	{
///		memDC.Rectangle(xMin+int(deltaX)+(i-1)*networkWidth/m_nx,			//NO offset
///								yMin+int(deltaY)+(j-1)*networkWidth/m_ny,	//NO offset
///
///								xMin+int(deltaX)+(i)*networkWidth/m_nx,		//NO offset
///								yMin+int(deltaY)+(j)*networkWidth/m_ny);	//NO offset
//	}
	//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
	
	
	
	
	}
		
		}}	//end i,j,k loop


//---------------------------------------------------




//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey2);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }




//Draw the network---3D--
//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey2);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }


//-----Draw Wound Margin if applicable-----------
/* 	CBrush brGrey(RGB(0,0,0));	//transparent??

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);
			memDC.SelectObject(&penGrey2);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}
*/
//---------------------------------------


//----3D----
/*
 if (m_nz!=1)
 {

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//	memDC.SelectObject(&penBlack);

	if (pTissueNutrientConc[i-1][j-1][k-1] <= 0.001)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penBlack);//
		//memDC.SelectObject(&penGrey1);
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.001 &&//*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.25)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penGreen);
		//choiceColour=LightBlue;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.25 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.5)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penGrey1);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.5 && //*runningTissConcMAX &&
			 pTissueNutrientConc[i-1][j-1][k-1] <= 0.75)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penPink);
		//choiceColour=White;
	}
	else if (pTissueNutrientConc[i-1][j-1][k-1] > 0.75)//*runningTissConcMAX)
	{
		memDC.SelectObject(&penWhite);
		//choiceColour=pink;
	}

	//if (pFluid[nbx-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nby-1]==66) { graphicsDC.SelectObject(&penBlack); }
	//if (pFluid[nbz-1]==66) { graphicsDC.SelectObject(&penBlack); }

    //graphicsDC.FillSolidRect(400,200,500,500,choiceColour);



	if (pTissueNutrientConc[i-1][j-1][k-1] > 0.001)
	{
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the z-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx-(int)(iOffset*cos(dAngle)),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny-(int)(iOffset*sin(dAngle)));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
		

	}
	// draw colour segment in the x-direction (dangling points)
	//graphicsDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	//graphicsDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
	//				  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	

	//======================
	
			}}}		//end i j k loops
//----------------------------

	}	//end if m_nz!=1



*/

//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------


//Finally, restore old pen
	memDC.SelectObject(pOldPen);

}
//***********************************************

//===================================
void CAngioNetDlg::SaveFlows(void)
//===================================
//Mike 12/08
{
//Sub-routine used for writing away data for post-process of oxygen diffusion

//---Save flows----------------------------------
	outfileSaveFlow << angiotime << endl;
	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if	(fabs(XFlow[i-1][j-1][k-1])>1.0e-200)	{outfileSaveFlow << XFlow[i-1][j-1][k-1] << "\t";}
				else	{outfileSaveFlow << 0.0 << "\t";}
				if	(fabs(YFlow[i-1][j-1][k-1])>1.0e-200)	{outfileSaveFlow << YFlow[i-1][j-1][k-1] << "\t";}
				else	{outfileSaveFlow << 0.0 << "\t";}
				if	(fabs(ZFlow[i-1][j-1][k-1])>1.0e-200)	{outfileSaveFlow << ZFlow[i-1][j-1][k-1] << endl;}
				else	{outfileSaveFlow << 0.0 << endl;}
			}

			int i=m_nx+1;
			
			if	(fabs(XFlow[i-1][j-1][k-1])>1.0e-200)	{outfileSaveFlow << XFlow[i-1][j-1][k-1] << endl;}
			else	{outfileSaveFlow << 0.0 << endl;}
	}}
//-----------------------------------------------
//---Save false flows----------------------------
	outfileSaveFalseFlow << angiotime << endl;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				outfileSaveFalseFlow << FalseFlow[nbx-1] << "\t";
				outfileSaveFalseFlow << FalseFlow[nby-1] << "\t";
				outfileSaveFalseFlow << FalseFlow[nbz-1] << endl;
			}

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSaveFalseFlow << FalseFlow[nbx-1] << endl;
	}}
//-----------------------------------------------
//---Save fractional RBC flows-------------------
	outfileSaveFQE << angiotime << endl;
	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				outfileSaveFQE << NormFractRBCFlowX[i-1][j-1][k-1] << "\t";
				outfileSaveFQE << NormFractRBCFlowY[i-1][j-1][k-1] << "\t";
				outfileSaveFQE << NormFractRBCFlowZ[i-1][j-1][k-1] << endl;
				
			}

			int i=m_nx+1;
			
			outfileSaveFQE << NormFractRBCFlowX[i-1][j-1][k-1] << endl;
			
	}}
//-----------------------------------------------
//---Save bFlowIn----------------------------
	outfileSavebFlowIn << angiotime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				outfileSavebFlowIn << bFlowIn[nbx-1] << "\t";
				outfileSavebFlowIn << bFlowIn[nby-1] << "\t";
				outfileSavebFlowIn << bFlowIn[nbz-1] << endl;
			}

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSavebFlowIn << bFlowIn[nbx-1] << endl;
	}}
//-----------------------------------------------
//---Save bFlowOut----------------------------
	outfileSavebFlowOut << angiotime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				outfileSavebFlowOut << bFlowOut[nbx-1] << "\t";
				outfileSavebFlowOut << bFlowOut[nby-1] << "\t";
				outfileSavebFlowOut << bFlowOut[nbz-1] << endl;
			}

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSavebFlowOut << bFlowOut[nbx-1] << endl;
	}}
//-----------------------------------------------
}

//***********************************************

//====================================
void CAngioNetDlg::ReadInFlow(void)
//====================================
//Mike 12/08
{
infileSaveFlow >> angiotime;

	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  	
			  infileSaveFlow >> XFlow[i-1][j-1][k-1];
			  infileSaveFlow >> YFlow[i-1][j-1][k-1];
			  infileSaveFlow >> ZFlow[i-1][j-1][k-1];
			}
			int i=m_nx+1;
			
			infileSaveFlow >> XFlow[i-1][j-1][k-1];
	}}
}

//***********************************************

//========================================
void CAngioNetDlg::SaveAgeVessels(void)
//========================================
//Mike 12/08
{
outfileSaveAge << angiotime << endl;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				outfileSaveAge << i << "\t";
				outfileSaveAge << j << "\t";
				outfileSaveAge << k << "\t";
				outfileSaveAge << pAgeOfVessel[nbx-1] << "\t";
				outfileSaveAge << pAgeOfVessel[nby-1] << "\t";
				outfileSaveAge << pAgeOfVessel[nbz-1] << "\t";
				outfileSaveAge << endl;
			}

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			outfileSaveAge << i << "\t";
			outfileSaveAge << j << "\t";
			outfileSaveAge << k << "\t";
			outfileSaveAge << pAgeOfVessel[nbx-1] << "\t";
			outfileSaveAge << endl;
	}}
}

//***********************************************

//==================================
void CAngioNetDlg::ReadInAge(void)
//==================================
//Mike 12/08
{
infileSaveAge >> angiotime;

	int nbx,nby,nbz;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
	
				infileSaveAge >> i;
				infileSaveAge >> j;
				infileSaveAge >> k;
				infileSaveAge >> pAgeOfVessel[nbx-1];
				infileSaveAge >> pAgeOfVessel[nby-1];
				infileSaveAge >> pAgeOfVessel[nbz-1];
			}

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			infileSaveAge >> i;
			infileSaveAge >> j;
			infileSaveAge >> k;
			infileSaveAge >> pAgeOfVessel[nbx-1];
	}}
}

//***********************************************

//===============================================
void CAngioNetDlg::UpdateHematocrit2(void)
//===============================================
//Mike 05/09 - now includes phase separation at bifurcations (equations adapted from Pries)
{
	double*** TotalFlowOut=NULL; 
	double*** TotalFlowIn=NULL;
	double*** TotalMassIn=NULL;

	double*** FractBloodFlowX=NULL;	
	double*** FractBloodFlowY=NULL;	
	double*** FractBloodFlowZ=NULL;

	double*** NormFractBloodFlowX=NULL;	 
	double*** NormFractBloodFlowY=NULL;	
	double*** NormFractBloodFlowZ=NULL;

	double*** FractRBCFlowX=NULL;
	double*** FractRBCFlowY=NULL;
	double*** FractRBCFlowZ=NULL;

	double*** CoeffA_X=NULL;
	double*** CoeffA_Y=NULL;
	double*** CoeffA_Z=NULL;

	bool*** Adjust_Node=NULL;

	int*** NumFlowsOut=NULL;
	int*** NumFlowsIn=NULL;

	TotalFlowOut=new double**[m_nx];
	TotalFlowIn=new double**[m_nx];
	TotalMassIn=new double**[m_nx];

	FractBloodFlowX=new double**[m_nx+1];
	FractBloodFlowY=new double**[m_nx];
	FractBloodFlowZ=new double**[m_nx];

	NormFractBloodFlowX=new double**[m_nx+1];
	NormFractBloodFlowY=new double**[m_nx];
	NormFractBloodFlowZ=new double**[m_nx];

	FractRBCFlowX=new double**[m_nx+1];
	FractRBCFlowY=new double**[m_nx];
	FractRBCFlowZ=new double**[m_nx];

	CoeffA_X=new double**[m_nx+1];
	CoeffA_Y=new double**[m_nx];
	CoeffA_Z=new double**[m_nx];

	Adjust_Node=new bool**[m_nx];

	NumFlowsOut=new int**[m_nx];
	NumFlowsIn=new int**[m_nx];

	for (int i=0;i<m_nx;i++)
	{
		TotalFlowOut[i]=new double* [m_ny];
		TotalFlowIn[i]=new double* [m_ny];
		TotalMassIn[i]=new double* [m_ny];

		FractBloodFlowY[i]=new double*[m_ny];
		FractBloodFlowZ[i]=new double*[m_ny];

		NormFractBloodFlowY[i]=new double*[m_ny];
		NormFractBloodFlowZ[i]=new double*[m_ny];

		FractRBCFlowY[i]=new double*[m_ny];
		FractRBCFlowZ[i]=new double*[m_ny];

		CoeffA_Y[i]=new double*[m_ny];
		CoeffA_Z[i]=new double*[m_ny];

		Adjust_Node[i]=new bool*[m_ny];

		NumFlowsOut[i]=new int* [m_ny];
		NumFlowsIn[i]=new int* [m_ny];
	}

	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			TotalFlowOut[i][j]=new double [m_nz];
			TotalFlowIn[i][j]=new double [m_nz];
			TotalMassIn[i][j]=new double [m_nz];

			FractBloodFlowY[i][j]=new double[m_nz];
			FractBloodFlowZ[i][j]=new double[m_nz];

			NormFractBloodFlowY[i][j]=new double[m_nz];
			NormFractBloodFlowZ[i][j]=new double[m_nz];

			FractRBCFlowY[i][j]=new double[m_nz];
			FractRBCFlowZ[i][j]=new double[m_nz];

			CoeffA_Y[i][j]=new double[m_nz];
			CoeffA_Z[i][j]=new double[m_nz];

			Adjust_Node[i][j]=new bool[m_nz];

			NumFlowsOut[i][j]=new int [m_nz];
			NumFlowsIn[i][j]=new int [m_nz];
	}}

	for (int i=0;i<m_nx+1;i++)
	{
		FractBloodFlowX[i]=new double*[m_ny];
		NormFractBloodFlowX[i]=new double*[m_ny];
		FractRBCFlowX[i]=new double*[m_ny];

		CoeffA_X[i]=new double*[m_ny];
	}

	for (int i=0;i<m_nx+1;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			FractBloodFlowX[i][j]=new double[m_nz];
			NormFractBloodFlowX[i][j]=new double[m_nz];
			FractRBCFlowX[i][j]=new double[m_nz];

			CoeffA_X[i][j]=new double[m_nz];
	}}

if	(b_TestNetwork)	//stop top PV mysteriously appearing
	{
		for	(int i=1;i<=m_nx+1;i++)
		{
			pFluid[LabX(i,1,1)-1]=0;
			//pFluid[LabX(i,1,25)-1]=0;
			//pFluid[LabX(i,49,25)-1]=0;
		}
	}

//-----------------------------------------------

//-----------------------------------------------
//FIND MINIMUM TIME UNTIL PORE COMPLETELY EMPTIED
//CAN'T GO LONGER (MASS NOT CONSERVED)
//-----------------------------------------------
	double theminflow=1.0e-30;
	double timestep=1.0e20;
	double timeStepInit=1.0e20;
	int MinTime_i,MinTime_j;
	double MinTime_Rad,MinTime_Flow;

	double pi=3.141592654;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXHem[i-1][j-1][k-1]=0.0;}
			if (pFluid[nby-1]!=10)	{pYHem[i-1][j-1][k-1]=0.0;}
			if (pFluid[nbz-1]!=10)	{pZHem[i-1][j-1][k-1]=0.0;}
			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]!=10)	{pXHem[i-1][j-1][k-1]=0.0;}
	}}

//-----------------------------------------------
	double tempDeltaT;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)		
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);
			
			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_Rad=XBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(XFlow[i-1][j-1][k-1]);}
			}
			if (pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]/fabs(YFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_Rad=YBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(YFlow[i-1][j-1][k-1]);}
			}

			if (m_nz !=1)
			{
				if (pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1]) > theminflow)
				{
				tempDeltaT=pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]/fabs(ZFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT;}
				}
			}

			}
			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1]) > theminflow)
			{
				tempDeltaT=pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]/fabs(XFlow[i-1][j-1][k-1]);
				if (tempDeltaT < timestep) {timestep=tempDeltaT; 
											MinTime_i=i;
											MinTime_j=j;
											MinTime_Rad=XBR[i-1][j-1][k-1];
											MinTime_Flow=fabs(XFlow[i-1][j-1][k-1]);}
			}

	}}

//-----------------------------------------------

//Now set the actual sim timestep to the tracer-constrained timestep
//to keep everything consistent
//	if (m_presetNetwork==FALSE && m_circTumour==FALSE)
//	{
//		if (timestep<angioDeltaT) {exit(1);}	//need to change angioDeltaT
//		else	{}//timestep=angioDeltaT*10;}	//set to the smaller angioDeltaT
//	}											//IDEALLY update concs
												//angiodeltaT(in secs)/tmstep
												//times before returning
												//to cycle.
												//Currently, the 2 timescales
												//are not synchronised.
//	else	//we're only doing tracer so no real need to worry about timestep
//	{
//		angioDeltaT=timestep;
//	}

//-----------------------------------------------

//SMcD 10/2004-----
	if ( fabs(timeStepInit-timestep) / timeStepInit <= 0.01) 
	{MessageBox("Timestep error");}

	outfileDebugTime << timestep << "\t" << MinTime_i << "\t" << 
						MinTime_j << "\t" <<
						MinTime_Rad << "\t" <<
						MinTime_Flow << "\t" << flowTime << "\t" << loop << endl;

	angioDeltaT=timestep/TimeFactor;
	
//-----------------------------------------------

//------------------------------------------
//Now calculate total flow into and out of nodes
//Initialise first

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalMassIn[i-1][j-1][k-1]=0.0;
	}}}

//Now do the calculation - NB total flow in = total flow out
	int jp1,kp1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			  if (j==m_ny) {jp1=1;} else {jp1=j+1;}
			  if (k==m_nz) {kp1=1;} else {kp1=k+1;}

			  TotalFlowIn[i-1][j-1][k-1]=0.5*(
				  fabs(XFlow[i-1][j-1][k-1])+fabs(XFlow[i+1-1][j-1][k-1])+
				  fabs(YFlow[i-1][j-1][k-1])+fabs(YFlow[i-1][jp1-1][k-1])+
				  fabs(ZFlow[i-1][j-1][k-1])+fabs(ZFlow[i-1][j-1][kp1-1])  );

			  TotalFlowOut[i-1][j-1][k-1]=TotalFlowIn[i-1][j-1][k-1];

			  }}}

//-----------------------------------------------

//Initialise phase separation variables
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				FractBloodFlowX[i-1][j-1][k-1]=0.0;
				FractBloodFlowY[i-1][j-1][k-1]=0.0;
				FractBloodFlowZ[i-1][j-1][k-1]=0.0;
				NormFractBloodFlowX[i-1][j-1][k-1]=0.0;
				NormFractBloodFlowY[i-1][j-1][k-1]=0.0;
				NormFractBloodFlowZ[i-1][j-1][k-1]=0.0;
				FractRBCFlowX[i-1][j-1][k-1]=0.0;
				FractRBCFlowY[i-1][j-1][k-1]=0.0;
				FractRBCFlowZ[i-1][j-1][k-1]=0.0;
				NormFractRBCFlowX[i-1][j-1][k-1]=0.0;
				NormFractRBCFlowY[i-1][j-1][k-1]=0.0;
				NormFractRBCFlowZ[i-1][j-1][k-1]=0.0;
				CoeffA_Y[i-1][j-1][k-1]=0.0;
				CoeffA_Z[i-1][j-1][k-1]=0.0;
			}

		int i=m_nx+1;

				FractBloodFlowX[i-1][j-1][k-1]=0.0;
				NormFractBloodFlowX[i-1][j-1][k-1]=0.0;
				FractRBCFlowX[i-1][j-1][k-1]=0.0;
				NormFractRBCFlowX[i-1][j-1][k-1]=0.0;
				CoeffA_X[i-1][j-1][k-1]=0.0;
		}}

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				Adjust_Node[i-1][j-1][k-1]=false;
			}}}

	for (int n=1;n<=Nbond;n++)	{bFlowIn[n-1]=false;	bFlowOut[n-1]=false;}

	double AvgDiamIn;	//Pries equation
	double AvgDiamOut;
	double AvgHemIn;
	double SkimThreshold;	//X0 in Pries
	double CoeffB;
	int nAdjustNode;

//-----------------------------------------------

//Calculate no. of bonds flowing in/out of each node

//	if (flowTime>25.0 && flowTime<30.0)	{
//		outfileDebugNodeFlows << flowTime << endl;
//					 outfileDebugInOut << flowTime << endl;
//					 outfileDebugInOut << "check 1" << endl;
//	}

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				NumFlowsOut[i-1][j-1][k-1]=0;
				NumFlowsIn[i-1][j-1][k-1]=0;

				//x-bond to left
				if		(XFlow[i-1][j-1][k-1]>0.0)
						{
							bFlowIn[LabX(i,j,k)-1]=true;
							NumFlowsIn[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "x left" << "\t" << i << "\t" << j << "\t" << XFlow[i-1][j-1][k-1] << "\t" << endl;}
						}

				else if	(XFlow[i-1][j-1][k-1]<0.0)
						{
							bFlowOut[LabX(i,j,k)-1]=true;
							NumFlowsOut[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "x left" << "\t" << i << "\t" << j << "\t" << XFlow[i-1][j-1][k-1] << "\t" << endl;}
						}

				//x-bond to right
				if		(XFlow[i+1-1][j-1][k-1]>0.0)
						{
							bFlowIn[LabX(i+1,j,k)-1]=true;
							NumFlowsOut[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "x right" << "\t" << i << "\t" << j << "\t" << XFlow[i+1-1][j-1][k-1] << "\t" << endl;}
						}

				else if	(XFlow[i+1-1][j-1][k-1]<0.0)
						{
							bFlowOut[LabX(i+1,j,k)-1]=true;
							NumFlowsIn[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "x right" << "\t" << i << "\t" << j << "\t" << XFlow[i+1-1][j-1][k-1] << "\t" << endl;}
						}
						
				//y-bond above
				if		(YFlow[i-1][j-1][k-1]>0.0)
						{
							bFlowIn[LabY(i,j,k)-1]=true;
							NumFlowsIn[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "y above" << "\t" << i << "\t" << j << "\t" << YFlow[i-1][j-1][k-1] << "\t" << endl;}
						}

				else if	(YFlow[i-1][j-1][k-1]<0.0)
						{
							bFlowOut[LabY(i,j,k)-1]=true;
							NumFlowsOut[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "y above" << "\t" << i << "\t" << j << "\t" << YFlow[i-1][j-1][k-1] << "\t" << endl;}
						}

				//y-bond below
				if		(YFlow[i-1][jp1-1][k-1]>0.0)
						{
							bFlowIn[LabY(i,jp1,k)-1]=true;
							NumFlowsOut[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "y below" << "\t" << i << "\t" << j << "\t" << YFlow[i-1][jp1-1][k-1] << "\t" << endl;}
						}

				else if	(YFlow[i-1][jp1-1][k-1]<0.0)
						{
							bFlowOut[LabY(i,jp1,k)-1]=true;
							NumFlowsIn[i-1][j-1][k-1]+=1;
//if (flowTime>25.0 && flowTime<30.0) {outfileDebugNodeFlows << "y below" << "\t" << i << "\t" << j << "\t" << YFlow[i-1][jp1-1][k-1] << "\t" << endl;}
						}

//if (flowTime>25.0 && flowTime<30.0)	{outfileDebugInOut << i << "\t" << j << "\t" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl;}	

				//z-bond out of screen
				if		(ZFlow[i-1][j-1][k-1]>0.0)
						{
							bFlowIn[LabZ(i,j,k)-1]=true;
							NumFlowsIn[i-1][j-1][k-1]+=1;
						}

				else if	(ZFlow[i-1][j-1][k-1]<0.0)
						{
							bFlowOut[LabZ(i,j,k)-1]=true;
							NumFlowsOut[i-1][j-1][k-1]+=1;
						}

				//z-bond into screen
				if		(ZFlow[i-1][j-1][kp1-1]>0.0)
						{
							bFlowIn[LabZ(i,j,kp1)-1]=true;
							NumFlowsOut[i-1][j-1][k-1]+=1;
						}

				else if	(ZFlow[i-1][j-1][kp1-1]<0.0)
						{
							bFlowOut[LabZ(i,j,kp1)-1]=true;
							NumFlowsIn[i-1][j-1][k-1]+=1;
						}
			}}}

//-----------------------------------------------

//Determine which vessels in the network carry red blood cells

//	if (flowTime>25.0 && flowTime<30.0) {
//		outfileDebugNodeFlows << "loop finished" << endl;
//					 outfileDebugInOut << endl;
//					 outfileDebugFQB << flowTime << endl;
//					 outfileDebugNodeRadii << flowTime << endl;
//					 outfileDebugNodeRadii << "check 1" << endl;
//					 outfileDebugInOut << "check 2" << endl;
//	}
///////START REPLACED SECTION OCT 2010

			/*
	int jm1,km1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==1) {jm1=m_ny;} else {jm1=j-1;}
				if (k==1) {km1=m_nz;} else {km1=k-1;}
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				if	(NumFlowsOut[i-1][j-1][k-1]>1 && NumFlowsIn[i-1][j-1][k-1]>0)
					{				
						AvgDiamIn=(2*(bFlowIn[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowOut[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
									 +bFlowIn[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowOut[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
									 +bFlowIn[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowOut[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/NumFlowsIn[i-1][j-1][k-1];

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugFQB << i << "\t" << j << endl;}

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugNodeRadii << i << "\t" << j << endl;
//					 outfileDebugNodeRadii << "x left" << "\t" << XBR[i-1][j-1][k-1] << "\t" << "x right" << "\t" << XBR[i+1-1][j-1][k-1] << endl; 
//					 outfileDebugNodeRadii << "y above" << "\t" << YBR[i-1][j-1][k-1] << "\t" << "y below" << "\t" << YBR[i-1][jp1-1][k-1] << endl;
//					 outfileDebugNodeRadii << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << endl;
//					 outfileDebugNodeRadii << endl;}

						SkimThreshold=double(0.4e-6/AvgDiamIn);
											
						if	(bFlowOut[LabX(i,j,k)-1]==true)
							{
								FractBloodFlowX[i-1][j-1][k-1]=fabs(XFlow[i-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (flowTime>25.0 && flowTime<30.0) {outfileDebugFQB << "x left" << "\t" << XFlow[i-1][j-1][k-1] << "\t" << 
//TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowX[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;}

								if	(
									//FractBloodFlowX[i-1][j-1][k-1]>=1.0 || 
									FractBloodFlowX[i-1][j-1][k-1]<=SkimThreshold
									)
									{
										bFlowOut[LabX(i,j,k)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										if	(i!=1)	{
														NumFlowsIn[i-1-1][j-1][k-1]+=-1;
														Adjust_Node[i-1-1][j-1][k-1]=true;
													}
									}
							}

						if	(bFlowIn[LabX(i+1,j,k)-1]==true)
							{
								FractBloodFlowX[i+1-1][j-1][k-1]=fabs(XFlow[i+1-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (flowTime>25.0 && flowTime<30.0) {outfileDebugFQB << "x right" << "\t" << XFlow[i+1-1][j-1][k-1] << "\t" << 
//TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowX[i+1-1][j-1][k-1] << "\t" << SkimThreshold << endl;}

                                if	(
									//FractBloodFlowX[i+1-1][j-1][k-1]>=1.0 || 
									FractBloodFlowX[i+1-1][j-1][k-1]<=SkimThreshold
									)
									{
										bFlowIn[LabX(i+1,j,k)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										if	(i!=m_nx)	{NumFlowsIn[i+1-1][j-1][k-1]+=-1;}
									}
							}

						if	(bFlowOut[LabY(i,j,k)-1]==true)
							{
								FractBloodFlowY[i-1][j-1][k-1]=fabs(YFlow[i-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (flowTime>25.0 && flowTime<30.0) {outfileDebugFQB << "y above" << "\t" << YFlow[i-1][j-1][k-1] << "\t" << 
//TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowY[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;}

								if	(
									//FractBloodFlowY[i-1][j-1][k-1]>=1.0 || 
									FractBloodFlowY[i-1][j-1][k-1]<=SkimThreshold
									) 
									{
										bFlowOut[LabY(i,j,k)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										NumFlowsIn[i-1][jm1-1][k-1]+=-1;
										if	(j!=1)	{
														Adjust_Node[i-1][jm1-1][k-1]=true;
													}
									}
							}

						if	(bFlowIn[LabY(i,jp1,k)-1]==true)
							{
								FractBloodFlowY[i-1][jp1-1][k-1]=fabs(YFlow[i-1][jp1-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (flowTime>25.0 && flowTime<30.0) {outfileDebugFQB << "y below" << "\t" << YFlow[i-1][jp1-1][k-1] << "\t" << 
//TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowY[i-1][jp1-1][k-1] << "\t" << SkimThreshold << endl;}

								if	(
									//FractBloodFlowY[i-1][jp1-1][k-1]>=1.0 || 
									FractBloodFlowY[i-1][jp1-1][k-1]<=SkimThreshold
									) 
									{
										bFlowIn[LabY(i,jp1,k)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										NumFlowsIn[i-1][jp1-1][k-1]+=-1;
										if	(j==m_ny)	{
															Adjust_Node[i-1][jp1-1][k-1]=true;
														}
									}
							}

//	if (flowTime>25.0 && flowTime<30.0) {outfileDebugFQB << endl;
//					 outfileDebugNodeRadii << endl;
//					 outfileDebugInOut << i << "\t" << j << "\t" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl;
//					 outfileDebugInOut << endl;}
					
						if	(bFlowOut[LabZ(i,j,k)-1]==true)
							{
								FractBloodFlowZ[i-1][j-1][k-1]=fabs(ZFlow[i-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];
								
								if	(
									//FractBloodFlowZ[i-1][j-1][k-1]>=1.0 || 
									FractBloodFlowZ[i-1][j-1][k-1]<=SkimThreshold
									) 
									{
										bFlowOut[LabZ(i,j,k)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										NumFlowsIn[i-1][j-1][km1-1]+=-1;
										if	(k!=1)	{
														Adjust_Node[i-1][j-1][km1-1]=true;
													}
									}
							}

						if	(bFlowIn[LabZ(i,j,kp1)-1]==true)
							{
								FractBloodFlowZ[i-1][j-1][kp1-1]=fabs(ZFlow[i-1][j-1][kp1-1])/TotalFlowOut[i-1][j-1][k-1];
								
								if	(
									//FractBloodFlowZ[i-1][j-1][kp1-1]>=1.0 || 
									FractBloodFlowZ[i-1][j-1][kp1-1]<=SkimThreshold
									) 
									{
										bFlowIn[LabZ(i,j,kp1)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										NumFlowsIn[i-1][j-1][kp1-1]+=-1;
										if	(k==m_nz)	{
															Adjust_Node[i-1][j-1][kp1-1]=true;
														}
									}
							}
					}
						
			}}}	//end i,j,k loop

//	if (flowTime>25.0 && flowTime<30.0)	{
//		outfileDebugFQB << "loop finished" << endl;
//					 outfileDebugFQB << endl;
//					 outfileDebugInOut << endl;
//					 outfileDebugNodeRadii << endl;
//	}

	nAdjustNode=0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nAdjustNode+=Adjust_Node[i-1][j-1][k-1];
			}}}

//Iterate process to adjust nodes affected by changes elsewhere in network

	while	(nAdjustNode>0)
	{

//	if (flowTime>25.0 && flowTime<30.0) {
//		outfileDebugAdjust << flowTime << endl;
//					 outfileDebugAdjust << "No. nodes for adjustment" << "\t" << nAdjustNode << endl;
//					 outfileDebugNodeRadii << "check 2" << endl;
//					 outfileDebugInOut << "check 3" << endl;
//	}

				for (int k=1;k<=m_nz;k++)
				{	for (int j=1;j<=m_ny;j++)
					{	for (int i=1;i<=m_nx;i++)
						{
							if (j==1) {jm1=m_ny;} else {jm1=j-1;}
							if (k==1) {km1=m_nz;} else {km1=k-1;}
							if (j==m_ny) {jp1=1;} else {jp1=j+1;}
							if (k==m_nz) {kp1=1;} else {kp1=k+1;}
				
							if	(Adjust_Node[i-1][j-1][k-1]==true)
							{
								if (flowTime>25.0 && flowTime<30.0) {outfileDebugAdjust << i << "\t" << j << endl;}

									if		(NumFlowsIn[i-1][j-1][k-1]==0)
											{
												NumFlowsOut[i-1][j-1][k-1]=0;
											}

									else if	(NumFlowsIn[i-1][j-1][k-1]>0)
											{
												AvgDiamIn=(2*(bFlowIn[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowOut[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
															 +bFlowIn[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowOut[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
															 +bFlowIn[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowOut[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/NumFlowsIn[i-1][j-1][k-1];

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugNodeRadii << i << "\t" << j << endl;
//					 outfileDebugNodeRadii << "x left" << "\t" << XBR[i-1][j-1][k-1] << "\t" << "x right" << "\t" << XBR[i+1-1][j-1][k-1] << endl; 
//					 outfileDebugNodeRadii << "y above" << "\t" << YBR[i-1][j-1][k-1] << "\t" << "y below" << "\t" << YBR[i-1][jp1-1][k-1] << endl;
//					 outfileDebugNodeRadii << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << endl;
//					 outfileDebugNodeRadii << endl;}

												SkimThreshold=double(0.4e-6/AvgDiamIn);

												if	(bFlowOut[LabX(i,j,k)-1]==true && FractBloodFlowX[i-1][j-1][k-1]<=SkimThreshold)
													{
														bFlowOut[LabX(i,j,k)-1]=false;
														NumFlowsOut[i-1][j-1][k-1]+=-1;
														if	(i!=1)	{
																		NumFlowsIn[i-1-1][j-1][k-1]+=-1;
																		Adjust_Node[i-1-1][j-1][k-1]=true;

																		if (flowTime>25.0 && flowTime<30.0) {outfileDebugAdjust << endl;
																						 outfileDebugAdjust << "x to left" << "\t" << i << "\t" << j << "\t" << 
																						 NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
																						 FractBloodFlowX[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;}
																	}
													}

												if	(bFlowIn[LabX(i+1,j,k)-1]==true && FractBloodFlowX[i+1-1][j-1][k-1]<=SkimThreshold)
													{
														bFlowIn[LabX(i+1,j,k)-1]=false;
														NumFlowsOut[i-1][j-1][k-1]+=-1;
														if	(i!=m_nx)	{NumFlowsIn[i+1-1][j-1][k-1]+=-1;}
													}

												if	(bFlowOut[LabY(i,j,k)-1]==true && FractBloodFlowY[i-1][j-1][k-1]<=SkimThreshold)
													{
														bFlowOut[LabY(i,j,k)-1]=false;
														NumFlowsOut[i-1][j-1][k-1]+=-1;
														NumFlowsIn[i-1][jm1-1][k-1]+=-1;
														if	(j!=1)	{
																		Adjust_Node[i-1][jm1-1][k-1]=true;

																		if (flowTime>25.0 && flowTime<30.0) {outfileDebugAdjust << endl;
																						 outfileDebugAdjust << "y above" << "\t" << i << "\t" << j << "\t" << 
																						 NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
																						 FractBloodFlowY[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;}
																	}
													}

												if	(bFlowIn[LabY(i,jp1,k)-1]==true && FractBloodFlowY[i-1][jp1-1][k-1]<=SkimThreshold)
													{
														bFlowIn[LabY(i,jp1,k)-1]=false;
														NumFlowsOut[i-1][j-1][k-1]+=-1;
														NumFlowsIn[i-1][jp1-1][k-1]+=-1;
														if	(j==m_ny)	{
																			Adjust_Node[i-1][jp1-1][k-1]=true;

																			if (flowTime>25.0 && flowTime<30.0) {outfileDebugAdjust << endl;
																							 outfileDebugAdjust << "y below" << "\t" << i << "\t" << j << "\t" << 
																							 NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
																							 FractBloodFlowY[i-1][jp1-1][k-1] << "\t" << SkimThreshold << endl;}
																		}
													}

//	if (flowTime>25.0 && flowTime<30.0) {outfileDebugInOut << i << "\t" << j << "\t" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl;
//					 outfileDebugInOut << endl;}
					
												if	(bFlowOut[LabZ(i,j,k)-1]==true && FractBloodFlowZ[i-1][j-1][k-1]<=SkimThreshold)
													{
														bFlowOut[LabZ(i,j,k)-1]=false;
														NumFlowsOut[i-1][j-1][k-1]+=-1;
														NumFlowsIn[i-1][j-1][km1-1]+=-1;
														if	(k!=1)	{
																		Adjust_Node[i-1][j-1][km1-1]=true;
																	}
													}

												if	(bFlowIn[LabZ(i,j,kp1)-1]==true && FractBloodFlowZ[i-1][j-1][kp1-1]<=SkimThreshold)
													{
														bFlowIn[LabZ(i,j,kp1)-1]=false;
														NumFlowsOut[i-1][j-1][k-1]+=-1;
														NumFlowsIn[i-1][j-1][kp1-1]+=-1;
														if	(k==m_nz)	{
																			Adjust_Node[i-1][j-1][kp1-1]=true;
																		}
													}
											}

									Adjust_Node[i-1][j-1][k-1]=false;
							}
						}}}

				nAdjustNode=0;

				for (int k=1;k<=m_nz;k++)
				{	for (int j=1;j<=m_ny;j++)
					{	for (int i=1;i<=m_nx;i++)
						{
							nAdjustNode+=Adjust_Node[i-1][j-1][k-1];
						}}}

//	if (flowTime>25.0 && flowTime<30.0)	{
//		outfileDebugAdjust << "loop finished" << endl;
//					 outfileDebugAdjust << endl;
//	}

			}
//-----------------------------------------------

*/

//////END REPLACED SECTION OCT2010




///START OF REPLACEMENT
//--------------------------------------------
//IDENTIFY WHICH VESSELS CARRY RED BLOOD CELLS
//NB - SKIM THRESHOLD CHECK
//--------------------------------------------

//	if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugNodeFlows << "loop finished" << endl;
//	outfileDebugInOut << endl;
//	outfileDebugFQB << flowTime << endl;
//	outfileDebugNodeRadii << flowTime << endl;
//	outfileDebugNodeRadii << "check 1" << endl;
//	outfileDebugInOut << "check 2" << endl;
//}

	int jm1,km1;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==1) {jm1=m_ny;} else {jm1=j-1;}
				if (k==1) {km1=m_nz;} else {km1=k-1;}
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				if	(NumFlowsOut[i-1][j-1][k-1]>1 && NumFlowsIn[i-1][j-1][k-1]>0)
					{
						//average diam of vessels flowing into node
						AvgDiamIn=(2*(bFlowIn[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowOut[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
									 +bFlowIn[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowOut[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
									 +bFlowIn[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowOut[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/NumFlowsIn[i-1][j-1][k-1];

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0)	
//{
//	outfileDebugFQB << i << "\t" << j << endl;
//}

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0)	
//{
//	outfileDebugNodeRadii << i << "\t" << j << endl;
//	outfileDebugNodeRadii << "x left" << "\t" << XBR[i-1][j-1][k-1] << "\t" << "x right" << "\t" << XBR[i+1-1][j-1][k-1] << endl; 
//	outfileDebugNodeRadii << "y above" << "\t" << YBR[i-1][j-1][k-1] << "\t" << "y below" << "\t" << YBR[i-1][jp1-1][k-1] << endl;
//	outfileDebugNodeRadii << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << endl;
//	outfileDebugNodeRadii << endl;
//}

						//generalised from Pries equation
						SkimThreshold=double(0.4e-6/AvgDiamIn);
											
						if	(bFlowOut[LabX(i,j,k)-1]==true)
						{
							FractBloodFlowX[i-1][j-1][k-1]=fabs(XFlow[i-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugFQB << "x left" << "\t" << XFlow[i-1][j-1][k-1] << "\t" << 
//	TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowX[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}

							if	(
									//FractBloodFlowX[i-1][j-1][k-1]>=1.0 || 
									FractBloodFlowX[i-1][j-1][k-1]<=SkimThreshold
								)
							{
								bFlowOut[LabX(i,j,k)-1]=false;	//adjusted to indicate only 
								NumFlowsOut[i-1][j-1][k-1]+=-1;	//vessels carrying RBCs
								if	(i!=1)	{
												NumFlowsIn[i-1-1][j-1][k-1]+=-1;	//nodes visited previously may require 
												Adjust_Node[i-1-1][j-1][k-1]=true;	//adjustment (ie no inflow of RBCs)
											}
							}
						}

						if	(bFlowIn[LabX(i+1,j,k)-1]==true)
						{
							FractBloodFlowX[i+1-1][j-1][k-1]=fabs(XFlow[i+1-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugFQB << "x right" << "\t" << XFlow[i+1-1][j-1][k-1] << "\t" << 
//	TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowX[i+1-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}

                            if	(
									//FractBloodFlowX[i+1-1][j-1][k-1]>=1.0 || 
									FractBloodFlowX[i+1-1][j-1][k-1]<=SkimThreshold
								)
							{
								bFlowIn[LabX(i+1,j,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(i!=m_nx)	{NumFlowsIn[i+1-1][j-1][k-1]+=-1;}
							}
						}

						if	(bFlowOut[LabY(i,j,k)-1]==true)
						{
							FractBloodFlowY[i-1][j-1][k-1]=fabs(YFlow[i-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugFQB << "y above" << "\t" << YFlow[i-1][j-1][k-1] << "\t" << 
//	TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowY[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}

							if	(
									//FractBloodFlowY[i-1][j-1][k-1]>=1.0 || 
									FractBloodFlowY[i-1][j-1][k-1]<=SkimThreshold
								) 
							{
								bFlowOut[LabY(i,j,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(j!=1)	{
												NumFlowsIn[i-1][jm1-1][k-1]+=-1;
												Adjust_Node[i-1][jm1-1][k-1]=true;
											}
							}
						}

						if	(bFlowIn[LabY(i,jp1,k)-1]==true)
						{
							FractBloodFlowY[i-1][jp1-1][k-1]=fabs(YFlow[i-1][jp1-1][k-1])/TotalFlowOut[i-1][j-1][k-1];

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugFQB << "y below" << "\t" << YFlow[i-1][jp1-1][k-1] << "\t" << 
//	TotalFlowOut[i-1][j-1][k-1] << "\t" << FractBloodFlowY[i-1][jp1-1][k-1] << "\t" << SkimThreshold << endl;
//}

							if	(
									//FractBloodFlowY[i-1][jp1-1][k-1]>=1.0 || 
									FractBloodFlowY[i-1][jp1-1][k-1]<=SkimThreshold
								) 
							{
								bFlowIn[LabY(i,jp1,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								NumFlowsIn[i-1][jp1-1][k-1]+=-1;
								if	(j==m_ny)	{
													Adjust_Node[i-1][jp1-1][k-1]=true;
												}
							}
						}

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugFQB << endl;
//	outfileDebugNodeRadii << endl;
//	outfileDebugInOut << i << "\t" << j << "\t" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl;
//	outfileDebugInOut << endl;
//}
					
						if	(bFlowOut[LabZ(i,j,k)-1]==true)
							{
								FractBloodFlowZ[i-1][j-1][k-1]=fabs(ZFlow[i-1][j-1][k-1])/TotalFlowOut[i-1][j-1][k-1];
								
								if	(
									//FractBloodFlowZ[i-1][j-1][k-1]>=1.0 || 
									FractBloodFlowZ[i-1][j-1][k-1]<=SkimThreshold
									) 
									{
										bFlowOut[LabZ(i,j,k)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										NumFlowsIn[i-1][j-1][km1-1]+=-1;
										if	(k!=1)	{
														Adjust_Node[i-1][j-1][km1-1]=true;
													}
									}
							}

						if	(bFlowIn[LabZ(i,j,kp1)-1]==true)
							{
								FractBloodFlowZ[i-1][j-1][kp1-1]=fabs(ZFlow[i-1][j-1][kp1-1])/TotalFlowOut[i-1][j-1][k-1];
								
								if	(
									//FractBloodFlowZ[i-1][j-1][kp1-1]>=1.0 || 
									FractBloodFlowZ[i-1][j-1][kp1-1]<=SkimThreshold
									) 
									{
										bFlowIn[LabZ(i,j,kp1)-1]=false;
										NumFlowsOut[i-1][j-1][k-1]+=-1;
										NumFlowsIn[i-1][j-1][kp1-1]+=-1;
										if	(k==m_nz)	{
															Adjust_Node[i-1][j-1][kp1-1]=true;
														}
									}
							}
					}
						
			}}}	//end i,j,k loop

//	if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0)	
//{
//	outfileDebugFQB << "loop finished" << endl;
//	outfileDebugFQB << endl;
//	outfileDebugInOut << endl;
//	outfileDebugNodeRadii << endl;
//	}

	nAdjustNode=0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nAdjustNode+=Adjust_Node[i-1][j-1][k-1];
			}}}

//Iterate process to adjust nodes affected by changes elsewhere in network

	while	(nAdjustNode>0)
	{	//visit nodes requiring adjustment & iterate until 
		//arriving at sub-network in which all vessels carry RBCs

//	if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << flowTime << endl;
//	outfileDebugAdjust << "No. nodes for adjustment" << "\t" << nAdjustNode << endl;
//	outfileDebugNodeRadii << "check 2" << endl;
//	outfileDebugInOut << "check 3" << endl;
//}

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (j==1) {jm1=m_ny;} else {jm1=j-1;}
					if (k==1) {km1=m_nz;} else {km1=k-1;}
					if (j==m_ny) {jp1=1;} else {jp1=j+1;}
					if (k==m_nz) {kp1=1;} else {kp1=k+1;}
				
					if	(Adjust_Node[i-1][j-1][k-1]==true)
					{

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << i << "\t" << j << endl;
//}

						if	(NumFlowsIn[i-1][j-1][k-1]==0)
						{
							NumFlowsOut[i-1][j-1][k-1]=0;

							if	(bFlowOut[LabX(i,j,k)-1]==true)	
							{
								bFlowOut[LabX(i,j,k)-1]=false;
								if	(i!=1)	{
												Adjust_Node[i-1-1][j-1][k-1]=true;
												NumFlowsIn[i-1-1][j-1][k-1]-=1;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "x to left" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowX[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}
											}
							}

							if	(bFlowIn[LabX(i+1,j,k)-1]==true)	
							{
								bFlowIn[LabX(i+1,j,k)-1]=false;
								if	(i!=m_nx)	{
													NumFlowsIn[i+1-1][j-1][k-1]-=1;
													Adjust_Node[i+1-1][j-1][k-1]=true;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "x to right" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowX[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}
												}
							}

							if	(bFlowOut[LabY(i,j,k)-1]==true)	
							{
								bFlowOut[LabY(i,j,k)-1]=false;
								if	(j!=1)	{
												Adjust_Node[i-1][jm1-1][k-1]=true;
												NumFlowsIn[i-1][jm1-1][k-1]-=1;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "y above" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowY[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}
											}
							}

							if	(bFlowIn[LabY(i,jp1,k)-1]==true)	
							{
								bFlowIn[LabY(i,jp1,k)-1]=false;
								if	(j!=m_ny)	{
													Adjust_Node[i-1][jp1-1][k-1]=true;
													NumFlowsIn[i-1][jp1-1][k-1]-=1;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "y above" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowY[i-1][jp1-1][k-1] << "\t" << SkimThreshold << endl;
//}
												}
							}

							if	(bFlowOut[LabZ(i,j,k)-1]==true)	
							{
								bFlowOut[LabZ(i,j,k)-1]=false;
								if	(k!=1)	{
												Adjust_Node[i-1][j-1][km1-1]=true;
												NumFlowsIn[i-1][j-1][km1-1]-=1;
											}
							}

							if	(bFlowIn[LabZ(i,j,kp1)-1]==true)	
							{
								bFlowIn[LabZ(i,j,kp1)-1]=false;
								if	(k!=m_nz)	{
													Adjust_Node[i-1][j-1][kp1-1]=true;
													NumFlowsIn[i-1][j-1][kp1-1]-=1;
												}
							}
						}

						else if	(NumFlowsIn[i-1][j-1][k-1]>0 && NumFlowsOut[i-1][j-1][k-1]>1)
						{
							AvgDiamIn=(2*(bFlowIn[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowOut[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
										 +bFlowIn[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowOut[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
										 +bFlowIn[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowOut[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/NumFlowsIn[i-1][j-1][k-1];

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0)	
//{
//	 outfileDebugNodeRadii << i << "\t" << j << endl;
//	 outfileDebugNodeRadii << "x left" << "\t" << XBR[i-1][j-1][k-1] << "\t" << "x right" << "\t" << XBR[i+1-1][j-1][k-1] << endl; 
//	 outfileDebugNodeRadii << "y above" << "\t" << YBR[i-1][j-1][k-1] << "\t" << "y below" << "\t" << YBR[i-1][jp1-1][k-1] << endl;
//	 outfileDebugNodeRadii << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << endl;
//	 outfileDebugNodeRadii << endl;
//}

							SkimThreshold=double(0.4e-6/AvgDiamIn);

							if	(bFlowOut[LabX(i,j,k)-1]==true && FractBloodFlowX[i-1][j-1][k-1]<=SkimThreshold)
							{
								bFlowOut[LabX(i,j,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]-=1;
								if	(i!=1)	{
												NumFlowsIn[i-1-1][j-1][k-1]+=-1;
												Adjust_Node[i-1-1][j-1][k-1]=true;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "x to left" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowX[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}
											}
							}

							if	(bFlowIn[LabX(i+1,j,k)-1]==true && FractBloodFlowX[i+1-1][j-1][k-1]<=SkimThreshold)
							{
								bFlowIn[LabX(i+1,j,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(i!=m_nx)	{
													NumFlowsIn[i+1-1][j-1][k-1]+=-1;
													Adjust_Node[i+1-1][j-1][k-1]=true;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "x to right" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowX[i+1-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}
												}
							}

							if	(bFlowOut[LabY(i,j,k)-1]==true && FractBloodFlowY[i-1][j-1][k-1]<=SkimThreshold)
							{
								bFlowOut[LabY(i,j,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(j!=1)	{
												NumFlowsIn[i-1][jm1-1][k-1]+=-1;
												Adjust_Node[i-1][jm1-1][k-1]=true;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "y above" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowY[i-1][j-1][k-1] << "\t" << SkimThreshold << endl;
//}
											}
							}

							if	(bFlowIn[LabY(i,jp1,k)-1]==true && FractBloodFlowY[i-1][jp1-1][k-1]<=SkimThreshold)
							{
								bFlowIn[LabY(i,jp1,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(j!=m_ny)	{
													NumFlowsIn[i-1][jp1-1][k-1]+=-1;
													Adjust_Node[i-1][jp1-1][k-1]=true;

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugAdjust << endl;
//	outfileDebugAdjust << "y below" << "\t" << i << "\t" << j << "\t" << 
//	NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << "\t" << 
//	FractBloodFlowY[i-1][jp1-1][k-1] << "\t" << SkimThreshold << endl;
//}
												}
							}

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugInOut << i << "\t" << j << "\t" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl;
//	outfileDebugInOut << endl;
//}
					
							if	(bFlowOut[LabZ(i,j,k)-1]==true && FractBloodFlowZ[i-1][j-1][k-1]<=SkimThreshold)
							{
								bFlowOut[LabZ(i,j,k)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(k!=1)	{
												NumFlowsIn[i-1][j-1][km1-1]+=-1;
												Adjust_Node[i-1][j-1][km1-1]=true;
											}
							}

							if	(bFlowIn[LabZ(i,j,kp1)-1]==true && FractBloodFlowZ[i-1][j-1][kp1-1]<=SkimThreshold)
							{
								bFlowIn[LabZ(i,j,kp1)-1]=false;
								NumFlowsOut[i-1][j-1][k-1]+=-1;
								if	(k!=m_nz)	{
													NumFlowsIn[i-1][j-1][kp1-1]+=-1;
													Adjust_Node[i-1][j-1][kp1-1]=true;
												}
							}
						}

						Adjust_Node[i-1][j-1][k-1]=false;
					}
				}
			}
		}

		nAdjustNode=0;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					nAdjustNode+=Adjust_Node[i-1][j-1][k-1];
				}
			}
		}

//	if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0)	
//{
//	outfileDebugAdjust << "loop finished" << endl;
//	outfileDebugAdjust << endl;
//}

	}	//end while loop
//-----------------------------------------------
	///END REPLACEMENT

//Normalise FQB values to ensure they sum to 1
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				if	(NumFlowsOut[i-1][j-1][k-1]>1 && NumFlowsIn[i-1][j-1][k-1]>0)
					{				
						if	(bFlowOut[LabX(i,j,k)-1]==true)
							{
								NormFractBloodFlowX[i-1][j-1][k-1]=FractBloodFlowX[i-1][j-1][k-1]/
									(bFlowOut[LabX(i,j,k)-1]*FractBloodFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractBloodFlowX[i+1-1][j-1][k-1]
									+bFlowOut[LabY(i,j,k)-1]*FractBloodFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractBloodFlowY[i-1][jp1-1][k-1]
									+bFlowOut[LabZ(i,j,k)-1]*FractBloodFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractBloodFlowZ[i-1][j-1][kp1-1]);
							}

						if	(bFlowIn[LabX(i+1,j,k)-1]==true)
							{
								NormFractBloodFlowX[i+1-1][j-1][k-1]=FractBloodFlowX[i+1-1][j-1][k-1]/
									(bFlowOut[LabX(i,j,k)-1]*FractBloodFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractBloodFlowX[i+1-1][j-1][k-1]
									+bFlowOut[LabY(i,j,k)-1]*FractBloodFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractBloodFlowY[i-1][jp1-1][k-1]
									+bFlowOut[LabZ(i,j,k)-1]*FractBloodFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractBloodFlowZ[i-1][j-1][kp1-1]);
							}

						if	(bFlowOut[LabY(i,j,k)-1]==true)
							{
								NormFractBloodFlowY[i-1][j-1][k-1]=FractBloodFlowY[i-1][j-1][k-1]/
									(bFlowOut[LabX(i,j,k)-1]*FractBloodFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractBloodFlowX[i+1-1][j-1][k-1]
									+bFlowOut[LabY(i,j,k)-1]*FractBloodFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractBloodFlowY[i-1][jp1-1][k-1]
									+bFlowOut[LabZ(i,j,k)-1]*FractBloodFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractBloodFlowZ[i-1][j-1][kp1-1]);
							}

						if	(bFlowIn[LabY(i,jp1,k)-1]==true)
							{
								NormFractBloodFlowY[i-1][jp1-1][k-1]=FractBloodFlowY[i-1][jp1-1][k-1]/
									(bFlowOut[LabX(i,j,k)-1]*FractBloodFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractBloodFlowX[i+1-1][j-1][k-1]
									+bFlowOut[LabY(i,j,k)-1]*FractBloodFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractBloodFlowY[i-1][jp1-1][k-1]
									+bFlowOut[LabZ(i,j,k)-1]*FractBloodFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractBloodFlowZ[i-1][j-1][kp1-1]);
							}

						if	(bFlowOut[LabZ(i,j,k)-1]==true)
							{
								NormFractBloodFlowZ[i-1][j-1][k-1]=FractBloodFlowZ[i-1][j-1][k-1]/
									(bFlowOut[LabX(i,j,k)-1]*FractBloodFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractBloodFlowX[i+1-1][j-1][k-1]
									+bFlowOut[LabY(i,j,k)-1]*FractBloodFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractBloodFlowY[i-1][jp1-1][k-1]
									+bFlowOut[LabZ(i,j,k)-1]*FractBloodFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractBloodFlowZ[i-1][j-1][kp1-1]);
							}

						if	(bFlowIn[LabZ(i,j,kp1)-1]==true)
							{
								NormFractBloodFlowZ[i-1][j-1][kp1-1]=FractBloodFlowZ[i-1][j-1][kp1-1]/
									(bFlowOut[LabX(i,j,k)-1]*FractBloodFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractBloodFlowX[i+1-1][j-1][k-1]
									+bFlowOut[LabY(i,j,k)-1]*FractBloodFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractBloodFlowY[i-1][jp1-1][k-1]
									+bFlowOut[LabZ(i,j,k)-1]*FractBloodFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractBloodFlowZ[i-1][j-1][kp1-1]);
							}
					}
			}
		}
	}
//-----------------------------------------------

//Calculate fraction of red blood cells received by each bond

//	if (flowTime>25.0 && flowTime<30.0)	{
//		outfileDebugAdjust << "iteration complete" << endl;
//					 outfileDebugAdjust << endl;
//					 outfileDebugNodeRadii << endl;
//					 outfileDebugNodeRadii << "check 3" << endl;
//					 outfileDebugInOut << "loop finished" << endl;
//					 outfileDebugInOut << endl;
//					 outfileDebugFQE << flowTime << endl;
//	}

	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				if		(NumFlowsOut[i-1][j-1][k-1]==0)	{}	//do nothing
					
				else if	(NumFlowsOut[i-1][j-1][k-1]==1 && NumFlowsIn[i-1][j-1][k-1]>0)	//all blood and RBCs enter one vessel
						{
							if	(bFlowOut[LabX(i,j,k)-1]==true)		{NormFractBloodFlowX[i-1][j-1][k-1]=NormFractRBCFlowX[i-1][j-1][k-1]=1.0;}
							if	(bFlowIn[LabX(i+1,j,k)-1]==true)	{NormFractBloodFlowX[i+1-1][j-1][k-1]=NormFractRBCFlowX[i+1-1][j-1][k-1]=1.0;}
							if	(bFlowOut[LabY(i,j,k)-1]==true)		{NormFractBloodFlowY[i-1][j-1][k-1]=NormFractRBCFlowY[i-1][j-1][k-1]=1.0;}
							if	(bFlowIn[LabY(i,jp1,k)-1]==true)	{NormFractBloodFlowY[i-1][jp1-1][k-1]=NormFractRBCFlowY[i-1][jp1-1][k-1]=1.0;}
							if	(bFlowOut[LabZ(i,j,k)-1]==true)		{NormFractBloodFlowZ[i-1][j-1][k-1]=NormFractRBCFlowZ[i-1][j-1][k-1]=1.0;}
							if	(bFlowIn[LabZ(i,j,kp1)-1]==true)	{NormFractBloodFlowZ[i-1][j-1][kp1-1]=NormFractRBCFlowZ[i-1][j-1][kp1-1]=1.0;}
						}

				else if	(NumFlowsOut[i-1][j-1][k-1]>1 && NumFlowsIn[i-1][j-1][k-1]>0)	//Pries equations determine phase separation
						{
							
							AvgDiamIn=double((2*(bFlowIn[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowOut[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
										 +bFlowIn[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowOut[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
										 +bFlowIn[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowOut[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/NumFlowsIn[i-1][j-1][k-1]);

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugNodeRadii << i << "\t" << j << endl;
//						 outfileDebugNodeRadii << "x left" << "\t" << XBR[i-1][j-1][k-1] << "\t" << "x right" << "\t" << XBR[i+1-1][j-1][k-1] << endl; 
//						 outfileDebugNodeRadii << "y above" << "\t" << YBR[i-1][j-1][k-1] << "\t" << "y below" << "\t" << YBR[i-1][jp1-1][k-1] << endl;
//						 outfileDebugNodeRadii << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << endl;
//						 outfileDebugNodeRadii << endl;}
							
							AvgHemIn=(bFlowIn[LabX(i,j,k)-1]*pXHem[i-1][j-1][k-1]+bFlowOut[LabX(i+1,j,k)-1]*pXHem[i+1-1][j-1][k-1]
									 +bFlowIn[LabY(i,j,k)-1]*pYHem[i-1][j-1][k-1]+bFlowOut[LabY(i,jp1,k)-1]*pYHem[i-1][jp1-1][k-1]
									 +bFlowIn[LabZ(i,j,k)-1]*pZHem[i-1][j-1][k-1]+bFlowOut[LabZ(i,j,kp1)-1]*pZHem[i-1][j-1][kp1-1])/NumFlowsIn[i-1][j-1][k-1];

							SkimThreshold=double(0.4e-6/AvgDiamIn);

							CoeffB=1+6.98e-6*((1-AvgHemIn)/AvgDiamIn);
                            														
							if	(bFlowOut[LabX(i,j,k)-1]==true)
								{
									AvgDiamOut=(2*(											  bFlowIn[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
												  +bFlowOut[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
												  +bFlowOut[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/(NumFlowsOut[i-1][j-1][k-1]-1);

									CoeffA_X[i-1][j-1][k-1]=(-6.96e-6/AvgDiamIn)*log((2*XBR[i-1][j-1][k-1])/AvgDiamOut);

									if	(NormFractBloodFlowX[i-1][j-1][k-1]+SkimThreshold>=0.99999)	//in case of rounding errors
										{NormFractBloodFlowX[i-1][j-1][k-1]=0.9999-SkimThreshold;}


									if		(NormFractBloodFlowX[i-1][j-1][k-1]<=SkimThreshold)	//in case normalisation causes a problem (shouldn't for sensible flows)
											{
												FractRBCFlowX[i-1][j-1][k-1]=0.0;
											}

									else	{
												FractRBCFlowX[i-1][j-1][k-1]=1/(1+exp(-(CoeffA_X[i-1][j-1][k-1]+CoeffB
																	*log((NormFractBloodFlowX[i-1][j-1][k-1]-SkimThreshold)
																		/(1-(NormFractBloodFlowX[i-1][j-1][k-1]+SkimThreshold))))));
											}

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugFQE << endl;
//					 outfileDebugFQE << "x left" << "\t" << i << "\t" << j << endl;
//					 outfileDebugFQE << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t"
//									 << "\t" << "No. flows out" << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl; 
//					 outfileDebugFQE << "Avg Diam In" << "\t" << AvgDiamIn << "\t" << "\t" 
//									 << "Avg Hem In" << "\t" << AvgHemIn << endl; 
//					 outfileDebugFQE << "Threshold" << "\t" << SkimThreshold << "\t" << "\t" 
//									 << "Avg Diam Out" << "\t" << AvgDiamOut << endl;
//					 outfileDebugFQE << "A" << "\t" << CoeffA_X[i-1][j-1][k-1] << "\t" << "\t" 
//									 << "B" << "\t" << CoeffB << endl; 
//					 outfileDebugFQE << "FQB" << "\t" << NormFractBloodFlowX[i-1][j-1][k-1] << "\t" << "\t" << "FQE" << "\t" 
//									 << FractRBCFlowX[i-1][j-1][k-1] << "\t" << "\t" << "Flow" << "\t" << XFlow[i-1][j-1][k-1] << endl;} 

								}

							if	(bFlowIn[LabX(i+1,j,k)-1]==true)
								{
									AvgDiamOut=(2*(bFlowOut[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]
												  +bFlowOut[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
												  +bFlowOut[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/(NumFlowsOut[i-1][j-1][k-1]-1);

									CoeffA_X[i+1-1][j-1][k-1]=(-6.96e-6/AvgDiamIn)*log((2*XBR[i+1-1][j-1][k-1])/AvgDiamOut);

									if	(NormFractBloodFlowX[i+1-1][j-1][k-1]+SkimThreshold>=0.99999)	//in case of rounding errors
										{NormFractBloodFlowX[i+1-1][j-1][k-1]=0.9999-SkimThreshold;}


									if		(NormFractBloodFlowX[i+1-1][j-1][k-1]<=SkimThreshold)	//in case normalisation causes a problem (shouldn't for sensible flows)
											{
												FractRBCFlowX[i+1-1][j-1][k-1]=0.0;
											}

									else	{
												FractRBCFlowX[i+1-1][j-1][k-1]=1/(1+exp(-(CoeffA_X[i+1-1][j-1][k-1]+CoeffB
																	*log((NormFractBloodFlowX[i+1-1][j-1][k-1]-SkimThreshold)
																		/(1-(NormFractBloodFlowX[i+1-1][j-1][k-1]+SkimThreshold))))));
											}

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugFQE << endl;
//					 outfileDebugFQE << "x right" << "\t" << i << "\t" << j << endl;
//					 outfileDebugFQE << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t"
//									 << "\t" << "No. flows out" << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl; 
//					 outfileDebugFQE << "Avg Diam In" << "\t" << AvgDiamIn << "\t" << "\t" 
//									 << "Avg Hem In" << "\t" << AvgHemIn << endl; 
//					 outfileDebugFQE << "Threshold" << "\t" << SkimThreshold << "\t" << "\t" 
//									 << "Avg Diam Out" << "\t" << AvgDiamOut << endl;
//					 outfileDebugFQE << "A" << "\t" << CoeffA_X[i+1-1][j-1][k-1] << "\t" << "\t" 
//									 << "B" << "\t" << CoeffB << endl; 
//					 outfileDebugFQE << "FQB" << "\t" << NormFractBloodFlowX[i+1-1][j-1][k-1] << "\t" << "\t" << "FQE" << "\t" 
//									 << FractRBCFlowX[i+1-1][j-1][k-1] << "\t" << "\t" << "Flow" << "\t" << XFlow[i+1-1][j-1][k-1] << endl;} 
					
								}

							if	(bFlowOut[LabY(i,j,k)-1]==true)
								{
									AvgDiamOut=(2*(bFlowOut[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
																							 +bFlowIn[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
												  +bFlowOut[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/(NumFlowsOut[i-1][j-1][k-1]-1);

									CoeffA_Y[i-1][j-1][k-1]=(-6.96e-6/AvgDiamIn)*log((2*YBR[i-1][j-1][k-1])/AvgDiamOut);

									if	(NormFractBloodFlowY[i-1][j-1][k-1]+SkimThreshold>=0.99999)	//in case of rounding errors
										{NormFractBloodFlowY[i-1][j-1][k-1]=0.9999-SkimThreshold;}


									if		(NormFractBloodFlowY[i-1][j-1][k-1]<=SkimThreshold)	//in case normalisation causes a problem (shouldn't for sensible flows)
											{
												FractRBCFlowY[i-1][j-1][k-1]=0.0;
											}

									else	{
												FractRBCFlowY[i-1][j-1][k-1]=1/(1+exp(-(CoeffA_Y[i-1][j-1][k-1]+CoeffB
																	*log((NormFractBloodFlowY[i-1][j-1][k-1]-SkimThreshold)
																		/(1-(NormFractBloodFlowY[i-1][j-1][k-1]+SkimThreshold))))));
											}

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugFQE << endl;
//					 outfileDebugFQE << "y above" << "\t" << i << "\t" << j << endl;
//					 outfileDebugFQE << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t"
//									 << "\t" << "No. flows out" << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl; 
//					 outfileDebugFQE << "Avg Diam In" << "\t" << AvgDiamIn << "\t" << "\t" 
//									 << "Avg Hem In" << "\t" << AvgHemIn << endl; 
//					 outfileDebugFQE << "Threshold" << "\t" << SkimThreshold << "\t" << "\t" 
//									 << "Avg Diam Out" << "\t" << AvgDiamOut << endl;
//					 outfileDebugFQE << "A" << "\t" << CoeffA_Y[i-1][j-1][k-1] << "\t" << "\t" 
//									 << "B" << "\t" << CoeffB << endl; 
//					 outfileDebugFQE << "FQB" << "\t" << NormFractBloodFlowY[i-1][j-1][k-1] << "\t" << "\t" << "FQE" << "\t" 
//									 << FractRBCFlowY[i-1][j-1][k-1] << "\t" << "\t" << "Flow" << "\t" << YFlow[i-1][j-1][k-1] << endl;} 
					
								}

							if	(bFlowIn[LabY(i,jp1,k)-1]==true)
								{
									AvgDiamOut=(2*(bFlowOut[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
												  +bFlowOut[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]
												  +bFlowOut[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/(NumFlowsOut[i-1][j-1][k-1]-1);

									CoeffA_Y[i-1][jp1-1][k-1]=(-6.96e-6/AvgDiamIn)*log((2*YBR[i-1][jp1-1][k-1])/AvgDiamOut);

									if	(NormFractBloodFlowY[i-1][jp1-1][k-1]+SkimThreshold>=0.99999)	//in case of rounding errors
										{NormFractBloodFlowY[i-1][jp1-1][k-1]=0.9999-SkimThreshold;}


									if		(NormFractBloodFlowY[i-1][jp1-1][k-1]<=SkimThreshold)	//in case normalisation causes a problem (shouldn't for sensible flows)
											{
												FractRBCFlowY[i-1][jp1-1][k-1]=0.0;
											}

									else	{
												FractRBCFlowY[i-1][jp1-1][k-1]=1/(1+exp(-(CoeffA_Y[i-1][jp1-1][k-1]+CoeffB
									 								*log((NormFractBloodFlowY[i-1][jp1-1][k-1]-SkimThreshold)
																		/(1-(NormFractBloodFlowY[i-1][jp1-1][k-1]+SkimThreshold))))));
											}

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugFQE << endl;
//					 outfileDebugFQE << "y below" << "\t" << i << "\t" << j << endl;
//					 outfileDebugFQE << "No. flows in" << "\t" << NumFlowsIn[i-1][j-1][k-1] << "\t"
//									 << "\t" << "No. flows out" << "\t" << NumFlowsOut[i-1][j-1][k-1] << endl; 
//					 outfileDebugFQE << "Avg Diam In" << "\t" << AvgDiamIn << "\t" << "\t" 
//									 << "Avg Hem In" << "\t" << AvgHemIn << endl; 
//					 outfileDebugFQE << "Threshold" << "\t" << SkimThreshold << "\t" << "\t" 
//									 << "Avg Diam Out" << "\t" << AvgDiamOut << endl;
//					 outfileDebugFQE << "A" << "\t" << CoeffA_Y[i-1][jp1-1][k-1] << "\t" << "\t" 
//									 << "B" << "\t" << CoeffB << endl; 
//					 outfileDebugFQE << "FQB" << "\t" << NormFractBloodFlowY[i-1][jp1-1][k-1] << "\t" << "\t" << "FQE" << "\t" 
//									 << FractRBCFlowY[i-1][jp1-1][k-1] << "\t" << "\t" << "Flow" << "\t" << YFlow[i-1][jp1-1][k-1] << endl;} 
					
																	 
								}

//	if (flowTime>25.0 && flowTime<30.0)	{outfileDebugFQE << endl;}

							if	(bFlowOut[LabZ(i,j,k)-1]==true)
								{
									AvgDiamOut=(2*(bFlowOut[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
												  +bFlowOut[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
																							 +bFlowIn[LabZ(i,j,kp1)-1]*ZBR[i-1][j-1][kp1-1]))/(NumFlowsOut[i-1][j-1][k-1]-1);

									CoeffA_Z[i-1][j-1][k-1]=(-6.96e-6/AvgDiamIn)*log((2*ZBR[i-1][j-1][k-1])/AvgDiamOut);

									if	(NormFractBloodFlowZ[i-1][j-1][k-1]+SkimThreshold>=0.99999)	//in case of rounding errors
										{NormFractBloodFlowZ[i-1][j-1][k-1]=0.9999-SkimThreshold;}


									if		(NormFractBloodFlowZ[i-1][j-1][k-1]<=SkimThreshold)	//in case normalisation causes a problem (shouldn't for sensible flows)
											{
												FractRBCFlowZ[i-1][j-1][k-1]=0.0;
											}

									else	{
												FractRBCFlowZ[i-1][j-1][k-1]=1/(1+exp(-(CoeffA_Z[i-1][j-1][k-1]+CoeffB
																	*log((NormFractBloodFlowZ[i-1][j-1][k-1]-SkimThreshold)
																		/(1-(NormFractBloodFlowZ[i-1][j-1][k-1]+SkimThreshold))))));
											}

								}

							if	(bFlowIn[LabZ(i,j,kp1)-1]==true)
								{
									AvgDiamOut=(2*(bFlowOut[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]
												  +bFlowOut[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*YBR[i-1][jp1-1][k-1]
												  +bFlowOut[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]											   ))/(NumFlowsOut[i-1][j-1][k-1]-1);

									CoeffA_Z[i-1][j-1][kp1-1]=(-6.96e-6/AvgDiamIn)*log((2*ZBR[i-1][j-1][kp1-1])/AvgDiamOut);

									if	(NormFractBloodFlowZ[i-1][j-1][kp1-1]+SkimThreshold>=0.99999)	//in case of rounding errors
										{NormFractBloodFlowZ[i-1][j-1][kp1-1]=0.9999-SkimThreshold;}


									if		(NormFractBloodFlowZ[i-1][j-1][kp1-1]<=SkimThreshold)	//in case normalisation causes a problem (shouldn't for sensible flows)
											{
												FractRBCFlowZ[i-1][j-1][kp1-1]=0.0;
											}

									else	{
												FractRBCFlowZ[i-1][j-1][kp1-1]=1/(1+exp(-(CoeffA_Z[i-1][j-1][kp1-1]+CoeffB
																	*log((NormFractBloodFlowZ[i-1][j-1][kp1-1]-SkimThreshold)
																		/(1-(NormFractBloodFlowZ[i-1][j-1][kp1-1]+SkimThreshold))))));
											}
								}

//adjust these for following normalisation & Total Mass In calculations
//(not done above since we may divide by zero)
							if	(bFlowOut[LabX(i,j,k)-1]==true && FractRBCFlowX[i-1][j-1][k-1]==0.0)
								{
									bFlowOut[LabX(i,j,k)-1]=false;
								}

							if	(bFlowIn[LabX(i+1,j,k)-1]==true && FractRBCFlowX[i+1-1][j-1][k-1]==0.0)
								{
									bFlowIn[LabX(i+1,j,k)-1]=false;
								}

							if	(bFlowOut[LabY(i,j,k)-1]==true && FractRBCFlowY[i-1][j-1][k-1]==0.0)
								{
									bFlowOut[LabY(i,j,k)-1]=false;
								}

							if	(bFlowIn[LabY(i,jp1,k)-1]==true && FractRBCFlowY[i-1][jp1-1][k-1]==0.0)
								{
									bFlowIn[LabY(i,jp1,k)-1]=false;
								}

							if	(bFlowOut[LabZ(i,j,k)-1]==true && FractRBCFlowZ[i-1][j-1][k-1]==0.0)
								{
									bFlowOut[LabZ(i,j,k)-1]=false;
								}

							if	(bFlowIn[LabZ(i,j,kp1)-1]==true && FractRBCFlowZ[i-1][j-1][kp1-1]==0.0)
								{
									bFlowIn[LabZ(i,j,kp1)-1]=false;
								}

//Normalise FQE values to ensure they sum to 1
							if	(bFlowOut[LabX(i,j,k)-1]==true)
										{
											NormFractRBCFlowX[i-1][j-1][k-1]=FractRBCFlowX[i-1][j-1][k-1]/
												(bFlowOut[LabX(i,j,k)-1]*FractRBCFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractRBCFlowX[i+1-1][j-1][k-1]
												+bFlowOut[LabY(i,j,k)-1]*FractRBCFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractRBCFlowY[i-1][jp1-1][k-1]
												+bFlowOut[LabZ(i,j,k)-1]*FractRBCFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractRBCFlowZ[i-1][j-1][kp1-1]);											
										}

									if	(bFlowIn[LabX(i+1,j,k)-1]==true)
										{
											NormFractRBCFlowX[i+1-1][j-1][k-1]=FractRBCFlowX[i+1-1][j-1][k-1]/
												(bFlowOut[LabX(i,j,k)-1]*FractRBCFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractRBCFlowX[i+1-1][j-1][k-1]
												+bFlowOut[LabY(i,j,k)-1]*FractRBCFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractRBCFlowY[i-1][jp1-1][k-1]
												+bFlowOut[LabZ(i,j,k)-1]*FractRBCFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractRBCFlowZ[i-1][j-1][kp1-1]);											
										}

									if	(bFlowOut[LabY(i,j,k)-1]==true)
										{
											NormFractRBCFlowY[i-1][j-1][k-1]=FractRBCFlowY[i-1][j-1][k-1]/
												(bFlowOut[LabX(i,j,k)-1]*FractRBCFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractRBCFlowX[i+1-1][j-1][k-1]
												+bFlowOut[LabY(i,j,k)-1]*FractRBCFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractRBCFlowY[i-1][jp1-1][k-1]
												+bFlowOut[LabZ(i,j,k)-1]*FractRBCFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractRBCFlowZ[i-1][j-1][kp1-1]);											
										}

									if	(bFlowIn[LabY(i,jp1,k)-1]==true)
										{
											NormFractRBCFlowY[i-1][jp1-1][k-1]=FractRBCFlowY[i-1][jp1-1][k-1]/
												(bFlowOut[LabX(i,j,k)-1]*FractRBCFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractRBCFlowX[i+1-1][j-1][k-1]
												+bFlowOut[LabY(i,j,k)-1]*FractRBCFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractRBCFlowY[i-1][jp1-1][k-1]
												+bFlowOut[LabZ(i,j,k)-1]*FractRBCFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractRBCFlowZ[i-1][j-1][kp1-1]);											
										}

									if	(bFlowOut[LabZ(i,j,k)-1]==true)
										{
											NormFractRBCFlowZ[i-1][j-1][k-1]=FractRBCFlowZ[i-1][j-1][k-1]/
												(bFlowOut[LabX(i,j,k)-1]*FractRBCFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractRBCFlowX[i+1-1][j-1][k-1]
												+bFlowOut[LabY(i,j,k)-1]*FractRBCFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractRBCFlowY[i-1][jp1-1][k-1]
												+bFlowOut[LabZ(i,j,k)-1]*FractRBCFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractRBCFlowZ[i-1][j-1][kp1-1]);										
										}

									if	(bFlowIn[LabZ(i,j,kp1)-1]==true)
										{
											NormFractRBCFlowZ[i-1][j-1][kp1-1]=FractRBCFlowZ[i-1][j-1][kp1-1]/
												(bFlowOut[LabX(i,j,k)-1]*FractRBCFlowX[i-1][j-1][k-1]+bFlowIn[LabX(i+1,j,k)-1]*FractRBCFlowX[i+1-1][j-1][k-1]
												+bFlowOut[LabY(i,j,k)-1]*FractRBCFlowY[i-1][j-1][k-1]+bFlowIn[LabY(i,jp1,k)-1]*FractRBCFlowY[i-1][jp1-1][k-1]
												+bFlowOut[LabZ(i,j,k)-1]*FractRBCFlowZ[i-1][j-1][k-1]+bFlowIn[LabZ(i,j,kp1)-1]*FractRBCFlowZ[i-1][j-1][kp1-1]);											
										}
						}


			}}}	//end i,j,k loop

//-----------------------------------------------

//--------------------------------------
//CALCULATE TOTAL MASS IN TO EACH VESSEL
//NB - ONLY THOSE CARRYING RBCS
//--------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalMassIn[i-1][j-1][k-1]=0.0;

				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalMassIn[i-1][j-1][k-1]+=bFlowIn[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;

				TotalMassIn[i-1][j-1][k-1]+=bFlowOut[LabX(i+1,j,k)-1]*fabs(XFlow[i+1-1][j-1][k-1])*pXHem[i+1-1][j-1][k-1]*angioDeltaT*TimeFactor;

				TotalMassIn[i-1][j-1][k-1]+=bFlowIn[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;

				TotalMassIn[i-1][j-1][k-1]+=bFlowOut[LabY(i,jp1,k)-1]*fabs(YFlow[i-1][jp1-1][k-1])*pYHem[i-1][jp1-1][k-1]*angioDeltaT*TimeFactor;

				TotalMassIn[i-1][j-1][k-1]+=bFlowIn[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1]*angioDeltaT*TimeFactor;

		  		TotalMassIn[i-1][j-1][k-1]+=bFlowOut[LabZ(i,j,kp1)-1]*fabs(ZFlow[i-1][j-1][kp1-1])*pZHem[i-1][j-1][kp1-1]*angioDeltaT*TimeFactor;
	
			}}}

//-----------------------------------------------

//--------------------------------
//UPDATE HEMATOCRIT IN EACH VESSEL
//--------------------------------

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugFQE << "loop finished" << endl;	
//	outfileDebugFQE << endl;
//	outfileDebugNodeRadii << endl;
//	outfileDebugNodeRadii << "loop finished" << endl;
//	outfileDebugNodeRadii << endl;
//}

	int zpos;
	int nCount=0;

	if (m_nz==1) {zpos=1;} else {zpos=int(m_nz/2);}

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0)	
//{
//	outfileDebugHem << flowTime << endl;
//}

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==1) {jm1=m_ny;} else {jm1=j-1;}
				if (k==1) {km1=m_nz;} else {km1=k-1;}

//---x-pores---
				if	(i==1)	//inlet nodes
				{	  
					if	(
							!b_TestNetwork && 
							(
								(j==1 && (k==4 || k==10 || k==16 || k==22 || k==29 || k==35 || k==41 || k==47))//(k==7 || k==19 || k==32 || k==44))//k==int(m_nz/10))//5)//(j==1 && k==zpos)//		
								|| 
								//(b_venousIncluded && j==m_ny-1 && k==45)//(b_venousIncluded && j==m_ny-1 && k==zpos)//
								//|| 
								(b_UU_wound_Model && j==nCount*m_ny/(nAdditionalCentralPVs+1) && k==zpos)
								|| 
								(b_UU_wound_Model && j==m_ny-1 && k==zpos)
							)
						)//**arts** 

						{
							if	(!b_HexNetwork || (b_HexNetwork && b_StraightPVs))	//square network or hex network with straight PVs
							{
								pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
														(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
															(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;

								nCount++;
							}

//-----------------------------------------------						
							else if	(b_HexNetwork && !b_StraightPVs)	//hexagonal network	
							{
								if	(int(j/2)-double(j/2.0)==0)	//j even, inlets at j+1
								{
									pXHem[i-1][j+1-1][k-1]+=fabs(XFlow[i-1][j+1-1][k-1])*angioDeltaT/
															(pi*pow(XBR[i-1][j+1-1][k-1],2)*XBL[i-1][j+1-1][k-1]) *
																(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j+1-1][k-1])/MaxHt;
								}

								else	//j odd, inlets at j
								{
									pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
															(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
																(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
								}

								nCount++;	//step to next additional PV

							}	//end if hexagonal network

//-----------------------------------------------
						}	//end if j=...

//-----------------------------------------------											
								//pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06

			  					//pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*timestep/
			  					//(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
			  					//(AverageHt-pXHem[i-1][j-1][k-1]);				
					
//-----------------------------------------------

					if	(b_TestNetwork)
					{
						if	(
								(j==51 && pFluid[LabX(i,51,k)-1]==10)	//one inlet at centre for branching networks
								||
								(j==2 && pFluid[LabX(i,2,k)-1]==10)		//one inlet at top for retina network
							)
						{
							pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
													(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
														(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
						}
					}
					
//-----------------------------------------------
			  //2nd arteriole
			  //if (j==m_ny-1 && k==1) //**2nd art** //Updated SMcD 07.11.06
				//	{
				  //pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
				//		(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
				//		(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
				  
			//		pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06
			//		}

//-----------------------------------------------
				}  //end if i=1

//-----------------------------------------------

				else	//not the inlet port
				{
					if	(TotalFlowOut[i-1][j-1][k-1]>0)
					{
						if	(XFlow[i-1][j-1][k-1]<0.0)
						{
							//hematocrit update based on flow of RBCs (not FQB, as previously)
							pXHem[i-1][j-1][k-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassIn[i-1][j-1][k-1])
													-(pXHem[i-1][j-1][k-1]*fabs(XFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
														/(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "x bond" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1][j-1][k-1] << endl;
//}
						}

						else if (XFlow[i-1][j-1][k-1]>0.0)
						{
							pXHem[i-1][j-1][k-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassIn[i-1-1][j-1][k-1])
													-(pXHem[i-1][j-1][k-1]*fabs(XFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
														/(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "x bond" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1-1][j-1][k-1] << endl;
//}
						}

//-----------------------------------------------
					}	//end if TotalFlowOut>0

				}	//end if i!=1

//-----------------------------------------------
//---y-pores---

				if	(TotalFlowOut[i-1][j-1][k-1]>0)
				{
					if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						pYHem[i-1][j-1][k-1]+=(((NormFractRBCFlowY[i-1][j-1][k-1]*TotalMassIn[i-1][j-1][k-1])
												-(pYHem[i-1][j-1][k-1]*fabs(YFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
													/(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "y bond" << "\t" << i << "\t" << j << "\t" << pYHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1][j-1][k-1] << endl;
//}
					}

					else if (YFlow[i-1][j-1][k-1]>0.0)
					{
						pYHem[i-1][j-1][k-1]+=(((NormFractRBCFlowY[i-1][j-1][k-1]*TotalMassIn[i-1][jm1-1][k-1])
												-(pYHem[i-1][j-1][k-1]*fabs(YFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
													/(pi*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "y bond" << "\t" << i << "\t" << j << "\t" << pYHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1][jm1-1][k-1] << endl;
//}
					}

//-----------------------------------------------
				}	//end if TotalFlowOut>0

//-----------------------------------------------
//---z-pores---
				if	(TotalFlowOut[i-1][j-1][k-1]>0)
				{
					if	(ZFlow[i-1][j-1][k-1]<0.0)
					{
						pZHem[i-1][j-1][k-1]+=(((NormFractRBCFlowZ[i-1][j-1][k-1]*TotalMassIn[i-1][j-1][k-1])
												-(pZHem[i-1][j-1][k-1]*fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
													/(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "z bond" << "\t" << i << "\t" << j << "\t" << pZHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1][j-1][k-1] << endl;
//}
					}

					else if	(ZFlow[i-1][j-1][k-1]>0.0)
					{
						pZHem[i-1][j-1][k-1]+=(((NormFractRBCFlowZ[i-1][j-1][k-1]*TotalMassIn[i-1][j-1][km1-1])
												-(pZHem[i-1][j-1][k-1]*fabs(ZFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
													/(pi*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "z bond" << "\t" << i << "\t" << j << "\t" << pZHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1][j-1][km1-1] << endl;
//}
					}

//-----------------------------------------------
				}	//end if TotalflowOut>0

//-----------------------------------------------
			}	// end i-loop

//-----------------------------------------------
//---x-danglers---
			int i=m_nx+1;

			if	(TotalFlowOut[i-1-1][j-1][k-1]>0)
			{
				pXHem[i-1][j-1][k-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassIn[i-1-1][j-1][k-1])
										-(pXHem[i-1][j-1][k-1]*fabs(XFlow[i-1][j-1][k-1])*angioDeltaT*TimeFactor))
											/(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])/MaxHt);

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "x bond" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1-1][j-1][k-1] << endl;
//}
			}

//-----------------------------------------------
		}	//end j loop
	}	//end k loop

//-----------------------------------------------

//if (i>=60 && i<=80 && j>=70 && j<=90 && flowTime>1000.0) 
//{
//	outfileDebugHem << "loop finished" << endl;
//	outfileDebugHem << endl;
//}

//-----------------------------------------------

//---------------------
//ENSURE MASS CONSERVED
//---------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			int nbz=LabZ(i,j,k);

			if ( pXHem[i-1][j-1][k-1]>1.0)	{pXHem[i-1][j-1][k-1]=1.0;}
			if ( pXHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}
			if ( pYHem[i-1][j-1][k-1]>1.0)	{pYHem[i-1][j-1][k-1]=1.0;}
			if ( pYHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}
			if ( pZHem[i-1][j-1][k-1]>1.0)	{pZHem[i-1][j-1][k-1]=1.0;}
			if ( pZHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}

//-----------------------------------------------
//			if	(loop%200==0)
//			{
//				if	(pFluid[nbx-1]==10)	{outfileDebugHem << flowTime << "\t" << "\t" << "X Hem" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << endl;}
//				if	(pFluid[nby-1]==10)	{outfileDebugHem << flowTime << "\t" << "\t" << "Y Hem" << "\t" << i << "\t" << j << "\t" << pYHem[i-1][j-1][k-1] << endl;}
//			}

//-----------------------------------------------
			}	//end i loop

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if ( pXHem[i-1][j-1][k-1]>1.0)	{pXHem[i-1][j-1][k-1]=1.0;}
			if ( pXHem[i-1][j-1][k-1]<0.0)		{MessageBox("RBCs not conserved");}

//-----------------------------------------------
//			if	(loop%200==0)
//			{
//				if	(pFluid[nbx-1]==10)	{outfileDebugHem << flowTime << "\t" << "\t" << "X Hem" << "\t" << i << "\t" << j << "\t" << pXHem[i-1][j-1][k-1] << endl;}
//			}

//-----------------------------------------------
		}	//end j loop
	}	//end k loop

//	if	(loop%200==0)	{outfileDebugHem << endl;}

//-----------------------------------------------

//---------------
//CLEAR UP ARRAYS
//---------------
	for (int i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] TotalFlowIn[i][j];
			delete[] TotalFlowOut[i][j];
			delete[] TotalMassIn[i][j];
			delete[] NumFlowsOut[i][j];
			delete[] NumFlowsIn[i][j];
			delete[] FractBloodFlowY[i][j];
			delete[] FractBloodFlowZ[i][j];
			delete[] NormFractBloodFlowY[i][j];
			delete[] NormFractBloodFlowZ[i][j];
			delete[] FractRBCFlowY[i][j];
			delete[] FractRBCFlowZ[i][j];
			delete[] CoeffA_Y[i][j];
			delete[] CoeffA_Z[i][j];
			delete[] Adjust_Node[i][j];
		}}

	for (int i=0;i<m_nx;i++)
	{
			delete[] TotalFlowIn[i];
			delete[] TotalFlowOut[i];
			delete[] TotalMassIn[i];
			delete[] NumFlowsOut[i];
			delete[] NumFlowsIn[i];
			delete[] FractBloodFlowY[i];
			delete[] FractBloodFlowZ[i];
			delete[] NormFractBloodFlowY[i];
			delete[] NormFractBloodFlowZ[i];
			delete[] FractRBCFlowY[i];
			delete[] FractRBCFlowZ[i];
			delete[] CoeffA_Y[i];
			delete[] CoeffA_Z[i];
			delete[] Adjust_Node[i];
	}

			delete[] TotalFlowIn;
			delete[] TotalFlowOut;
			delete[] TotalMassIn;
			delete[] NumFlowsOut;
			delete[] NumFlowsIn;
			delete[] FractBloodFlowY;
			delete[] FractBloodFlowZ;
			delete[] NormFractBloodFlowY;
			delete[] NormFractBloodFlowZ;
			delete[] FractRBCFlowY;
			delete[] FractRBCFlowZ;
			delete[] CoeffA_Y;
			delete[] CoeffA_Z;
			delete[] Adjust_Node;

	for (int i=0;i<m_nx+1;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] FractBloodFlowX[i][j];
			delete[] NormFractBloodFlowX[i][j];
			delete[] FractRBCFlowX[i][j];
			delete[] CoeffA_X[i][j];
		}}

	for (int i=0;i<m_nx+1;i++)
	{
			delete[] FractBloodFlowX[i];
			delete[] NormFractBloodFlowX[i];
			delete[] FractRBCFlowX[i];
			delete[] CoeffA_X[i];
	}

			delete[] FractBloodFlowX;
			delete[] NormFractBloodFlowX;
			delete[] FractRBCFlowX;
			delete[] CoeffA_X;

//-----------------------------------------------
}

//***********************************************
//=====================================
void CAngioNetDlg::SaveHematocrit()
//=====================================
//Mike 06/09
{
	outfileSaveHem << angiotime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				outfileSaveHem << i << "\t";
				outfileSaveHem << j << "\t";
				outfileSaveHem << k << "\t";
				if	(pXHem[i-1][j-1][k-1]>1.0e-200)	{outfileSaveHem << pXHem[i-1][j-1][k-1] << "\t";}
				else	{outfileSaveHem << 0.0 << "\t";}
				if	(pYHem[i-1][j-1][k-1]>1.0e-200)	{outfileSaveHem << pYHem[i-1][j-1][k-1] << "\t";}
				else	{outfileSaveHem << 0.0 << "\t";}
				if	(pZHem[i-1][j-1][k-1]>1.0e-200)	{outfileSaveHem << pZHem[i-1][j-1][k-1] << "\t";}
				else	{outfileSaveHem << 0.0 << "\t";}
				outfileSaveHem << endl;
			}

			int i=m_nx+1;

			outfileSaveHem << i << "\t";
			outfileSaveHem << j << "\t";
			outfileSaveHem << k << "\t";
			if	(pXHem[i-1][j-1][k-1]>1.0e-200)	{outfileSaveHem << pXHem[i-1][j-1][k-1] << "\t";}
			else	{outfileSaveHem << 0.0 << "\t";}
			outfileSaveHem << endl;
	}}
}

//***********************************************

//========================================
void CAngioNetDlg::ReadInHematocrit()
//========================================
//Mike 06/09
{
	infileSaveHem >> angiotime;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				infileSaveHem >> i;
				infileSaveHem >> j;
				infileSaveHem >> k;
				infileSaveHem >> pXHem[i-1][j-1][k-1];
				infileSaveHem >> pYHem[i-1][j-1][k-1];
				infileSaveHem >> pZHem[i-1][j-1][k-1];
			}

			int i=m_nx+1;

			infileSaveHem >> i;
			infileSaveHem >> j;
			infileSaveHem >> k;
			infileSaveHem >> pXHem[i-1][j-1][k-1];
	}}
}

//***********************************************

//==============================================
void CAngioNetDlg::CalculateConductedStim(void)
//==============================================
//Mike 07/09 - calculates a further growth stimulus resulting from 
//conduction of signals through the network (adapted from Pries '98)
//
//intended to "increase diameter of segments feeding or draining 
//extensive networks; prevent low-flow, low-generation shunts"
//
//does not take into account flow directions in network (i.e. uses Euclidean 
//distance, rather than flow distance, between connected vessels)
//
//the line i=m_nx/2 is chosen as an imaginary boundary between arterial & 
//venous vessels (stimulus conduction proceeds toward inlets & outlets)
{
/*	int nbx,nby,nbz;
	int nbxx,nbyy,nbzz;
	int ClustLabel1,ClustLabel2;
	double metab;
	double distance;
	double refLength=1.0e-3; //from Pries ('98)	
	double FlowRef=1.0e-14;//1.9096e-11; //m3/s (Flow in PV)
				
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				ConductedStimX[i-1][j-1][k-1]=0.0;
				ConductedStimY[i-1][j-1][k-1]=0.0;
				ConductedStimZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			ConductedStimX[i-1][j-1][k-1]=0.0;
		}
	}
//outfileDebugConStim << "got here" << endl;

//-----------------------------------------------

	Clustering(pIclusO,10,10);//separates network into groups of interconnected "clusters"
//	outfileDebugConStim << "got here" << endl;

//	for (int k=1;k<=m_nz;k++)
//	{	for (int j=1;j<=m_ny;j++)
//		{	for (int i=1;i<=m_nx;i++)
//			{
//				nbx=LabX(i,j,k);
//				nby=LabY(i,j,k);
//				nbz=LabZ(i,j,k);
//
//				if	(pFluid[nbx-1]==10)	{outfileDebugConStim << i << "\t" << j << "\t" << pIclusO[nbx-1] << endl;}
//				if	(pFluid[nby-1]==10)	{outfileDebugConStim << i << "\t" << j << "\t" << pIclusO[nby-1] << endl;}
//			}}}
//outfileDebugConStim << "got here" << endl;

//-----------------------------------------------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
	
				//x-bond produces metabolic stimulus
				if	(pFluid[nbx-1]==10)
					{ 
						ClustLabel1=pIclusO[nbx-1];
				  
						if (XFlow[i-1][j-1][k-1]==0.0 || pXHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
						else {metab=log10((FlowRef/(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]))+1.0);}//Pries equation

						for (int kk=1;kk<=m_nz;kk++)
							{	for (int jj=1;jj<=m_ny;jj++)
								{	for (int ii=1;ii<=m_nx;ii++)
									{
										nbxx=LabX(ii,jj,kk);
										nbyy=LabY(ii,jj,kk);
										nbzz=LabZ(ii,jj,kk);

										//metabolic stimulus not conducted to itself
										if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
											{
												//calculate distance travelled by conducted stimulus
												//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

												//all x-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbxx-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}

												//all y-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbyy-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbyy-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimY[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}

												//all z-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbzz-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbzz-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimZ[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}
											}//end if nbxx!=nbx

									}//end ii loop

									ii=m_nx+1;

									if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
										{
											//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

											//all x-danglers in same cluster also receive conducted stimulus
											if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
												{
													//calculate distance travelled by conducted stimulus
													distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

													ClustLabel2=pIclusO[nbxx-1];

													if	(ClustLabel1==ClustLabel2)
														{
															ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
														}
												}
										}//end if nbxx!=nbx

								}//end jj loop

							}//end kk loop

					}// end if pFluid x

//-----------------------------------------------

				//y-bond produces metabolic stimulus
				if	(pFluid[nby-1]==10)
					{ 
						ClustLabel1=pIclusO[nby-1];
				  
						if (YFlow[i-1][j-1][k-1]==0.0 || pYHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
						else {metab=log10((FlowRef/(fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1]))+1.0);}//Pries equation

						for (int kk=1;kk<=m_nz;kk++)
							{	for (int jj=1;jj<=m_ny;jj++)
								{	for (int ii=1;ii<=m_nx;ii++)
									{
										nbxx=LabX(ii,jj,kk);
										nbyy=LabY(ii,jj,kk);
										nbzz=LabZ(ii,jj,kk);

										//metabolic stimulus not conducted to itself
										if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
											{
												//calculate distance travelled by conducted stimulus
												//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

												//all x-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbxx-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}

												//all y-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbyy-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbyy-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimY[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}

												//all z-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbzz-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbzz-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimZ[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}
											}//end if nbxx!=nbx

									}//end ii loop

									ii=m_nx+1;

									if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
										{
											//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

											//all x-danglers in same cluster also receive conducted stimulus
											if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
												{
													//calculate distance travelled by conducted stimulus
													distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

													ClustLabel2=pIclusO[nbxx-1];

													if	(ClustLabel1==ClustLabel2)
														{
															ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
														}
												}
										}//end if nbxx!=nbx

								}//end jj loop

							}//end kk loop

					}//end if pFluid y

//-----------------------------------------------

				//z-bond produces metabolic stimulus
				if	(pFluid[nbz-1]==10)
					{ 
						ClustLabel1=pIclusO[nbz-1];
				  
						if (ZFlow[i-1][j-1][k-1]==0.0 || pZHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
						else {metab=log10((FlowRef/(fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1]))+1.0);}//Pries equation

						for (int kk=1;kk<=m_nz;kk++)
							{	for (int jj=1;jj<=m_ny;jj++)
								{	for (int ii=1;ii<=m_nx;ii++)
									{
										nbxx=LabX(ii,jj,kk);
										nbyy=LabY(ii,jj,kk);
										nbzz=LabZ(ii,jj,kk);

										//metabolic stimulus not conducted to itself
										if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
											{
												//calculate distance travelled by conducted stimulus
												//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

												//all x-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbxx-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}

												//all y-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbyy-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbyy-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimY[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}

												//all z-bonds in same cluster receive conducted stimulus
												if	(pFluid[nbzz-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
													{
														//calculate distance travelled by conducted stimulus
														distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

														ClustLabel2=pIclusO[nbzz-1];

														if	(ClustLabel1==ClustLabel2)
															{
																ConductedStimZ[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
															}
													}
											}//end if nbxx!=nbx

									}//end ii loop

									ii=m_nx+1;

									if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
										{
											//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

											//all x-danglers in same cluster also receive conducted stimulus
											if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
												{
													//calculate distance travelled by conducted stimulus
													distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

													ClustLabel2=pIclusO[nbxx-1];

													if	(ClustLabel1==ClustLabel2)
														{
															ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
														}
												}
										}//end if nbxx!=nbx

								}//end jj loop

							}//end kk loop

					}//end if pFluid z

//-----------------------------------------------

			}//end i loop

			i=m_nx+1;

			nbx=LabX(i,j,k);
				
			//x-danglers also produce metabolic stimulus
			if	(pFluid[nbx-1]==10)
				{ 
					ClustLabel1=pIclusO[nbx-1];
				  
					if (XFlow[i-1][j-1][k-1]==0.0 || pXHem[i-1][j-1][k-1]<0.001) {metab=0.0;} 
					else {metab=log10((FlowRef/(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1]))+1.0);}//Pries equation

					for (int kk=1;kk<=m_nz;kk++)
						{	for (int jj=1;jj<=m_ny;jj++)
							{	for (int ii=1;ii<=m_nx;ii++)
								{
									nbxx=LabX(ii,jj,kk);
									nbyy=LabY(ii,jj,kk);
									nbzz=LabZ(ii,jj,kk);

									//metabolic stimulus not conducted to itself
									if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
										{
											//calculate distance travelled by conducted stimulus
											//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

											//all x-bonds in same cluster receive conducted stimulus
											if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
												{
													//calculate distance travelled by conducted stimulus
													distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

													ClustLabel2=pIclusO[nbxx-1];

													if	(ClustLabel1==ClustLabel2)
														{
															ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
														}
												}

											//all y-bonds in same cluster receive conducted stimulus
											if	(pFluid[nbyy-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
												{
													//calculate distance travelled by conducted stimulus
													distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

													ClustLabel2=pIclusO[nbyy-1];

													if	(ClustLabel1==ClustLabel2)
														{
															ConductedStimY[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
														}
												}

											//all z-bonds in same cluster receive conducted stimulus
											if	(pFluid[nbzz-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
												{
													//calculate distance travelled by conducted stimulus
													distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

													ClustLabel2=pIclusO[nbzz-1];

													if	(ClustLabel1==ClustLabel2)
														{
															ConductedStimZ[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
														}
												}
										}//end if nbxx!=nbx

								}//end ii loop

								ii=m_nx+1;

								if	(nbxx!=nbx && nbyy!=nby && nbzz!=nbz)
									{
										//distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

										//all x-danglers in same cluster also receive conducted stimulus
										if	(pFluid[nbxx-1]==10 && (i-m_nx/2)*(ii-m_nx/2)>0 && ((ii<m_nx/2 && ii<i) || (ii>m_nx/2 && ii>i)))
											{
												//calculate distance travelled by conducted stimulus
												distance=bondLength*sqrt(pow(i-ii,2)+pow(j-jj,2)+pow(k-kk,2));

												ClustLabel2=pIclusO[nbxx-1];

												if	(ClustLabel1==ClustLabel2)
													{
														ConductedStimX[ii-1][jj-1][kk-1]+=metab*exp(-distance/refLength);
													}
											}
									}//end if nbxx!=nbx 

							}//end jj loop

						}//end kk loop

				}//end if pFluid x

//-----------------------------------------------

		}//end j loop

	}//end k loop
*/
/*	if	(loop%250==0)
	{
		outfileDebugConStim << flowTime << endl;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					nbx=LabX(i,j,k);
					nby=LabY(i,j,k);
					nbz=LabZ(i,j,k);

					if	(pFluid[nbx-1]==10)	{outfileDebugConStim << "x-bond" << "\t" << i << "\t" << j << "\t" 
																 << ConductedStimX[i-1][j-1][k-1] << endl;}
					if	(pFluid[nby-1]==10)	{outfileDebugConStim << "y-bond" << "\t" << i << "\t" << j << "\t" 
																 << ConductedStimY[i-1][j-1][k-1] << endl;}
				}
			}
		}
		outfileDebugConStim << endl;
	}
*/

	int i,j,k,ii,jj,kk;
	int nbx,nby,nbz;
		
	int ConductDistance=Nbond;
	int ConductLoopCounter=0;
	int ConductRefLength=int(3.5*m_nx);//(see Pries)//350;//50;	//no. of bonds
	int ReceiveStimNodes=0;
	double FlowRef=1.0e-18*6.0e13;
	double DecayIndex=1.0/ConductRefLength;

	int Nnode=m_nx*m_ny*m_nz;
	bool* ReceiveStim=NULL;
	bool* StimIndicator=NULL;
	double* NodeStim=NULL;
	ReceiveStim=new bool[Nnode];
	StimIndicator=new bool[Nnode];
	NodeStim=new double[Nnode];

	for	(int n=1;n<=Nnode;n++)	
	{
		ReceiveStim[n-1]=false;	
		StimIndicator[n-1]=false;
		NodeStim[n-1]=0.0;
	}

//-----------------------------------------------
	int*** NumFlowsIn=NULL;
	
	NumFlowsIn=new int**[m_nx];
	
	for (i=0;i<m_nx;i++)
	{
		NumFlowsIn[i]=new int* [m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			NumFlowsIn[i][j]=new int [m_nz];
		}
	}

//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				ConductedStimX[i-1][j-1][k-1]=0.0;
				ConductedStimY[i-1][j-1][k-1]=0.0;
				ConductedStimZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			ConductedStimX[i-1][j-1][k-1]=0.0;
		}
	}
	
//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				NumFlowsIn[i-1][j-1][k-1]=0;

//---x-bond to left---
				if	(
						XFlow[i-1][j-1][k-1]>0.0
						&& fabs(XFlow[i-1][j-1][k-1])>=1.0e-18
					)
				{
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}

//---x-bond to right---
				if	(
						XFlow[i+1-1][j-1][k-1]<0.0
						&& fabs(XFlow[i+1-1][j-1][k-1])>=1.0e-18
					)
				{
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}
						
//---y-bond above---
				if	(
						YFlow[i-1][j-1][k-1]>0.0
						&& fabs(YFlow[i-1][j-1][k-1])>=1.0e-18
					)
				{
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}

//---y-bond below---
				if	(j!=m_ny)
				{
					if	(
							YFlow[i-1][j+1-1][k-1]<0.0
							&& fabs(YFlow[i-1][j+1-1][k-1])>=1.0e-18
						)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---z-bond out of screen---
				if	(
						ZFlow[i-1][j-1][k-1]>0.0
						&& fabs(ZFlow[i-1][j-1][k-1])>=1.0e-18
					)
				{
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}

//---z-bond into screen---
				if	(k!=m_nz)
				{
					if	(
							ZFlow[i-1][j-1][k+1-1]<0.0
							&& fabs(ZFlow[i-1][j-1][k+1-1])>=1.0e-18
						)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}
//-----------------------------------------------
			}	//end i loop
		}	//end j loop
	}	//end k loop

//-----------------------------------------------
//if	(loop%1000==0)	{outfileDebugConductedStim << flowTime << endl;}

//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

//-----------------------------------------------
//---x-bonds conduct stimulus---
				if	(pFluid[nbx-1]==10) 
				{	
					if	(ConvectedStimX[i-1][j-1][k-1]>0.0)
					{
						ConductedStimX[i-1][j-1][k-1]+=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
														(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
														
//if	(loop%1000==0)	{outfileDebugConductedStim << "x-bond (" << i << "," << j << ") generates stim of " << log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef))) << endl;}

						
						if	(XFlow[i-1][j-1][k-1]>0.0)
						{
							if	(i!=1)
							{
								ReceiveStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

								NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
																				(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
							}
						
//if	(loop%1000==0)	{outfileDebugConductedStim << "node (" << i-1 << "," << j << ") receives " << log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef))) << endl;}
						}

						else if	(XFlow[i-1][j-1][k-1]<0.0)
						{
							ReceiveStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
																		(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));

//if	(loop%1000==0)	{outfileDebugConductedStim << "node (" << i << "," << j << ") receives " << log10(1+(ConvectedStimX[i-1][j-1][k-1]/(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef))) << endl;}
							
						}

						ConductLoopCounter+=1;

						for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
						while	(ConductLoopCounter<ConductDistance && ReceiveStimNodes>0)
						{

//if	(loop%1000==0)	{outfileDebugConductedStim << "--------------------" << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << "Loop Number: " << ConductLoopCounter << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << "No. of Nodes: " << ReceiveStimNodes << endl;}

							ReceiveStimNodes=0;

							for	(kk=1;kk<=m_nz;kk++)
							{	for	(jj=1;jj<=m_ny;jj++)
								{	for	(ii=1;ii<=m_nx;ii++)
									{
										if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
										{
//if	(loop%1000==0)	{outfileDebugConductedStim << "node passing stim is (" << ii << "," << jj << ")" << endl;}
											//x-bond to left
											if	(
													XFlow[ii-1][jj-1][kk-1]>0.0 
													&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimX[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
																								
												if	(ii!=1)	
												{
													StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

//if	(loop%1000==0)	{outfileDebugConductedStim << "node (" << ii-1 << "," << jj << ") receives " << (NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1] << endl;}

												}
											}

											//x-bond to right
											if	(
													XFlow[ii+1-1][jj-1][kk-1]<0.0 
													&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimX[ii+1-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(ii!=m_nx)	
												{
													StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

//if	(loop%1000==0)	{outfileDebugConductedStim << "node (" << ii+1 << "," << jj << ") receives " << (NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1] << endl;}

												}
											}

											//y-bond above
											if	(
													YFlow[ii-1][jj-1][kk-1]>0.0
													&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimY[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(jj!=1)	
												{
													StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

//if	(loop%1000==0)	{outfileDebugConductedStim << "node (" << ii << "," << jj-1 << ") receives " << (NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1] << endl;}

												}
											}

											//y-bond below
											if	(jj!=m_ny)
											{
												if	(
														YFlow[ii-1][jj+1-1][kk-1]<0.0
														&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
													)
												{
													ConductedStimY[ii-1][jj+1-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

													StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

//if	(loop%1000==0)	{outfileDebugConductedStim << "node (" << ii << "," << jj+1 << ") receives " << (NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1] << endl;}
												}
											}

											//z-bond out of screen
											if	(
													ZFlow[ii-1][jj-1][kk-1]>0.0
													&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimZ[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(kk!=1)	
												{
													StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//z-bond into screen
											if	(kk!=m_nz)
											{
												if	(
														ZFlow[ii-1][jj-1][kk+1-1]<0.0
														&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
													)
												{
													ConductedStimZ[ii-1][jj-1][kk+1-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

													StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

											NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

//if	(loop%1000==0)	{outfileDebugConductedStim << endl;}

										}	//end if ReceiveStim=true

//-----------------------------------------------
									}	//end ii loop

								}	//end jj loop

							}	//end kk loop

//-----------------------------------------------
							for	(int n=1;n<=Nnode;n++)	
							{
								ReceiveStim[n-1]=StimIndicator[n-1];
								ReceiveStimNodes+=ReceiveStim[n-1];
								StimIndicator[n-1]=false;
							}

							ConductLoopCounter+=1;

//-----------------------------------------------
						}	//end while loop

						ConductLoopCounter=0;

						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=false;
							NodeStim[n-1]=0.0;
						}
//if	(loop%1000==0)	{outfileDebugConductedStim << "end of x-bond" << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << "====================" << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << endl;}
//-----------------------------------------------
					}	//end if O2 < O2,ref

				}	//end if pFluid=10


//-----------------------------------------------
//---y-bonds convect stimulus---

				if	(pFluid[nby-1]==10) 
				{
					if	(
							ConvectedStimY[i-1][j-1][k-1]>0.0
						)
					{
						ConductedStimY[i-1][j-1][k-1]+=log10(1+(ConvectedStimY[i-1][j-1][k-1]/
														(fabs(YFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));

						
						if	(YFlow[i-1][j-1][k-1]<0.0)
						{
							ReceiveStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimY[i-1][j-1][k-1]/
																		(fabs(YFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
						}

						else if	(YFlow[i-1][j-1][k-1]>0.0)
						{
							if	(j!=1)	
							{
								ReceiveStim[i+((j-1)-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

								NodeStim[i+((j-1)-1)*m_nx+(k-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimY[i-1][j-1][k-1]/
																				(fabs(YFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
							}
						}

						ConductLoopCounter+=1;

						for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
						while	(ConductLoopCounter<ConductDistance && ReceiveStimNodes>0)
						{
							ReceiveStimNodes=0;

							for	(kk=1;kk<=m_nz;kk++)
							{	for	(jj=1;jj<=m_ny;jj++)
								{	for	(ii=1;ii<=m_nx;ii++)
									{
										if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
										{
											//x-bond to left
											if	(
													XFlow[ii-1][jj-1][kk-1]>0.0 
													&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimX[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												
												if	(ii!=1)	
												{
													StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//x-bond to right
											if	(
													XFlow[ii+1-1][jj-1][kk-1]<0.0 
													&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimX[ii+1-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(ii!=m_nx)	
												{
													StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//y-bond above
											if	(
													YFlow[ii-1][jj-1][kk-1]>0.0
													&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimY[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(jj!=1)	
												{
													StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//y-bond below
											if	(jj!=m_ny)
											{
												if	(
														YFlow[ii-1][jj+1-1][kk-1]<0.0
														&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
													)
												{
													ConductedStimY[ii-1][jj+1-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

													StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//z-bond out of screen
											if	(
													ZFlow[ii-1][jj-1][kk-1]>0.0
													&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimZ[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(kk!=1)	
												{
													StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//z-bond into screen
											if	(kk!=m_nz)
											{
												if	(
														ZFlow[ii-1][jj-1][kk+1-1]<0.0
														&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
													)
												{
													ConductedStimZ[ii-1][jj-1][kk+1-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

													StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

											NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

										}	//end if ReceiveStim=true

//-----------------------------------------------
									}	//end ii loop

								}	//end jj loop

							}	//end kk loop

//-----------------------------------------------
							for	(int n=1;n<=Nnode;n++)	
							{
								ReceiveStim[n-1]=StimIndicator[n-1];
								ReceiveStimNodes+=ReceiveStim[n-1];
								StimIndicator[n-1]=false;
							}

							ConductLoopCounter+=1;

//-----------------------------------------------
						}	//end while loop

						ConductLoopCounter=0;

						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=false;
							NodeStim[n-1]=0.0;
						}

//-----------------------------------------------
					}	//end if O2 < O2,ref

				}	//end if pFluid=10

//-----------------------------------------------
//---z-bonds convect stimulus---

				if	(pFluid[nbz-1]==10) 
				{
					if	(
							ConvectedStimZ[i-1][j-1][k-1]>0.0
						)
					{
						ConductedStimZ[i-1][j-1][k-1]+=log10(1+(ConvectedStimZ[i-1][j-1][k-1]/
														(fabs(ZFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));

						
						if	(ZFlow[i-1][j-1][k-1]<0.0)
						{
							ReceiveStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimZ[i-1][j-1][k-1]/
																		(fabs(ZFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
						}

						else if	(ZFlow[i-1][j-1][k-1]>0.0)
						{
							if	(k!=1)	
							{
								ReceiveStim[i+(j-1)*m_nx+((k-1)-1)*m_nx*m_ny-1]=true;

								NodeStim[i+(j-1)*m_nx+((k-1)-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimZ[i-1][j-1][k-1]/
																				(fabs(ZFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
							}
						}

						ConductLoopCounter+=1;

						for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
						while	(ConductLoopCounter<ConductDistance && ReceiveStimNodes>0)
						{
							ReceiveStimNodes=0;

							for	(kk=1;kk<=m_nz;kk++)
							{	for	(jj=1;jj<=m_ny;jj++)
								{	for	(ii=1;ii<=m_nx;ii++)
									{
										if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
										{
											//x-bond to left
											if	(
													XFlow[ii-1][jj-1][kk-1]>0.0 
													&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimX[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												
												if	(ii!=1)	
												{
													StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//x-bond to right
											if	(
													XFlow[ii+1-1][jj-1][kk-1]<0.0 
													&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimX[ii+1-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(ii!=m_nx)	
												{
													StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//y-bond above
											if	(
													YFlow[ii-1][jj-1][kk-1]>0.0
													&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimY[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(jj!=1)	
												{
													StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//y-bond below
											if	(jj!=m_ny)
											{
												if	(
														YFlow[ii-1][jj+1-1][kk-1]<0.0
														&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
													)
												{
													ConductedStimY[ii-1][jj+1-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

													StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//z-bond out of screen
											if	(
													ZFlow[ii-1][jj-1][kk-1]>0.0
													&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimZ[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												if	(kk!=1)	
												{
													StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											//z-bond into screen
											if	(kk!=m_nz)
											{
												if	(
														ZFlow[ii-1][jj-1][kk+1-1]<0.0
														&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
													)
												{
													ConductedStimZ[ii-1][jj-1][kk+1-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

													StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																										*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												}
											}

											ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

											NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

										}	//end if ReceiveStim=true

//-----------------------------------------------
									}	//end ii loop

								}	//end jj loop

							}	//end kk loop

//-----------------------------------------------
							for	(int n=1;n<=Nnode;n++)	
							{
								ReceiveStim[n-1]=StimIndicator[n-1];
								ReceiveStimNodes+=ReceiveStim[n-1];
								StimIndicator[n-1]=false;
							}

							ConductLoopCounter+=1;

//-----------------------------------------------
						}	//end while loop

						ConductLoopCounter=0;

						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=false;
							NodeStim[n-1]=0.0;
						}

//-----------------------------------------------
					}	//end if O2 < O2,ref

				}	//end if pFluid=10

//-----------------------------------------------
//-----------------------------------------------
			}	//end i loop

//-----------------------------------------------
//---x-danglers convect stimulus---
			i=m_nx+1;
			nbx=LabX(i,j,k);

			if	(pFluid[nbx-1]==10) 
			{
				if	(
						ConvectedStimX[i-1][j-1][k-1]>0.0
					)
				{
					ConductedStimX[i-1][j-1][k-1]+=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
													(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));

						
					if	(XFlow[i-1][j-1][k-1]>0.0)
						{
							ReceiveStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
																		(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
						}

					else if	(XFlow[i-1][j-1][k-1]<0.0)	{}

					ConductLoopCounter+=1;

					for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
					while	(ConductLoopCounter<ConductDistance && ReceiveStimNodes>0)
					{
						ReceiveStimNodes=0;

						for	(kk=1;kk<=m_nz;kk++)
						{	for	(jj=1;jj<=m_ny;jj++)
							{	for	(ii=1;ii<=m_nx;ii++)
								{
									if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
									{
										//x-bond to left
										if	(
												XFlow[ii-1][jj-1][kk-1]>0.0 
												&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConductedStimX[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																				*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
												
											if	(ii!=1)	
											{
												StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																									*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
											}
										}

										//x-bond to right
										if	(
												XFlow[ii+1-1][jj-1][kk-1]<0.0 
												&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConductedStimX[ii+1-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

											if	(ii!=m_nx)	
											{
												StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																									*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
											}
										}

										//y-bond above
										if	(
												YFlow[ii-1][jj-1][kk-1]>0.0
												&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConductedStimY[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																				*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

											if	(jj!=1)	
											{
												StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																									*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
											}
										}

										//y-bond below
										if	(jj!=m_ny)
										{
											if	(
													YFlow[ii-1][jj+1-1][kk-1]<0.0
													&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
												)
											{
												ConductedStimY[ii-1][jj+1-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																									*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
											}
										}

										//z-bond out of screen
										if	(
												ZFlow[ii-1][jj-1][kk-1]>0.0
												&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConductedStimZ[ii-1][jj-1][kk-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																				*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

											if	(kk!=1)	
											{
												StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																									*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
											}
										}

										//z-bond into screen
										if	(kk!=m_nz)
										{
											if	(
													ZFlow[ii-1][jj-1][kk+1-1]<0.0
													&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
												)
											{
												ConductedStimZ[ii-1][jj-1][kk+1-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];

												StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]
																									*exp(-DecayIndex))/NumFlowsIn[ii-1][jj-1][kk-1];
											}
										}

										ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

										NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

									}	//end if ReceiveStim=true

//-----------------------------------------------
								}	//end ii loop

							}	//end jj loop

						}	//end kk loop

//-----------------------------------------------
						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=StimIndicator[n-1];
							ReceiveStimNodes+=ReceiveStim[n-1];
							StimIndicator[n-1]=false;
						}

						ConductLoopCounter+=1;

//-----------------------------------------------
					}	//end while loop

					ConductLoopCounter=0;

					for	(int n=1;n<=Nnode;n++)	
					{
						ReceiveStim[n-1]=false;
						NodeStim[n-1]=0.0;
					}

//-----------------------------------------------
				}	//end if O2 < O2,ref

			}	//end if pFluid=10

//-----------------------------------------------
		}	//end j loop

	}	//end k loop

//if	(loop%1000==0)	{outfileDebugConductedStim << "loop finished" << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << "===================" << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << "===================" << endl;}
//if	(loop%1000==0)	{outfileDebugConductedStim << endl;}
//-----------------------------------------------

	for	(i=1;i<=m_nx;i++)
	{	for(j=1;j<=m_ny;j++)
		{
			k=1;

			if	(loop%1000==0)	
			{
				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConductedStim2 << i << "\t" << j << "\t" << ConductedStimX[i-1][j-1][k-1] << endl;}
			}
		}
	}

	for(j=1;j<=m_ny;j++)
	{
			i=m_nx+1;
			k=1;

			if	(loop%1000==0)	
			{
				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConductedStim2 << i << "\t" << j << "\t" << ConductedStimX[i-1][j-1][k-1] << endl;}
			}
	}

//-----------------------------------------------
//---Clear up arrays---

	for (i=0;i<m_nx;i++)
	{	for (int j=0;j<m_ny;j++)
		{
			delete[] NumFlowsIn[i][j];
		}
	}

	for (i=0;i<m_nx;i++)
	{
		delete[] NumFlowsIn[i];
	}

	delete[] NumFlowsIn;
	
	delete[] NodeStim;
	delete[] StimIndicator;
	delete[] ReceiveStim;

}

//***********************************************

//==========================================
void CAngioNetDlg::CalculateWoundArea(void)
//==========================================
//Calculates the wound area by considering the nearest
//perfused vessel in each quadrant of the domain
{
//---Method 1------------------------------------
//-----------------------------------------------
	int i,j,k;
	int nbx,nby;
	double distance;
	double WoundRadius1=1e20;
	double WoundRadius2=1e20;
	double WoundRadius3=1e20;
	double WoundRadius4=1e20;
	double AvgWoundRadius1=0.0;
	double WoundArea1=0.0;

	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);

				//1st quadrant (top left)				
				if	(i<=m_nx/2 && j<m_ny/2)
					{
						distance=0.0;

						if		(
									(pFluid[nbx-1]==10 && pXHem[i-1][j-1][k-1]>0.02) 
									|| 
									(pFluid[nby-1]==10 && pYHem[i-1][j-1][k-1]>0.02) 
								)
								{
									distance=bondLength*sqrt(pow(i-iCentre,2)+pow(j-jCentre,2));

									if	(distance<WoundRadius1)
										{
											WoundRadius1=distance;	//in metres
										}
								}

						else	{}
					}//end if 1st quadrant

				//2nd quadrant (top right)
				if	(i>m_nx/2 && j<m_ny/2)
					{
						distance=0.0;

						if		(
									(pFluid[nbx-1]==10 && pXHem[i-1][j-1][k-1]>0.02) 
									|| 
									(pFluid[nby-1]==10 && pYHem[i-1][j-1][k-1]>0.02) 
								)
								{
									distance=bondLength*sqrt(pow(i-iCentre,2)+pow(j-jCentre,2));

									if	(distance<WoundRadius2)
										{
											WoundRadius2=distance;	//in metres
										}
								}

						else	{}
					}//end if second quadrant

				//3rd quadrant (bottom left)
				if	(i<=m_nx/2 && j>=m_ny/2)
					{
						distance=0.0;

						if		(
									(pFluid[nbx-1]==10 && pXHem[i-1][j-1][k-1]>0.02) 
									|| 
									(pFluid[nby-1]==10 && pYHem[i-1][j-1][k-1]>0.02) 
								)
								{
									distance=bondLength*sqrt(pow(i-iCentre,2)+pow(j-jCentre,2));

									if	(distance<WoundRadius3)
										{
											WoundRadius3=distance;	//in metres
										}
								}

						else	{}
					}//end if 3rd quadrant

				//4th quadrant (bottom right)
				if	(i>m_nx/2 && j>=m_ny/2)
					{
						distance=0.0;

						if		(
									(pFluid[nbx-1]==10 && pXHem[i-1][j-1][k-1]>0.02) 
									|| 
									(pFluid[nby-1]==10 && pYHem[i-1][j-1][k-1]>0.02) 
								)
								{
									distance=bondLength*sqrt(pow(i-iCentre,2)+pow(j-jCentre,2));

									if	(distance<WoundRadius4)
										{
											WoundRadius4=distance;	//in metres
										}
								}

						else	{}
					}//end if 4th quadrant
	//-------------------------------------------

			}//end i loop (no need to consider danglers - should always be closer perfused vessel)
		}//end j loop
	}//end k loop

	AvgWoundRadius1=(WoundRadius1+WoundRadius2+WoundRadius3+WoundRadius4)/4;	//in metres

	WoundArea1=PI*pow(AvgWoundRadius1,2)*1000000;	// in mm^2

	outfileWoundArea << angiotime << "\t" << WoundRadius1 << "\t" << WoundRadius2 << "\t" << 
		WoundRadius3 << "\t" << WoundRadius4 << "\t" << AvgWoundRadius1 << "\t" << WoundArea1 << endl;

//-----------------------------------------------

//---Method 2------------------------------------
//-----------------------------------------------
	int nSampleRegions=32;//16;
	double theta_end=0.0;
	double theta_start=0.0;
	double RadiiSum=0.0;
	double WoundArea2=0.0;
	double* NodeAngle=NULL;
	double* RegionRadius=NULL;
	int Nnode=m_nx*m_ny*m_nz;
	double AvgWoundRadius2=0.0;

	NumBondsRadius=0;	//global variable for graphics

	NodeAngle=new double[Nnode];
	RegionRadius=new double[nSampleRegions];

	for	(int n=1;n<=Nnode;n++)
	{
		NodeAngle[n-1]=0.0;
	}

	for	(int p=1;p<=nSampleRegions;p++)
	{
		RegionRadius[p-1]=1.0e20;
	}

	outfileWoundArea2 << angiotime << "\t";
	
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				if	(i>=m_nx/2 && j>=m_ny/2)	{NodeAngle[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=atan(double(i-m_nx/2)/double(j-m_ny/2));}
				else if	(i>=m_nx/2 && j<m_ny/2)	{NodeAngle[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=PI/2+atan(double(m_ny/2-j)/double(i-m_nx/2));}
				else if	(i<m_nx/2 && j<m_ny/2)	{NodeAngle[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=PI+atan(double(m_nx/2-i)/double(m_ny/2-j));}
				else if	(i<m_nx/2 && j>=m_ny/2)	{NodeAngle[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=3*PI/2+atan(double(j-m_ny/2)/double(m_nx/2-i));}
			}
		}
	}

	for (int region=1;region<=nSampleRegions;region++)
	{
		theta_start=(double(region-1)/double(nSampleRegions))*2*PI;
		theta_end=(double(region)/double(nSampleRegions))*2*PI;

		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)
			{	for (i=1;i<=m_nx;i++)
				{
					if	(NodeAngle[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]>=theta_start && NodeAngle[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]<theta_end)
					{
						int nbx=LabX(i,j,k);
						int nby=LabY(i,j,k);

						distance=0.0;

						if	(
								(pFluid[nbx-1]==10)// && FalseFlow[nbx-1]==false && fabs(XFlow[i-1][j-1][k-1])>1.0e-24) 
								||																				
								(pFluid[nby-1]==10)// && FalseFlow[nby-1]==false && fabs(YFlow[i-1][j-1][k-1])>1.0e-24)
							)
						{
                        	distance=bondLength*sqrt(pow(i-iCentre,2)+pow(j-jCentre,2));

							if	(distance<RegionRadius[region-1])
							{
								RegionRadius[region-1]=distance;	//in metres
							}
						}

						if	(RegionRadius[region-1]==1.0e20)	
						{
							RegionRadius[region-1]=bondLength*sqrt(pow(i_UU_WoundRad-iCentre,2)+pow(i_UU_WoundRad-jCentre,2));
						}
					}
				}
			}
		}
		
		RadiiSum+=RegionRadius[region-1];

		outfileWoundArea2 << RegionRadius[region-1] << "\t";
	}

	AvgWoundRadius2=double(RadiiSum)/double(nSampleRegions);	//in metres
	NumBondsRadius=(int)(AvgWoundRadius2/bondLength);
	WoundArea2=PI*pow(AvgWoundRadius2,2)*1000000;	// in mm^2

	outfileWoundArea2 << AvgWoundRadius2 << "\t" << NumBondsRadius << "\t" << WoundArea2 << endl;

//-----------------------------------------------

//---Method 3------------------------------------
//-----------------------------------------------
	double WoundArea3=0.0;

	for (int n=1;n<=Nnode;n++)
	{
		bCountBlock[n-1]=false;
	}

	outfileWoundArea3 << angiotime << "\t";

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if	(
						(i>=iCentre-(int)sqrt(  pow(i_UU_WoundRad,2)-pow(j-jCentre,2) ) && i<iCentre)
						||
						(i<=iCentre+(int)sqrt(  pow(i_UU_WoundRad,2)-pow(j-jCentre,2) ) && i>iCentre)
						||
						(i==iCentre && j>=jCentre-i_UU_WoundRad && j<=jCentre+i_UU_WoundRad)
					)
				{
					bCountBlock[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

					if	(
							(FalseFlow[LabX(i,j,k)-1]==false && fabs(XFlow[i-1][j-1][k-1])>0.0)
							||
							(FalseFlow[LabY(i,j,k)-1]==false && fabs(YFlow[i-1][j-1][k-1])>0.0)
							||
							(FalseFlow[LabX(i+1,j,k)-1]==false && fabs(XFlow[i+1-1][j-1][k-1])>0.0)
							||
							(FalseFlow[LabY(i,j+1,k)-1]==false && fabs(XFlow[i-1][j+1-1][k-1])>0.0)
						)
					{
//outfileWoundArea3 << FalseFlow[LabX(i,j,k)-1] << "\t" << fabs(XFlow[i-1][j-1][k-1]) << "\t" << FalseFlow[LabY(i,j,k)-1] << "\t" << fabs(YFlow[i-1][j-1][k-1]) << 
//"\t" << FalseFlow[LabX(i+1,j,k)-1] << "\t" << fabs(XFlow[i+1-1][j-1][k-1]) << "\t" << FalseFlow[LabY(i,j+1,k)-1] << "\t" << fabs(XFlow[i-1][j+1-1][k-1]) << "\t";
						bCountBlock[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=false;
					}
				}
			}
		}
	}

	for (int n=1;n<=Nnode;n++)
	{
		if	(bCountBlock[n-1]==true)	{WoundArea3+=pow(bondLength,2)*1000000;}
	}

	outfileWoundArea3 << WoundArea3 << endl;
//-----------------------------------------------

	delete[] NodeAngle;
	delete[] RegionRadius;

}
//------------------------------------------
//******************************************

//===============================================
void CAngioNetDlg::PutInTestNetwork(void)
//===============================================
{
	int i,j,k;
	if (m_nz==1) {k=1;} else { k=int(m_nz/2); }

//-----------------------------------------------
//---Branching network---
/*	int ibegin=0;
	int ibranch=26;
	int NumVessels=1;
	int iSection=1;

	while	(NumVessels<33)
	{
		for	(int nCount=1;nCount<=2*NumVessels-1;nCount++)
		{
			int jcoord=nCount*m_ny/(2*NumVessels)+1;

            if	(int(nCount/2)-double(nCount/2.0)!=0)//if nCount odd
			{
				for	(i=ibegin+1;i<=ibranch;i++)	
				{
					pFluid[LabX(i,jcoord,k)-1]=10;
					XBR[i-1][jcoord-1][k-1]=4.0e-6;//(14.0-(2.0*(iSection-1)))*1.0e-6;
					pArterialVenousID[LabX(i,jcoord,k)-1]=1;
				}
			}	//end if nCount odd

			if	(
					double(nCount/2.0)-int(nCount/2)==0	//if nCount even &
					&&									//not a multiple of 4
					double(nCount/4.0)-int(nCount/4)!=0	//(i.e. 2,6,10,...)
				)	
			{
				for (j=(nCount-1)*m_ny/(2*NumVessels)+1+1;j<=(nCount+1)*m_ny/(2*NumVessels)+1;j++)
				{
					pFluid[LabY(ibegin,j,k)-1]=10;
					YBR[ibegin-1][j-1][k-1]=4.0e-6;//(14.0-(2.0*(iSection-1)))*1.0e-6;
					pArterialVenousID[LabY(ibegin,j,k)-1]=1;
				}
			}	//end if nCount even
		}	//end nCount loop

		ibegin=ibranch;
		ibranch+=(6-iSection)*5;
		NumVessels*=2;
		iSection+=1;

	}	//end while loop
*/
//-----------------------------------------------
//---"Retina" network---
	for	(j=1;j<=m_ny;j++)
	{	for	(i=1;i<=m_nx+1;i++)
		{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);
			
			infileRetinaXBonds >> pFluid[nbx-1];
			if	(pFluid[nbx-1]==10)	
			{
				XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
				pArterialVenousID[nbx-1]=1;
			}

			if	(i!=m_nx+1)	{infileRetinaYBonds >> pFluid[nby-1];}
			if	(pFluid[nby-1]==10)	
			{
				YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;
				pArterialVenousID[nby-1]=1;
			}
		}
	}

//-----------------------------------------------
//---"Arterio-Venous" network---
//---Compatible with hexagonal grid---

//---inlets and outlets---
/*	j=51;
	for	(i=1;i<=7;i++)
	{
		pFluid[LabX(i,j,k)-1]=10;
	}

	for	(i=91;i<=101;i++)
	{
		pFluid[LabX(i,j,k)-1]=10;
	}

//---first branches---
	j=50;
	for	(i=8;i<=47;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		pFluid[LabX(i+1,j,k)-1]=10;
		pFluid[LabX(98-i-1,j,k)-1]=10;
		pFluid[LabX(i+1,102-j,k)-1]=10;
		pFluid[LabX(98-i-1,102-j,k)-1]=10;

		j-=2;
	}

	j=49;
	for	(i=10;i<=49;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		j-=2;
	}

	j=51;
	for	(i=7;i<=46;i+=3)
	{
		pFluid[LabY(i,j,k)-1]=10;
		pFluid[LabY(97-i,j,k)-1]=10;
		pFluid[LabY(i,103-j,k)-1]=10;
		pFluid[LabY(97-i,103-j,k)-1]=10;

		j-=1;
		
		pFluid[LabY(i+2,j,k)-1]=10;
		pFluid[LabY(97-i-2,j,k)-1]=10;
		pFluid[LabY(i+2,103-j,k)-1]=10;
		pFluid[LabY(97-i-2,103-j,k)-1]=10;

		j-=1;
	}

//---second branches---
	j=36;
	for	(i=32;i<=47;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		pFluid[LabX(i+1,j,k)-1]=10;
		pFluid[LabX(98-i-1,j,k)-1]=10;
		pFluid[LabX(i+1,102-j,k)-1]=10;
		pFluid[LabX(98-i-1,102-j,k)-1]=10;

		j+=2;
	}

	j=37;
	for	(i=34;i<=49;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		j+=2;
	}

	j=36;
	for	(i=31;i<=46;i+=3)
	{
		pFluid[LabY(i,j,k)-1]=10;
		pFluid[LabY(97-i,j,k)-1]=10;
		pFluid[LabY(i,103-j,k)-1]=10;
		pFluid[LabY(97-i,103-j,k)-1]=10;

		j+=1;
		
		pFluid[LabY(i+2,j,k)-1]=10;
		pFluid[LabY(97-i-2,j,k)-1]=10;
		pFluid[LabY(i+2,103-j,k)-1]=10;
		pFluid[LabY(97-i-2,103-j,k)-1]=10;

		j+=1;
	}

//---third branches (upper)---
	j=28;
	for	(i=44;i<=47;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		pFluid[LabX(i+1,j,k)-1]=10;
		pFluid[LabX(98-i-1,j,k)-1]=10;
		pFluid[LabX(i+1,102-j,k)-1]=10;
		pFluid[LabX(98-i-1,102-j,k)-1]=10;

		j+=2;
	}

	j=29;
	for	(i=46;i<=49;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		j+=2;
	}

	j=28;
	for	(i=43;i<=46;i+=3)
	{
		pFluid[LabY(i,j,k)-1]=10;
		pFluid[LabY(97-i,j,k)-1]=10;
		pFluid[LabY(i,103-j,k)-1]=10;
		pFluid[LabY(97-i,103-j,k)-1]=10;

		j+=1;
		
		pFluid[LabY(i+2,j,k)-1]=10;
		pFluid[LabY(97-i-2,j,k)-1]=10;
		pFluid[LabY(i+2,103-j,k)-1]=10;
		pFluid[LabY(97-i-2,103-j,k)-1]=10;

		j+=1;
	}

//---third branches (lower)---
	j=42;
	for	(i=44;i<=47;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		pFluid[LabX(i+1,j,k)-1]=10;
		pFluid[LabX(98-i-1,j,k)-1]=10;
		pFluid[LabX(i+1,102-j,k)-1]=10;
		pFluid[LabX(98-i-1,102-j,k)-1]=10;

		j-=2;
	}

	j=41;
	for	(i=46;i<=49;i+=3)
	{
		pFluid[LabX(i,j,k)-1]=10;
		pFluid[LabX(98-i,j,k)-1]=10;
		pFluid[LabX(i,102-j,k)-1]=10;
		pFluid[LabX(98-i,102-j,k)-1]=10;

		j-=2;
	}

	j=43;
	for	(i=43;i<=46;i+=3)
	{
		pFluid[LabY(i,j,k)-1]=10;
		pFluid[LabY(97-i,j,k)-1]=10;
		pFluid[LabY(i,103-j,k)-1]=10;
		pFluid[LabY(97-i,103-j,k)-1]=10;

		j-=1;
		
		pFluid[LabY(i+2,j,k)-1]=10;
		pFluid[LabY(97-i-2,j,k)-1]=10;
		pFluid[LabY(i+2,103-j,k)-1]=10;
		pFluid[LabY(97-i-2,103-j,k)-1]=10;

		j-=1;
	}

//-----------------------------------------------
	for	(j=1;j<=m_ny;j++)
	{	for	(i=1;i<=m_nx;i++)
		{
			int nbx=LabX(i,j,k);
			int nby=LabY(i,j,k);

			if	(pFluid[nbx-1]==10)	{XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;}
			if	(pFluid[nby-1]==10)	{YBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;}
		}

		i=m_nx+1;
		int nbx=LabX(i,j,k);

		if	(pFluid[nbx-1]==10)	{XBR[i-1][j-1][k-1]=UU_PV_AdditionalRadius;}
	}
*/
//-----------------------------------------------
}

//***********************************************
//===============================================
void CAngioNetDlg::CalculateConvectedStim(void)
//===============================================
{
	int i,j,k,ii,jj,kk;
	int nbx,nby,nbz;
		
//	double NutrientRef=0.95;

	double FlowRef=1.5e-13;//1.0e-13;
	double HDRef=0.45;
//	double RadiusRef=12.0e-6;
//	double LengthRef=bondLength;
	double NutrientRef=FlowRef*HDRef;//*LengthRef*pow(RadiusRef,2);

	int ConvectDistance=Nbond;
	int ConvectLoopCounter=0;
	int ReceiveStimNodes=0;

	int Nnode=m_nx*m_ny*m_nz;
	bool* ReceiveStim=NULL;
	bool* StimIndicator=NULL;
	bool* bFlowWeight=NULL;
	double* NodeStim=NULL;
	ReceiveStim=new bool[Nnode];
	StimIndicator=new bool[Nnode];
	bFlowWeight=new bool[Nbond];
	NodeStim=new double[Nnode];

	for	(int n=1;n<=Nnode;n++)	
	{
		ReceiveStim[n-1]=false;	
		StimIndicator[n-1]=false;
		NodeStim[n-1]=0.0;
	}

	for	(int n=1;n<=Nbond;n++)	
	{
		bFlowWeight[n-1]=false;
	}

//-----------------------------------------------
	double*** TotalFlowOut=NULL;

	TotalFlowOut=new double**[m_nx];

	for (i=0;i<m_nx;i++)
	{
		TotalFlowOut[i]=new double* [m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			TotalFlowOut[i][j]=new double [m_nz];
		}
	}

//-----------------------------------------------
	double*** LocalNutrientX;
	double*** LocalNutrientY;
	double*** LocalNutrientZ;

	LocalNutrientX=new double**[m_nx+1];
	LocalNutrientY=new double**[m_nx];
	LocalNutrientZ=new double**[m_nx];

	for (i=0;i<m_nx;i++)
	{
		LocalNutrientY[i]=new double*[m_ny];
		LocalNutrientZ[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			LocalNutrientY[i][j]=new double[m_nz];
			LocalNutrientZ[i][j]=new double[m_nz];
		}
	}

	for (i=0;i<m_nx+1;i++)
	{
		LocalNutrientX[i]=new double*[m_ny];
	}

	for (i=0;i<m_nx+1;i++)
	{	for (j=0;j<m_ny;j++)
		{
			LocalNutrientX[i][j]=new double[m_nz];
		}
	}

//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				ConvectedStimX[i-1][j-1][k-1]=0.0;
				ConvectedStimY[i-1][j-1][k-1]=0.0;
				ConvectedStimZ[i-1][j-1][k-1]=0.0;
				LocalNutrientX[i-1][j-1][k-1]=0.0;
				LocalNutrientY[i-1][j-1][k-1]=0.0;
				LocalNutrientZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			ConvectedStimX[i-1][j-1][k-1]=0.0;
			LocalNutrientX[i-1][j-1][k-1]=0.0;
		}
	}

//-----------------------------------------------

	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				TotalFlowOut[i-1][j-1][k-1]=0.0;
								
//---x-bond to left---
				if	(
						XFlow[i-1][j-1][k-1]<0.0 
						&& fabs(XFlow[i-1][j-1][k-1])>=1.0e-18
						
					)
				{
					bFlowWeight[LabX(i,j,k)-1]=true;		
				}

//---x-bond to right---
				if	(
						XFlow[i+1-1][j-1][k-1]>0.0
						&& fabs(XFlow[i+1-1][j-1][k-1])>=1.0e-18
						
					)
				{
					bFlowWeight[LabX(i+1,j,k)-1]=true;		
				}

//---y-bond above---
				if	(
						YFlow[i-1][j-1][k-1]<0.0
						&& fabs(YFlow[i-1][j-1][k-1])>=1.0e-18
					)
				{
					bFlowWeight[LabY(i,j,k)-1]=true;
				}

//---y-bond below---
				if	(j!=m_ny)
				{
					if	(
							YFlow[i-1][j+1-1][k-1]>0.0
							&& fabs(YFlow[i-1][j+1-1][k-1])>=1.0e-18
						)
					{
						bFlowWeight[LabY(i,j+1,k)-1]=true;
					}
				}

//---z-bond out of screen---
				if	(
						ZFlow[i-1][j-1][k-1]<0.0
						&& fabs(ZFlow[i-1][j-1][k-1])>=1.0e-18
					)
				{
					bFlowWeight[LabZ(i,j,k)-1]=true;
				}

//---z-bond into screen---
				if	(k!=m_nz)
				{
					if	(
							ZFlow[i-1][j-1][k+1-1]>0.0
							&& fabs(ZFlow[i-1][j-1][k+1-1])>=1.0e-18
						)
					{
						bFlowWeight[LabZ(i,j,k+1)-1]=true;
					}
				}

//-----------------------------------------------
				int jp1,kp1;

				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalFlowOut[i-1][j-1][k-1]=(
				  bFlowWeight[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])+
				  bFlowWeight[LabX(i+1,j,k)-1]*fabs(XFlow[i+1-1][j-1][k-1])+
				  bFlowWeight[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])+
				  bFlowWeight[LabY(i,jp1,k)-1]*fabs(YFlow[i-1][jp1-1][k-1])+
				  bFlowWeight[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])+
				  bFlowWeight[LabZ(i,j,kp1)-1]*fabs(ZFlow[i-1][j-1][kp1-1])  );

//-----------------------------------------------
				bFlowWeight[LabX(i,j,k)-1]=false;
				bFlowWeight[LabX(i+1,j,k)-1]=false;
				bFlowWeight[LabY(i,j,k)-1]=false;
				bFlowWeight[LabY(i,j+1,k)-1]=false;
				bFlowWeight[LabZ(i,j,k)-1]=false;
				bFlowWeight[LabZ(i,j,k+1)-1]=false;

//-----------------------------------------------
			}	//end i loop
		}	//end j loop
	}	//end k loop

//-----------------------------------------------
/*	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				int iplus=i+1;
				int jplus=j+1;
				int kplus=k+1;

				if	(j==m_ny)	{jplus=j;}
				if	(k==m_nz)	{kplus=k;}

				if	(pFluid[nbx-1]==10)
				{
					LocalNutrientX[i-1][j-1][k-1]=(pTissueNutrientConc[i-1][j-1][k-1]+
													pTissueNutrientConc[i-1][jplus-1][k-1]+
														pTissueNutrientConc[i-1][j-1][kplus-1]+
															pTissueNutrientConc[i-1][jplus-1][kplus-1])/4.0;

//if	(loop%1000==0)	{outfileLocalNutrient << "x-bond" << "\t" << i << "\t" << j << "\t" << pTissueNutrientConc[i-1][j-1][k-1] << "\t" 
//						<< pTissueNutrientConc[i-1][jplus-1][k-1] << "\t" << LocalNutrientX[i-1][j-1][k-1] << endl;}   
				}

				if	(pFluid[nby-1]==10)
				{
					LocalNutrientY[i-1][j-1][k-1]=(pTissueNutrientConc[i-1][j-1][k-1]+
													pTissueNutrientConc[iplus-1][j-1][k-1]+
														pTissueNutrientConc[i-1][j-1][kplus-1]+
															pTissueNutrientConc[iplus-1][j-1][kplus-1])/4.0;

//if	(loop%1000==0)	{outfileLocalNutrient << "y-bond" << "\t" << i << "\t" << j << "\t" << pTissueNutrientConc[i-1][j-1][k-1] << "\t" 
//						<< pTissueNutrientConc[iplus-1][j-1][k-1] << "\t" << LocalNutrientY[i-1][j-1][k-1] << endl;}
				}

				if	(pFluid[nbz-1]==10)
				{
					LocalNutrientZ[i-1][j-1][k-1]=(pTissueNutrientConc[i-1][j-1][k-1]+
													pTissueNutrientConc[iplus-1][j-1][k-1]+
														pTissueNutrientConc[i-1][jplus-1][k-1]+
															pTissueNutrientConc[iplus-1][jplus-1][k-1])/4.0;
				}

			}	//end i loop

			i=m_nx+1;
			nbx=LabX(i,j,k);

			int jplus=j+1;
			int kplus=k+1;

			if	(j==m_ny)	{jplus=j;}
			if	(k==m_nz)	{kplus=k;}

			if	(pFluid[nbx-1]==10)
			{
				LocalNutrientX[i-1][j-1][k-1]=(pTissueNutrientConc[i-1][j-1][k-1]+
												pTissueNutrientConc[i-1][jplus-1][k-1]+
													pTissueNutrientConc[i-1][j-1][kplus-1]+
														pTissueNutrientConc[i-1][jplus-1][kplus-1])/4.0;

//if	(loop%1000==0)	{outfileLocalNutrient << "x-bond" << "\t" << i << "\t" << j << "\t" << pTissueNutrientConc[i-1][j-1][k-1] << "\t" 
//						<< pTissueNutrientConc[i-1][jplus-1][k-1] << "\t" << LocalNutrientX[i-1][j-1][k-1] << endl;}
			}

		}	//end j loop
	}	//end k loop
*/
//if	(loop%1000==0)	{outfileDebugConvectedStim << flowTime << endl;}
//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

//-----------------------------------------------
//---x-bonds convect stimulus---
				if	(pFluid[nbx-1]==10) 
				{
					LocalNutrientX[i-1][j-1][k-1]=fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1];
													//*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2);

					if	(
							LocalNutrientX[i-1][j-1][k-1]<NutrientRef 
							&& fabs(XFlow[i-1][j-1][k-1])>=1.0e-18
						)
					{
						ConvectedStimX[i-1][j-1][k-1]+=XBL[i-1][j-1][k-1]*1.0e6*
														(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef);

//if	(loop%1000==0)	{outfileDebugConvectedStim << "x-bond (" << i << "," << j << ") generates stim of " << XBL[i-1][j-1][k-1]*1.0e6*(1-LocalNutrientX[i-1][j-1][k-1]/NutrientRef) << endl;}

						
						if	(XFlow[i-1][j-1][k-1]>0.0)
						{
							ReceiveStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=XBL[i-1][j-1][k-1]*1.0e6*
																		(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef);

//if	(loop%1000==0)	{outfileDebugConvectedStim << "node (" << i << "," << j << ") receives " << XBL[i-1][j-1][k-1]*1.0e6*(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef) << endl;}
						}

						else if	(XFlow[i-1][j-1][k-1]<0.0)
						{
							if	(i!=1)	
							{
								ReceiveStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

								NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=XBL[i-1][j-1][k-1]*1.0e6*
																			(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef);

//if	(loop%1000==0)	{outfileDebugConvectedStim << "node (" << i-1 << "," << j << ") receives " << XBL[i-1][j-1][k-1]*1.0e6*(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef) << endl;}
							}
						}

						ConvectLoopCounter+=1;

						for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
						while	(ConvectLoopCounter<ConvectDistance && ReceiveStimNodes>0)
						{

//if	(loop%1000==0)	{outfileDebugConvectedStim << "--------------------" << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << "Loop Number: " << ConvectLoopCounter << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << "No. of Nodes: " << ReceiveStimNodes << endl;}

							ReceiveStimNodes=0;

							for	(kk=1;kk<=m_nz;kk++)
							{	for	(jj=1;jj<=m_ny;jj++)
								{	for	(ii=1;ii<=m_nx;ii++)
									{
										if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
										{
//if	(loop%1000==0)	{outfileDebugConvectedStim << "node passing stim is (" << ii << "," << jj << ")" << endl;}
											//x-bond to left
											if	(
													XFlow[ii-1][jj-1][kk-1]<0.0 
													&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimX[ii-1][jj-1][kk-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
																								
												if	(ii!=1)	
												{
													StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

//if	(loop%1000==0)	{outfileDebugConvectedStim << "node (" << ii-1 << "," << jj << ") receives " << (fabs(XFlow[ii-1][jj-1][kk-1])/TotalFlowOut[ii-1][jj-1][kk-1])*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1] << endl;}
												}
											}

											//x-bond to right
											if	(
													XFlow[ii+1-1][jj-1][kk-1]>0.0 
													&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimX[ii+1-1][jj-1][kk-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																						/TotalFlowOut[ii-1][jj-1][kk-1])
																							*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

//outfileDebugConvectedStim << ii << "\t" << jj << "\t" << fabs(XFlow[ii-1][jj-1][kk-1]) << "\t" << fabs(XFlow[ii+1-1][jj-1][kk-1]) << "\t" << TotalFlowOut[ii-1][jj-1][kk-1] << "\t" << NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1] << endl; 

												if	(ii!=m_nx)	
												{
													StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

//if	(loop%1000==0)	{outfileDebugConvectedStim << "node (" << ii+1 << "," << jj << ") receives " << (fabs(XFlow[ii+1-1][jj-1][kk-1])/TotalFlowOut[ii-1][jj-1][kk-1])*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1] << endl;}
												}
											}

											//y-bond above
											if	(
													YFlow[ii-1][jj-1][kk-1]<0.0
													&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimY[ii-1][jj-1][kk-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(jj!=1)	
												{
													StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

//if	(loop%1000==0)	{outfileDebugConvectedStim << "node (" << ii << "," << jj-1 << ") receives " << (fabs(YFlow[ii-1][jj-1][kk-1])/TotalFlowOut[ii-1][jj-1][kk-1])*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1] << endl;}
												}
											}

											//y-bond below
											if	(jj!=m_ny)
											{
												if	(
														YFlow[ii-1][jj+1-1][kk-1]>0.0
														&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
													)
												{
													ConvectedStimY[ii-1][jj+1-1][kk-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																							/TotalFlowOut[ii-1][jj-1][kk-1])
																								*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

													StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

//if	(loop%1000==0)	{outfileDebugConvectedStim << "node (" << ii << "," << jj+1 << ") receives " << (fabs(YFlow[ii-1][jj+1-1][kk-1])/TotalFlowOut[ii-1][jj-1][kk-1])*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1] << endl;}
												}
											}

											//z-bond out of screen
											if	(
													ZFlow[ii-1][jj-1][kk-1]<0.0
													&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimZ[ii-1][jj-1][kk-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(kk!=1)	
												{
													StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//z-bond into screen
											if	(kk!=m_nz)
											{
												if	(
														ZFlow[ii-1][jj-1][kk+1-1]>0.0
														&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
													)
												{
													ConvectedStimZ[ii-1][jj-1][kk+1-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																							/TotalFlowOut[ii-1][jj-1][kk-1])
																								*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

													StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

											NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

//if	(loop%1000==0)	{outfileDebugConvectedStim << endl;}

										}	//end if ReceiveStim=true

//-----------------------------------------------
									}	//end ii loop

								}	//end jj loop

							}	//end kk loop

//-----------------------------------------------
							for	(int n=1;n<=Nnode;n++)	
							{
								ReceiveStim[n-1]=StimIndicator[n-1];
								ReceiveStimNodes+=ReceiveStim[n-1];
								StimIndicator[n-1]=false;
							}

							ConvectLoopCounter+=1;

//-----------------------------------------------
						}	//end while loop

						ConvectLoopCounter=0;

						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=false;
							NodeStim[n-1]=0.0;
						}
//if	(loop%1000==0)	{outfileDebugConvectedStim << "end of x-bond" << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << "====================" << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << endl;}
//-----------------------------------------------
					}	//end if O2 < O2,ref

				}	//end if pFluid=10


//-----------------------------------------------
//---y-bonds convect stimulus---

				if	(pFluid[nby-1]==10) 
				{
					LocalNutrientY[i-1][j-1][k-1]=fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1];
													//*YBL[i-1][j-1][k-1]*pow(YBR[i-1][j-1][k-1],2);

					if	(
							LocalNutrientY[i-1][j-1][k-1]<NutrientRef 
							&& fabs(YFlow[i-1][j-1][k-1])>=1.0e-18
						)
					{
						ConvectedStimY[i-1][j-1][k-1]+=YBL[i-1][j-1][k-1]*1.0e6*
														(1-(double)LocalNutrientY[i-1][j-1][k-1]/NutrientRef);

						
						if	(YFlow[i-1][j-1][k-1]>0.0)
						{
							ReceiveStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=YBL[i-1][j-1][k-1]*1.0e6*
																		(1-(double)LocalNutrientY[i-1][j-1][k-1]/NutrientRef);
						}

						else if	(YFlow[i-1][j-1][k-1]<0.0)
						{
							if	(j!=1)	
							{
								ReceiveStim[i+((j-1)-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

								NodeStim[i+((j-1)-1)*m_nx+(k-1)*m_nx*m_ny-1]+=YBL[i-1][j-1][k-1]*1.0e6*
																				(1-(double)LocalNutrientY[i-1][j-1][k-1]/NutrientRef);
							}
						}

						ConvectLoopCounter+=1;

						for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
						while	(ConvectLoopCounter<ConvectDistance && ReceiveStimNodes>0)
						{
							ReceiveStimNodes=0;

							for	(kk=1;kk<=m_nz;kk++)
							{	for	(jj=1;jj<=m_ny;jj++)
								{	for	(ii=1;ii<=m_nx;ii++)
									{
										if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
										{
											//x-bond to left
											if	(
													XFlow[ii-1][jj-1][kk-1]<0.0 
													&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimX[ii-1][jj-1][kk-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												
												if	(ii!=1)	
												{
													StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//x-bond to right
											if	(
													XFlow[ii+1-1][jj-1][kk-1]>0.0 
													&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimX[ii+1-1][jj-1][kk-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																						/TotalFlowOut[ii-1][jj-1][kk-1])
																							*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(ii!=m_nx)	
												{
													StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//y-bond above
											if	(
													YFlow[ii-1][jj-1][kk-1]<0.0
													&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimY[ii-1][jj-1][kk-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(jj!=1)	
												{
													StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//y-bond below
											if	(jj!=m_ny)
											{
												if	(
														YFlow[ii-1][jj+1-1][kk-1]>0.0
														&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
													)
												{
													ConvectedStimY[ii-1][jj+1-1][kk-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																							/TotalFlowOut[ii-1][jj-1][kk-1])
																								*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

													StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//z-bond out of screen
											if	(
													ZFlow[ii-1][jj-1][kk-1]<0.0
													&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimZ[ii-1][jj-1][kk-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(kk!=1)	
												{
													StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//z-bond into screen
											if	(kk!=m_nz)
											{
												if	(
														ZFlow[ii-1][jj-1][kk+1-1]>0.0
														&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
													)
												{
													ConvectedStimZ[ii-1][jj-1][kk+1-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																							/TotalFlowOut[ii-1][jj-1][kk-1])
																								*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

													StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

											NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

										}	//end if ReceiveStim=true

//-----------------------------------------------
									}	//end ii loop

								}	//end jj loop

							}	//end kk loop

//-----------------------------------------------
							for	(int n=1;n<=Nnode;n++)	
							{
								ReceiveStim[n-1]=StimIndicator[n-1];
								ReceiveStimNodes+=ReceiveStim[n-1];
								StimIndicator[n-1]=false;
							}

							ConvectLoopCounter+=1;

//-----------------------------------------------
						}	//end while loop

						ConvectLoopCounter=0;

						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=false;
							NodeStim[n-1]=0.0;
						}

//-----------------------------------------------
					}	//end if O2 < O2,ref

				}	//end if pFluid=10

//-----------------------------------------------
//---z-bonds convect stimulus---

				if	(pFluid[nbz-1]==10) 
				{
					LocalNutrientZ[i-1][j-1][k-1]=fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1];
													//*ZBL[i-1][j-1][k-1]*pow(ZBR[i-1][j-1][k-1],2);

					if	(
							LocalNutrientZ[i-1][j-1][k-1]<NutrientRef 
							&& fabs(ZFlow[i-1][j-1][k-1])>=1.0e-18
						)
					{
						ConvectedStimZ[i-1][j-1][k-1]+=ZBL[i-1][j-1][k-1]*1.0e6*
														(1-(double)LocalNutrientZ[i-1][j-1][k-1]/NutrientRef);

						
						if	(ZFlow[i-1][j-1][k-1]>0.0)
						{
							ReceiveStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

							NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ZBL[i-1][j-1][k-1]*1.0e6*
																		(1-(double)LocalNutrientZ[i-1][j-1][k-1]/NutrientRef);
						}

						else if	(ZFlow[i-1][j-1][k-1]<0.0)
						{
							if	(k!=1)	
							{
								ReceiveStim[i+(j-1)*m_nx+((k-1)-1)*m_nx*m_ny-1]=true;

								NodeStim[i+(j-1)*m_nx+((k-1)-1)*m_nx*m_ny-1]+=ZBL[i-1][j-1][k-1]*1.0e6*
																				(1-(double)LocalNutrientZ[i-1][j-1][k-1]/NutrientRef);
							}
						}

						ConvectLoopCounter+=1;

						for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
						while	(ConvectLoopCounter<ConvectDistance && ReceiveStimNodes>0)
						{
							ReceiveStimNodes=0;

							for	(kk=1;kk<=m_nz;kk++)
							{	for	(jj=1;jj<=m_ny;jj++)
								{	for	(ii=1;ii<=m_nx;ii++)
									{
										if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
										{
											//x-bond to left
											if	(
													XFlow[ii-1][jj-1][kk-1]<0.0 
													&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimX[ii-1][jj-1][kk-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												
												if	(ii!=1)	
												{
													StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//x-bond to right
											if	(
													XFlow[ii+1-1][jj-1][kk-1]>0.0 
													&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimX[ii+1-1][jj-1][kk-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																						/TotalFlowOut[ii-1][jj-1][kk-1])
																							*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(ii!=m_nx)	
												{
													StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//y-bond above
											if	(
													YFlow[ii-1][jj-1][kk-1]<0.0
													&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimY[ii-1][jj-1][kk-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(jj!=1)	
												{
													StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//y-bond below
											if	(jj!=m_ny)
											{
												if	(
														YFlow[ii-1][jj+1-1][kk-1]>0.0
														&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
													)
												{
													ConvectedStimY[ii-1][jj+1-1][kk-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																							/TotalFlowOut[ii-1][jj-1][kk-1])
																								*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

													StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//z-bond out of screen
											if	(
													ZFlow[ii-1][jj-1][kk-1]<0.0
													&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimZ[ii-1][jj-1][kk-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												if	(kk!=1)	
												{
													StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											//z-bond into screen
											if	(kk!=m_nz)
											{
												if	(
														ZFlow[ii-1][jj-1][kk+1-1]>0.0
														&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
													)
												{
													ConvectedStimZ[ii-1][jj-1][kk+1-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																							/TotalFlowOut[ii-1][jj-1][kk-1])
																								*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

													StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

													NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																										/TotalFlowOut[ii-1][jj-1][kk-1])
																											*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												}
											}

											ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

											NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

										}	//end if ReceiveStim=true

//-----------------------------------------------
									}	//end ii loop

								}	//end jj loop

							}	//end kk loop

//-----------------------------------------------
							for	(int n=1;n<=Nnode;n++)	
							{
								ReceiveStim[n-1]=StimIndicator[n-1];
								ReceiveStimNodes+=ReceiveStim[n-1];
								StimIndicator[n-1]=false;
							}

							ConvectLoopCounter+=1;

//-----------------------------------------------
						}	//end while loop

						ConvectLoopCounter=0;

						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=false;
							NodeStim[n-1]=0.0;
						}

//-----------------------------------------------
					}	//end if O2 < O2,ref

				}	//end if pFluid=10

//-----------------------------------------------
//-----------------------------------------------
			}	//end i loop

//-----------------------------------------------
//---x-danglers convect stimulus---
			i=m_nx+1;
			nbx=LabX(i,j,k);

			if	(pFluid[nbx-1]==10) 
			{
				LocalNutrientX[i-1][j-1][k-1]=fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1];
													//*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2);

				if	(
						LocalNutrientX[i-1][j-1][k-1]<NutrientRef 
						&& fabs(XFlow[i-1][j-1][k-1])>=1.0e-18
					)
				{
					ConvectedStimX[i-1][j-1][k-1]+=XBL[i-1][j-1][k-1]*1.0e6*
													(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef);

						
					if	(XFlow[i-1][j-1][k-1]>0.0)	{}
						

					else if	(XFlow[i-1][j-1][k-1]<0.0)
					{
						ReceiveStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

						NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=XBL[i-1][j-1][k-1]*1.0e6*
																		(1-(double)LocalNutrientX[i-1][j-1][k-1]/NutrientRef);
					}

					ConvectLoopCounter+=1;

					for	(int n=1;n<=Nnode;n++)	{ReceiveStimNodes+=ReceiveStim[n-1];}

//-----------------------------------------------
					while	(ConvectLoopCounter<ConvectDistance && ReceiveStimNodes>0)
					{
						ReceiveStimNodes=0;

						for	(kk=1;kk<=m_nz;kk++)
						{	for	(jj=1;jj<=m_ny;jj++)
							{	for	(ii=1;ii<=m_nx;ii++)
								{
									if	(ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]==true)
									{
										//x-bond to left
										if	(
												XFlow[ii-1][jj-1][kk-1]<0.0 
												&& fabs(XFlow[ii-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConvectedStimX[ii-1][jj-1][kk-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																				/TotalFlowOut[ii-1][jj-1][kk-1])
																					*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
												
											if	(ii!=1)	
											{
												StimIndicator[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[(ii-1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii-1][jj-1][kk-1])
																									/TotalFlowOut[ii-1][jj-1][kk-1])
																										*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
											}
										}

										//x-bond to right
										if	(
												XFlow[ii+1-1][jj-1][kk-1]>0.0 
												&& fabs(XFlow[ii+1-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConvectedStimX[ii+1-1][jj-1][kk-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																					/TotalFlowOut[ii-1][jj-1][kk-1])
																						*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

											if	(ii!=m_nx)	
											{
												StimIndicator[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[(ii+1)+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(XFlow[ii+1-1][jj-1][kk-1])
																									/TotalFlowOut[ii-1][jj-1][kk-1])
																										*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
											}
										}

										//y-bond above
										if	(
												YFlow[ii-1][jj-1][kk-1]<0.0
												&& fabs(YFlow[ii-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConvectedStimY[ii-1][jj-1][kk-1]+=(fabs(YFlow[ii-1][jj-1][kk-1])
																				/TotalFlowOut[ii-1][jj-1][kk-1])
																					*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

											if	(jj!=1)	
											{
												StimIndicator[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+((jj-1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=(fabs(YFlow[ii-1][jj-1][kk-1])
																									/TotalFlowOut[ii-1][jj-1][kk-1])
																										*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
											}
										}

										//y-bond below
										if	(jj!=m_ny)
										{
											if	(
													YFlow[ii-1][jj+1-1][kk-1]>0.0
													&& fabs(YFlow[ii-1][jj+1-1][kk-1])>=1.0e-18
												)
											{
												ConvectedStimY[ii-1][jj+1-1][kk-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																						/TotalFlowOut[ii-1][jj-1][kk-1])
																							*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												StimIndicator[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+((jj+1)-1)*m_nx+(kk-1)*m_nx*m_ny-1]+=(fabs(YFlow[ii-1][jj+1-1][kk-1])
																									/TotalFlowOut[ii-1][jj-1][kk-1])
																										*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
											}
										}

										//z-bond out of screen
										if	(
												ZFlow[ii-1][jj-1][kk-1]<0.0
												&& fabs(ZFlow[ii-1][jj-1][kk-1])>=1.0e-18
											)
										{
											ConvectedStimZ[ii-1][jj-1][kk-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																				/TotalFlowOut[ii-1][jj-1][kk-1])
																					*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

											if	(kk!=1)	
											{
												StimIndicator[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+(jj-1)*m_nx+((kk-1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk-1])
																									/TotalFlowOut[ii-1][jj-1][kk-1])
																										*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
											}
										}

										//z-bond into screen
										if	(kk!=m_nz)
										{
											if	(
													ZFlow[ii-1][jj-1][kk+1-1]>0.0
													&& fabs(ZFlow[ii-1][jj-1][kk+1-1])>=1.0e-18
												)
											{
												ConvectedStimZ[ii-1][jj-1][kk+1-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																						/TotalFlowOut[ii-1][jj-1][kk-1])
																							*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];

												StimIndicator[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]=true;

												NodeStim[ii+(jj-1)*m_nx+((kk+1)-1)*m_nx*m_ny-1]+=(fabs(ZFlow[ii-1][jj-1][kk+1-1])
																									/TotalFlowOut[ii-1][jj-1][kk-1])
																										*NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1];
											}
										}

										ReceiveStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=false;

										NodeStim[ii+(jj-1)*m_nx+(kk-1)*m_nx*m_ny-1]=0.0;

									}	//end if ReceiveStim=true

//-----------------------------------------------
								}	//end ii loop

							}	//end jj loop

						}	//end kk loop

//-----------------------------------------------
						for	(int n=1;n<=Nnode;n++)	
						{
							ReceiveStim[n-1]=StimIndicator[n-1];
							ReceiveStimNodes+=ReceiveStim[n-1];
							StimIndicator[n-1]=false;
						}

						ConvectLoopCounter+=1;

//-----------------------------------------------
					}	//end while loop

					ConvectLoopCounter=0;

					for	(int n=1;n<=Nnode;n++)	
					{
						ReceiveStim[n-1]=false;
						NodeStim[n-1]=0.0;
					}

//-----------------------------------------------
				}	//end if O2 < O2,ref

			}	//end if pFluid=10

//-----------------------------------------------
		}	//end j loop

	}	//end k loop

//if	(loop%1000==0)	{outfileDebugConvectedStim << "loop finished" << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << "===================" << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << "===================" << endl;}
//if	(loop%1000==0)	{outfileDebugConvectedStim << endl;}
//-----------------------------------------------

	for	(i=1;i<=m_nx;i++)
	{	for(j=1;j<=m_ny;j++)
		{
			k=1;

			if	(loop%1000==0)	
			{
				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConvectedStim2 << i << "\t" << j << "\t" << ConvectedStimX[i-1][j-1][k-1] << endl;}
			}
		}
	}

	for(j=1;j<=m_ny;j++)
	{
			i=m_nx+1;
			k=1;

			if	(loop%1000==0)	
			{
				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConvectedStim2 << i << "\t" << j << "\t" << ConvectedStimX[i-1][j-1][k-1] << endl;}
			}
	}

//-----------------------------------------------
//---Clear up arrays---

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			delete[] TotalFlowOut[i][j];
			delete[] LocalNutrientY[i][j];
			delete[] LocalNutrientZ[i][j];
		}
	}

	for (i=0;i<m_nx;i++)
	{
		delete[] TotalFlowOut[i];
		delete[] LocalNutrientY[i];
		delete[] LocalNutrientZ[i];
	}

	delete[] TotalFlowOut;
	delete[] LocalNutrientY;
	delete[] LocalNutrientZ;

	for (i=0;i<m_nx+1;i++)
	{	for (j=0;j<m_ny;j++)
		{
			delete[] LocalNutrientX[i][j];
		}
	}

	for (i=0;i<m_nx+1;i++)
	{
		delete[] LocalNutrientX[i];
	}

	delete[] LocalNutrientX;
	
	delete[] NodeStim;
	delete[] StimIndicator;
	delete[] ReceiveStim;
	delete[] bFlowWeight;

}

//===============================================
void CAngioNetDlg::CalculateConvectedStim2(void)
//===============================================
{
	int i,j,k;
	int q=0;
	int nbx,nby,nbz;
		
	double FlowRef=1.5e-13;//1.0e-14;//8.0e-15;//1.5e-12;//1.0e-13;
	double HDRef=0.45;
	double NutrientRef=FlowRef*HDRef;

	int ConvectRefLength=1000000;//2;//35;//150;//(see Pries)//350;//50;	//no. of bonds
	double DecayIndex=1.0/ConvectRefLength;

	int BondLabelMax=0;
	int BondLabelSum=0;
	int Nnode=m_nx*m_ny*m_nz;
	int PassMin=500000;

	bool* bFlowWeight=NULL;
	int* BondLabel=NULL;
	int* BondsIn=NULL;
	bool* PassNode=NULL;
	double* NodeStim=NULL;
	int* icoord=NULL;
	int* jcoord=NULL;
	int* kcoord=NULL;
	
	bFlowWeight=new bool[Nbond];
	BondLabel=new int[Nbond];
	BondsIn=new int[Nnode];
	PassNode=new bool[Nnode];
	NodeStim=new double[Nnode];
	icoord=new int[Nbond];
	jcoord=new int[Nbond];
	kcoord=new int[Nbond];
    		
	for	(int n=1;n<=Nbond;n++)	
	{
		bFlowWeight[n-1]=false;
		BondLabel[n-1]=0;
		icoord[n-1]=0;
		jcoord[n-1]=0;
		kcoord[n-1]=0;
	}

	for	(int n=1;n<=Nnode;n++)	
	{
		BondsIn[n-1]=0;
		PassNode[n-1]=false;
		NodeStim[n-1]=0.0;
	}

//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				ConvectedStimX[i-1][j-1][k-1]=0.0;
				ConvectedStimY[i-1][j-1][k-1]=0.0;
				ConvectedStimZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			ConvectedStimX[i-1][j-1][k-1]=0.0;
		}
	}

//-----------------------------------------------
	double*** TotalFlowOut=NULL;
	int*** NumFlowsIn=NULL;
	
	TotalFlowOut=new double**[m_nx];
	NumFlowsIn=new int**[m_nx];
	
	for (i=0;i<m_nx;i++)
	{
		TotalFlowOut[i]=new double* [m_ny];
		NumFlowsIn[i]=new int*[m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			TotalFlowOut[i][j]=new double [m_nz];
			NumFlowsIn[i][j]=new int[m_nz];
		}
	}

//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				NumFlowsIn[i-1][j-1][k-1]=0;
												
//---x-bond to left---
				if	(FalseFlow[LabX(i,j,k)-1]==false)
				{
					if	(XFlow[i-1][j-1][k-1]<0.0)
					{
						bFlowWeight[LabX(i,j,k)-1]=true;
					}

					else if	(XFlow[i-1][j-1][k-1]>0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---x-bond to right---
				if	(FalseFlow[LabX(i+1,j,k)-1]==false)
					{
					if	(XFlow[i+1-1][j-1][k-1]>0.0)
					{
						bFlowWeight[LabX(i+1,j,k)-1]=true;
					}

					else if	(XFlow[i+1-1][j-1][k-1]<0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---y-bond above---
				if	(FalseFlow[LabY(i,j,k)-1]==false)
				{
					if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						bFlowWeight[LabY(i,j,k)-1]=true;
					}

					else if	(YFlow[i-1][j-1][k-1]>0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---y-bond below---
				if	(j!=m_ny)
				{
					if	(FalseFlow[LabY(i,j+1,k)-1]==false)
					{
						if	(YFlow[i-1][j+1-1][k-1]>0.0)
						{
							bFlowWeight[LabY(i,j+1,k)-1]=true;
						}

						else if	(YFlow[i-1][j+1-1][k-1]<0.0)
						{
							NumFlowsIn[i-1][j-1][k-1]+=1;
						}
					}
				}

//---z-bond out of screen---
				if	(FalseFlow[LabZ(i,j,k)-1]==false)
				{
					if	(ZFlow[i-1][j-1][k-1]<0.0)
					{
						bFlowWeight[LabZ(i,j,k)-1]=true;
					}

					else if	(ZFlow[i-1][j-1][k-1]>0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---z-bond into screen---
				if	(k!=m_nz)
				{
					if	(FalseFlow[LabZ(i,j,k+1)-1]==false)
					{
						if	(ZFlow[i-1][j-1][k+1-1]>0.0)
						{
							bFlowWeight[LabZ(i,j,k+1)-1]=true;
						}

						else if	(ZFlow[i-1][j-1][k+1-1]<0.0)
						{
							NumFlowsIn[i-1][j-1][k-1]+=1;
						}
					}
				}
				
//-----------------------------------------------
				int jp1,kp1;

				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalFlowOut[i-1][j-1][k-1]=(
				  bFlowWeight[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])+
				  bFlowWeight[LabX(i+1,j,k)-1]*fabs(XFlow[i+1-1][j-1][k-1])+
				  bFlowWeight[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])+
				  bFlowWeight[LabY(i,jp1,k)-1]*fabs(YFlow[i-1][jp1-1][k-1])+
				  bFlowWeight[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])+
				  bFlowWeight[LabZ(i,j,kp1)-1]*fabs(ZFlow[i-1][j-1][kp1-1])  );

//-----------------------------------------------
				bFlowWeight[LabX(i,j,k)-1]=false;
				bFlowWeight[LabX(i+1,j,k)-1]=false;
				bFlowWeight[LabY(i,j,k)-1]=false;
				bFlowWeight[LabY(i,j+1,k)-1]=false;
				bFlowWeight[LabZ(i,j,k)-1]=false;
				bFlowWeight[LabZ(i,j,k+1)-1]=false;

//-----------------------------------------------
			}	//end i loop
		}	//end j loop
	}	//end k loop
//outfileConvected2 << "got past flow weighting" << endl;
//-----------------------------------------------

//---Each bond generates a unique stimulus---
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

//-----------------------------------------------
//---x-bonds produce stimulus---
				if	(pFluid[nbx-1]==10) 
				{
					if	(
							(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1])<NutrientRef 
							&& FalseFlow[nbx-1]==false
						)
					{
						ConvectedStimX[i-1][j-1][k-1]=XBL[i-1][j-1][k-1]*1.0e6*
														(1-(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1])/NutrientRef);
					}
				}

//-----------------------------------------------
//---y-bonds produce stimulus---

				if	(pFluid[nby-1]==10) 
				{
					if	(
							(fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1])<NutrientRef 
							&& FalseFlow[nby-1]==false
						)
					{
						ConvectedStimY[i-1][j-1][k-1]=YBL[i-1][j-1][k-1]*1.0e6*
														(1-(fabs(YFlow[i-1][j-1][k-1])*pYHem[i-1][j-1][k-1])/NutrientRef);
					}
				}

//-----------------------------------------------
//---z-bonds produce stimulus---

				if	(m_nz!=1)
				{
					if	(pFluid[nbz-1]==10) 
					{
						if	(
								(fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1])<NutrientRef 
								&& FalseFlow[nbz-1]==false
							)
						{
							ConvectedStimZ[i-1][j-1][k-1]=ZBL[i-1][j-1][k-1]*1.0e6*
															(1-(fabs(ZFlow[i-1][j-1][k-1])*pZHem[i-1][j-1][k-1])/NutrientRef);
						}
					}
				}

			}	//end i loop

			i=m_nx+1;
			nbx=LabX(i,j,k);

//-----------------------------------------------
//---x-danglers produce stimulus---
			if	(pFluid[nbx-1]==10) 
			{
				if	(
						(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1])<NutrientRef 
						&& FalseFlow[nbx-1]==false
					)
				{
					ConvectedStimX[i-1][j-1][k-1]=XBL[i-1][j-1][k-1]*1.0e6*
													(1-(fabs(XFlow[i-1][j-1][k-1])*pXHem[i-1][j-1][k-1])/NutrientRef);
				}
			}
//-----------------------------------------------
		}	//end j loop
	}	//end k loop
//outfileConvected2 << "got past unique stimuli" << endl;
//outfileConvected2 << flowTime << endl;

	PassMin=500000;
	i=1;
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{
			if	(
					XFlow[i-1][j-1][k-1]>0.0 
					&& FalseFlow[LabX(i,j,k)-1]==false
				)
			{
				BondLabelMax+=1;
				BondLabel[LabX(i,j,k)-1]=BondLabelMax;

				icoord[BondLabelMax]=i;
				jcoord[BondLabelMax]=j;
				kcoord[BondLabelMax]=k;

				NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ConvectedStimX[i-1][j-1][k-1];
				BondsIn[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

				if	(NumFlowsIn[i-1][j-1][k-1]==BondsIn[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1])
				{
					PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
				}

				if	(PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
				{
					if	(BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
					{
						PassMin=BondLabel[LabX(i,j,k)-1];
						q=PassMin;
					}
				}
//outfileConvected2 << "x-bond (" << i << "," << j << ")" << "\t" << BondLabel[LabX(i,j,k)-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[i-1][j-1][k-1] << "\t" << "node stim=" << NodeStim[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
			}
		}
	}
//outfileConvected2 << "got past inlets" << endl;
//-----------------------------------------------
	for (int n=1;n<=Nbond;n++)
	{
		BondLabelSum+=BondLabel[n-1];
	}

//-----------------------------------------------
	while	(BondLabelSum>0)
	{
		//outfileConvected2 << "Bond Label Sum=" << BondLabelSum << endl;
		BondLabelSum=0;

		//x-bond with negative flow labelled
		if	(
				BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==q
				&&
				XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
			)
		{
//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(icoord[q]>2)
			{
				if	(
						XFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]-1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];
	
						BondsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-2-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConvected2 << "x-bond (" << icoord[q]-1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
					}
				}
			}

			//y-bond above labelled bond
			if	(jcoord[q]>1 && icoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]-1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConvected2 << "y-bond (" << icoord[q]-1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimY[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}

			//y-bond below labelled bond
			if	(jcoord[q]<m_ny && icoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]-1;
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConvected2 << "y-bond (" << icoord[q]-1 << "," << jcoord[q]+1 << ")" << "\t" << BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimY[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}
						
			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(kcoord[q]>1 && icoord[q]>1)
				{
					if	(
							ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q]-1;
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q];

							ConvectedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]+=fabs(ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])
																						/TotalFlowOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]
																							*NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(kcoord[q]<m_nz && icoord[q]>1)
				{
					if	(
							ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q]-1;
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConvectedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]+=fabs(ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1])
																						/TotalFlowOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]
																							*NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1];
	
							BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}
			}
		}
								
		//x-bond with positive flow labelled
		else if	(
					BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}
					
if	(icoord[q]<m_nx)
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

else
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

					}
				}
			}

			//y-bond above labelled bond
			if	(icoord[q]!=m_nx+1 && jcoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}

			//y-bond below labelled bond
			if	(icoord[q]!=m_nx+1 && jcoord[q]<m_ny)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}

			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(icoord[q]!=m_nx+1 && kcoord[q]>1)
				{	
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q];

							ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
																						/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																							*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(icoord[q]!=m_nx+1 && kcoord[q]<m_nz)
				{	
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1])
																						/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																							*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}
			}
		}
		
		//y-bond with negative flow labelled
		else if	(
					BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
				)
		{
//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(icoord[q]>1 && jcoord[q]>1)
			{
				if	(
						XFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]-1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1 && jcoord[q]>1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q]-1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=0;}

if	(icoord[q]<m_nx)
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

else
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

					}
				}
			}
									
			//y-bond above labelled bond
			if	(jcoord[q]>2)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]-1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]-2-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimY[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}

			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(jcoord[q]>1 && kcoord[q]>1)
				{
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q]-1;
							kcoord[BondLabelMax]=kcoord[q];

							ConvectedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])
																						/TotalFlowOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]
																							*NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(jcoord[q]>1 && kcoord[q]<m_nz)
				{
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q]-1;
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConvectedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1])
																						/TotalFlowOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]
																							*NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1];
		
							BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}
			}
		}

		//y-bond with positive flow labelled
		else if	(
					BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(icoord[q]>1)
			{
				if	(
						XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}

if	(icoord[q]<m_nx)
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

else
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

					}
				}
			}
									
			//y-bond below labelled bond
			if	(jcoord[q]<m_ny)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConvected2 << "vessel stim=" << ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

					}
				}
			}
									
			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(kcoord[q]>1)
				{
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q];

							ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
																						/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																							*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(kcoord[q]<m_nz)
				{
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1])
																						/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																							*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																								*exp(-DecayIndex);

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
						}
					}
				}
			}
		}
							
		//z-bond with negative flow labelled
		else if	(
					BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
				)
		{
			BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(icoord[q]>1 && kcoord[q]>1)
			{
				if	(
						XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]+=fabs(XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1 && kcoord[q]>1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]+=fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=0;}
					}
				}
			}
									
			//y-bond above labelled bond
			if	(jcoord[q]>1 && kcoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}

			//y-bond below labelled bond
			if	(jcoord[q]<m_ny && kcoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}
									
			//z-bond out of screen from labelled bond
			if	(kcoord[q]>2)
			{
				if	(
						ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
						&& 
						FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];
	
						BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-2-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}
		}

		//z-bond with positive flow labelled
		else if (
					BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
			BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(icoord[q]>1)
			{
				if	(
						XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]+=fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsIn[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}
					}
				}
			}
									
			//y-bond above labelled bond
			if	(jcoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}

			//y-bond below labelled node
			if	(jcoord[q]<m_ny)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]+=fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConvectedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}
									
			//z-bond into screen from labelled bond
			if	(kcoord[q]<m_nz)
			{
				if	(
						ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
						&& 
						FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==false
					)
				{
					if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]+1;

						ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]+=fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1])
																					/TotalFlowOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]
																						*NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																							*exp(-DecayIndex);

						NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConvectedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1];
	
						BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
						}
					}
				}
			}
		}
//outfileConvected2 << YFlow[34-1][2-1][1-1] << endl;

		PassMin=500000;
		
		for	(k=1;k<=m_nz;k++)
		{	for	(j=1;j<=m_ny;j++)
			{	for	(i=1;i<=m_nx;i++)
				{
					if	(PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
					{
						//x-bond to left
						if	(XFlow[i-1][j-1][k-1]>0.0 && BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabX(i,j,k)-1];
							q=PassMin;
						}

						//x-bond to right
						if	(XFlow[i+1-1][j-1][k-1]<0.0 && BondLabel[LabX(i+1,j,k)-1]>0 && BondLabel[LabX(i+1,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabX(i+1,j,k)-1];
							q=PassMin;
						}

						//y-bond above
						if	(YFlow[i-1][j-1][k-1]>0.0 && BondLabel[LabY(i,j,k)-1]>0 && BondLabel[LabY(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabY(i,j,k)-1];
							q=PassMin;
						}

						//y-bond below
						if	(j<m_ny)
						{
							if	(YFlow[i-1][j+1-1][k-1]<0.0 && BondLabel[LabY(i,j+1,k)-1]>0 && BondLabel[LabY(i,j+1,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabY(i,j+1,k)-1];
								q=PassMin;
							}
						}

						if	(m_nz!=1)
						{
							//z-bond out of screen
							if	(ZFlow[i-1][j-1][k-1]>0.0 && BondLabel[LabZ(i,j,k)-1]>0 && BondLabel[LabZ(i,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabZ(i,j,k)-1];
								q=PassMin;
							}

							if	(k<m_nz)
							{
								//z-bond into screen
								if	(ZFlow[i-1][j-1][k+1-1]<0.0 && BondLabel[LabZ(i,j,k+1)-1]>0 && BondLabel[LabZ(i,j,k+1)-1]<PassMin)
								{
									PassMin=BondLabel[LabZ(i,j,k+1)-1];
									q=PassMin;
								}
							}
						}
					}
				}
			}
		}

		for (int n=1;n<=Nbond;n++)
		{
			BondLabelSum+=BondLabel[n-1];
//			if (BondLabel[n-1]!=0){outfileDebugBone<<n<<endl;}
		}

/*		if	(BondLabelSum_Old==BondLabelSum)
		{
			PassMin=500000;
		
			for	(k=1;k<=m_nz;k++)
			{	for	(j=1;j<=m_ny;j++)
				{	for	(i=1;i<=m_nx;i++)
					{
						if	(PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==false)
						{
							//x-bond to left
							if	(XFlow[i-1][j-1][k-1]>0.0 && BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabX(i,j,k)-1];
								q=PassMin;
//								PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
							}

							//x-bond to right
							if	(XFlow[i+1-1][j-1][k-1]<0.0 && BondLabel[LabX(i+1,j,k)-1]>0 && BondLabel[LabX(i+1,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabX(i+1,j,k)-1];
								q=PassMin;
//								PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
							}

							//y-bond above
							if	(YFlow[i-1][j-1][k-1]>0.0 && BondLabel[LabY(i,j,k)-1]>0 && BondLabel[LabY(i,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabY(i,j,k)-1];
								q=PassMin;
//								PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
							}

							//y-bond below
							if	(j<m_ny)
							{
								if	(YFlow[i-1][j+1-1][k-1]<0.0 && BondLabel[LabY(i,j+1,k)-1]>0 && BondLabel[LabY(i,j+1,k)-1]<PassMin)
								{
									PassMin=BondLabel[LabY(i,j+1,k)-1];
									q=PassMin;
//									PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
								}
							}

							if	(m_nz!=1)
							{
								//z-bond out of screen
								if	(ZFlow[i-1][j-1][k-1]>0.0 && BondLabel[LabZ(i,j,k)-1]>0 && BondLabel[LabZ(i,j,k)-1]<PassMin)
								{
									PassMin=BondLabel[LabZ(i,j,k)-1];
									q=PassMin;
//									PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
								}

								if	(k<m_nz)
								{
									//z-bond into screen
									if	(ZFlow[i-1][j-1][k+1-1]<0.0 && BondLabel[LabZ(i,j,k+1)-1]>0 && BondLabel[LabZ(i,j,k+1)-1]<PassMin)
									{
										PassMin=BondLabel[LabZ(i,j,k+1)-1];
										q=PassMin;
//										PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
									}
								}
							}
						}
					}
				}
			}

			PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
		}
*/
	}	//end while loop
//outfileConvected2 << "got past while loop" << endl;

//outfileDebugConvectedStim2 << flowTime << endl;
//	for	(i=1;i<=m_nx;i++)
//	{	for(j=1;j<=m_ny;j++)
//		{
//			k=1;
//
//			if	(loop%1000==0)	
//			{
//				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConvectedStim2 << "x-bond (" << i << "," << j << ")" << "\t" << ConvectedStimX[i-1][j-1][k-1] << endl;}
//				if	(pFluid[LabY(i,j,k)-1]==10)	{outfileDebugConvectedStim2 << "y-bond (" << i << "," << j << ")" << "\t" << ConvectedStimY[i-1][j-1][k-1] << endl;}
//			}
//		}
//	}

//	for(j=1;j<=m_ny;j++)
//	{
//			i=m_nx+1;
//			k=1;
//
//			if	(loop%1000==0)	
//			{
//				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConvectedStim2 << "x-bond (" << i << "," << j << ")" << "\t" << ConvectedStimX[i-1][j-1][k-1] << endl;}
//			}
//	}
//	outfileDebugConvectedStim2 << endl;	

//---Clear up arrays---

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			delete[] TotalFlowOut[i][j];
			delete[] NumFlowsIn[i][j];
		}
	}

	for (i=0;i<m_nx;i++)
	{
		delete[] TotalFlowOut[i];
		delete[] NumFlowsIn[i];
	}

	delete[] TotalFlowOut;
	delete[] NumFlowsIn;
		
	delete[] bFlowWeight;
	delete[] BondLabel;
	delete[] BondsIn;
	delete[] PassNode;
	delete[] NodeStim;
	delete[] icoord;
	delete[] jcoord;
	delete[] kcoord;

}
//-----------------------------------------------

//===============================================
void CAngioNetDlg::CalculateConductedStim2(void)
//===============================================
{
	int i,j,k;
	int q=0;
	int nbx,nby,nbz;
		
	int BondLabelMax=0;
	int BondLabelSum=0;
	int Nnode=m_nx*m_ny*m_nz;
	int PassMin=500000;

	int ConductRefLength=500;//int(3.5*m_nx);//(see Pries)//350;//50;	//no. of bonds
	double FlowRef=1.0e-18*6.0e13;
	double DecayIndex=1.0/ConductRefLength;

	int* BondLabel=NULL;
	int* BondsIn=NULL;
	bool* PassNode=NULL;
	bool* DeadEnd=NULL;
	double* NodeStim=NULL;
	int* icoord=NULL;
	int* jcoord=NULL;
	int* kcoord=NULL;
	
	BondLabel=new int[Nbond];
	BondsIn=new int[Nnode];
	PassNode=new bool[Nnode];
	DeadEnd=new bool[Nnode];
	NodeStim=new double[Nnode];
	icoord=new int[Nbond];
	jcoord=new int[Nbond];
	kcoord=new int[Nbond];
    		
	for	(int n=1;n<=Nbond;n++)	
	{
		BondLabel[n-1]=0;
		icoord[n-1]=0;
		jcoord[n-1]=0;
		kcoord[n-1]=0;
	}

	for	(int n=1;n<=Nnode;n++)	
	{
		BondsIn[n-1]=0;
		PassNode[n-1]=false;
		DeadEnd[n-1]=false;
		NodeStim[n-1]=0.0;
	}

//-----------------------------------------------
	int*** NumFlowsIn=NULL;
	int*** NumFlowsOut=NULL;
	
	NumFlowsIn=new int**[m_nx];
	NumFlowsOut=new int**[m_nx];
	
	for (i=0;i<m_nx;i++)
	{
		NumFlowsIn[i]=new int* [m_ny];
		NumFlowsOut[i]=new int* [m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			NumFlowsIn[i][j]=new int [m_nz];
			NumFlowsOut[i][j]=new int [m_nz];
		}
	}

//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				ConductedStimX[i-1][j-1][k-1]=0.0;
				ConductedStimY[i-1][j-1][k-1]=0.0;
				ConductedStimZ[i-1][j-1][k-1]=0.0;
			}

			i=m_nx+1;

			ConductedStimX[i-1][j-1][k-1]=0.0;
		}
	}

//-----------------------------------------------
//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				NumFlowsIn[i-1][j-1][k-1]=0;
				NumFlowsOut[i-1][j-1][k-1]=0;
												
//---x-bond to left---
				if	(FalseFlow[LabX(i,j,k)-1]==false)
				{
					if	(XFlow[i-1][j-1][k-1]<0.0)
					{
						NumFlowsOut[i-1][j-1][k-1]+=1;
					}

					else if	(XFlow[i-1][j-1][k-1]>0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---x-bond to right---
				if	(FalseFlow[LabX(i+1,j,k)-1]==false)
					{
					if	(XFlow[i+1-1][j-1][k-1]>0.0)
					{
						NumFlowsOut[i-1][j-1][k-1]+=1;
					}

					else if	(XFlow[i+1-1][j-1][k-1]<0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---y-bond above---
				if	(FalseFlow[LabY(i,j,k)-1]==false)
				{
					if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						NumFlowsOut[i-1][j-1][k-1]+=1;
					}

					else if	(YFlow[i-1][j-1][k-1]>0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---y-bond below---
				if	(j!=m_ny)
				{
					if	(FalseFlow[LabY(i,j+1,k)-1]==false)
					{
						if	(YFlow[i-1][j+1-1][k-1]>0.0)
						{
							NumFlowsOut[i-1][j-1][k-1]+=1;
						}

						else if	(YFlow[i-1][j+1-1][k-1]<0.0)
						{
							NumFlowsIn[i-1][j-1][k-1]+=1;
						}
					}
				}

//---z-bond out of screen---
				if	(FalseFlow[LabZ(i,j,k)-1]==false)
				{
					if	(ZFlow[i-1][j-1][k-1]<0.0)
					{
						NumFlowsOut[i-1][j-1][k-1]+=1;
					}

					else if	(ZFlow[i-1][j-1][k-1]>0.0)
					{
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---z-bond into screen---
				if	(k!=m_nz)
				{
					if	(FalseFlow[LabZ(i,j,k+1)-1]==false)
					{
						if	(ZFlow[i-1][j-1][k+1-1]>0.0)
						{
							NumFlowsOut[i-1][j-1][k-1]+=1;
						}

						else if	(ZFlow[i-1][j-1][k+1-1]<0.0)
						{
							NumFlowsIn[i-1][j-1][k-1]+=1;
						}
					}
				}

				if	(
						NumFlowsIn[i-1][j-1][k-1]>0 
						&& NumFlowsOut[i-1][j-1][k-1]==0
					)	
				{
					DeadEnd[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;

//outfileConducted2 << "node (" << i << "," << j << ") is a dead end" << endl;
				}	
//-----------------------------------------------
			}	//end i loop
		}	//end j loop
	}	//end k loop

//outfileConducted2 << "got past flow weighting" << endl;
//-----------------------------------------------

//---Each bond generates a unique stimulus---
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

//-----------------------------------------------
//---x-bonds produce stimulus---
				if	(pFluid[nbx-1]==10) 
				{
					if	(
							ConvectedStimX[i-1][j-1][k-1]>0.0 
							&& FalseFlow[nbx-1]==false
						)
					{
						ConductedStimX[i-1][j-1][k-1]=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
														(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
					}
				}

//-----------------------------------------------
//---y-bonds produce stimulus---

				if	(pFluid[nby-1]==10) 
				{
					if	(
							ConvectedStimY[i-1][j-1][k-1]>0.0 
							&& FalseFlow[nby-1]==false
						)
					{
						ConductedStimY[i-1][j-1][k-1]=log10(1+(ConvectedStimY[i-1][j-1][k-1]/
														(fabs(YFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
					}
				}

//-----------------------------------------------
//---z-bonds produce stimulus---

				if	(m_nz!=1)
				{
					if	(pFluid[nbz-1]==10) 
					{
						if	(
								ConvectedStimZ[i-1][j-1][k-1]>0.0 
								&& FalseFlow[nbz-1]==false
							)
						{
							ConductedStimZ[i-1][j-1][k-1]=log10(1+(ConvectedStimZ[i-1][j-1][k-1]/
														(fabs(ZFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
						}
					}
				}

			}	//end i loop

			i=m_nx+1;
			nbx=LabX(i,j,k);

//-----------------------------------------------
//---x-danglers produce stimulus---
			if	(pFluid[nbx-1]==10) 
			{
				if	(
						ConvectedStimX[i-1][j-1][k-1]>0.0 
						&& FalseFlow[nbx-1]==false
					)
				{
					ConductedStimX[i-1][j-1][k-1]=log10(1+(ConvectedStimX[i-1][j-1][k-1]/
													(fabs(XFlow[i-1][j-1][k-1]*6.0e13)+FlowRef)));
				}
			}
//-----------------------------------------------
		}	//end j loop
	}	//end k loop
//outfileConducted2 << "got past unique stimuli" << endl;
//outfileConducted2 << flowTime << endl;

	PassMin=500000;

	for	(k=1;k<=m_nz;k++)
	{	for	(j=1;j<=m_ny;j++)
		{	for	(i=1;i<=m_nx;i++)
			{
				if	(DeadEnd[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
				{
//outfileConducted2 << endl;
//outfileConducted2 << "Node (" << i << "," << j << ")" << endl;

					//x-bond to left
					if	(
							XFlow[i-1][j-1][k-1]>0.0
							&& FalseFlow[LabX(i,j,k)-1]==false
						)
					{
						BondLabelMax+=1;
						BondLabel[LabX(i,j,k)-1]=BondLabelMax;

						icoord[BondLabelMax]=i;
						jcoord[BondLabelMax]=j;
						kcoord[BondLabelMax]=k;

						if	(i>1)
						{
							NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ConductedStimX[i-1][j-1][k-1];
							BondsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[i-1-1][j-1][k-1]==BondsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1])
							{
								PassNode[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
							}

							if	(PassNode[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
							{
								if	(BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
								{
									PassMin=BondLabel[LabX(i,j,k)-1];
									q=PassMin;
								}
							}
						}

						else	{BondLabel[LabX(i,j,k)-1]=0;}

if	(i>1)
{
//outfileConducted2 << "x-bond (" << i << "," << j << ")" << "\t" << BondLabel[LabX(i,j,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[i-1][j-1][k-1] << "\t" << "node stim=" << NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << i << "," << j << ")" << "\t" << BondLabel[LabX(i,j,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[i-1][j-1][k-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}
					}

					//x-bond to right
					if	(
							XFlow[i+1-1][j-1][k-1]<0.0
							&& FalseFlow[LabX(i+1,j,k)-1]==false
						)
					{
						BondLabelMax+=1;
						BondLabel[LabX(i+1,j,k)-1]=BondLabelMax;

						icoord[BondLabelMax]=i+1;
						jcoord[BondLabelMax]=j;
						kcoord[BondLabelMax]=k;

						if	(i<m_nx)
						{
							NodeStim[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ConductedStimX[i+1-1][j-1][k-1];
							BondsIn[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[i+1-1][j-1][k-1]==BondsIn[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1])
							{
								PassNode[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
							}

							if	(PassNode[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
							{
								if	(BondLabel[LabX(i+1,j,k)-1]>0 && BondLabel[LabX(i+1,j,k)-1]<PassMin)
								{
									PassMin=BondLabel[LabX(i+1,j,k)-1];
									q=PassMin;
								}
							}
						}

						else	{BondLabel[LabX(i+1,j,k)-1]=0;}

if	(i<m_nx)
{
//outfileConducted2 << "x-bond (" << i+1 << "," << j << ")" << "\t" << BondLabel[LabX(i+1,j,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[i+1-1][j-1][k-1] << "\t" << "node stim=" << NodeStim[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << i+1 << "," << j << ")" << "\t" << BondLabel[LabX(i+1,j,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[i+1-1][j-1][k-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}
					}
				
					//y-bond above
					if	(
							YFlow[i-1][j-1][k-1]>0.0
							&& FalseFlow[LabY(i,j,k)-1]==false
						)
					{
						BondLabelMax+=1;
						BondLabel[LabY(i,j,k)-1]=BondLabelMax;

						icoord[BondLabelMax]=i;
						jcoord[BondLabelMax]=j;
						kcoord[BondLabelMax]=k;

						NodeStim[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ConductedStimY[i-1][j-1][k-1];
						BondsIn[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[i-1][j-1-1][k-1]==BondsIn[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1])
						{
							PassNode[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
						}

						if	(PassNode[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
						{
							if	(BondLabel[LabY(i,j,k)-1]>0 && BondLabel[LabY(i,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabY(i,j,k)-1];
								q=PassMin;
							}
						}
//outfileConducted2 << "y-bond (" << i << "," << j << ")" << "\t" << BondLabel[LabY(i,j,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[i-1][j-1][k-1] << "\t" << "node stim=" << NodeStim[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
					
					//y-bond below
					if	(j<m_ny)
					{
						if	(
								YFlow[i-1][j+1-1][k-1]<0.0
								&& FalseFlow[LabY(i,j+1,k)-1]==false
							)
						{
							BondLabelMax+=1;
							BondLabel[LabY(i,j+1,k)-1]=BondLabelMax;

							icoord[BondLabelMax]=i;
							jcoord[BondLabelMax]=j+1;
							kcoord[BondLabelMax]=k;

							NodeStim[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ConductedStimY[i-1][j+1-1][k-1];
							BondsIn[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[i-1][j+1-1][k-1]==BondsIn[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1])
							{
								PassNode[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
							}

							if	(PassNode[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
							{
								if	(BondLabel[LabY(i,j+1,k)-1]>0 && BondLabel[LabY(i,j+1,k)-1]<PassMin)
								{
									PassMin=BondLabel[LabY(i,j+1,k)-1];
									q=PassMin;
								}
							}
//outfileConducted2 << "y-bond (" << i << "," << j+1 << ")" << "\t" << BondLabel[LabY(i,j+1,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[i-1][j+1-1][k-1] << "\t" << "node stim=" << NodeStim[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
					
					if	(m_nz!=1)
					{
						//z-bond out of screen
						if	(
								ZFlow[i-1][j-1][k-1]>0.0
								&& FalseFlow[LabZ(i,j,k)-1]==false
							)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(i,j,k)-1]=BondLabelMax;

							icoord[BondLabelMax]=i;
							jcoord[BondLabelMax]=j;
							kcoord[BondLabelMax]=k;

							NodeStim[i+(j-1)*m_nx+(k-1-1)*m_nx*m_ny-1]+=ConductedStimZ[i-1][j-1][k-1];
							BondsIn[i+(j-1)*m_nx+(k-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[i-1][j-1][k-1-1]==BondsIn[i+(j-1)*m_nx+(k-1-1)*m_nx*m_ny-1])
							{
								PassNode[i+(j-1)*m_nx+(k-1-1)*m_nx*m_ny-1]=true;
							}

							if	(PassNode[i+(j-1)*m_nx+(k-1-1)*m_nx*m_ny-1]==true)
							{
								if	(BondLabel[LabZ(i,j,k)-1]>0 && BondLabel[LabZ(i,j,k)-1]<PassMin)
								{
									PassMin=BondLabel[LabZ(i,j,k)-1];
									q=PassMin;
								}
							}
						}
						
						if	(k<m_nz)
						{
							//z-bond into screen
							if	(
									ZFlow[i-1][j-1][k+1-1]<0.0
									&& FalseFlow[LabZ(i,j,k+1)-1]==false
								)
							{
								BondLabelMax+=1;
								BondLabel[LabZ(i,j,k+1)-1]=BondLabelMax;

								icoord[BondLabelMax]=i;
								jcoord[BondLabelMax]=j;
								kcoord[BondLabelMax]=k+1;

								NodeStim[i+(j-1)*m_nx+(k+1-1)*m_nx*m_ny-1]+=ConductedStimZ[i-1][j-1][k+1-1];
								BondsIn[i+(j-1)*m_nx+(k+1-1)*m_nx*m_ny-1]+=1;

								if	(NumFlowsOut[i-1][j-1][k+1-1]==BondsIn[i+(j-1)*m_nx+(k+1-1)*m_nx*m_ny-1])
								{
									PassNode[i+(j-1)*m_nx+(k+1-1)*m_nx*m_ny-1]=true;
								}

								if	(PassNode[i+(j-1)*m_nx+(k+1-1)*m_nx*m_ny-1]==true)
								{
									if	(BondLabel[LabZ(i,j,k+1)-1]>0 && BondLabel[LabZ(i,j,k+1)-1]<PassMin)
									{
										PassMin=BondLabel[LabZ(i,j,k+1)-1];
										q=PassMin;
									}
								}
							}
						}
					}
					
					DeadEnd[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=false;
				}

			}	//end i-loop

			i=m_nx+1;
	
			if	(
					XFlow[i-1][j-1][k-1]>0.0 
					&& FalseFlow[LabX(i,j,k)-1]==false
				)
			{
				BondLabelMax+=1;
				BondLabel[LabX(i,j,k)-1]=BondLabelMax;

				icoord[BondLabelMax]=i;
				jcoord[BondLabelMax]=j;
				kcoord[BondLabelMax]=k;

				NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=ConductedStimX[i-1][j-1][k-1];
				BondsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

				if	(NumFlowsOut[i-1-1][j-1][k-1]==BondsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1])
				{
					PassNode[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
				}

				if	(PassNode[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
				{
					if	(BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
					{
						PassMin=BondLabel[LabX(i,j,k)-1];
						q=PassMin;
					}
				}
//outfileConducted2 << "x-bond (" << i << "," << j << ")" << "\t" << BondLabel[LabX(i,j,k)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[i-1][j-1][k-1] << "\t" << "node stim=" << NodeStim[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
			}
		}	//end j-loop
	}	//end k-loop

//outfileConducted2 << "got past dead ends & outlets" << endl;
//-----------------------------------------------
	for (int n=1;n<=Nbond;n++)
	{
		BondLabelSum+=BondLabel[n-1];
	}

//-----------------------------------------------
	while	(BondLabelSum>0)
	{
//outfileConducted2 << "Bond Label Sum=" << BondLabelSum << endl;
		BondLabelSum=0;

		//x-bond with negative flow labelled
		if	(
				BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==q
				&&
				XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
			)
		{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}
					
if	(icoord[q]<m_nx)
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

					}
				}
			}

			//y-bond above labelled bond
			if	(jcoord[q]>1 && icoord[q]<m_nx+1)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;

					}
				}
			}

			//y-bond below labelled bond
			if	(jcoord[q]<m_ny && icoord[q]<m_nx+1)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;

					}
				}
			}
						
			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(kcoord[q]>1 && icoord[q]<m_nx+1)
				{outfileConducted2 << "x neg z out" << endl;
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q];

							ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(kcoord[q]<m_nz && icoord[q]<m_nx+1)
				{outfileConducted2 << "x neg z in" << endl;
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q]+1 << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}
			}
		}
								
		//x-bond with positive flow labelled
		else if	(
					BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(icoord[q]>1)
			{
				if	(
						XFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]-1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

						if	(icoord[q]>2)
						{
							NodeStim[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

							BondsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-2-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]=0;}
if	(icoord[q]>2)
{
//outfileConducted2 << "x-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else	
{
//outfileConducted2 << "x-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

					}
				}
			}

			//y-bond above labelled bond
			if	(icoord[q]>1 && jcoord[q]>1)
			{
				if	(
						YFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]-1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					
//outfileConducted2 << "y-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;

					}
				}
			}

			//y-bond below labelled bond
			if	(icoord[q]>1 && jcoord[q]<m_ny)
			{
				if	(
						YFlow[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]-1;
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]+=NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConducted2 << "y-bond (" << icoord[q]-1 << "," << jcoord[q]+1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;

					}
				}
			}

			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(icoord[q]>1 && kcoord[q]>1)
				{outfileConducted2 << "x pos z out" << endl;	
					if	(
							ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q]-1;
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q];

							ConductedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

							NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(icoord[q]>1 && kcoord[q]<m_nz)
				{outfileConducted2 << "x pos z in" << endl;	
					if	(
							ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q]-1;
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConductedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]+=NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1];

							NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1];
	
							BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q]+1 << ")" << "\t" << BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}
			}
		}
		
		//y-bond with negative flow labelled
		else if	(
					BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
				)
		{
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(
					XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0 
					&& 
					FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q])-1]==false
				)
			{
				if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==0)
				{
					BondLabelMax+=1;
					BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

					icoord[BondLabelMax]=icoord[q];
					jcoord[BondLabelMax]=jcoord[q];
					kcoord[BondLabelMax]=kcoord[q];

					ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																			*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

					if	(icoord[q]>1)
					{
						NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					}

					else	{BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;}

if	(icoord[q]>1)
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

				}
			}
			
			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}
						
if	(icoord[q]<m_nx)
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

					}
				}
			}
									
			//y-bond below labelled bond
			if	(jcoord[q]<m_ny)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;

					}
				}
			}

			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(kcoord[q]>1)
				{outfileConducted2 << "y neg z out" << endl;
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q];

							ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(kcoord[q]<m_nz)
				{outfileConducted2 << "y neg z in" << endl;
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q];
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

							NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1];
		
							BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q]-1 << "," << jcoord[q] << "," << kcoord[q]+1 << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}
			}
		}

		//y-bond with positive flow labelled
		else if	(
					BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(jcoord[q]>1)
			{
				if	(
						XFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]-1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

						if	(icoord[q]>1)
						{
							NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

							BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]=0;}

if	(icoord[q]>1)
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

					}
				}
			}

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1 && jcoord[q]>1)
			{
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q]-1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}
						
						else	{BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=0;}
						
if	(icoord[q]<m_nx)
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

					}
				}
			}
									
			//y-bond above labelled bond
			if	(jcoord[q]>2)
			{
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]-1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]-2-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}

//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;

					}
				}
			}
									
			if	(m_nz!=1)
			{
				//z-bond out of screen from labelled bond
				if	(jcoord[q]>1 && kcoord[q]>1)
				{outfileConducted2 << "y pos z out" << endl;
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]>0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q]-1;
							kcoord[BondLabelMax]=kcoord[q];

							ConductedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

							NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}

				//z-bond into screen from labelled bond
				if	(jcoord[q]>1 && kcoord[q]<m_nz)
				{outfileConducted2 << "y pos z in" << endl;
					if	(
							ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]<0.0 
							&& 
							FalseFlow[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]==false
						)
					{
						if	(BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]==0)
						{
							BondLabelMax+=1;
							BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]=BondLabelMax;

							icoord[BondLabelMax]=icoord[q];
							jcoord[BondLabelMax]=jcoord[q]-1;
							kcoord[BondLabelMax]=kcoord[q]+1;

							ConductedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]+=NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																						*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1];

							NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1];
	
							BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
							}
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q]-1 << "," << kcoord[q]+1 << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
						}
					}
				}
			}
		}
							
		//z-bond with negative flow labelled
		else if	(
					BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
				)
		{
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(
					XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0 
					&& 
					FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q])-1]==false
				)
			{//outfileConducted2 << "z neg x left" << endl;
				if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==0)
				{
					BondLabelMax+=1;
					BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

					icoord[BondLabelMax]=icoord[q];
					jcoord[BondLabelMax]=jcoord[q];
					kcoord[BondLabelMax]=kcoord[q];

					ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																			*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

					if	(icoord[q]>1)
					{
						NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
					}

					else	{BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;}

if	(icoord[q]>1)
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}
					
				}
			}
			
			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1)
			{//outfileConducted2 << "z neg x right" << endl;
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}

if	(icoord[q]<m_nx)
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}
					}
				}
			}
									
			//y-bond above labelled bond
			if	(jcoord[q]>1)
			{//outfileConducted2 << "z neg y above" << endl;
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																				*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
				}
			}

			//y-bond below labelled bond
			if	(jcoord[q]<m_ny)
			{//outfileConducted2 << "z neg y below" << endl;
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q];

						ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]=true;
						}
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
				}
			}
									
			//z-bond into screen from labelled bond
			if	(kcoord[q]<m_nz)
			{//outfileConducted2 << "z neg z in" << endl;
				if	(
						ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]<0.0 
						&& 
						FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==false
					)
				{
					if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]+1;

						ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1];

						NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1];
	
						BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]=true;
						}
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q]+1 << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
				}
			}
		}

		//z-bond with positive flow labelled
		else if (
					BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=0;

			//x-bond to left of labelled bond
			if	(kcoord[q]>1)
			{//outfileConducted2 << "z pos x left" << endl;
				if	(
						XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]>0.0 
						&& 
						FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						if	(icoord[q]>1)
						{
							NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

							BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]=0;}

if	(icoord[q]>1)
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1] << "\t" << "node stim=" << NodeStim[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q] << "," << jcoord[q]-1 << "," << kcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}
					}
				}
			}

			//x-bond to right of labelled bond
			if	(icoord[q]<m_nx+1 && kcoord[q]>1)
			{//outfileConducted2 << "z pos x right" << endl;
				if	(
						XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
						&& 
						FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q]+1;
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						if	(icoord[q]<m_nx)
						{
							NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1];

							BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

							if	(NumFlowsOut[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]==BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
							{
								PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
							}
						}

						else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=0;}

if	(icoord[q]<m_nx)
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}

else
{
//outfileConducted2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << "," << kcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimX[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
}
					}
				}
			}
									
			//y-bond above labelled bond
			if	(jcoord[q]>1 && kcoord[q]>1)
			{outfileConducted2 << "z pos y above" << endl;
				if	(
						YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]>0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
						}
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q]-1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
				}
			}

			//y-bond below labelled node
			if	(jcoord[q]<m_ny && kcoord[q]>1)
			{outfileConducted2 << "z pos y below" << endl;
				if	(
						YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]<0.0 
						&& 
						FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q]+1;
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1];

						BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]==BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]=true;
						}
//outfileConducted2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << "," << kcoord[q]-1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimY[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
				}
			}
									
			//z-bond out of screen from labelled bond
			if	(kcoord[q]>2)
			{outfileConducted2 << "z pos z out" << endl;
				if	(
						ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]>0.0 
						&& 
						FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]==false
					)
				{
					if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
					{
						BondLabelMax+=1;
						BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

						icoord[BondLabelMax]=icoord[q];
						jcoord[BondLabelMax]=jcoord[q];
						kcoord[BondLabelMax]=kcoord[q]-1;

						ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]+=NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]
																					*exp(-DecayIndex)/NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];

						NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]+=ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1];
	
						BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]+=1;

						if	(NumFlowsOut[icoord[q]-1][jcoord[q]-1][kcoord[q]-2-1]==BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1])
						{
							PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]=true;
						}
//outfileConducted2 << "z-bond (" << icoord[q] << "," << jcoord[q] << "," << kcoord[q]-1 << ")" << "\t" << BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1] << endl;
//outfileConducted2 << "vessel stim=" << ConductedStimZ[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1] << "\t" << "node stim=" << NodeStim[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "bonds in=" << BondsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1] << "\t" << "pass node=" << PassNode[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1] << endl;
//outfileConducted2 << "q=" << q << endl;
//outfileConducted2 << endl;
					}
				}
			}
		}
//-----------------------------------------------

		PassMin=500000;
		
		for	(k=1;k<=m_nz;k++)
		{	for	(j=1;j<=m_ny;j++)
			{	for	(i=1;i<=m_nx;i++)
				{
//if	(i==26 && j==21 && k==22){outfileConducted2 << ZFlow[i-1][j-1][k-1] << endl;}
					if	(PassNode[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
					{
						//x-bond to left
						if	(XFlow[i-1][j-1][k-1]<0.0 && BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabX(i,j,k)-1];
							q=PassMin;
						}

						//x-bond to right
						if	(XFlow[i+1-1][j-1][k-1]>0.0 && BondLabel[LabX(i+1,j,k)-1]>0 && BondLabel[LabX(i+1,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabX(i+1,j,k)-1];
							q=PassMin;
						}

						//y-bond above
						if	(YFlow[i-1][j-1][k-1]<0.0 && BondLabel[LabY(i,j,k)-1]>0 && BondLabel[LabY(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabY(i,j,k)-1];
							q=PassMin;
						}

						//y-bond below
						if	(j<m_ny)
						{
							if	(YFlow[i-1][j+1-1][k-1]>0.0 && BondLabel[LabY(i,j+1,k)-1]>0 && BondLabel[LabY(i,j+1,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabY(i,j+1,k)-1];
								q=PassMin;
							}
						}

						if	(m_nz!=1)
						{
							//z-bond out of screen
							if	(ZFlow[i-1][j-1][k-1]<0.0 && BondLabel[LabZ(i,j,k)-1]>0 && BondLabel[LabZ(i,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabZ(i,j,k)-1];
								q=PassMin;
							}

							if	(k<m_nz)
							{
								//z-bond into screen
								if	(ZFlow[i-1][j-1][k+1-1]>0.0 && BondLabel[LabZ(i,j,k+1)-1]>0 && BondLabel[LabZ(i,j,k+1)-1]<PassMin)
								{
									PassMin=BondLabel[LabZ(i,j,k+1)-1];
									q=PassMin;
								}
							}
						}
					}
				}
			}
		}

		for (int n=1;n<=Nbond;n++)
		{
			BondLabelSum+=BondLabel[n-1];
			
//			if (BondLabel[n-1]>0)
//			{
//				outfileConducted2 << n << "\t" << BondLabel[n-1] << endl;
//			}
		}

//-----------------------------------------------
	}	//end while loop

//outfileConducted2 << "got past while loop" << endl;

/*outfileDebugConductedStim2 << flowTime << endl;
	for	(i=1;i<=m_nx;i++)
	{	for(j=1;j<=m_ny;j++)
		{
			k=1;

//			if	(loop%1000==0)	
//			{
				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConductedStim2 << "x-bond (" << i << "," << j << ")" << "\t" << ConductedStimX[i-1][j-1][k-1] << endl;}
				if	(pFluid[LabY(i,j,k)-1]==10)	{outfileDebugConductedStim2 << "y-bond (" << i << "," << j << ")" << "\t" << ConductedStimY[i-1][j-1][k-1] << endl;}
//			}
		}
	}

	for(j=1;j<=m_ny;j++)
	{
			i=m_nx+1;
			k=1;

//			if	(loop%1000==0)	
//			{
				if	(pFluid[LabX(i,j,k)-1]==10)	{outfileDebugConductedStim2 << "x-bond (" << i << "," << j << ")" << "\t" << ConductedStimX[i-1][j-1][k-1] << endl;}
//			}
	}
	outfileDebugConductedStim2 << endl;	
*/
//---Clear up arrays---

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			delete[] NumFlowsOut[i][j];
			delete[] NumFlowsIn[i][j];
		}
	}

	for (i=0;i<m_nx;i++)
	{
		delete[] NumFlowsOut[i];
		delete[] NumFlowsIn[i];
	}

	delete[] NumFlowsOut;
	delete[] NumFlowsIn;
		
	delete[] BondLabel;
	delete[] BondsIn;
	delete[] PassNode;
	delete[] DeadEnd;
	delete[] NodeStim;
	delete[] icoord;
	delete[] jcoord;
	delete[] kcoord;
}

//***********************************************

//==========================================
void CAngioNetDlg::IdentifyFalseFlows(void)
//==========================================
{
	int i,j,k;
	int q=0;
	
	int BondLabelMax=0;
	int BondLabelSum=0;
	int Nnode=m_nx*m_ny*m_nz;
	int PassMin=500000;

	int* BondLabel=NULL;
	int* icoord=NULL;
	int* jcoord=NULL;
	int* kcoord=NULL;
	
	BondLabel=new int[Nbond];
	icoord=new int[Nbond];
	jcoord=new int[Nbond];
	kcoord=new int[Nbond];
    		
	for	(int n=1;n<=Nbond;n++)	
	{
		BondLabel[n-1]=0;
		icoord[n-1]=0;
		jcoord[n-1]=0;
		kcoord[n-1]=0;
	}
//-----------------------------------------------
	
	double*** TotalFlowOut=NULL;
	double*** TotalFlowIn=NULL;
	int*** NumFlowsIn=NULL;
	
	TotalFlowOut=new double**[m_nx];
	TotalFlowIn=new double**[m_nx];
	NumFlowsIn=new int**[m_nx];
	
	for (i=0;i<m_nx;i++)
	{
		TotalFlowOut[i]=new double* [m_ny];
		TotalFlowIn[i]=new double* [m_ny];
		NumFlowsIn[i]=new int*[m_ny];
	}

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			TotalFlowOut[i][j]=new double [m_nz];
			TotalFlowIn[i][j]=new double [m_nz];
			NumFlowsIn[i][j]=new int[m_nz];
		}
	}

	bool* AdjustOutflows=NULL;
	int* FalseFlowsIn=NULL;
			
	AdjustOutflows=new bool[Nnode];
	FalseFlowsIn=new int[Nnode];
		    		
	for	(int n=1;n<=Nbond;n++)	
	{
		FalseFlow[n-1]=false;
	}

	for	(int n=1;n<=Nnode;n++)	
	{
		FalseFlowsIn[n-1]=0;
		AdjustOutflows[n-1]=false;
	}

//outfileConvected2 << "got past initialisation" << endl;
//outfileConvected2 << flowTime << endl;
//-----------------------------------------------
	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{
				TotalFlowOut[i-1][j-1][k-1]=0.0;
				TotalFlowIn[i-1][j-1][k-1]=0.0;
				NumFlowsIn[i-1][j-1][k-1]=0;

				//---x-bond to left---
				if	(XFlow[i-1][j-1][k-1]<0.0)
				{
					TotalFlowOut[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1]);
				}

				else if	(XFlow[i-1][j-1][k-1]>0.0)
				{
					TotalFlowIn[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1]);
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}
				
//---x-bond to right---
				if	(XFlow[i+1-1][j-1][k-1]>0.0)
				{
					TotalFlowOut[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1]);
				}

				else if	(XFlow[i+1-1][j-1][k-1]<0.0)
				{
					TotalFlowIn[i-1][j-1][k-1]+=fabs(XFlow[i+1-1][j-1][k-1]);
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}
				
//---y-bond above---
				if	(YFlow[i-1][j-1][k-1]<0.0)
				{
					TotalFlowOut[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1]);
				}

				else if	(YFlow[i-1][j-1][k-1]>0.0)
				{
					TotalFlowIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j-1][k-1]);
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}
				
//---y-bond below---
				if	(j!=m_ny)
				{
					if	(YFlow[i-1][j+1-1][k-1]>0.0)
					{
						TotalFlowOut[i-1][j-1][k-1]+=fabs(YFlow[i-1][j+1-1][k-1]);
					}

					else if	(YFlow[i-1][j+1-1][k-1]<0.0)
					{
						TotalFlowIn[i-1][j-1][k-1]+=fabs(YFlow[i-1][j+1-1][k-1]);
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}

//---z-bond out of screen---
				if	(ZFlow[i-1][j-1][k-1]<0.0)
				{
					TotalFlowOut[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1]);
				}

				else if	(ZFlow[i-1][j-1][k-1]>0.0)
				{
					TotalFlowIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k-1]);
					NumFlowsIn[i-1][j-1][k-1]+=1;
				}
				
//---z-bond into screen---
				if	(k!=m_nz)
				{
					if	(ZFlow[i-1][j-1][k+1-1]>0.0)
					{
						TotalFlowOut[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k+1-1]);
					}

					else if	(ZFlow[i-1][j-1][k+1-1]<0.0)
					{
						TotalFlowIn[i-1][j-1][k-1]+=fabs(ZFlow[i-1][j-1][k+1-1]);
						NumFlowsIn[i-1][j-1][k-1]+=1;
					}
				}
//--------------------------

				if	(TotalFlowOut[i-1][j-1][k-1]>0.0 && TotalFlowIn[i-1][j-1][k-1]==0.0)
				{
					AdjustOutflows[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=true;
//outfileConvected2 << "False source from node (" << i << "," << j << ")" << endl;
				}

//outfileConvected2 << "(" << i << "," << j << ")" << "\t" << "Total Flow In=" << TotalFlowIn[i-1][j-1][k-1] << "\t" 
//<< "Total Flow Out=" << TotalFlowOut[i-1][j-1][k-1] << endl;
//if	(TotalFlowOut[i-1][j-1][k-1]>TotalFlowIn[i-1][j-1][k-1])	{//outfileConvected2 << "False Flow!" << endl;}
////outfileConvected2 << endl;

			}
		}
	}

	for	(k=1;k<=m_nz;k++)
	{	for	(j=1;j<=m_ny;j++)
		{	for	(i=1;i<=m_nx;i++)
			{
				if	(AdjustOutflows[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true)
				{
//outfileConvected2 << endl;
//outfileConvected2 << "Node (" << i << "," << j << ")" << endl;

					//x-bond to left
					if	(XFlow[i-1][j-1][k-1]<0.0)
					{
						FalseFlow[LabX(i,j,k)-1]=true;
						if	(i>1)	{FalseFlowsIn[i-1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;}

						BondLabelMax+=1;
						BondLabel[LabX(i,j,k)-1]=BondLabelMax;

						icoord[BondLabelMax]=i;
						jcoord[BondLabelMax]=j;
						kcoord[BondLabelMax]=k;

						if	(BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabX(i,j,k)-1];
							q=PassMin;
						}

//outfileConvected2 << "x-bond (" << i << "," << j << ")" << "\t" << "Bond Label=" << BondLabel[LabX(i,j,k)-1] << endl;

					}

					//x-bond to right
					if	(XFlow[i+1-1][j-1][k-1]>0.0)
					{
						FalseFlow[LabX(i+1,j,k)-1]=true;
						if	(i<m_nx)	{FalseFlowsIn[i+1+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;}

						BondLabelMax+=1;
						BondLabel[LabX(i+1,j,k)-1]=BondLabelMax;

						icoord[BondLabelMax]=i+1;
						jcoord[BondLabelMax]=j;
						kcoord[BondLabelMax]=k;

						if	(BondLabel[LabX(i+1,j,k)-1]>0 && BondLabel[LabX(i+1,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabX(i+1,j,k)-1];
							q=PassMin;
						}

//outfileConvected2 << "x-bond (" << i+1 << "," << j << ")" << "\t" << "Bond Label=" << BondLabel[LabX(i+1,j,k)-1] << endl;

					}

					//y-bond above
					if	(YFlow[i-1][j-1][k-1]<0.0)
					{
						FalseFlow[LabY(i,j,k)-1]=true;
						if	(j>1)	{FalseFlowsIn[i+(j-1-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;}

						BondLabelMax+=1;
						BondLabel[LabY(i,j,k)-1]=BondLabelMax;

						icoord[BondLabelMax]=i;
						jcoord[BondLabelMax]=j;
						kcoord[BondLabelMax]=k;

						if	(BondLabel[LabY(i,j,k)-1]>0 && BondLabel[LabY(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabY(i,j,k)-1];
							q=PassMin;
						}

//outfileConvected2 << "y-bond (" << i << "," << j << ")" << "\t" << "Bond Label=" << BondLabel[LabY(i,j,k)-1] << endl;

					}

					//y-bond below
					if	(j<m_ny)
					{
						if	(YFlow[i-1][j+1-1][k-1]>0.0)
						{
							FalseFlow[LabY(i,j+1,k)-1]=true;
							FalseFlowsIn[i+(j+1-1)*m_nx+(k-1)*m_nx*m_ny-1]+=1;

							BondLabelMax+=1;
							BondLabel[LabY(i,j+1,k)-1]=BondLabelMax;

							icoord[BondLabelMax]=i;
							jcoord[BondLabelMax]=j+1;
							kcoord[BondLabelMax]=k;

							if	(BondLabel[LabY(i,j+1,k)-1]>0 && BondLabel[LabY(i,j+1,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabY(i,j+1,k)-1];
								q=PassMin;
							}

//outfileConvected2 << "y-bond (" << i << "," << j+1 << ")" << "\t" << "Bond Label=" << BondLabel[LabY(i,j+1,k)-1] << endl;

						}
					}

					if	(m_nz!=1)
					{
						//z-bond out of screen
						if	(ZFlow[i-1][j-1][k-1]<0.0)
						{
							FalseFlow[LabZ(i,j,k)-1]=true;
							if	(k>1)	{FalseFlowsIn[i+(j-1)*m_nx+(k-1-1)*m_nx*m_ny-1]+=1;}

							BondLabelMax+=1;
							BondLabel[LabZ(i,j,k)-1]=BondLabelMax;

							icoord[BondLabelMax]=i;
							jcoord[BondLabelMax]=j;
							kcoord[BondLabelMax]=k;

							if	(BondLabel[LabZ(i,j,k)-1]>0 && BondLabel[LabZ(i,j,k)-1]<PassMin)
							{
								PassMin=BondLabel[LabZ(i,j,k)-1];
								q=PassMin;
							}

						}

						if	(k<m_nz)
						{
							//z-bond into screen
							if	(ZFlow[i-1][j-1][k+1-1]>0.0)
							{
								FalseFlow[LabZ(i,j,k+1)-1]=true;
								FalseFlowsIn[i+(j-1)*m_nx+(k+1-1)*m_nx*m_ny-1]+=1;

								BondLabelMax+=1;
								BondLabel[LabZ(i,j,k+1)-1]=BondLabelMax;

								icoord[BondLabelMax]=i;
								jcoord[BondLabelMax]=j;
								kcoord[BondLabelMax]=k+1;

								if	(BondLabel[LabZ(i,j,k+1)-1]>0 && BondLabel[LabZ(i,j,k+1)-1]<PassMin)
								{
									PassMin=BondLabel[LabZ(i,j,k+1)-1];
									q=PassMin;
								}
							}
						}
					}

					AdjustOutflows[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]=false;

				}
			}
		}
	}

	for	(int n=1;n<=Nbond;n++)
	{
		BondLabelSum+=BondLabel[n-1];
	}

	while	(BondLabelSum>0)
	{
		//outfileConvected2 << "Bond Label Sum=" << BondLabelSum << endl;
		BondLabelSum=0;

		//x-bond with negative flow labelled
		if	(
				BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==q
				&&
				XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
			)
		{
//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;

			if	(FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]>0)
			{
				if	(FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]==NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])
				{
					//x-bond to left of labelled bond
					if	(icoord[q]>2)
					{
						if	(
								XFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(XFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]-1;
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
											
//outfileConvected2 << "x-bond (" << icoord[q]-1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]-2+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-2-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
		
					//y-bond above labelled bond
					if	(jcoord[q]>1 && icoord[q]>1)
					{
						if	(
								YFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]-1;
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
					
//outfileConvected2 << "y-bond (" << icoord[q]-1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q]-1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
			
					//y-bond below labelled bond
					if	(jcoord[q]<m_ny && icoord[q]>1)
					{
						if	(
								YFlow[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]-1;
								jcoord[BondLabelMax]=jcoord[q]+1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
					
//outfileConvected2 << "y-bond (" << icoord[q]-1 << "," << jcoord[q]+1 << ")" << "\t" << BondLabel[LabY(icoord[q]-1,jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]-1+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1-1][jcoord[q]+1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
									
					if	(m_nz!=1)
					{
						//z-bond out of screen from labelled bond
						if	(kcoord[q]>1 && icoord[q]>1)
						{
							if	(
									ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q]-1;
									jcoord[BondLabelMax]=jcoord[q];
									kcoord[BondLabelMax]=kcoord[q];

									FalseFlow[LabZ(icoord[q]-1,jcoord[q],kcoord[q])-1]=true;
									FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
				
						//z-bond into screen from labelled bond
						if	(kcoord[q]<m_nz && icoord[q]>1)
						{
							if	(
									ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1-1][jcoord[q]-1][kcoord[q]+1-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q]-1;
									jcoord[BondLabelMax]=jcoord[q];
									kcoord[BondLabelMax]=kcoord[q]+1;

									FalseFlow[LabZ(icoord[q]-1,jcoord[q],kcoord[q]+1)-1]=true;
									FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
					}
				}
			}
		}
								
		//x-bond with positive flow labelled
		else if	(
					BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=0;

			if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]>0)
			{
				if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]==NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
				{
					//x-bond to right of labelled bond
					if	(icoord[q]<m_nx+1)
					{
						if	(
								XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]+1;
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=true;
								if	(icoord[q]<m_nx)
								{
									FalseFlowsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
								}

								else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}
					
if	(icoord[q]<m_nx)
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

else
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}
							}
						}
					}
			
					//y-bond above labelled bond
					if	(icoord[q]!=m_nx+1 && jcoord[q]>1)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
					
//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
			
					//y-bond below labelled bond
					if	(icoord[q]!=m_nx+1 && jcoord[q]<m_ny)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q]+1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
			
					if	(m_nz!=1)
					{
						//z-bond out of screen from labelled bond
						if	(icoord[q]!=m_nx+1 && kcoord[q]>1)
						{	
							if	(
									ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q];
									jcoord[BondLabelMax]=jcoord[q];
									kcoord[BondLabelMax]=kcoord[q];

									FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=true;
									FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
							
						//z-bond into screen from labelled bond
						if	(icoord[q]!=m_nx+1 && kcoord[q]<m_nz)
						{	
							if	(
									ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q];
									jcoord[BondLabelMax]=jcoord[q];
									kcoord[BondLabelMax]=kcoord[q]+1;

									FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=true;
									FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
					}
				}
			}
		}
		
		//y-bond with negative flow labelled
		else if	(
					BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
				)
		{
//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=0;

			if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]>0)
			{
				if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]==NumFlowsIn[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])
				{
					//x-bond to left of labelled bond
					if	(icoord[q]>1 && jcoord[q]>1)
					{
						if	(
								XFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(XFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q]-1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]-1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
			
					//x-bond to right of labelled bond
					if	(icoord[q]<m_nx+1 && jcoord[q]>1)
					{
						if	(
								XFlow[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(XFlow[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]+1;
								jcoord[BondLabelMax]=jcoord[q]-1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=true;
								if	(icoord[q]<m_nx)
								{
									FalseFlowsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
								}

								else	{BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1]=0;}

if	(icoord[q]<m_nx)
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]+1+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]+1-1][jcoord[q]-1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

else
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

							}
						}
					}
				
					//y-bond above labelled bond
					if	(jcoord[q]>2)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q]-1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q]-1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]-1,kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]+(jcoord[q]-2-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1][jcoord[q]-2-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
			
					if	(m_nz!=1)
					{
						//z-bond out of screen from labelled bond
						if	(jcoord[q]>1 && kcoord[q]>1)
						{
							if	(
									ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1]<0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q];
									jcoord[BondLabelMax]=jcoord[q]-1;
									kcoord[BondLabelMax]=kcoord[q];

									FalseFlow[LabZ(icoord[q],jcoord[q]-1,kcoord[q])-1]=true;
									FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
				
						//z-bond into screen from labelled bond
						if	(jcoord[q]>1 && kcoord[q]<m_nz)
						{
							if	(
									ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1]>0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1][jcoord[q]-1-1][kcoord[q]+1-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q];
									jcoord[BondLabelMax]=jcoord[q]-1;
									kcoord[BondLabelMax]=kcoord[q]+1;

									FalseFlow[LabZ(icoord[q],jcoord[q]-1,kcoord[q]+1)-1]=true;
									FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
					}
				}
			}
		}

		//y-bond with positive flow labelled
		else if	(
					BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << "q=" << q << endl;

			BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=0;

			if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]>0)
			{
				if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]==NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
				{
					//x-bond to left of labelled bond
					if	(icoord[q]>1)
					{
						if	(
								XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

//outfileConvected2 << "x-bond (" << icoord[q] << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
			
					//x-bond to right of labelled bond
					if	(icoord[q]<m_nx+1)
					{
						if	(
								XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]+1;
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=true;
								if	(icoord[q]<m_nx)
								{
									FalseFlowsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
								}

								else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}

if	(icoord[q]<m_nx)
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "false flows in=" << FalseFlowsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

else
{
//outfileConvected2 << "x-bond (" << icoord[q]+1 << "," << jcoord[q] << ")" << "\t" << BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;
}

							}
						}
					}
												
					//y-bond below labelled bond
					if	(jcoord[q]<m_ny)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q]+1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;

//outfileConvected2 << "y-bond (" << icoord[q] << "," << jcoord[q]+1 << ")" << "\t" << BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1] << endl;
//outfileConvected2 << "fasle flows in=" << FalseFlowsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1] << endl;
//outfileConvected2 << "num flows in=" << NumFlowsIn[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1] << endl;
//outfileConvected2 << "q=" << q << endl;
//outfileConvected2 << endl;

							}
						}
					}
												
					if	(m_nz!=1)
					{
						//z-bond out of screen from labelled bond
						if	(kcoord[q]>1)
						{
							if	(
									ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q];
									jcoord[BondLabelMax]=jcoord[q];
									kcoord[BondLabelMax]=kcoord[q];

									FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=true;
									FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
				
						//z-bond into screen from labelled bond
						if	(kcoord[q]<m_nz)
						{
							if	(
									ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
//									&& 
//									fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1])>=1.0e-18
								)
							{
								if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
								{
									BondLabelMax+=1;
									BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

									icoord[BondLabelMax]=icoord[q];
									jcoord[BondLabelMax]=jcoord[q];
									kcoord[BondLabelMax]=kcoord[q]+1;

									FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=true;
									FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;
								}
							}
						}
					}
				}
			}
		}
							
		//z-bond with negative flow labelled
		else if	(
					BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0
				)
		{
			BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=0;

			if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]>0)
			{
				if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]==NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])
				{
					//x-bond to left of labelled bond
					if	(icoord[q]>1 && kcoord[q]>1)
					{
						if	(
								XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
//								&& 
//								fabs(XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q]-1;

								FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q]-1)-1]=true;
								FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
			
					//x-bond to right of labelled bond
					if	(icoord[q]<m_nx+1 && kcoord[q]>1)
					{
						if	(
								XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1]>0.0 
//								&& 
//								fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]+1;
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q]-1;

								FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=true;
								if	(icoord[q]<m_nx)
								{
									FalseFlowsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
								}

								else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q]-1)-1]=0;}
							}
						}
					}
												
					//y-bond above labelled bond
					if	(jcoord[q]>1 && kcoord[q]>1)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q]-1;

								FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q]-1)-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
			
					//y-bond below labelled bond
					if	(jcoord[q]<m_ny && kcoord[q]>1)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1]>0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q]+1;
								kcoord[BondLabelMax]=kcoord[q]-1;

								FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q]-1)-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
												
					//z-bond out of screen from labelled bond
					if	(kcoord[q]>2)
					{
						if	(
								ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1]<0.0 
//								&& 
//								fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q]-1;

								FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]-1)-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-2-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
				}
			}
		}

		//z-bond with positive flow labelled
		else if (
					BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]==q 
					&& 
					ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]>0.0
				)
		{
			BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q])-1]=0;

			if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]>0)
			{
				if	(FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]==NumFlowsIn[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])
				{
					//x-bond to left of labelled bond
					if	(icoord[q]>1)
					{
						if	(
								XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(XFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q],jcoord[q],kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]-1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
			
					//x-bond to right of labelled bond
					if	(icoord[q]<m_nx+1)
					{
						if	(
								XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(XFlow[icoord[q]+1-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q]+1;
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=true;
								if	(icoord[q]<m_nx)
								{
									FalseFlowsIn[icoord[q]+1+(jcoord[q]-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
								}

								else	{BondLabel[LabX(icoord[q]+1,jcoord[q],kcoord[q])-1]=0;}
							}
						}
					}
												
					//y-bond above labelled bond
					if	(jcoord[q]>1)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1]<0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q],kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q],jcoord[q],kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]-1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
			
					//y-bond below labelled node
					if	(jcoord[q]<m_ny)
					{
						if	(
								YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1]>0.0 
//								&& 
//								fabs(YFlow[icoord[q]-1][jcoord[q]+1-1][kcoord[q]-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q]+1;
								kcoord[BondLabelMax]=kcoord[q];

								FalseFlow[LabY(icoord[q],jcoord[q]+1,kcoord[q])-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]+1-1)*m_nx+(kcoord[q]-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
												
					//z-bond into screen from labelled bond
					if	(kcoord[q]<m_nz)
					{
						if	(
								ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1]>0.0 
//								&& 
//								fabs(ZFlow[icoord[q]-1][jcoord[q]-1][kcoord[q]+1-1])>=1.0e-18
							)
						{
							if	(BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]==0)
							{
								BondLabelMax+=1;
								BondLabel[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=BondLabelMax;

								icoord[BondLabelMax]=icoord[q];
								jcoord[BondLabelMax]=jcoord[q];
								kcoord[BondLabelMax]=kcoord[q]+1;

								FalseFlow[LabZ(icoord[q],jcoord[q],kcoord[q]+1)-1]=true;
								FalseFlowsIn[icoord[q]+(jcoord[q]-1)*m_nx+(kcoord[q]+1-1)*m_nx*m_ny-1]+=1;
							}
						}
					}
				}
			}
		}

		PassMin=500000;
		
		for	(k=1;k<=m_nz;k++)
		{	for	(j=1;j<=m_ny;j++)
			{	for	(i=1;i<=m_nx;i++)
				{if	(i==26 && j==21 && k==22){outfileConducted2 << ZFlow[i-1][j-1][k-1] << endl;}
					//x-bond to left
					if	(XFlow[i-1][j-1][k-1]<0.0 && BondLabel[LabX(i,j,k)-1]>0 && BondLabel[LabX(i,j,k)-1]<PassMin)
					{
						PassMin=BondLabel[LabX(i,j,k)-1];
						q=PassMin;
					}

					//x-bond to right
					if	(XFlow[i+1-1][j-1][k-1]>0.0 && BondLabel[LabX(i+1,j,k)-1]>0 && BondLabel[LabX(i+1,j,k)-1]<PassMin)
					{
						PassMin=BondLabel[LabX(i+1,j,k)-1];
						q=PassMin;
					}

					//y-bond above
					if	(YFlow[i-1][j-1][k-1]<0.0 && BondLabel[LabY(i,j,k)-1]>0 && BondLabel[LabY(i,j,k)-1]<PassMin)
					{
						PassMin=BondLabel[LabY(i,j,k)-1];
						q=PassMin;
					}

					//y-bond below
					if	(j<m_ny)
					{
						if	(YFlow[i-1][j+1-1][k-1]>0.0 && BondLabel[LabY(i,j+1,k)-1]>0 && BondLabel[LabY(i,j+1,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabY(i,j+1,k)-1];
							q=PassMin;
						}
					}

					if	(m_nz!=1)
					{
						//z-bond out of screen
						if	(ZFlow[i-1][j-1][k-1]<0.0 && BondLabel[LabZ(i,j,k)-1]>0 && BondLabel[LabZ(i,j,k)-1]<PassMin)
						{
							PassMin=BondLabel[LabZ(i,j,k)-1];
							q=PassMin;
						}

						if	(k<m_nz)
						{
							//z-bond into screen
							if	(ZFlow[i-1][j-1][k+1-1]>0.0 && BondLabel[LabZ(i,j,k+1)-1]>0 && BondLabel[LabZ(i,j,k+1)-1]<PassMin)
							{
								PassMin=BondLabel[LabZ(i,j,k+1)-1];
								q=PassMin;
							}
						}
					}
				}
			}
		}
	
		for (int n=1;n<=Nbond;n++)
		{
			BondLabelSum+=BondLabel[n-1];
		}

	}	//end while loop
//-----------------------------------------------
/*
//Code has numerical problems with unconnected vessels (e.g. in wound)
//Clear this up here by setting False Flows to true
	for	(k=1;k<=m_nz;k++)
	{	for	(j=1;j<=m_ny;j++)
		{	for	(i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if	(pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1])<1.0e-24)	{FalseFlow[nbx-1]=true;}
				if	(pFluid[nby-1]==10 && fabs(YFlow[i-1][j-1][k-1])<1.0e-24)	{FalseFlow[nby-1]=true;}
				if	(pFluid[nbz-1]==10 && fabs(ZFlow[i-1][j-1][k-1])<1.0e-24)	{FalseFlow[nbz-1]=true;}
			}

			i=m_nx+1;
			int nbx=LabX(i,j,k);

			if	(pFluid[nbx-1]==10 && fabs(XFlow[i-1][j-1][k-1])<1.0e-24)	{FalseFlow[nbx-1]=true;}

		}}
*/
//-----------------------------------------------

	//---Clear up arrays---

	for (i=0;i<m_nx;i++)
	{	for (j=0;j<m_ny;j++)
		{
			delete[] TotalFlowOut[i][j];
			delete[] TotalFlowIn[i][j];
			delete[] NumFlowsIn[i][j];
		}
	}

	for (i=0;i<m_nx;i++)
	{
		delete[] TotalFlowOut[i];
		delete[] TotalFlowIn[i];
		delete[] NumFlowsIn[i];
	}

	delete[] TotalFlowOut;
	delete[] TotalFlowIn;
	delete[] NumFlowsIn;
		
	delete[] BondLabel;
	delete[] icoord;
	delete[] jcoord;
	delete[] kcoord;
	delete[] AdjustOutflows;
	delete[] FalseFlowsIn;
}
//***********************************************

//===================================================================
void CAngioNetDlg::WoundAreaGraphics(int xMin, int xMax, int yMin, 
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//===================================================================
{
//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),Yellow=RGB(255,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,150,150),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
//	COLORREF choiceColour;

//Define the pens 
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penPink(PS_SOLID,1,pink);
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penWhite(PS_SOLID,2,White);

//Select the pen into the DC (Device Context)
//	CPen *pOldPen=NULL;
//	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("FLOW TIME %f",flowTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//-----Draw Wound Margin if applicable-----------
//	memDC.SelectObject(&penGrey1);
 	CBrush brGrey(RGB(50,50,50));

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}
//---------------------------------------
	//---------------------------------------

/*	int x1,x2,y1,y2;

//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
			
	//memDC.SelectObject(&penBlack);
	choiceColour=Black;

	if		(bCountBlock[i+(j-1)*m_nx+(k-1)*m_nx*m_ny-1]==true) {choiceColour=Yellow;}
	
	x1=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)((XPOS[i][j][k]-1)*networkWidth/m_nx);
	y1=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny);
	x2=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)(XPOS[i][j][k]*networkWidth/m_nx);
	y2=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)((YPOS[i][j][k]-1)*networkWidth/m_ny);

	memDC.FillSolidRect((int)x1,(int)y1,(int)( fabs(double(x1-x2)) ),(int)( fabs(double(y1-y2)+1) ),choiceColour);
*/
//I've added the +1 just to stop black lines on graphics
	/*
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	*/
/*	}}}
*/
//------------------------------------------------
//-----Draw Estimated Wound Margin-------
	if	(NumBondsRadius>0)
	{
		memDC.SelectObject(&penWhite);
 	
		memDC.Ellipse(
	xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-NumBondsRadius*networkWidth/m_nx,
	yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-NumBondsRadius*networkWidth/m_ny,
	xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+NumBondsRadius*networkWidth/m_nx,
	yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+NumBondsRadius*networkWidth/m_ny
						  );
	}
//----------------------------------------------------
//outfileFalseFlowTest << loop << endl;
	//Draw the network
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{
			  int nbx=LabX(i,j,k);
			  int nby=LabY(i,j,k);
			  int nbz=LabZ(i,j,k);
				
//			  if	(bGrowing==false)	{if	(pFluid[nbx-1]==10)	{outfileFalseFlowTest << i << "\t" << j << "\t" << FalseFlow[nbx-1] << "\t" << XFlow[i-1][j-1][k-1] << endl;}}

//z-pores
//	if	(FalseFlow[nbz-1]==false && fabs(ZFlow[i-1][j-1][k-1])>1.0e-24)	{memDC.SelectObject(&penPink);}
//	if	(FalseFlow[nbz-1]==true || fabs(ZFlow[i-1][j-1][k-1])<1.0e-24)	{memDC.SelectObject(&penDarkBlue);}

	if	(pFluid[nbz-1]==10)	{memDC.SelectObject(&penPink);}
		
	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//x-pores
//	if	(FalseFlow[nbx-1]==false && fabs(XFlow[i-1][j-1][k-1])>1.0e-24)	{memDC.SelectObject(&penPink);}
//	if	(FalseFlow[nbx-1]==true || fabs(XFlow[i-1][j-1][k-1])<1.0e-24)	{memDC.SelectObject(&penDarkBlue);}

	if	(pFluid[nbx-1]==10)	{memDC.SelectObject(&penPink);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

//y-pores
//	if	(FalseFlow[nby-1]==false && fabs(YFlow[i-1][j-1][k-1])>1.0e-24)	{memDC.SelectObject(&penPink);}
//	if	(FalseFlow[nby-1]==true || fabs(YFlow[i-1][j-1][k-1])<1.0e-24)	{memDC.SelectObject(&penDarkBlue);}

	if	(pFluid[nby-1]==10)	{memDC.SelectObject(&penPink);}

	if (pFluid[nby-1]==10)
	{
		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

	}	//end i loop

//dangling x-pores
	int i=m_nx+1;
	int nbx=LabX(i,j,k);

//	if	(FalseFlow[nbx-1]==false && fabs(XFlow[i-1][j-1][k-1])>1.0e-24)	{memDC.SelectObject(&penPink);}
//	if	(FalseFlow[nbx-1]==true || fabs(XFlow[i-1][j-1][k-1])<1.0e-24)	{memDC.SelectObject(&penDarkBlue);}

	if	(pFluid[nbx-1]==10)	{memDC.SelectObject(&penPink);}

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
	}

	}}// end j- and k-loops
//outfileFalseFlowTest << endl;
//----------------------------------------
	//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
//	memDC.SelectObject(pOldPen);
}
//***********************************************

//=====================================
void CAngioNetDlg::SaveWoundArea(void)
//=====================================
{
	outfileSaveWoundArea << angiotime << endl;
	outfileSaveWoundArea << NumBondsRadius << endl;
}
//***********************************************

//==========================================
void CAngioNetDlg::ReadInWoundArea(void)
//==========================================
{
	infileSaveWoundArea >> angiotime;
	infileSaveWoundArea >> NumBondsRadius;
}
//***********************************************

//===============================================
void CAngioNetDlg::CalculateNutrientTimeStep(void)
//===============================================
{
	int i,j,k;
	int nbx,nby,nbz;

	double theminflow=1.0e-30;
	double timestep=1.0e20;
	double timeStepInit=1.0e20;

	int MinTimeVesselNut_i,MinTimeVesselNut_j,MinTimeVesselNut_k;
	int MinTimeTissueNut_i,MinTimeTissueNut_j,MinTimeTissueNut_k;
	double MinTimeVesselNut_Hem,MinTimeVesselNut_Rad,MinTimeVesselNut_Conc;

	MinTimeVesselNut_i=MinTimeVesselNut_j=MinTimeVesselNut_k=
		MinTimeTissueNut_i=MinTimeTissueNut_j=MinTimeTissueNut_k=0;

	MinTimeVesselNut_Hem=MinTimeVesselNut_Rad=MinTimeVesselNut_Conc=0.0;

	double tempDeltaT;

//-----------------------------------------------
outfileDebugTime << flowTime << endl;
	
	if (b_Bone_model)
	{
		if	(m_nz==1)	//2D case
		{
//Must conserve mass of nutrient in vessels
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx;i++)
				{
					nbx=LabX(i,j,k);
					nby=LabY(i,j,k);
						
					if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
					{
						tempDeltaT=1.0/
									(
											fabs(XFlow[i-1][j-1][k-1])*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
						}
					}	//end if x-vessel
			
//-----------------------------------------------
					if (pFluid[nby-1]==10 && bAllowNutrientTransport[nby-1])
					{
						tempDeltaT=1.0/
									(
											fabs(YFlow[i-1][j-1][k-1])*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(YBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nby-1]*CharTime/YBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=YBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pYHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nby-1];
						}
					}	//end if y-vessel
			
//-----------------------------------------------
				}	//end i loop

				i=m_nx+1;
				nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
				{						
					tempDeltaT=1.0/
								(
										fabs(XFlow[i-1][j-1][k-1])*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

									+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
								);

					if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
					{
						timestep=tempDeltaT;
						MinTimeVesselNut_i=i;
						MinTimeVesselNut_j=j;
						MinTimeVesselNut_k=k;
						MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
						MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
						MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
					}
				}	//end if x-dangler

//-----------------------------------------------			
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Vessel Nutrient" << endl;
outfileDebugTime << timestep << "\t" << MinTimeVesselNut_i << "\t" << 
					MinTimeVesselNut_j << "\t" << MinTimeVesselNut_k << "\t" <<
					MinTimeVesselNut_Rad << "\t" << MinTimeVesselNut_Hem << "\t" << MinTimeVesselNut_Conc << endl;

//-----------------------------------------------

//Must conserve mass of nutrient in tissue
//**All vessel contributions commented out since we assume nutrient cannot move from tissue to vessels (Mike 04/13)**
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx+1;i++)
				{
					if (i==1)
					{
						if (j==1)	//top LH corner block
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient
												
											+	diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	diffCoeffNutrient/angioDeltaY/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*Perm_Vessel[LabY(i,j+1,k)-1]/Rmaximum*YBR[i-1][j+1-1][k-1]/angioDeltaX
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}									
						}

						else if (j==m_ny)	//bottom LH corner block
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient
												
											+	diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	diffCoeffNutrient/angioDeltaY/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

						else	//other LH edge blocks
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient
												
											+	diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*Perm_Vessel[LabY(i,j+1,k)-1]/Rmaximum*YBR[i-1][j+1-1][k-1]/angioDeltaX
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}
					}

//---------------------------------------

					if (i==m_nx+1)
					{
						if (j==1)	//top RH corner block
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient
												
											+	diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	diffCoeffNutrient/angioDeltaY/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*Perm_Vessel[LabY(i,j+1,k)-1]/Rmaximum*YBR[i-1][j+1-1][k-1]/angioDeltaX
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

						else if (j==m_ny)	//bottom RH corner block
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient
												
											+	diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	diffCoeffNutrient/angioDeltaY/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

						else	//other RH edge blocks
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient
												
											+	diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*Perm_Vessel[LabY(i,j+1,k)-1]/Rmaximum*YBR[i-1][j+1-1][k-1]/angioDeltaX
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

					}
//---------------------------------------

					if (j==1 && i!=1 && i!=m_nx+1)	//top edge blocks (excluding corner blocks already done)	//**UP TO HERE SO FAR!!**
					{
						tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

										//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*Perm_Vessel[LabY(i,j+1,k)-1]/Rmaximum*YBR[i-1][j+1-1][k-1]/angioDeltaX
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeTissueNut_i=i;
							MinTimeTissueNut_j=j;
							MinTimeTissueNut_k=k;
						}
					}

//---------------------------------------

					if (j==m_ny && i!=1 && i!=m_nx+1)	//bottom edge blocks (excluding corner blocks already done)
					{
						tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

										//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeTissueNut_i=i;
							MinTimeTissueNut_j=j;
							MinTimeTissueNut_k=k;
						}
					}

//---------------------------------------

					if (i!=1 && i!=m_nx+1 && j!=1)		//internal blocks
					{
						tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

										//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*Perm_Vessel[LabX(i+1,j,k)-1]/Rmaximum*XBR[i+1-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*Perm_Vessel[LabY(i,j+1,k)-1]/Rmaximum*YBR[i-1][j+1-1][k-1]/angioDeltaX
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeTissueNut_i=i;
							MinTimeTissueNut_j=j;
							MinTimeTissueNut_k=k;
						}
					}

//-----------------------------------------------
				}	//end i loop
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Tissue Nutrient" << endl;
outfileDebugTime << timestep << //endl;
				"\t" << MinTimeTissueNut_i << "\t" << 
					MinTimeTissueNut_j << "\t" << MinTimeTissueNut_k << endl;

	}	//end if m_nz==1
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//-----------------------------------------------
	else	//3D case
	{

//Must conserve mass of nutrient in vessels
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx;i++)
				{
					nbx=LabX(i,j,k);
					nby=LabY(i,j,k);
					nbz=LabZ(i,j,k);

					if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
					{
						tempDeltaT=1.0/
									(
											XFlow[i-1][j-1][k-1]*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
						}
					}	//end if x-vessel
			
//-----------------------------------------------
					if (pFluid[nby-1]==10 && bAllowNutrientTransport[nby-1])
					{
						tempDeltaT=1.0/
									(
											YFlow[i-1][j-1][k-1]*CharTime/(PI*YBL[i-1][j-1][k-1]*pow(YBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nby-1]*CharTime/YBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=YBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pYHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nby-1];
						}
					}	//end if y-vessel

//-----------------------------------------------
					if (pFluid[nbz-1]==10 && bAllowNutrientTransport[nbz-1])
					{
						tempDeltaT=1.0/
									(
											ZFlow[i-1][j-1][k-1]*CharTime/(PI*ZBL[i-1][j-1][k-1]*pow(ZBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nbz-1]*CharTime/ZBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=ZBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pZHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nbz-1];
						}
					}	//end if z-vessel
			
//-----------------------------------------------
				}	//end i loop

				i=m_nx+1;
				nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
				{						
					tempDeltaT=1.0/
								(
										XFlow[i-1][j-1][k-1]*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

									+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
								);

					if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
					{
						timestep=tempDeltaT;
						MinTimeVesselNut_i=i;
						MinTimeVesselNut_j=j;
						MinTimeVesselNut_k=k;
						MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
						MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
						MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
					}
				}	//end if x-dangler

//-----------------------------------------------			
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Vessel Nutrient" << endl;
outfileDebugTime << timestep << "\t" << MinTimeVesselNut_i << "\t" << 
					MinTimeVesselNut_j << "\t" << MinTimeVesselNut_k << "\t" <<
					MinTimeVesselNut_Rad << "\t" << MinTimeVesselNut_Hem << "\t" << MinTimeVesselNut_Conc << endl;

//-----------------------------------------------

//Must conserve mass of nutrient in tissue blocks
//**All vessel contributions commented out since we assume nutrient cannot move from tissue to vessels (Mike 04/13)**
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx+1;i++)
				{

//------LH FACE----------------------------------
					if (i==1)
					{
						if (j==1)	
						{
							if (k==1) //farside, top LH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, top LH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//top LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else if (j==m_ny)
						{
							if (k==1) //farside, bottom LH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, bottom LH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//bottom LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else
						{
							if (k==1) //farside, LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//LH face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END LH FACE---------------------------------

//---RH FACE-------------------------------------

					if (i==m_nx+1)
					{
						if (j==1)	
						{
							if (k==1) //farside, top RH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, top RH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//top RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else if (j==m_ny)
						{
							if (k==1) //farside, bottom RH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, bottom RH corner block
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//bottom RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else
						{
							if (k==1) //farside, RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//RH face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END RH FACE---------------------------------

//---TOP FACE------------------------------------

					if (j==1)
					{
						if (i!=1 && i!=m_nx+1)
						{
							if (k==1)	//farside top edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz)	//nearside top edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else    //top face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END TOP FACE--------------------------------

//---BOTTOM FACE------------------------------------

					if (j==m_ny)
					{
						if (i!=1 && i!=m_nx+1)
						{
							if (k==1)	//farside bottom edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz)	//nearside bottom edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else    //bottom face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
											(
													sigma_Nutrient

												+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

												+	diffCoeffNutrient/angioDeltaY/angioDeltaY

												+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

												//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

												//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

												//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
											);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END BOTTOM FACE-----------------------------

					if (i!=1 && i!=m_nx+1 && j!=1 && j!=m_ny)
					{

//---FARSIDE FACE--------------------------------

						if (k==1)	//farside face blocks (excluding edges already done)
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient

											+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

											+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

											//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

											//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

//---END FARSIDE FACE----------------------------

//---NEARSIDE FACE-------------------------------

						else if (k==m_nz)	//nearside face blocks (excluding edges already done)
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient

											+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

											+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

											//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

//---END NEARSIDE FACE---------------------------

//---INTERNAL BLOCKS-----------------------------

						else
						{
							tempDeltaT=1.0/
										(
												sigma_Nutrient

											+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

											+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

											+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

											//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

											//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

											//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/angioDeltaX/angioDeltaY

											//+	bAllowNutrientTransport[LabX(i+1,j,k)-1]*PI*Perm_Vessel[LabX(i+1,j,k)-1]*XBR[i+1-1][j-1][k-1]/CharLength/angioDeltaY/angioDeltaZ

											//+	bAllowNutrientTransport[LabY(i,j+1,k)-1]*PI*Perm_Vessel[LabY(i,j+1,k)-1]*YBR[i-1][j+1-1][k-1]/CharLength/angioDeltaX/angioDeltaZ

											//+	bAllowNutrientTransport[LabZ(i,j,k+1)-1]*PI*Perm_Vessel[LabZ(i,j,k+1)-1]*ZBR[i-1][j-1][k+1-1]/CharLength/angioDeltaX/angioDeltaY
										);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

//---END INTERNAL BLOCKS-------------------------
					}

//-----------------------------------------------
				}	//end i loop
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Tissue Nutrient" << "\t" << tempDeltaT << endl;
outfileDebugTime << timestep << endl;
//				"\t" << MinTimeTissueNut_i << "\t" << 
//					MinTimeTissueNut_j << "\t" << MinTimeTissueNut_k << endl;

//-----------------------------------------------
	}	//end if m_nz>1
	}
	
	else //not bone model
	{
		if	(m_nz==1)	//2D case
		{
//Must conserve mass of nutrient in vessels
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx;i++)
				{
					nbx=LabX(i,j,k);
					nby=LabY(i,j,k);
						
					if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
					{
						tempDeltaT=1.0/
									(
											fabs(XFlow[i-1][j-1][k-1])*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
						}
					}	//end if x-vessel
			
//-----------------------------------------------
					if (pFluid[nby-1]==10 && bAllowNutrientTransport[nby-1])
					{
						tempDeltaT=1.0/
									(
											fabs(YFlow[i-1][j-1][k-1])*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(YBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nby-1]*CharTime/YBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=YBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pYHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nby-1];
						}
					}	//end if y-vessel
			
//-----------------------------------------------
				}	//end i loop

				i=m_nx+1;
				nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
				{						
					tempDeltaT=1.0/
								(
										fabs(XFlow[i-1][j-1][k-1])*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

									+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
								);

					if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
					{
						timestep=tempDeltaT;
						MinTimeVesselNut_i=i;
						MinTimeVesselNut_j=j;
						MinTimeVesselNut_k=k;
						MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
						MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
						MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
					}
				}	//end if x-dangler

//-----------------------------------------------			
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Vessel Nutrient" << endl;
outfileDebugTime << timestep << "\t" << MinTimeVesselNut_i << "\t" << 
					MinTimeVesselNut_j << "\t" << MinTimeVesselNut_k << "\t" <<
					MinTimeVesselNut_Rad << "\t" << MinTimeVesselNut_Hem << "\t" << MinTimeVesselNut_Conc << endl;

//-----------------------------------------------

//Must conserve mass of nutrient in tissue
//**All vessel contributions commented out since we assume nutrient cannot move from tissue to vessels (Mike 04/13)**
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx+1;i++)
				{
					if (i==1)
					{
						if (j==1)	//top LH corner block
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}									
						}

						else if (j==m_ny)	//bottom LH corner block
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*Perm_Vessel[LabX(i,j-1,k)-1]/Rmaximum*XBR[i-1][j-1-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

						else	//other LH edge blocks
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*Perm_Vessel[LabX(i,j-1,k)-1]/Rmaximum*XBR[i-1][j-1-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}
					}

//---------------------------------------

					if (i==m_nx+1)
					{
						if (j==1)	//top RH corner block
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*Perm_Vessel[LabY(i-1,j,k)-1]/Rmaximum*YBR[i-1-1][j-1][k-1]/angioDeltaX
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

						else if (j==m_ny)	//bottom RH corner block
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*Perm_Vessel[LabX(i,j-1,k)-1]/Rmaximum*XBR[i-1][j-1-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*Perm_Vessel[LabY(i-1,j,k)-1]/Rmaximum*YBR[i-1-1][j-1][k-1]/angioDeltaX
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

						else	//other RH edge blocks
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*Perm_Vessel[LabX(i,j-1,k)-1]/Rmaximum*XBR[i-1][j-1-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*Perm_Vessel[LabY(i-1,j,k)-1]/Rmaximum*YBR[i-1-1][j-1][k-1]/angioDeltaX
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

					}
//---------------------------------------

					if (j==1 && i!=1 && i!=m_nx+1)	//top edge blocks (excluding corner blocks already done)	//**UP TO HERE SO FAR!!**
					{
						tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*Perm_Vessel[LabY(i-1,j,k)-1]/Rmaximum*YBR[i-1-1][j-1][k-1]/angioDeltaX
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeTissueNut_i=i;
							MinTimeTissueNut_j=j;
							MinTimeTissueNut_k=k;
						}
					}

//---------------------------------------

					if (j==m_ny && i!=1 && i!=m_nx+1)	//bottom edge blocks (excluding corner blocks already done)
					{
						tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*Perm_Vessel[LabX(i,j-1,k)-1]/Rmaximum*XBR[i-1][j-1-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*Perm_Vessel[LabY(i-1,j,k)-1]/Rmaximum*YBR[i-1-1][j-1][k-1]/angioDeltaX
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeTissueNut_i=i;
							MinTimeTissueNut_j=j;
							MinTimeTissueNut_k=k;
						}
					}

//---------------------------------------

					if (i!=1 && i!=m_nx+1 && j!=1)		//internal blocks
					{
						tempDeltaT=1.0/
									(
											sigma_Nutrient
												
										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*Perm_Vessel[LabX(i,j,k)-1]/Rmaximum*XBR[i-1][j-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*Perm_Vessel[LabX(i,j-1,k)-1]/Rmaximum*XBR[i-1][j-1-1][k-1]/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*Perm_Vessel[LabY(i,j,k)-1]/Rmaximum*YBR[i-1][j-1][k-1]/angioDeltaX

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*Perm_Vessel[LabY(i-1,j,k)-1]/Rmaximum*YBR[i-1-1][j-1][k-1]/angioDeltaX
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeTissueNut_i=i;
							MinTimeTissueNut_j=j;
							MinTimeTissueNut_k=k;
						}
					}

//-----------------------------------------------
				}	//end i loop
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Tissue Nutrient" << endl;
outfileDebugTime << timestep << //endl;
				"\t" << MinTimeTissueNut_i << "\t" << 
					MinTimeTissueNut_j << "\t" << MinTimeTissueNut_k << endl;

	}	//end if m_nz==1
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//-----------------------------------------------
	else	//3D case
	{

//Must conserve mass of nutrient in vessels
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx;i++)
				{
					nbx=LabX(i,j,k);
					nby=LabY(i,j,k);
					nbz=LabZ(i,j,k);

					if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
					{
						tempDeltaT=1.0/
									(
											XFlow[i-1][j-1][k-1]*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
						}
					}	//end if x-vessel
			
//-----------------------------------------------
					if (pFluid[nby-1]==10 && bAllowNutrientTransport[nby-1])
					{
						tempDeltaT=1.0/
									(
											YFlow[i-1][j-1][k-1]*CharTime/(PI*YBL[i-1][j-1][k-1]*pow(YBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nby-1]*CharTime/YBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=YBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pYHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nby-1];
						}
					}	//end if y-vessel

//-----------------------------------------------
					if (pFluid[nbz-1]==10 && bAllowNutrientTransport[nbz-1])
					{
						tempDeltaT=1.0/
									(
											ZFlow[i-1][j-1][k-1]*CharTime/(PI*ZBL[i-1][j-1][k-1]*pow(ZBR[i-1][j-1][k-1],2))

										+	2.0*DimPerm_Vessel[nbz-1]*CharTime/ZBR[i-1][j-1][k-1]
									);

						if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
						{
							timestep=tempDeltaT;
							MinTimeVesselNut_i=i;
							MinTimeVesselNut_j=j;
							MinTimeVesselNut_k=k;
							MinTimeVesselNut_Rad=ZBR[i-1][j-1][k-1];
							MinTimeVesselNut_Hem=pZHem[i-1][j-1][k-1];
							MinTimeVesselNut_Conc=pVesselNutrientConc[nbz-1];
						}
					}	//end if z-vessel
			
//-----------------------------------------------
				}	//end i loop

				i=m_nx+1;
				nbx=LabX(i,j,k);

				if (pFluid[nbx-1]==10 && bAllowNutrientTransport[nbx-1])
				{						
					tempDeltaT=1.0/
								(
										XFlow[i-1][j-1][k-1]*CharTime/(PI*XBL[i-1][j-1][k-1]*pow(XBR[i-1][j-1][k-1],2))

									+	2.0*DimPerm_Vessel[nbx-1]*CharTime/XBR[i-1][j-1][k-1]
								);

					if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
					{
						timestep=tempDeltaT;
						MinTimeVesselNut_i=i;
						MinTimeVesselNut_j=j;
						MinTimeVesselNut_k=k;
						MinTimeVesselNut_Rad=XBR[i-1][j-1][k-1];
						MinTimeVesselNut_Hem=pXHem[i-1][j-1][k-1];
						MinTimeVesselNut_Conc=pVesselNutrientConc[nbx-1];
					}
				}	//end if x-dangler

//-----------------------------------------------			
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Vessel Nutrient" << endl;
outfileDebugTime << timestep << "\t" << MinTimeVesselNut_i << "\t" << 
					MinTimeVesselNut_j << "\t" << MinTimeVesselNut_k << "\t" <<
					MinTimeVesselNut_Rad << "\t" << MinTimeVesselNut_Hem << "\t" << MinTimeVesselNut_Conc << endl;

//-----------------------------------------------

//Must conserve mass of nutrient in tissue blocks
//**All vessel contributions commented out since we assume nutrient cannot move from tissue to vessels (Mike 04/13)**
		for (k=1;k<=m_nz;k++)
		{	for (j=1;j<=m_ny;j++)		
			{	for (i=1;i<=m_nx+1;i++)
				{

//------LH FACE----------------------------------
					if (i==1)
					{
						if (j==1)	
						{
							if (k==1) //farside, top LH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, top LH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//top LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else if (j==m_ny)
						{
							if (k==1) //farside, bottom LH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, bottom LH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//bottom LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else
						{
							if (k==1) //farside, LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, LH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//LH face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END LH FACE---------------------------------

//---RH FACE-------------------------------------

					if (i==m_nx+1)
					{
						if (j==1)	
						{
							if (k==1) //farside, top RH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, top RH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//top RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else if (j==m_ny)
						{
							if (k==1) //farside, bottom RH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, bottom RH corner block
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//bottom RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}

						else
						{
							if (k==1) //farside, RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz) //nearside, RH edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else	//RH face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END RH FACE---------------------------------

//---TOP FACE------------------------------------

					if (j==1)
					{
						if (i!=1 && i!=m_nx+1)
						{
							if (k==1)	//farside top edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz)	//nearside top edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else    //top face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END TOP FACE--------------------------------

//---BOTTOM FACE------------------------------------

					if (j==m_ny)
					{
						if (i!=1 && i!=m_nx+1)
						{
							if (k==1)	//farside bottom edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else if (k==m_nz)	//nearside bottom edge blocks (excluding corners already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}

							else    //bottom face blocks (excluding edges already done)
							{
								tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

								if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
								{
									timestep=tempDeltaT;
									MinTimeTissueNut_i=i;
									MinTimeTissueNut_j=j;
									MinTimeTissueNut_k=k;
								}
							}
						}
					}

//---END BOTTOM FACE-----------------------------

					if (i!=1 && i!=m_nx+1 && j!=1 && j!=m_ny)
					{

//---FARSIDE FACE--------------------------------

						if (k==1)	//farside face blocks (excluding edges already done)
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

//---END FARSIDE FACE----------------------------

//---NEARSIDE FACE-------------------------------

						else if (k==m_nz)	//nearside face blocks (excluding edges already done)
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

//---END NEARSIDE FACE---------------------------

//---INTERNAL BLOCKS-----------------------------

						else
						{
							tempDeltaT=1.0/
									(
											sigma_Nutrient

										+	2.0*diffCoeffNutrient/angioDeltaX/angioDeltaX

										+	2.0*diffCoeffNutrient/angioDeltaY/angioDeltaY

										+	2.0*diffCoeffNutrient/angioDeltaZ/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j,k)-1]*PI*Perm_Vessel[LabX(i,j,k)-1]*XBR[i-1][j-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k)-1]*PI*Perm_Vessel[LabY(i,j,k)-1]*YBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i,j,k)-1]*PI*Perm_Vessel[LabZ(i,j,k)-1]*ZBR[i-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabX(i,j,k-1)-1]*PI*Perm_Vessel[LabX(i,j,k-1)-1]*XBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k)-1]*PI*Perm_Vessel[LabX(i,j-1,k)-1]*XBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabX(i,j-1,k-1)-1]*PI*Perm_Vessel[LabX(i,j-1,k-1)-1]*XBR[i-1][j-1-1][k-1-1]/CharLength/2/angioDeltaY/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k)-1]*PI*Perm_Vessel[LabY(i-1,j,k)-1]*YBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i,j,k-1)-1]*PI*Perm_Vessel[LabY(i,j,k-1)-1]*YBR[i-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabY(i-1,j,k-1)-1]*PI*Perm_Vessel[LabY(i-1,j,k-1)-1]*YBR[i-1-1][j-1][k-1-1]/CharLength/2/angioDeltaX/angioDeltaZ

										//+	bAllowNutrientTransport[LabZ(i-1,j,k)-1]*PI*Perm_Vessel[LabZ(i-1,j,k)-1]*ZBR[i-1-1][j-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i,j-1,k)-1]*PI*Perm_Vessel[LabZ(i,j-1,k)-1]*ZBR[i-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY

										//+	bAllowNutrientTransport[LabZ(i-1,j-1,k)-1]*PI*Perm_Vessel[LabZ(i-1,j-1,k)-1]*ZBR[i-1-1][j-1-1][k-1]/CharLength/2/angioDeltaX/angioDeltaY
									);

							if (tempDeltaT > 0.0 && tempDeltaT < timestep) 
							{
								timestep=tempDeltaT;
								MinTimeTissueNut_i=i;
								MinTimeTissueNut_j=j;
								MinTimeTissueNut_k=k;
							}
						}

//---END INTERNAL BLOCKS-------------------------
					}

//-----------------------------------------------
				}	//end i loop
			}	//end j loop
		}	//end k loop

outfileDebugTime << "Tissue Nutrient" << "\t" << tempDeltaT << endl;
outfileDebugTime << timestep << endl;
//				"\t" << MinTimeTissueNut_i << "\t" << 
//					MinTimeTissueNut_j << "\t" << MinTimeTissueNut_k << endl;

//-----------------------------------------------
	}	//end if m_nz>1
	}

//-----------------------------------------------
//---SMcD 10/2004---

	if (fabs(timeStepInit-timestep) / timeStepInit <= 0.01) 
	{
		MessageBox("Timestep error");
	}

	oxyDeltaT=timestep/TimeFactor;
	
	outfileDebugTime << endl;
}
//***********************************************

//===============================================
void CAngioNetDlg::SetInitialVesselNutConc(void)
//===============================================
{
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				pVesselNutrientConc[LabX(i,j,k)-1]=0.0;
				pVesselNutrientConc[LabY(i,j,k)-1]=0.0;
				pVesselNutrientConc[LabZ(i,j,k)-1]=0.0;
			}
			int i=m_nx+1;
			pVesselNutrientConc[LabX(i,j,k)-1]=0.0;
	 }}

//-----------------------------------------------

//---Initialise intact PV hematocrits to 0.45---
	int i;
	int kk=1;
	if (m_nz!=1) {kk=m_nz/2;}	//3D arteriole in middle of top face

	for	(i=1;i<=m_nx+1;i++)	//do an x-scan
	{
		pVesselNutrientConc[LabX(i,1,kk)-1]=0.0;//InputNutConc;	//Upper PV

		if	(b_venousIncluded || b_UU_wound_Model) //venule if required
		{
			pVesselNutrientConc[LabX(i,m_ny-1,kk)-1]=0.0;//InputNutConc;
		}

//------------------------------------------------------
		if	(b_UU_wound_Model && (!b_HexNetwork || (b_HexNetwork && b_StraightPVs)))	//square network or hex network with straight PVs 
		{
			for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
			{
				if	(
						nCount*m_ny/(nAdditionalCentralPVs+1)<=jCentre-iWoundRadius
						||
						nCount*m_ny/(nAdditionalCentralPVs+1)>=jCentre+iWoundRadius
					)

				{
					pVesselNutrientConc[LabX(i,nCount*m_ny/(nAdditionalCentralPVs+1),kk)-1]=InputNutConc;
				}

//-----------------------------------------------
			}	//end nCount loop

//-----------------------------------------------
		}	//end if UU wound

//-----------------------------------------------
	}	//end i loop

//-----------------------------------------------

	if	(b_UU_wound_Model && b_HexNetwork && !b_StraightPVs)	//hex network with wiggly PVs
	{
		for (int nCount=1;nCount<=nAdditionalCentralPVs;nCount++)
		{
			int	j=nCount*m_ny/(nAdditionalCentralPVs+1);//4;

			if	(int(j/2)-double(j/2.0)==0)	//if j even (inlets & outlets on j+1)
			{
				for (i=2;i<=m_nx-2;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabX(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabX(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

				for (i=1;i<=m_nx;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabX(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				i=m_nx+1;	
		
				if	(
						j<=jCentre-iWoundRadius
						||
						j>=jCentre+iWoundRadius
					)

				{
					pVesselNutrientConc[LabX(i,j,kk)-1]=InputNutConc;
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabY(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

						{
							pVesselNutrientConc[LabY(i,j,kk)-1]=InputNutConc;
						}
				}

//-----------------------------------------------
			}	//end if j even

//-----------------------------------------------

			else	//if j odd (inlets & outlets on j)
			{
				for (i=1;i<=m_nx;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabY(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				i=m_nx+1;	
		
				if	(
						j<=jCentre-iWoundRadius
						||
						j>=jCentre+iWoundRadius
					)

				{
					pVesselNutrientConc[LabX(i,j,kk)-1]=InputNutConc;
				}

//-----------------------------------------------
				j=j+1;	//increment j to target lower x-bonds & connecting y-bonds

				for (i=2;i<=m_nx-2;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabY(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabX(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				for (i=1;i<=m_nx-3;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabY(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------
				for (i=3;i<=m_nx-1;i+=3)	
				{
					if	(
							j<=jCentre-iWoundRadius
							||
							j>=jCentre+iWoundRadius
						)

					{
						pVesselNutrientConc[LabY(i,j,kk)-1]=InputNutConc;
					}
				}

//-----------------------------------------------								
			}	//end if j odd
//-----------------------------------------------

		}	//end nCount loop

	}	//end if hexagonal vasculature
}
//***********************************************

//========================================================================
void CAngioNetDlg::TransmuralVesselGraphics(int xMin, int xMax, int yMin, 
											int yMax, int networkWidth, 
											double deltaX, double deltaY)
//========================================================================
{
	//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -------------------------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//------------------------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(200,200,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),
			 DarkGreen=RGB(0,128,64),Yellow=RGB(255,255,0),
			 Orange=RGB(255,128,0),Grey1=RGB(128,128,128),
			 Green1=RGB(0,90,0),Green2=RGB(0,110,0),
			 Green3=RGB(0,130,0),Green4=RGB(0,150,0),
			 Green5=RGB(0,170,0),Green6=RGB(0,190,0),
			 Green7=RGB(0,210,0),Green8=RGB(0,230,0),
			 Green9=RGB(0,250,0);

//Define the pens 
	CPen penGrey1(PS_SOLID,1,Grey1);
	CPen penPink(PS_SOLID,1,pink);
	CPen penDarkBlue(PS_SOLID,1,DarkBlue);
	CPen penLightBlue(PS_SOLID,1,LightBlue);
	CPen penWhite(PS_SOLID,1,White);
	CPen penBlack(PS_SOLID,1,Black);
	CPen penDarkGreen(PS_SOLID,1,DarkGreen);
	CPen penGreen(PS_SOLID,1,green);
	CPen penYellow(PS_SOLID,1,Yellow);
	CPen penOrange(PS_SOLID,2,Orange);
	CPen penRed(PS_SOLID,3,red);
	CPen penGreen1(PS_SOLID,1,Green1);
	CPen penGreen2(PS_SOLID,1,Green2);
	CPen penGreen3(PS_SOLID,1,Green3);
	CPen penGreen4(PS_SOLID,2,Green4);
	CPen penGreen5(PS_SOLID,2,Green5);
	CPen penGreen6(PS_SOLID,2,Green6);
	CPen penGreen7(PS_SOLID,3,Green7);
	CPen penGreen8(PS_SOLID,3,Green8);
	CPen penGreen9(PS_SOLID,3,Green9);

//Select the pen into the DC (Device Context)
	CPen *pOldPen=NULL;
	pOldPen=memDC.SelectObject(&penBlack);


//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("OXY TIME %f",oxyTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);

//-----Draw Wound Margin if applicable-----------
 	CBrush brGrey(RGB(25,25,25));	//changed from 50,50,50 by Mike 10/09

	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}

//---------------------------------------
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//------------------------------------------

//-----------------------------------------------
//---Find max vessel rad (ie brightest bond)---
	double ConcMax=0.8;
	double ConcMin=0.0;

/*	for	(int k=1;k<=m_nz;k++)
	{	for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if	(pFluid[nbx-1]==10)
				{
					if	(pVesselNutrientConc[nbx-1]>ConcMax)	{ConcMax=pVesselNutrientConc[nbx-1];}
				}

				if	(pFluid[nby-1]==10)
				{
					if	(pVesselNutrientConc[nby-1]>ConcMax)	{ConcMax=pVesselNutrientConc[nby-1];}
				}

				if	(pFluid[nbz-1]==10)
				{
					if	(pVesselNutrientConc[nbz-1]>ConcMax)	{ConcMax=pVesselNutrientConc[nbz-1];}
				}

			}	//end i loop

			i=m_nx+1;
			int nbx=LabX(i,j,k);

			if	(pFluid[nbx-1]==10)
				{
					if	(pVesselNutrientConc[nbx-1]>ConcMax)	{ConcMax=pVesselNutrientConc[nbx-1];}
				}

		}	//end j loop

	}	//end k loop
*/
	double ColourMult=255/(ConcMax-ConcMin);	//ColourMult(iplier) used to define quasi-continuous spectrum of colours	
								//correlated with vessel nutrient conc (ie small => dark, large => bright)

//-----------------------------------------------
//---Draw the network---
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
	   {	for (int i=1;i<=m_nx;i++)
			{

//----------------------------------------------
	int nbx=LabX(i,j,k);
	int nby=LabY(i,j,k);
	int nbz=LabZ(i,j,k);

//----------------------------------------------
//	int ZShade=int(ColourMult*ZBR[i-1][j-1][k-1]);	//ie 255*(ZBR/Rmax) => integer between 0,255

//	COLORREF ZGreen1=RGB(0,ZShade,0),ZGreen2=RGB(0,ZShade,0),ZGreen3=RGB(0,ZShade,0);

//	CPen penZGreen1(PS_SOLID,1,ZGreen1);	//Same colours, 
//	CPen penZGreen2(PS_SOLID,2,ZGreen2);	//different line
//	CPen penZGreen3(PS_SOLID,3,ZGreen3);	//thickness

	int ZShade=int(ColourMult*(pVesselNutrientConc[nbz-1]-ConcMin));
	
	COLORREF ZColour=RGB(ZShade,ZShade,ZShade);

	CPen penZColour(PS_SOLID,2,ZColour);
		
//z-pores-- DO FIRST SO x and Y lie ABOVE THE VESSELS
/*
	//if      (ZBR[i-1][j-1][k-1]>0 && ZBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (ZBR[i-1][j-1][k-1]>0.0  && ZBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (ZBR[i-1][j-1][k-1]>10e-6 && ZBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (ZBR[i-1][j-1][k-1]>15e-6 && ZBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (ZBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}

	if      (ZBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (ZBR[i-1][j-1][k-1]>Bound1 && ZBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (ZBR[i-1][j-1][k-1]>Bound2 && ZBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (ZBR[i-1][j-1][k-1]>Bound3 && ZBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (ZBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/
/*	if		(ZBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (ZBR[i-1][j-1][k-1]>4e-6 && ZBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (ZBR[i-1][j-1][k-1]>5e-6 && ZBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (ZBR[i-1][j-1][k-1]>6e-6 && ZBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (ZBR[i-1][j-1][k-1]>7e-6 && ZBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (ZBR[i-1][j-1][k-1]>8e-6 && ZBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (ZBR[i-1][j-1][k-1]>9e-6 && ZBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (ZBR[i-1][j-1][k-1]>10e-6 && ZBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (ZBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/

//	if		(ZBR[i-1][j-1][k-1]>=Bound1 && ZBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penZGreen1);}
//	else if (ZBR[i-1][j-1][k-1]>=Bound2 && ZBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penZGreen2);}
//	else if (ZBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penZGreen3);}

	if	(pVesselNutrientConc[nbz-1]>=0.0)	{memDC.SelectObject(&penZColour);}
	
	if (pFluid[nbz-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbz-1]!=10) { memDC.SelectObject(&penDarkGreen);}

///SMcD Retino 10/08



	///SMcD Retino 10/08
//	memDC.SelectObject(&penYellow);
	///--------------------------

	if (pFluid[nbz-1]==10)
	{
		if (k!=1)
		{
		memDC.MoveTo( (int)((k-1)*iOffset*cos(dAngle) + xMin + deltaX + XPOS[i][j][k-1]*networkWidth/m_nx -iOffset*cos(dAngle)
						),//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*cos(dAngle)  ),
					  (int)((k-1)*iOffset*sin(dAngle) + yMin + deltaY + YPOS[i][j][k-1]*networkWidth/m_ny -iOffset*sin(dAngle)
					    ));//+ (ZPOS[i][j][k-1]-(k-1)) * iOffset*sin(dAngle)  ));
		memDC.LineTo( (int)( (k-1)*iOffset*cos(dAngle)+xMin+deltaX+XPOS[i][j][k]*networkWidth/m_nx
						),//+ (ZPOS[i][j][k]-k) * iOffset*cos(dAngle)  ),
					  (int)( (k-1)*iOffset*sin(dAngle)+yMin+deltaY+YPOS[i][j][k]*networkWidth/m_ny
						));//+ (ZPOS[i][j][k]-k) * iOffset*sin(dAngle)  ));
		
		//memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k-1]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][k-1])*networkWidth/m_ny));
		//memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
		//			  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else	//don't plot these for small nz - poor output
		{
	
//		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][m_nz]*networkWidth/m_nx)-(int)(iOffset*cos(dAngle)),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j][m_nz])*networkWidth/m_ny)-(int)(iOffset*sin(dAngle)));
//		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
//					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}


	}

//x-pores--

//	int XShade=int(ColourMult*XBR[i-1][j-1][k-1]);	//ie 255*(XBR/Rmax) => integer between 0,255

//	COLORREF XGreen1=RGB(0,XShade,0),XGreen2=RGB(0,XShade,0),XGreen3=RGB(0,XShade,0);

//	CPen penXGreen1(PS_SOLID,1,XGreen1);	//Same colour,
//	CPen penXGreen2(PS_SOLID,2,XGreen2);	//different line
//	CPen penXGreen3(PS_SOLID,3,XGreen3);	//thickness

	int XShade=int(ColourMult*(pVesselNutrientConc[nbx-1]-ConcMin));
	
	COLORREF XColour=RGB(XShade,XShade,XShade);

	CPen penXColour(PS_SOLID,2,XColour);
	
/*
	//if      (XBR[i-1][j-1][k-1]>0.0 && XBR[i-1][j-1][k-1]<=2e-6)  { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}

	if      (XBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound1 && XBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound2 && XBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (XBR[i-1][j-1][k-1]>Bound3 && XBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/
/*	if		(XBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (XBR[i-1][j-1][k-1]>6e-6 && XBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (XBR[i-1][j-1][k-1]>8e-6 && XBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (XBR[i-1][j-1][k-1]>9e-6 && XBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (XBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/
//	if		(XBR[i-1][j-1][k-1]>=Bound1 && XBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penXGreen1);}
//	else if (XBR[i-1][j-1][k-1]>=Bound2 && XBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penXGreen2);}
//	else if (XBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penXGreen3);}

	if	(pVesselNutrientConc[nbx-1]>=0.0)	{memDC.SelectObject(&penXColour);}
	
	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penDarkGreen);}

	///SMcD Retino 10/08
//	memDC.SelectObject(&penYellow);
	///--------------------------

////Draw all network
	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}


//y-pores--

//	int YShade=int(ColourMult*YBR[i-1][j-1][k-1]);	//ie 255*(YBR/Rmax) => integer between 0,255

//	COLORREF YGreen1=RGB(0,YShade,0),YGreen2=RGB(0,YShade,0),YGreen3=RGB(0,YShade,0);

//	CPen penYGreen1(PS_SOLID,1,YGreen1);	//Same colour,
//	CPen penYGreen2(PS_SOLID,2,YGreen2);	//different line
//	CPen penYGreen3(PS_SOLID,3,YGreen3);	//thickness

	int YShade=int(ColourMult*(pVesselNutrientConc[nby-1]-ConcMin));
	
	COLORREF YColour=RGB(YShade,YShade,YShade);

	CPen penYColour(PS_SOLID,2,YColour);
	
/*
	//if      (YBR[i-1][j-1][k-1]>0 && YBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (YBR[i-1][j-1][k-1]>0.0  && YBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (YBR[i-1][j-1][k-1]>10e-6 && YBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (YBR[i-1][j-1][k-1]>15e-6 && YBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (YBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}


	if      (YBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (YBR[i-1][j-1][k-1]>Bound1 && YBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (YBR[i-1][j-1][k-1]>Bound2 && YBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (YBR[i-1][j-1][k-1]>Bound3 && YBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (YBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/

/*	if		(YBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (YBR[i-1][j-1][k-1]>4e-6 && YBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (YBR[i-1][j-1][k-1]>5e-6 && YBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (YBR[i-1][j-1][k-1]>6e-6 && YBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (YBR[i-1][j-1][k-1]>7e-6 && YBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (YBR[i-1][j-1][k-1]>8e-6 && YBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (YBR[i-1][j-1][k-1]>9e-6 && YBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (YBR[i-1][j-1][k-1]>10e-6 && YBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (YBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/

//	if		(YBR[i-1][j-1][k-1]>=Bound1 && YBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penYGreen1);}
//	else if (YBR[i-1][j-1][k-1]>=Bound2 && YBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penYGreen2);}
//	else if (YBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penYGreen3);}

	if		(pVesselNutrientConc[nby-1]>=0.0)	{memDC.SelectObject(&penYColour);}
	
	if (pFluid[nby-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nby-1]!=10) { memDC.SelectObject(&penDarkGreen);}
	
	
	///SMcD Retino 10/08
///	memDC.SelectObject(&penYellow);
	///--------------------------

	if (pFluid[nby-1]==10)
	{

		if (j!=1)
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j-1][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][j-1][k])*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
		else
		{
		memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][m_ny][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i][m_ny][k]-m_ny)*networkWidth/m_ny));
		memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));
		}
	}

//----------------------------------------------------------
		  }	//end i loop

//dangling x-pores

	int i=m_nx+1;

	int nbx=LabX(i,j,k);

//	int XShade=int(ColourMult*XBR[i-1][j-1][k-1]);	//ie 255*(ZBR/Rmax) => integer between 0,255

//	COLORREF XGreen1=RGB(0,XShade,0),XGreen2=RGB(0,XShade,0),XGreen3=RGB(0,XShade,0);

//	CPen penXGreen1(PS_SOLID,1,XGreen1);	//Same colour,
//	CPen penXGreen2(PS_SOLID,2,XGreen2);	//different line
//	CPen penXGreen3(PS_SOLID,3,XGreen3);	//thickness

	int XShade=int(ColourMult*(pVesselNutrientConc[nbx-1]-ConcMin));
	
	COLORREF XColour1=RGB(XShade,XShade,XShade);

	CPen penXColour1(PS_SOLID,1,XColour1);
	
	/*	
	//if      (XBR[i-1][j-1][k-1]>0 && XBR[i-1][j-1][k-1]<=2e-6)    { memDC.SelectObject(&penBlack);}
	if      (XBR[i-1][j-1][k-1]>0.0  && XBR[i-1][j-1][k-1]<=5e-6)   { memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=10e-6)  { memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=15e-6) { memDC.SelectObject(&penYellow);}
	else if (XBR[i-1][j-1][k-1]>15e-6 && XBR[i-1][j-1][k-1]<=20e-6) { memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>20e-6)                              { memDC.SelectObject(&penRed);}

	if      (XBR[i-1][j-1][k-1]<=Bound1)								{ memDC.SelectObject(&penDarkGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound1 && XBR[i-1][j-1][k-1]<=Bound2)	{ memDC.SelectObject(&penGreen);}
	else if (XBR[i-1][j-1][k-1]>Bound2 && XBR[i-1][j-1][k-1]<=Bound3)	{ memDC.SelectObject(&penPink);}
	else if (XBR[i-1][j-1][k-1]>Bound3 && XBR[i-1][j-1][k-1]<=Bound4)	{ memDC.SelectObject(&penOrange);}
	else if (XBR[i-1][j-1][k-1]>Bound4)									{ memDC.SelectObject(&penRed);}
*/

/*	if		(XBR[i-1][j-1][k-1]<=4e-6)								{memDC.SelectObject(&penGreen1);}
	else if (XBR[i-1][j-1][k-1]>4e-6 && XBR[i-1][j-1][k-1]<=5e-6)	{memDC.SelectObject(&penGreen2);}
	else if (XBR[i-1][j-1][k-1]>5e-6 && XBR[i-1][j-1][k-1]<=6e-6)	{memDC.SelectObject(&penGreen3);}
	else if (XBR[i-1][j-1][k-1]>6e-6 && XBR[i-1][j-1][k-1]<=7e-6)	{memDC.SelectObject(&penGreen4);}
	else if (XBR[i-1][j-1][k-1]>7e-6 && XBR[i-1][j-1][k-1]<=8e-6)	{memDC.SelectObject(&penGreen5);}
	else if (XBR[i-1][j-1][k-1]>8e-6 && XBR[i-1][j-1][k-1]<=9e-6)	{memDC.SelectObject(&penGreen6);}
	else if (XBR[i-1][j-1][k-1]>9e-6 && XBR[i-1][j-1][k-1]<=10e-6)	{memDC.SelectObject(&penGreen7);}
	else if (XBR[i-1][j-1][k-1]>10e-6 && XBR[i-1][j-1][k-1]<=11e-6)	{memDC.SelectObject(&penGreen8);}
	else if (XBR[i-1][j-1][k-1]>11e-6)								{memDC.SelectObject(&penGreen9);}
*/

//	if		(XBR[i-1][j-1][k-1]>=Bound1 && XBR[i-1][j-1][k-1]<Bound2)	{memDC.SelectObject(&penXGreen1);}
//	else if (XBR[i-1][j-1][k-1]>=Bound2 && XBR[i-1][j-1][k-1]<Bound3)	{memDC.SelectObject(&penXGreen2);}
//	else if (XBR[i-1][j-1][k-1]>=Bound3)								{memDC.SelectObject(&penXGreen3);}

	if		(pVesselNutrientConc[nbx-1]>=0.0)	{memDC.SelectObject(&penXColour1);}
	
	if (pFluid[nbx-1]==66) { memDC.SelectObject(&penBlack);}
	if (pFluid[nbx-1]!=10) { memDC.SelectObject(&penDarkGreen);}


	///SMcD Retino 10/08
//	memDC.SelectObject(&penYellow);
	///--------------------------

	if (pFluid[nbx-1]==10)
	{
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i-1][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int((YPOS[i-1][j][k])*networkWidth/m_ny));
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+int(XPOS[i][j][k]*networkWidth/m_nx),
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+int(YPOS[i][j][k]*networkWidth/m_ny));

	}

	   }	//end j loop
	}		// end k loop


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

//---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }

//------------------------------------------------

//----- MODIF A.S.----------------------------------------		
	CClientDC graphics(this);    
    graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
	memDC.SelectObject(pOldPen);
}
//***********************************************

//====================================================
void CAngioNetDlg::SetInitialTissueNutrientConc(void)
//====================================================
{
	if	(b_UU_wound_Model)
	{
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx+1;i++)
				{
					pOldTissueNutrientConc[i-1][j-1][k-1]=0.0;//0.9*(pow((double)j/jCentre-1,4.0))/(pow(1.0,4.0)+pow((double)j/jCentre-1,4.0));
				}
			}
		}
	}
}
//***********************************************

//==========================================
void CAngioNetDlg::PruneCapillaries(void)
//==========================================
{
//	double VEGF_CritFract=0.01;//0.25; VEGF_Max=O(0.05)
//	double Haemo_CritFract=0.01;//0.01;//NB MaxHt=1.0 set initially
//	double Age_Crit=0.26;//0.625;//0.4;//0.5;
	double LocalNut=0.0;

	for (int i=1;i<=m_nx;i++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int k=m_nz;k<=m_nz;k++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
//				int nbz=LabZ(i,j,k);

				if	(pFluid[nbx-1]==10 && pAgeOfVessel[nbx-1]>1.0)
				{
					if	(j<m_ny)	{LocalNut=0.5*(pTissueNutrientConc[i-1][j-1][k-1]+pTissueNutrientConc[i-1][j+1-1][k-1]);}
					else	{LocalNut=pTissueNutrientConc[i-1][j-1][k-1];}

					if	(pVesselNutrientConc[nbx-1]<0.5*LocalNut)
					{
						pFluid[nbx-1]=0;
						pSprout[nbx-1]=0;
					}
				}

				if	(pFluid[nby-1]==10 && pAgeOfVessel[nby-1]>1.0)
				{
					LocalNut=0.5*(pTissueNutrientConc[i-1][j-1][k-1]+pTissueNutrientConc[i+1-1][j-1][k-1]);
					
					if	(pVesselNutrientConc[nby-1]<0.5*LocalNut)
					{
						pFluid[nby-1]=0;
						pSprout[nby-1]=0;
					}
				}
//-----------------------------------------------
/*				if (vVEGFConc[i-1][j-1][k-1]<VEGF_CritFract)
				{
					if (
							pXHem[i-1][j-1][k-1] < Haemo_CritFract*MaxHt
							&&
							pAgeOfVessel[nbx-1]>Age_Crit
						)
					{	
						pFluid[nbx-1]=0;
						pSprout[nbx-1]=0; 
					}	
				
					if (
							pYHem[i-1][j-1][k-1] < Haemo_CritFract*MaxHt
							&&
							pAgeOfVessel[nby-1]>Age_Crit
						)
					{	
						pFluid[nby-1]=0;
						pSprout[nby-1]=0; 
					}	
				}
//-----------------------------------------------
*/			}
		}
	}

//-----------------------------------------------
}

//*********************************************************
//=================================================
void CAngioNetDlg::UpdateTissueNutrientConcs2(void)
//=================================================
{
		//Cannibalises MDF algorithm, so ignore MDF references here - replace with nutrient
	// Print out some stuff
	// Get a device context first
	CClientDC graphicsDC(this);

//---------------------------------------------------------
	//--Keeps a total of how much "conc" has to be removed from each vessel
	//--These are updated in Source() for all vessels at end of the gridblock nutrient updates

	for (int n=1;n<=Nbond;n++) { pConcDecrement[n-1]=0.0; }

	//------------------------------------------------------

	double*** pStoredOldTissueConc=NULL;
	pStoredOldTissueConc=new double** [m_nx+1]; //m_nx+1 tissue blocks

	for (int i=0;i<=m_nx;i++)
	{    
		pStoredOldTissueConc[i]=new double* [m_ny];
	}

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	 
			pStoredOldTissueConc[i][j]=new double [m_nz];
		}
	}

//-----------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				pStoredOldTissueConc[i-1][j-1][k-1]=0.0;
			}
		}
	}
//-----------------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				pStoredOldTissueConc[i-1][j-1][k-1]=pOldTissueNutrientConc[i-1][j-1][k-1];
			}
		}
	}
//--------------------------------------------------

	// Print the loop variable
	CString myString;
	int yval=200; // ?

	int iplus,iminus,jplus,jminus,kplus,kminus;

	double subAngioDeltaT;

	if (m_nz==1) { subAngioDeltaT=oxyDeltaT/2.0; } // for a 2D network
		else     { subAngioDeltaT=oxyDeltaT/3.0; } // for a 3D network
 
//**********************
		//NB D_Transmural is set in LocaliseNutrient..() and defines
		//magnitude of Source terms (in Source())
	//double diffCoeffTissue=0.0005;//(Mike 07/10)0.000005;//0.0000025;//0.000005;//10e-6;	//intratissue diffusion coefficient
	//Modified value 14_4_2008 SMcD
	//double sigma=0.00015;//(Mike 07/10)0.1;//0.01;				//decay constant
	double sig_Uptake=0.0;//0.1; //same as TAF uptake rate by ECs. Is this OK?
		
//***********************************
	double lambdaX=(diffCoeffNutrient*subAngioDeltaT)/(pow(angioDeltaX,2));//XX Not m_Diff, eps
	double lambdaY=(diffCoeffNutrient*subAngioDeltaT)/(pow(angioDeltaY,2));
	
	angioDeltaZ=angioDeltaY;
	double lambdaZ=(diffCoeffNutrient*subAngioDeltaT)/(pow(angioDeltaZ,2));
	//or angioDeltaZ=angioDeltaY to avoid a division by zero (see InitVariables())

    double* coeffA;
	double* coeffB; 
	double* coeffC;
	double* coeffD;

//---------------------------------------------------------------------------
// calculation of the variables in the x-direction time=[t,t+subAngioDeltaT]
//---------------------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nx+1];
	coeffB=new double[m_nx+1];
    coeffC=new double[m_nx+1];
	coeffD=new double[m_nx+1];

	for	(int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{  	for (int i=0;i<=m_nx;i++) 
			{
				if	(i==0 || i==m_nx)	{pTissueNutrientConc[i][j][k]=pOldTissueNutrientConc[i][j][k]=InputNutConc;}
				if	(j==0 || j==m_ny-1)	{pTissueNutrientConc[i][j][k]=pOldTissueNutrientConc[i][j][k]=InputNutConc;}
			}
		}
	}

	//-----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=1;j<=m_ny-2;j++)
		{  //----------------------------
		
			for (int i=1;i<=m_nx-1;i++) 
			{	
		
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}
			

	//=========Check to see if uptake by PC is needed	
		
		int PC_Present=0;	//no pericyte at the site yet

		int nbx=LabX(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nby=LabY(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nbz=LabZ(i+1,j+1,k+1);	//add 1 to get into correct range for LabX

		if (bDiscretePericyte[nbx-1] || bDiscretePericyte[nby-1] ||
			bDiscretePericyte[nbz-1]) {PC_Present=1;}	//add uptake term if
														// PC is present
														//(active or not)
	//===============================================

	// update Matrix Degradation Factor (MDF)
		coeffA[i]=-lambdaX;
		coeffB[i]=1.0+2.0*lambdaX;
		coeffC[i]=-lambdaX;

		coeffD[i]=pOldTissueNutrientConc[i][j][k]+subAngioDeltaT*( 

		Source(i,j,k)+	//vessel sources

	     -sigma_Nutrient*pOldTissueNutrientConc[i][j][k]	//decay term
		 -sig_Uptake*pOldTissueNutrientConc[i][j][k]*PC_Present	//uptake by PCs term
		
	   + diffCoeffNutrient*(//--------------------------------------------------------------

		((pOldTissueNutrientConc[i][jplus][k]-2.0*pOldTissueNutrientConc[i][j][k]+
		  pOldTissueNutrientConc[i][jminus][k])/pow(angioDeltaY,2)) 

	   +((pOldTissueNutrientConc[i][j][kplus]-2.0*pOldTissueNutrientConc[i][j][k]+
		  pOldTissueNutrientConc[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close diffCoeffTissue-------------------------------------------------------

		); //close subAngioDeltaT


////		pTissueNutrientConc[i][j][k]=pTissueNutrientConc[i][j][k]-
////			angioDeltaT*sigma*pOldTissueNutrientConc[i][j][k];

		} // end loop i


		SolveTridiagTissX2(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);

	
	}} // end loops j and k



//--------------------------------------------------------------------------------------------
// calculation of the variables in the y-direction time=[t+subAngioDeltaT,t+2*subAngioDeltaT]
//--------------------------------------------------------------------------------------------

	//=======================
	  OverWriteOldWithNewTiss();
	//=======================
		//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------




	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_ny];
	coeffB=new double[m_ny];
    coeffC=new double[m_ny];
	coeffD=new double[m_ny];
 
	//----------------------------
	for (int k=0;k<=m_nz-1;k++)
	{   for ( int i=0;i<=m_nx-1;i++)
		{  //----------------------------
		
			for (int j=0;j<=m_ny-2;j++) 
			{

		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}

		//=========Check to see if uptake by PC is needed	
		
		int PC_Present=0;	//no pericyte at the site yet

		int nbx=LabX(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nby=LabY(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nbz=LabZ(i+1,j+1,k+1);	//add 1 to get into correct range for LabX

		if (bDiscretePericyte[nbx-1] || bDiscretePericyte[nby-1] ||
			bDiscretePericyte[nbz-1]) {PC_Present=1;}  //add uptake term
	//===============================================


	// update Matrix Degradation Factor (MDF)
		coeffA[j]=-lambdaY;
		coeffB[j]=1.0+2.0*lambdaY;
		coeffC[j]=-lambdaY;

		coeffD[j]=pOldTissueNutrientConc[i][j][k]+subAngioDeltaT*( 

		Source(i,j,k)+	//vessel sources

		 -sigma_Nutrient*pOldTissueNutrientConc[i][j][k]	//decay term
		 -sig_Uptake*pOldTissueNutrientConc[i][j][k]*PC_Present	//uptake by PCs term
	   
	   + diffCoeffNutrient*(//--------------------------------------------------------------

		((pOldTissueNutrientConc[iplus][j][k]-2.0*pOldTissueNutrientConc[i][j][k]+
		  pOldTissueNutrientConc[iminus][j][k])/pow(angioDeltaX,2))

	   +((pOldTissueNutrientConc[i][j][kplus]-2.0*pOldTissueNutrientConc[i][j][k]+
		  pOldTissueNutrientConc[i][j][kminus])/pow(angioDeltaZ,2))

		  ) //close epsilon-------------------------------------------------------

		); //close subAngioDeltaT

		} // end loop j

		SolveTridiagTissY2(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and k
 

	//=======================
	  OverWriteOldWithNewTiss();	///SMcD  $$$$  SHOULD WE NOT CALL THIS HERE TOO 
								////   (if  nz=1 then the y-values are not overwritten)
	//=======================
		//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------
//-----------------------------------------------------------------------------------------
// calculation of the variables in the z-direction time=[t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz is not equal to 1 (i.e. 3D network)
//------------------------------------------------------------------------------------------


	if (m_nz!=1) { //=====================================================================


	//=======================
	////SMcD  OverWriteOldWithNewMDF();
	//=======================

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nz];
	coeffB=new double[m_nz];
    coeffC=new double[m_nz];
	coeffD=new double[m_nz];

	//-----------------------------
	for (int i=0;i<=m_nx;i++)
	{   for (int j=0;j<=m_ny-1;j++)
		{   //----------------------------
		
			for (int k=0;k<=m_nz-1;k++) 
			{	
		
		if (i==0)      { iminus=i+1;   } else { iminus=i-1; }
		if (i==m_nx)   { iplus=m_nx-1; } else { iplus=i+1;  }
		if (j==0)	   { jminus=j+1;   } else { jminus=j-1; }
		if (j==m_ny-1) { jplus=m_ny-2; } else { jplus=j+1;  }

		if (m_nz==1) {	kminus=k;
						kplus=k;  }
		else {	if (k==0)	   { kminus=k+1;   } else { kminus=k-1; }
				if (k==m_nz-1) { kplus=m_nz-2; } else { kplus=k+1;  }}

	//=========Check to see if uptake by PC is needed	
		
		int PC_Present=0;	//no pericyte at the site yet

		int nbx=LabX(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nby=LabY(i+1,j+1,k+1);	//add 1 to get into correct range for LabX
		int nbz=LabZ(i+1,j+1,k+1);	//add 1 to get into correct range for LabX

		if (bDiscretePericyte[nbx-1] || bDiscretePericyte[nby-1] ||
			bDiscretePericyte[nbz-1]) {PC_Present=1;}  //add uptake term
	//===============================================


	// update EndoCellDensity
		coeffA[k]=-lambdaZ;
		coeffB[k]=1.0+2.0*lambdaZ;
		coeffC[k]=-lambdaZ;
		
        coeffD[k]=pOldTissueNutrientConc[i][j][k]+subAngioDeltaT*( 
			
		Source(i,j,k)+	//vessel sources

		-sigma_Nutrient*pOldTissueNutrientConc[i][j][k]	//decay term
		-sig_Uptake*pOldTissueNutrientConc[i][j][k]*PC_Present	//uptake by PCs term
	   
	   + diffCoeffNutrient*(//--------------------------------------------------------------

		((pOldTissueNutrientConc[iplus][j][k]-2.0*pOldTissueNutrientConc[i][j][k]+
		  pOldTissueNutrientConc[iminus][j][k])/pow(angioDeltaX,2))

	   +((pOldTissueNutrientConc[i][jplus][k]-2.0*pOldTissueNutrientConc[i][j][k]+
		  pOldTissueNutrientConc[i][jminus][k])/pow(angioDeltaY,2))

		  ) //close epsilon-------------------------------------------------------
		 
		); //close subAngioDeltaT

		} // end loop k

		SolveTridiagTissZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

	}} // end loops i and j



			OverWriteOldWithNewTiss();	//SMcD put this in

		//Delete arrays----------
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
	//----------------------------

	} // end if (m_nz!=1) =============================================================





	// Now get new running TissueConc maximum
	runningTissConcMAX=0.0; // used for graphics

	if	(oxyTime>10.0 && RateNutChangeMAX<=2.5e-5)//if	(loop%25000==0 || angiotime>m_angiotimeMax)
	{

		double TotalOxygen=0.0;
		int nTissueBlocks=0;

		for (int k=0;k<=m_nz-1;k++)
		{	for (int j=0;j<=m_ny-1;j++)
			{	for (int i=0;i<=m_nx;i++)
				{
					if (pTissueNutrientConc[i][j][k]>runningTissConcMAX)
					{	
						runningTissConcMAX=pTissueNutrientConc[i][j][k];
					}

					if	(
							(i>=iCentre-(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) ) && i<iCentre)
							||
							(i<=iCentre+(int)sqrt(  pow(iWoundRadius,2)-pow(j-jCentre,2) ) && i>iCentre)
						)
					{
						TotalOxygen+=pTissueNutrientConc[i][j][k];
						nTissueBlocks+=1;
					}

//					int nbx=LabX(i+1,j+1,k+1);	
//					int nby=LabY(i+1,j+1,k+1);

//					if (pFluid[nbx-1]==10)	{outfileFlows << i << "\t" << j << "\t" << XFlow[i][j][k] << "\t" << pXHem[i][j][k] << endl;}
//					if (pFluid[nby-1]==10)	{outfileFlows << i << "\t" << j << "\t" << YFlow[i][j][k] << "\t" << pYHem[i][j][k] << endl;}
			
		}}}

		outfileWoundOxygen << TotalOxygen << "\t" << nTissueBlocks << endl;

//-----------------------------------------------

		int i,j,n,p,q;

		double* CircOxygen;	//sum of oxy concs within each circle
		double* RegOxygen;	//sum of oxy concs within each corresponding region
		double* CircRadius;	//fraction of wound radius used to define each circle
		int* CircBlocks;	//no. of tissue blocks within each circle 

		CircOxygen=NULL;
		RegOxygen=NULL;
		CircRadius=NULL;
		CircBlocks=NULL;

		CircOxygen=new double[9];
		RegOxygen=new double[5];	
		CircRadius=new double[9];
		CircBlocks=new int[9];

		for (i=0;i<=8;i++)	{CircOxygen[i]=0.0;	CircRadius[i]=0.0;	CircBlocks[i]=0;}				
		for (i=0;i<=4;i++)	{RegOxygen[i]=0.0;}

		CircRadius[1]=2.0/15.0;
		CircRadius[8]=1.0;									
													
		for (p=1;p<=3;p++)									
		{												
			CircRadius[2*p]=CircRadius[2*p-1]+3.0/20.0;	
			CircRadius[2*p+1]=CircRadius[2*p]+4.0/15.0;	
		}												

		for (n=1;n<=8;n++)
		{
			for (int k=1;k<=m_nz;k++)
			{	
				for (j=1;j<=m_ny;j++)
				{	
					for (i=1;i<=m_nx;i++)
					{					
//--------------------------------------------------

						if	(
								i>iCentre-(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )  
								&&                                                           
								i<iCentre+(int)sqrt( (double)(pow(i_UU_WoundRad*CircRadius[n],2))-pow(j-jCentre,2) )
							)
						{
							CircOxygen[n]+=pTissueNutrientConc[i-1][j-1][k-1];
							CircBlocks[n]+=1;
						}
					}
				}
			}
		}

		for (q=1;q<=4;q++)
		{					
			RegOxygen[q]=(CircOxygen[2*q-1]-CircOxygen[2*q-2]);
		}

		outfileRegionOxygen << RegOxygen[1] << "\t" << CircBlocks[1] << endl;
		outfileRegionOxygen << RegOxygen[2] << "\t" << CircBlocks[3]-CircBlocks[2] << endl;
		outfileRegionOxygen << RegOxygen[3] << "\t" << CircBlocks[5]-CircBlocks[4] << endl;
		outfileRegionOxygen << RegOxygen[4] << "\t" << CircBlocks[7]-CircBlocks[6] << endl;

		delete [] CircOxygen;			
		delete [] RegOxygen;
		delete [] CircRadius;

		SaveNutrient();

		while(1)
		{
			OnDrawIt3();	//KEEP GRAPHICS ALIVE AFTER LAST LOOP IN REPLAY
			ProcessMessageLoop();
			UpdateData();
		}
	}
//	outfileFlows << "loop finished" << endl;

	double RateNutChange=0.0;
	RateNutChangeMAX=0.0;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				RateNutChange=fabs(pStoredOldTissueConc[i-1][j-1][k-1]-pTissueNutrientConc[i-1][j-1][k-1])/oxyDeltaT;

				if	(RateNutChange>RateNutChangeMAX)	{RateNutChangeMAX=RateNutChange;}
			}
		}
	}

	outfileNutConverge << angiotime << "\t" << RateNutChangeMAX << endl;

	

//---------------------------------------------------------------
	for (int i=1;i<=m_nx+1;i++)
	{	for (int j=1;j<=m_ny;j++)
		{
			delete[] pStoredOldTissueConc[i-1][j-1];
		}
	}

	for (int i=1;i<=m_nx+1;i++)
	{
		delete[] pStoredOldTissueConc[i-1];
	}

	delete [] pStoredOldTissueConc;

//--------------------------------------------------
				

//---------------------------------------------------------------

//--Finally, modify the vessel concentrations----

//	for ( n=1;n<=Nbond;n++)
//	{
//
//		pVesselNutrientConc[n-1]=pOldVesselNutrientConc[n-1]-pConcDecrement[n-1];
//	}

//--------------------------------------
//CALCULATE TOTAL MASS IN TO EACH NODE
//NB - ONLY THOSE CARRYING RBCS
//--------------------------------------

	int jp1,kp1;
	
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				TotalMassesIn[i-1][j-1][k-1]=0.0;

				if (j==m_ny) {jp1=1;} else {jp1=j+1;}
				if (k==m_nz) {kp1=1;} else {kp1=k+1;}

				TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabX(i,j,k)-1]*CharTime*oxyDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabX(i+1,j,k)-1]*fabs(XFlow[i+1-1][j-1][k-1])*pOldVesselNutrientConc[LabX(i+1,j,k)-1]*CharTime*oxyDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabY(i,j,k)-1]*CharTime*oxyDeltaT;

				TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabY(i,jp1,k)-1]*fabs(YFlow[i-1][jp1-1][k-1])*pOldVesselNutrientConc[LabY(i,jp1,k)-1]*CharTime*oxyDeltaT;

				if	(m_nz!=1)
				{
					TotalMassesIn[i-1][j-1][k-1]+=bFlowIn[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*pOldVesselNutrientConc[LabZ(i,j,k)-1]*CharTime*oxyDeltaT;

		  			TotalMassesIn[i-1][j-1][k-1]+=bFlowOut[LabZ(i,j,kp1)-1]*fabs(ZFlow[i-1][j-1][kp1-1])*pOldVesselNutrientConc[LabZ(i,j,kp1)-1]*CharTime*oxyDeltaT;
				}
	
	}}}

//--------------------------------
//UPDATE NUTRIENT IN EACH VESSEL
//--------------------------------
	int zpos,jm1,km1;
	int nCount=1;

	if (m_nz==1) {zpos=1;} else {zpos=int(m_nz/2);}
//outfileDebugOxyTracer << flowTime << endl;

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				if (j==1) {jm1=m_ny;} else {jm1=j-1;}
				if (k==1) {km1=m_nz;} else {km1=k-1;}

				
//---x-pores---
				if	(i==1)	//inlet nodes
				{	  
					if	(
							!b_TestNetwork && 
//							(
//								((j==1 || j==2) && k==zpos)	
//								|| 
//								(b_venousIncluded && j==m_ny-1 && k==zpos)
//								|| 
								(b_UU_wound_Model && j==nCount*m_ny/(nAdditionalCentralPVs+1) && k==zpos && j!=100)
//								|| 
//								(b_UU_wound_Model && j==m_ny-1 && k==zpos)
//							)
						)//**arts** 

						{
							if	(!b_HexNetwork || (b_HexNetwork && b_StraightPVs))	//square network or hex network with straight PVs
							{
								pVesselNutrientConc[LabX(i,j,k)-1]+=fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT/
																		(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])*
																			(InputNutConc-pOldVesselNutrientConc[LabX(i,j,k)-1]);

								nCount++;
							}

//-----------------------------------------------						
							else if	(b_HexNetwork && !b_StraightPVs)	//hexagonal network	
							{
								if	(int(j/2)-double(j/2.0)==0)	//j even, inlets at j+1
								{
									pVesselNutrientConc[LabX(i,j+1,k)-1]+=fabs(XFlow[i-1][j+1-1][k-1])*oxyDeltaT/
																			(PI*pow(XBR[i-1][j+1-1][k-1],2)*XBL[i-1][j+1-1][k-1])*
																				(InputNutConc-pOldVesselNutrientConc[LabX(i,j+1,k)-1]);
								}

								else	//j odd, inlets at j
								{
									pVesselNutrientConc[LabX(i,j,k)-1]+=fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT/
																			(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])*
																				(InputNutConc-pOldVesselNutrientConc[LabX(i,j,k)-1]);
								}

								nCount++;	//step to next additional PV

							}	//end if hexagonal network

//-----------------------------------------------
						}	//end if j=...

//-----------------------------------------------											
								//pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06

			  					//pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*timestep/
			  					//(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
			  					//(AverageHt-pXHem[i-1][j-1][k-1]);				
					
//-----------------------------------------------

					if	(b_TestNetwork)
					{
						if	(
								(j==51 && pFluid[LabX(i,51,k)-1]==10)	//one inlet at centre for branching networks
								||
								(j==2 && pFluid[LabX(i,2,k)-1]==10)		//one inlet at top for retina network
							)
						{
							pVesselNutrientConc[LabX(i,j,k)-1]+=fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT/
																	(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1])*
																		(InputNutConc-pOldVesselNutrientConc[LabX(i,j,k)-1]);
						}
					}
					
//-----------------------------------------------
			  //2nd arteriole
			  //if (j==m_ny-1 && k==1) //**2nd art** //Updated SMcD 07.11.06
				//	{
				  //pXHem[i-1][j-1][k-1]+=fabs(XFlow[i-1][j-1][k-1])*angioDeltaT/
				//		(pi*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]) *
				//		(TimeFactor*AverageHt-TimeFactor*pXHem[i-1][j-1][k-1])/MaxHt;
				  
			//		pXHem[i-1][j-1][k-1]=AverageHt;  //Put back SMcD 11.06
			//		}

//-----------------------------------------------
				}  //end if i=1

//-----------------------------------------------

				else	//not the inlet port
				{
					if	(TotalFlowsOut[i-1][j-1][k-1]>0)
					{
						if	(
								XFlow[i-1][j-1][k-1]<0.0 
								&& 
								(bAllowNutrientTransport[LabX(i,j,k)-1] || j==2)
							)
						{
							pVesselNutrientConc[LabX(i,j,k)-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][k-1])
																	-(pOldVesselNutrientConc[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]))
																			-pConcDecrement[LabX(i,j,k)-1];
						}

						else if (
									XFlow[i-1][j-1][k-1]>0.0 
									&& 
									(bAllowNutrientTransport[LabX(i,j,k)-1] || j==2)
								)
						{
							pVesselNutrientConc[LabX(i,j,k)-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassesIn[i-1-1][j-1][k-1])
																	-(pOldVesselNutrientConc[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]))
																			-pConcDecrement[LabX(i,j,k)-1];
//outfileDebugOxyTracer << i << "\t" << j << "\t" << NormFractRBCFlowX[i-1][j-1][k-1] << "\t" << TotalMassIn[i-1-1][j-1][k-1] << "\t" << pOldVesselNutrientConc[LabX(i,j,k)-1] << "\t" << fabs(XFlow[i-1][j-1][k-1]) << "\t" << pConcDecrement[LabX(i,j,k)-1] << endl;  
						}

//-----------------------------------------------
					}	//end if TotalFlowOut>0

				}	//end if i!=1

//-----------------------------------------------
//---y-pores---

				if	(TotalFlowsOut[i-1][j-1][k-1]>0)
				{
					if	(
							YFlow[i-1][j-1][k-1]<0.0 
							&& 
							bAllowNutrientTransport[LabY(i,j,k)-1]
						)
					{
						pVesselNutrientConc[LabY(i,j,k)-1]+=(((NormFractRBCFlowY[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][k-1])
																-(pOldVesselNutrientConc[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																	/(PI*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]))
																		-pConcDecrement[LabY(i,j,k)-1];
					}

					else if (
								YFlow[i-1][j-1][k-1]>0.0 
								&& 
								bAllowNutrientTransport[LabY(i,j,k)-1]
							)
					{
						pVesselNutrientConc[LabY(i,j,k)-1]+=(((NormFractRBCFlowY[i-1][j-1][k-1]*TotalMassesIn[i-1][jm1-1][k-1])
																-(pOldVesselNutrientConc[LabY(i,j,k)-1]*fabs(YFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																	/(PI*pow(YBR[i-1][j-1][k-1],2)*YBL[i-1][j-1][k-1]))
																		-pConcDecrement[LabY(i,j,k)-1];
					}

//-----------------------------------------------
				}	//end if TotalFlowOut>0

//-----------------------------------------------
//---z-pores---
				if	(m_nz!=1)
				{
					if	(TotalFlowsOut[i-1][j-1][k-1]>0)
					{
						if	(
								ZFlow[i-1][j-1][k-1]<0.0 
								&& 
								bAllowNutrientTransport[LabZ(i,j,k)-1]
							)
						{
							pVesselNutrientConc[LabZ(i,j,k)-1]+=((NormFractRBCFlowZ[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][k-1])
																	-(pOldVesselNutrientConc[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1])
																			-pConcDecrement[LabZ(i,j,k)-1];
						}

						else if	(
									ZFlow[i-1][j-1][k-1]>0.0 
									&& 
									bAllowNutrientTransport[LabZ(i,j,k)-1]
								)
						{
							pVesselNutrientConc[LabZ(i,j,k)-1]+=(((NormFractRBCFlowZ[i-1][j-1][k-1]*TotalMassesIn[i-1][j-1][km1-1])
																	-(pOldVesselNutrientConc[LabZ(i,j,k)-1]*fabs(ZFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
																		/(PI*pow(ZBR[i-1][j-1][k-1],2)*ZBL[i-1][j-1][k-1]))
																			-pConcDecrement[LabZ(i,j,k)-1];
						}

//-----------------------------------------------
					}	//end if TotalflowOut>0
				}
//-----------------------------------------------
			}	// end i-loop

//-----------------------------------------------
//---x-danglers---
			int i=m_nx+1;

			if	(
					TotalFlowsOut[i-1-1][j-1][k-1]>0
					&&
					bAllowNutrientTransport[LabX(i,j,k)-1]
				)
			{
				pVesselNutrientConc[LabX(i,j,k)-1]+=(((NormFractRBCFlowX[i-1][j-1][k-1]*TotalMassesIn[i-1-1][j-1][k-1])
														-(pOldVesselNutrientConc[LabX(i,j,k)-1]*fabs(XFlow[i-1][j-1][k-1])*oxyDeltaT*CharTime))
															/(PI*pow(XBR[i-1][j-1][k-1],2)*XBL[i-1][j-1][k-1]))
																-pConcDecrement[LabX(i,j,k)-1];
			}

//-----------------------------------------------
		}	//end j loop
	}	//end k loop

//-----------------------------------------------

//---------------------------------------------------------------
}

//*********************************************************
//================================================
void CAngioNetDlg::SolveTridiagTissX2(int m_nx, int m_ny, int m_nz, int j, int k, 
									 double *coeffA, double *coeffB, double *coeffC, double *coeffD)
//================================================
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_nx+1]; // indice: 0 to m_nx
	q=new double[m_nx+1];

	for	(int i=0;i<=m_nx;i++)
	{
		p[i]=0.0;
		q[i]=0.0;
	}

	//modify calculated coeffs for Dirich BC
	coeffD[1]=coeffD[1]-coeffA[1]*InputNutConc;
	coeffD[m_nx-1]=coeffD[m_nx-1]-coeffC[m_nx-1]*InputNutConc;

	//calculation of the matrix coefficients
    p[1]=coeffC[1]/coeffB[1];
	q[1]=coeffD[1]/coeffB[1];

	for (int i=2;i<=m_nx-1;i++)
	{
		p[i]=coeffC[i]/(coeffB[i]-coeffA[i]*p[i-1]);
		q[i]=(coeffD[i]-coeffA[i]*q[i-1])/(coeffB[i]-coeffA[i]*p[i-1]);
	}

	//calculation of the function for the next time step (iteration)
	//pTissueNutrientConc[m_nx-1][j][k]=(q[m_nx-1]-p[m_nx-1]*q[m_nx-2])/(1.0-p[m_nx-1]*p[m_nx-2]);
	pTissueNutrientConc[m_nx-1][j][k]=q[m_nx-1];

	int i=m_nx-2;
	while(i>0)
    {
		pTissueNutrientConc[i][j][k]=q[i]-pTissueNutrientConc[i+1][j][k]*p[i];
		i=i-1;
	}

	//----------
	delete [] p;
	delete [] q;


}
//****************************************************************
//=================================================
void CAngioNetDlg::SolveTridiagTissY2(int m_nx, int m_ny, int m_nz, int i, int k, 
									 double *coeffA, double *coeffB, double *coeffC, double *coeffD)
//=================================================
{
	double* p; 
	double* q;
	p=q=NULL;
	p=new double[m_ny]; // indice: 0 to m_ny-1
	q=new double[m_ny];

	for	(int j=0;j<=m_ny-1;j++)
	{
		p[j]=0.0;
		q[j]=0.0;
	}

	//modify calculated coeffs for Dirich BC
	coeffD[1]=coeffD[1]-coeffA[1]*InputNutConc;
	coeffD[m_ny-2]=coeffD[m_ny-2]-coeffC[m_ny-2]*InputNutConc;

	//calculation of the matrix coefficients
    p[1]=coeffC[1]/coeffB[1];
	q[1]=coeffD[1]/coeffB[1];

	for (int j=2;j<=m_ny-2;j++)
	{
		p[j]=coeffC[j]/(coeffB[j]-coeffA[j]*p[j-1]);
		q[j]=(coeffD[j]-coeffA[j]*q[j-1])/(coeffB[j]-coeffA[j]*p[j-1]);
	}
	
	//calculation of the function for the next time step (iteration)
	//pTissueNutrientConc[i][m_ny-2][k]=(q[m_ny-2]-p[m_ny-2]*q[m_ny-3])/(1.0-p[m_ny-2]*p[m_ny-3]);
	pTissueNutrientConc[i][m_ny-2][k]=q[m_ny-2];

	int j=m_ny-3;
	while(j>0)
    {
		pTissueNutrientConc[i][j][k]=q[j]-pTissueNutrientConc[i][j+1][k]*p[j];
		j=j-1;
	}

	//----------
	delete [] p;
	delete [] q;
}
//*********************************************************

//===============================================
void CAngioNetDlg::InitialiseBoneTissue(void)
//===============================================
{
//Sub-routine populates domain with bone tissue using algorithm of choice

//===============================================
/*
//Bone tissue assigned randomly to particular fraction of nodes OR to a specified sub-set of nodes

	double throwDice;
	double boneFraction=0.0;//0.32;//0.24;//0.4;//0.8;//0.3;//0.46;//

	for	(int k=1;k<=m_nz;k++)
	{	for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx+1;i++)
			{
//-----------------------------------------------

				//Exclude bone tissue around domain boundaries (e.g. for initial vessel sprouts)
				if	(i>2 && j>2 && k>2 && i<m_nx-2 && j<m_ny-2 && k<m_nz-2)
				{
					throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1

					if	(throwDice<boneFraction)
					{
						bBoneTissue[i-1][j-1][k-1]=TRUE;
					}
				}
//-----------------------------------------------
//				if	((i>20 && j>10 && i<25 && j<90)||(i>52 && j>10 && i<57 && j<90)||(i>80 && j>10 && i<85 && j<90))
//				{
//					bBoneTissue[i-1][j-1][k-1]=TRUE;
//				}
//-----------------------------------------------
			}
		}
	}
*/
//===============================================

//Bone tissue read-in from pre-prepared file

	for	(int k=1;k<=m_nz;k++)
	{	for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx;i++)
			{
				infileBoneTissue>>bBoneTissue[i-1][j-1][k-1];

				//Exclude bone tissue around domain boundaries (e.g. for initial vessel sprouts)
				if	(i<=2 || j<=2 || i>=m_nx-1 || j>=m_ny-2 || k<=2 || k>=m_nz-2)
				{
					bBoneTissue[i-1][j-1][k-1]=FALSE;
				}
			}
		}
	}

//-----------------------------------------------

//Remove any "floating" regions of bone tissue

	BoneClustering(pIclusBone, 1);	//identify bone clusters in order to remove regions disconnected from scaffold bulk

	int* pIclusSize=NULL;	//array for storing no. of blocks in each cluster
	pIclusSize=new int[(m_nx+1)*m_ny*m_nz];

	for (int n=1;n<=(m_nx+1)*m_ny*m_nz;n++)
	{
		pIclusSize[n-1]=0;
	}

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				if (pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]!=1000000)
				{
					pIclusSize[pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]-1]+=1;
				}

//outfileDebugBone<<i<<"\t"<<j<<"\t"<<k<<"\t"<<pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]<<endl;
	}}}

	int nMaxClusterSize=0;
	int nMaxClusterLabel=0;

	for (int n=1;n<=(m_nx+1)*m_ny*m_nz;n++)	//identify cluster with most bone blocks (should represent connected bulk scaffold)
	{
		if (pIclusSize[n-1]!=0) {outfileDebugBone<<n<<"\t"<<pIclusSize[n-1]<<endl;}

		if (pIclusSize[n-1]>nMaxClusterSize)
		{
			nMaxClusterSize=pIclusSize[n-1];
			nMaxClusterLabel=n;

//outfileDebugBone<<nMaxClusterSize<<"\t"<<nMaxClusterLabel<<endl;
		}
	}

	for (int k=1;k<=m_nz;k++)	//remove all clusters disconnected from bulk scaffold
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				if (pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]!=1000000 && pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]!=nMaxClusterLabel)
				{
					bBoneTissue[i-1][j-1][k-1]=FALSE;

//outfileDebugBone<<i<<"\t"<<j<<"\t"<<k<<"\t"<<pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]<<endl;
				}

	}}}

	delete[] pIclusSize;

//-----------------------------------------------

//Calculate areal porosities on outer scaffold surfaces

	int nCountLeft=0;
	int nCountRight=0;
	int nCountTop=0;
	int nCountBottom=0;
	int nCountBack=0;
	int nCountFront=0;

	for	(int k=1;k<=m_nz;k++)
	{	for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx;i++)
			{
				if	(bBoneTissue[i-1][j-1][k-1]==FALSE)
				{
					if (i==3 && j>2 && j<m_ny-2 && k>2 && k<m_nz-2) {nCountLeft+=1;}
					if (i==m_nx-2 && j>2 && j<m_ny-2 && k>2 && k<m_nz-2) {nCountRight+=1;}
					if (j==3 && i>2 && i<m_nx-1 && k>2 && k<m_nz-2) {nCountTop+=1;}
					if (j==m_ny-3 && i>2 && i<m_nx-1 && k>2 && k<m_nz-2) {nCountBottom+=1;}
					if (k==3 && i>2 && i<m_nx-1 && j>2 && j<m_ny-2) {nCountBack+=1;}
					if (k==m_nz-3 && i>2 && i<m_nx-1 && j>2 && j<m_ny-2) {nCountFront+=1;}
				}
			}
		}
	}

outfileDebugBone<<"Left: "<<nCountLeft<<"\t"<<"Right: "<<nCountRight<<"\t"<<"Top: "<<nCountTop<<
	"\t"<<"Bottom: "<<nCountBottom<<"\t"<<"Back: "<<nCountBack<<"\t"<<"Front: "<<nCountFront<<endl;
	
//===============================================
/*
//Bone tissue constructed by reading-in single image or series of images (e.g. microCT scaffold reconstruction)
//Pixellated pore space recreated on (coarser) computational domain

//N.B. This need only be done once for each image set --> quicker to output result and read-in above instead

	int numPixels_x=100;//150;//	//**Must match value for images being read-in**
	int numPixels_y=100;//150;//	//**Must match value for images being read-in**
	int numImages_z=113;//1;//		//**Match to desired number of images**

//-----------------------------------------------

	int*** nPixelValue=NULL;	//array stores read-in pixel values (0 or 1 --> "bone" or void)

	nPixelValue=new int**[numPixels_x];

	for (int ii=1;ii<=numPixels_x;ii++)
	{    
		nPixelValue[ii-1]=new int*[numPixels_y];
	}

	for (int jj=1;jj<=numPixels_y;jj++)
	{	for (int ii=1;ii<=numPixels_x;ii++)
		{
			nPixelValue[ii-1][jj-1]=new int[numImages_z];
		}
	}

	for (int kk=1;kk<=numImages_z;kk++)
	{	for (int jj=1;jj<=numPixels_y;jj++)
		{	for (int ii=1;ii<=numPixels_x;ii++)
			{
				nPixelValue[ii-1][jj-1][kk-1]=0;
			}
		}
	}

	for	(int kk=1;kk<=numImages_z;kk++)
	{	for	(int jj=1;jj<=numPixels_y;jj++)
		{	for	(int ii=1;ii<=numPixels_x;ii++)
			{
				infileBoneTissue>>nPixelValue[ii-1][jj-1][kk-1];

//				if (ii>=76 && ii<226 && jj>=76 && jj<226)	{outfileBoneTissue<<nPixelValue[ii-1][jj-1][kk-1]<<endl;}

				if (nPixelValue[ii-1][jj-1][kk-1]==1)			{nPixelValue[ii-1][jj-1][kk-1]=0;}	//Reverses pixel values for consistency
				else if (nPixelValue[ii-1][jj-1][kk-1]==0)	{nPixelValue[ii-1][jj-1][kk-1]=1;}		//with bBoneTissue (0 or 1 --> void or "bone")

//				outfileBoneTissue<<nPixelValue[ii-1][jj-1][kk-1]<<endl;

//				if (nPixelValue[ii-1][jj-1][kk-1]==1)			{bBoneTissue[ii-1][jj-1][kk-1]=0;}
//				else if (nPixelValue[ii-1][jj-1][kk-1]==0)	{bBoneTissue[ii-1][jj-1][kk-1]=1;}

//				outfileBoneTissue<<bBoneTissue[ii-1][jj-1][kk-1]<<endl;
			}
		}
	}

//-----------------------------------------------

	if (numImages_z>1)	//Series of images read-in to produce 3D bone tissue distribution (i.e. m_nz>1)
	{
		double iGridLength=20.0;// microns (model grid spacing)
		double jGridLength=20.0;// microns (model grid spacing)
		double kGridLength=20.0;// microns (model grid spacing)
		double iiGridLength=12.0;// microns (image pixel resolution) N.B. Must be <= iGridLength
		double jjGridLength=12.0;// microns (image pixel resolution) N.B. Must be <= jGridLength
		double kkGridLength=10.7;// microns (average microCT slice spacing) N.B. Must be <= kGridLength

		//---IMPORTANT! Need to set m_nx=int(iiGridLength/iGridLength*numPixels_x)---
		//---IMPORTANT! Need to set m_ny=int(jjGridLength/jGridLength*numPixels_y)---
		//---IMPORTANT! Need to set m_nz=int(kkGridLength/kGridLength*numImages_z)---
		//---(N.B. numImages_z must be sufficient such that m_nz>1)------------------

//-----------------------------------------------

		//Pixellated grid overlain on computational grid, assuming origins coincide
		//These values represent x, y and z boundaries of the computational blocks, expressed in "pixel" co-ordinates 
		double iiLeftBoundary=0.0;							
		double iiRightBoundary=iGridLength/iiGridLength;
		double jjTopBoundary=0.0;							
		double jjBottomBoundary=jGridLength/jjGridLength;
		double kkBackBoundary=0.0;						
		double kkFrontBoundary=kGridLength/kkGridLength;

//-----------------------------------------------

		//These values represent the smallest and largest x, y and z values of pixels that overlap the current computational grid block
		int iiMin=1;
		int jjMin=1;
		int kkMin=1;

		int iiMax, jjMax, kkMax;
		double tol=1.0e-6;	//tolerance prevents numerical issues when converting between double and integer values

		if ((ceil(iiRightBoundary)-iiRightBoundary)>(1.0-tol)) {iiMax=int(ceil(iiRightBoundary))-1;} else {iiMax=int(ceil(iiRightBoundary));}
		if ((ceil(jjBottomBoundary)-jjBottomBoundary)>(1.0-tol)) {jjMax=int(ceil(jjBottomBoundary))-1;} else {jjMax=int(ceil(jjBottomBoundary));}
		if ((ceil(kkFrontBoundary)-kkFrontBoundary)>(1.0-tol)) {kkMax=int(ceil(kkFrontBoundary))-1;} else {kkMax=int(ceil(kkFrontBoundary));}

//-----------------------------------------------

		//Volumetric fraction of bone found in each computational grid block by summing appropriate pixel segments
		double BoneFraction=0.0;

		int BoneCount=0;

		//Visit every computational grid block
		for	(int k=1;k<=m_nz;k++)
		{	for	(int j=1;j<=m_ny;j++)
			{	for	(int i=1;i<=m_nx;i++)
				{

//outfileDebugBone<<endl;
//outfileDebugBone<<i<<"\t"<<j<<"\t"<<k<<"\t"<<iiMin<<"\t"<<iiMax<<"\t"<<jjMin<<"\t"<<jjMax<<"\t"<<kkMin<<"\t"<<kkMax<<"\t"<<iiLeftBoundary
//							<<"\t"<<iiRightBoundary<<"\t"<<jjTopBoundary<<"\t"<<jjBottomBoundary<<"\t"<<kkBackBoundary<<"\t"<<kkFrontBoundary<<endl;

//-----------------------------------------------

					//Visit every pixel grid block overlapping the current computational grid block
					for	(int kk=kkMin;kk<=kkMax;kk++)
					{	for	(int jj=jjMin;jj<=jjMax;jj++)
						{	for	(int ii=iiMin;ii<=iiMax;ii++)
							{
								//If pixel contains bone, add the normalised overlap volume
								if (nPixelValue[ii-1][jj-1][kk-1]==1)
								{
									if (ii==iiMin)
									{
										if (jj==jjMin)
										{
											if (kk==kkMin)
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"1: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"2: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"3: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}

										else if (jj==jjMax)
										{
											if (kk==kkMin)
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"4: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"5: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"6: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}

										else
										{
											if (kk==kkMin)
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"7: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"8: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"9: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}
									}

									else if (ii==iiMax)
									{
										if (jj==jjMin)
										{
											if (kk==kkMin)
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"10: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"11: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"12: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}

										else if (jj==jjMax)
										{
											if (kk==kkMin)
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"13: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"14: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"15: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}

										else
										{
											if (kk==kkMin)
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"16: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"17: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"18: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}
									}

									else
									{
										if (jj==jjMin)
										{
											if (kk==kkMin)
											{
												BoneFraction+=(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"19: "<<(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"20: "<<(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"21: "<<(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}

										else if (jj==jjMax)
										{
											if (kk==kkMin)
											{
												BoneFraction+=(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"22: "<<(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"23: "<<(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"24: "<<(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}

										else
										{
											if (kk==kkMin)
											{
												BoneFraction+=(iiGridLength*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"25: "<<(iiGridLength*jjGridLength*(double(kkMin)-kkBackBoundary)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else if (kk==kkMax)
											{
												BoneFraction+=(iiGridLength*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"26: "<<(iiGridLength*jjGridLength*(kkFrontBoundary-double(kkMax)+1.0)*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}

											else
											{
												BoneFraction+=(iiGridLength*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength);
//outfileDebugBone<<"27: "<<(iiGridLength*jjGridLength*kkGridLength)/(iGridLength*jGridLength*kGridLength)<<"\t";
											}
										}
									}
								}	//end if bone tissue
					}}}	//end ii, jj, kk loops

//-----------------------------------------------

					//If computational grid block contains > 50% bone, fill with bone
//					if	(i>2 && j>2 && i<m_nx-2 && j<m_ny-2)//&& k>2 && k<m_nz-2?
//					{
						if (BoneFraction>=0.5)	{bBoneTissue[i-1][j-1][k-1]=TRUE;	BoneCount+=1;}
//					}

//-----------------------------------------------

					//If rhs of image not been reached, move to next grid block in pos. x-direction
					if (iiMax<numPixels_x)
					{
						if (double(iiMax)>iiRightBoundary)	{iiMin=iiMax;}	else {iiMin=iiMax+1;}

						iiLeftBoundary+=iGridLength/iiGridLength;
				
						iiRightBoundary+=iGridLength/iiGridLength;

						if ((ceil(iiRightBoundary)-iiRightBoundary)>(1.0-tol)) {iiMax=int(ceil(iiRightBoundary))-1;} else {iiMax=int(ceil(iiRightBoundary));}
					}

					//If RHS of image reached,...
					else 
					{
						//If bottom of image not been reached, move to next grid block in pos. y-direction
						if (jjMax<numPixels_y)
						{
							if (double(jjMax)>jjBottomBoundary)	{jjMin=jjMax;}	else {jjMin=jjMax+1;}

							jjTopBoundary+=jGridLength/jjGridLength;
				
							jjBottomBoundary+=jGridLength/jjGridLength;

							if ((ceil(jjBottomBoundary)-jjBottomBoundary)>(1.0-tol)) {jjMax=int(ceil(jjBottomBoundary))-1;} else {jjMax=int(ceil(jjBottomBoundary));}
						}

						//Otherwise, move to next grid block in pos. z-direction and return to top of image
						else
						{
							jjTopBoundary=0.0;

							jjBottomBoundary=jGridLength/jjGridLength;
				
							jjMin=1;

							if ((ceil(jjBottomBoundary)-jjBottomBoundary)>(1.0-tol)) {jjMax=int(ceil(jjBottomBoundary))-1;} else {jjMax=int(ceil(jjBottomBoundary));}

							if (double(kkMax)>kkFrontBoundary)	{kkMin=kkMax;}	else {kkMin=kkMax+1;}

							kkBackBoundary+=kGridLength/kkGridLength;
				
							kkFrontBoundary+=kGridLength/kkGridLength;

							if ((ceil(kkFrontBoundary)-kkFrontBoundary)>(1.0-tol)) {kkMax=int(ceil(kkFrontBoundary))-1;} else {kkMax=int(ceil(kkFrontBoundary));}
						}

						//Return to lhs of image
						iiLeftBoundary=0.0;

						iiRightBoundary=iGridLength/iiGridLength;
				
						iiMin=1;

						if ((ceil(iiRightBoundary)-iiRightBoundary)>(1.0-tol)) {iiMax=int(ceil(iiRightBoundary))-1;} else {iiMax=int(ceil(iiRightBoundary));}
					}

//-----------------------------------------------

					BoneFraction=0.0;

outfileBoneTissue<<bBoneTissue[i-1][j-1][k-1]<<"\t";
if (i==m_nx) {outfileBoneTissue<<endl;}

outfileDebugBone<<"BoneCount = "<<BoneCount<<endl;

//-----------------------------------------------

		}}}	//end i, j, k loops
	}	//end if 3D

//-----------------------------------------------
//-----------------------------------------------

	else if (numImages_z==1)	//Single image read-in to produce 2D bone tissue distribution (i.e. m_nz=1)
	{
		int k=1;
		int kk=1;

		double iGridLength=20.0;// microns (model grid spacing)
		double jGridLength=20.0;// microns (model grid spacing)
		double iiGridLength=12.0;// microns (image pixel resolution) N.B. Must be < iGridLength
		double jjGridLength=12.0;// microns (image pixel resolution) N.B. Must be < jGridLength

		//---IMPORTANT! Need to set m_nx=iiGridLength/iGridLength*numPixels_x---
		//---IMPORTANT! Need to set m_ny=jjGridLength/jGridLength*numPixels_y---
		//---IMPORTANT! Need to set m_nz=1---

//-----------------------------------------------

		//Pixellated grid overlain on computational grid, assuming origins coincide
		//These values represent x and y boundaries of the computational blocks, expressed in "pixel" co-ordinates
		double iiLeftBoundary=0.0;
		double iiRightBoundary=iGridLength/iiGridLength;
		double jjTopBoundary=0.0;
		double jjBottomBoundary=jGridLength/jjGridLength;

//-----------------------------------------------

		//These values represent the smallest and largest x and y values of pixels that overlap the current computational grid block
		int iiMin=1;
		int jjMin=1;

		int iiMax, jjMax;
		double tol=1.0e-6;	//tolerance prevents numerical issues when converting between double and integer values
		if ((ceil(iiRightBoundary)-iiRightBoundary)>(1.0-tol)) {iiMax=int(ceil(iiRightBoundary))-1;} else {iiMax=int(ceil(iiRightBoundary));}
		if ((ceil(jjBottomBoundary)-jjBottomBoundary)>(1.0-tol)) {jjMax=int(ceil(jjBottomBoundary))-1;} else {jjMax=int(ceil(jjBottomBoundary));}

//-----------------------------------------------

		//Areal fraction of bone found in each computational grid block by summing appropriate pixel segments
		double BoneFraction=0.0;

		//Visit every computational grid block
		for	(int j=1;j<=m_ny;j++)
		{	for	(int i=1;i<=m_nx;i++)
			{

//outfileDebugBone<<endl;
//outfileDebugBone<<i<<"\t"<<j<<"\t"<<iiMin<<"\t"<<iiMax<<"\t"<<jjMin<<"\t"<<jjMax<<"\t"<<iiLeftBoundary<<"\t"<<iiRightBoundary<<"\t"<<jjTopBoundary<<"\t"<<jjBottomBoundary<<endl;

//-----------------------------------------------

				//Visit every pixel grid block overlapping the current computational grid block
				for	(int jj=jjMin;jj<=jjMax;jj++)
				{	for	(int ii=iiMin;ii<=iiMax;ii++)
					{
						//If pixel contains bone, add the normalised overlap area
						if (nPixelValue[ii-1][jj-1][kk-1]==1)
						{
							if (ii==iiMin)
							{
								if (jj==jjMin)
								{
									BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"1: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}

								else if (jj==jjMax)
								{
									BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"2: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}

								else
								{
									BoneFraction+=((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"3: "<<((double(iiMin)-iiLeftBoundary)*iiGridLength*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}
							}

							else if (ii==iiMax)
							{
								if (jj==jjMin)
								{
									BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"4:	"<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}

								else if (jj==jjMax)
								{
									BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"5: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}

								else
								{
									BoneFraction+=((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"6: "<<((iiRightBoundary-double(iiMax)+1.0)*iiGridLength*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}
							}

							else
							{
								if (jj==jjMin)
								{
									BoneFraction+=(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"7: "<<(iiGridLength*(double(jjMin)-jjTopBoundary)*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}

								else if (jj==jjMax)
								{
									BoneFraction+=(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"8: "<<(iiGridLength*(jjBottomBoundary-double(jjMax)+1.0)*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}

								else
								{
									BoneFraction+=(iiGridLength*jjGridLength)/(iGridLength*jGridLength);
//outfileDebugBone<<"9: "<<(iiGridLength*jjGridLength)/(iGridLength*jGridLength)<<"\t";
								}
							}
						}	//end if bone tissue
				}}	//end i, j loops

//-----------------------------------------------

				//If computational grid block contains > 50% bone, fill with bone
				if	(i>2 && j>2 && i<m_nx-2 && j<m_ny-2)
				{
					if (BoneFraction>=0.5)	{bBoneTissue[i-1][j-1][k-1]=TRUE;}
				}

//-----------------------------------------------

				//If rhs of image not been reached, move to next grid block in pos. x-direction
				if (iiMax<numPixels_x)
				{
					if (double(iiMax)>iiRightBoundary)	{iiMin=iiMax;}	else {iiMin=iiMax+1;}

					iiLeftBoundary+=iGridLength/iiGridLength;
				
					iiRightBoundary+=iGridLength/iiGridLength;

					if ((ceil(iiRightBoundary)-iiRightBoundary)>(1.0-tol)) {iiMax=int(ceil(iiRightBoundary))-1;} else {iiMax=int(ceil(iiRightBoundary));}
				}

				//Otherwise, move to next grid block in pos. y-direction and return to lhs of image
				else 
				{
					if (double(jjMax)>jjBottomBoundary)	{jjMin=jjMax;}	else {jjMin=jjMax+1;}

					jjTopBoundary+=jGridLength/jjGridLength;
				
					jjBottomBoundary+=jGridLength/jjGridLength;

					if ((ceil(jjBottomBoundary)-jjBottomBoundary)>(1.0-tol)) {jjMax=int(ceil(jjBottomBoundary))-1;} else {jjMax=int(ceil(jjBottomBoundary));}

					iiLeftBoundary=0.0;

					iiRightBoundary=iGridLength/iiGridLength;
				
					iiMin=1;

					if ((ceil(iiRightBoundary)-iiRightBoundary)>(1.0-tol)) {iiMax=int(ceil(iiRightBoundary))-1;} else {iiMax=int(ceil(iiRightBoundary));}
				}

//-----------------------------------------------

				BoneFraction=0.0;

//outfileBoneTissue<<bBoneTissue[i-1][j-1][k-1]<<"\t";
//if (i==m_nx) {outfileBoneTissue<<endl;}

		}}	//end i, j loops
	}	//end if 2D

//-----------------------------------------------
//-----------------------------------------------

//Delete dummy array

	for (int jj=1;jj<=numPixels_y;jj++)
	{	for (int ii=1;ii<=numPixels_x;ii++)
		{
			delete[] nPixelValue[ii-1][jj-1];
		}
	}

	for (int ii=1;ii<=numPixels_x;ii++)
	{
		delete[] nPixelValue[ii-1];
	}

	delete[] nPixelValue;

//===============================================
*/
}
//*********************************************************

//================================
void CAngioNetDlg::GetProbs3(void)
//================================
{
//---Initialisation of probs to zero-------------

	m_chi=m_chi*D_TAF_Scaling;				//rescales for TAF diffusion coeff
	m_rho=m_rho*D_TAF_Scaling;				//rescales for TAF diffusion coeff
	m_diffCoeff=m_diffCoeff*D_TAF_Scaling;	//rescales for TAF diffusion coeff

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				probP0[i][j][k]=0.0;
				probP1[i][j][k]=0.0;
				probP2[i][j][k]=0.0;
				probP3[i][j][k]=0.0;
				probP4[i][j][k]=0.0;
				probP5[i][j][k]=0.0;
				probP6[i][j][k]=0.0;
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=0.0;
				R1inf[i][j][k]=0.0;
				R1sup[i][j][k]=0.0;
				R2inf[i][j][k]=0.0;
				R2sup[i][j][k]=0.0;
				R3inf[i][j][k]=0.0;
				R3sup[i][j][k]=0.0;
				R4inf[i][j][k]=0.0;
				R4sup[i][j][k]=0.0;
				R5inf[i][j][k]=0.0;
				R5sup[i][j][k]=0.0;
				R6inf[i][j][k]=0.0;
				R6sup[i][j][k]=0.0;			
	}}}
//-----------------------------------------------
//-----------------------------------------------
    
//---Calculation of probs for each sprout--------

	 angioDeltaZ=angioDeltaX;

	//---switch 2D/3D---
	  int coeffZ;
	  if (m_nz==1) {coeffZ=0;} else {coeffZ=1;}
	//------------------
	//------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				if	(vSproutsTips[i][j][k]==1)
				{
					double dTAF_dx, dTAF_dy, dTAF_dz, d2TAF_dx2, d2TAF_dy2, d2TAF_dz2;	//1st & 2nd spatial
					double dFib_dx, dFib_dy, dFib_dz, d2Fib_dx2, d2Fib_dy2, d2Fib_dz2;	//derivatives of TAF, Fibronectin

					dTAF_dx=dTAF_dy=dTAF_dz=d2TAF_dx2=d2TAF_dy2=d2TAF_dz2=0.0;
					dFib_dx=dFib_dy=dFib_dz=d2Fib_dx2=d2Fib_dy2=d2Fib_dz2=0.0;

					//---x derivatives-----------
					if	(i==0)
					{
						if	(bBoneTissue[i+1][j][k]==TRUE)	//TAF, FN not defined at LH and RH nodes
						{
							dTAF_dx=d2TAF_dx2=dFib_dx=d2Fib_dx2=0.0;
						}

						else	//TAF, FN not defined at LH node
						{
							dTAF_dx=(vTAFConc[i+1][j][k]-vTAFConc[i][j][k])/angioDeltaX;
							d2TAF_dx2=(vTAFConc[i+1][j][k]-vTAFConc[i][j][k])/angioDeltaX/angioDeltaX;
							dFib_dx=(vFibronectinConc[i+1][j][k]-vFibronectinConc[i][j][k])/angioDeltaX;
							d2Fib_dx2=(vFibronectinConc[i+1][j][k]-vFibronectinConc[i][j][k])/angioDeltaX/angioDeltaX;
						}
					}

					else if	(i==m_nx)
					{
						if	(bBoneTissue[i-1][j][k]==TRUE)	//TAF, FN not defined at LH and RH nodes
						{
							dTAF_dx=d2TAF_dx2=dFib_dx=d2Fib_dx2=0.0;
						}

						else	//TAF, FN not defined at RH node
						{
							dTAF_dx=(vTAFConc[i][j][k]-vTAFConc[i-1][j][k])/angioDeltaX;
							d2TAF_dx2=(vTAFConc[i-1][j][k]-vTAFConc[i][j][k])/angioDeltaX/angioDeltaX;
							dFib_dx=(vFibronectinConc[i][j][k]-vFibronectinConc[i-1][j][k])/angioDeltaX;
							d2Fib_dx2=(vFibronectinConc[i-1][j][k]-vFibronectinConc[i][j][k])/angioDeltaX/angioDeltaX;
						}
					}

					else
					{
						if	(bBoneTissue[i+1][j][k]==TRUE && bBoneTissue[i-1][j][k]==TRUE)	//TAF, FN not defined at LH and RH nodes
						{
							dTAF_dx=d2TAF_dx2=dFib_dx=d2Fib_dx2=0.0;
						}

						else if	(bBoneTissue[i-1][j][k]==TRUE)	//TAF, FN not defined at LH node
						{
							dTAF_dx=(vTAFConc[i+1][j][k]-vTAFConc[i][j][k])/angioDeltaX;
							d2TAF_dx2=(vTAFConc[i+1][j][k]-vTAFConc[i][j][k])/angioDeltaX/angioDeltaX;
							dFib_dx=(vFibronectinConc[i+1][j][k]-vFibronectinConc[i][j][k])/angioDeltaX;
							d2Fib_dx2=(vFibronectinConc[i+1][j][k]-vFibronectinConc[i][j][k])/angioDeltaX/angioDeltaX;
						}

						else if	(bBoneTissue[i+1][j][k]==TRUE)	//TAF, FN not defined at RH node
						{
							dTAF_dx=(vTAFConc[i][j][k]-vTAFConc[i-1][j][k])/angioDeltaX;
							d2TAF_dx2=(vTAFConc[i-1][j][k]-vTAFConc[i][j][k])/angioDeltaX/angioDeltaX;
							dFib_dx=(vFibronectinConc[i][j][k]-vFibronectinConc[i-1][j][k])/angioDeltaX;
							d2Fib_dx2=(vFibronectinConc[i-1][j][k]-vFibronectinConc[i][j][k])/angioDeltaX/angioDeltaX;
						}

						else	//TAF, Fibronectin defined at LH and RH nodes
						{
							dTAF_dx=(vTAFConc[i+1][j][k]-vTAFConc[i-1][j][k])/angioDeltaX/2.0;
							d2TAF_dx2=(vTAFConc[i+1][j][k]-2.0*vTAFConc[i][j][k]+vTAFConc[i-1][j][k])/angioDeltaX/angioDeltaX;
							dFib_dx=(vFibronectinConc[i+1][j][k]-vFibronectinConc[i-1][j][k])/angioDeltaX/2.0;
							d2Fib_dx2=(vFibronectinConc[i+1][j][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i-1][j][k])/angioDeltaX/angioDeltaX;
						}
					}

					//---y derivatives-----------
					if	(j==0)
					{
						if	(bBoneTissue[i][j+1][k]==TRUE)	//TAF, FN not defined at upper and lower nodes
						{
							dTAF_dy=d2TAF_dy2=dFib_dy=d2Fib_dy2=0.0;
						}

						else	//TAF, FN not defined at upper node
						{
							dTAF_dy=(vTAFConc[i][j+1][k]-vTAFConc[i][j][k])/angioDeltaY;
							d2TAF_dy2=(vTAFConc[i][j+1][k]-vTAFConc[i][j][k])/angioDeltaY/angioDeltaY;
							dFib_dy=(vFibronectinConc[i][j+1][k]-vFibronectinConc[i][j][k])/angioDeltaY;
							d2Fib_dy2=(vFibronectinConc[i][j+1][k]-vFibronectinConc[i][j][k])/angioDeltaY/angioDeltaY;
						}
					}

					else if	(j==m_ny-1)
					{
						if	(bBoneTissue[i][j-1][k]==TRUE)	//TAF, FN not defined at upper and lower nodes
						{
							dTAF_dy=d2TAF_dy2=dFib_dy=d2Fib_dy2=0.0;
						}

						else	//TAF, FN not defined at lower node
						{
							dTAF_dy=(vTAFConc[i][j][k]-vTAFConc[i][j-1][k])/angioDeltaY;
							d2TAF_dy2=(vTAFConc[i][j-1][k]-vTAFConc[i][j][k])/angioDeltaY/angioDeltaY;
							dFib_dy=(vFibronectinConc[i][j][k]-vFibronectinConc[i][j-1][k])/angioDeltaY;
							d2Fib_dy2=(vFibronectinConc[i][j-1][k]-vFibronectinConc[i][j][k])/angioDeltaY/angioDeltaY;
						}
					}

					else
					{
						if	(bBoneTissue[i][j+1][k]==TRUE && bBoneTissue[i][j-1][k]==TRUE)	//TAF, FN not defined at upper and lower nodes
						{
							dTAF_dy=d2TAF_dy2=dFib_dy=d2Fib_dy2=0.0;
						}

						else if	(bBoneTissue[i][j-1][k]==TRUE)	//TAF, FN not defined at upper node
						{
							dTAF_dy=(vTAFConc[i][j+1][k]-vTAFConc[i][j][k])/angioDeltaY;
							d2TAF_dy2=(vTAFConc[i][j+1][k]-vTAFConc[i][j][k])/angioDeltaY/angioDeltaY;
							dFib_dy=(vFibronectinConc[i][j+1][k]-vFibronectinConc[i][j][k])/angioDeltaY;
							d2Fib_dy2=(vFibronectinConc[i][j+1][k]-vFibronectinConc[i][j][k])/angioDeltaY/angioDeltaY;
						}

						else if	(bBoneTissue[i][j+1][k]==TRUE)	//TAF, FN not defined at lower node
						{
							dTAF_dy=(vTAFConc[i][j][k]-vTAFConc[i][j-1][k])/angioDeltaY;
							d2TAF_dy2=(vTAFConc[i][j-1][k]-vTAFConc[i][j][k])/angioDeltaY/angioDeltaY;
							dFib_dy=(vFibronectinConc[i][j][k]-vFibronectinConc[i][j-1][k])/angioDeltaY;
							d2Fib_dy2=(vFibronectinConc[i][j-1][k]-vFibronectinConc[i][j][k])/angioDeltaY/angioDeltaY;
						}

						else	//TAF, Fibronectin defined at upper and lower nodes
						{
							dTAF_dy=(vTAFConc[i][j+1][k]-vTAFConc[i][j-1][k])/angioDeltaY/2.0;
							d2TAF_dy2=(vTAFConc[i][j+1][k]-2.0*vTAFConc[i][j][k]+vTAFConc[i][j-1][k])/angioDeltaY/angioDeltaY;
							dFib_dy=(vFibronectinConc[i][j+1][k]-vFibronectinConc[i][j-1][k])/angioDeltaY/2.0;
							d2Fib_dy2=(vFibronectinConc[i][j+1][k]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][j-1][k])/angioDeltaY/angioDeltaY;
						}
					}

					if	(m_nz>1)
					{
						//---z derivatives-------
						if	(k==0)
						{
							if	(bBoneTissue[i][j][k+1]==TRUE)	//TAF, FN not defined at front and back nodes
							{
								dTAF_dz=d2TAF_dz2=dFib_dz=d2Fib_dz2=0.0;
							}

							else	//TAF, FN not defined at back node
							{
								dTAF_dz=(vTAFConc[i][j][k+1]-vTAFConc[i][j][k])/angioDeltaZ;
								d2TAF_dz2=(vTAFConc[i][j][k+1]-vTAFConc[i][j][k])/angioDeltaZ/angioDeltaZ;
								dFib_dz=(vFibronectinConc[i][j][k+1]-vFibronectinConc[i][j][k])/angioDeltaZ;
								d2Fib_dz2=(vFibronectinConc[i][j][k+1]-vFibronectinConc[i][j][k])/angioDeltaZ/angioDeltaZ;
							}
						}

						else if	(k==m_nz-1)
						{
							if	(bBoneTissue[i][j][k-1]==TRUE)	//TAF, FN not defined at front and back nodes
							{
								dTAF_dz=d2TAF_dz2=dFib_dz=d2Fib_dz2=0.0;
							}

							else	//TAF, FN not defined at front node
							{
								dTAF_dz=(vTAFConc[i][j][k]-vTAFConc[i][j][k-1])/angioDeltaZ;
								d2TAF_dz2=(vTAFConc[i][j][k-1]-vTAFConc[i][j][k])/angioDeltaZ/angioDeltaZ;
								dFib_dz=(vFibronectinConc[i][j][k]-vFibronectinConc[i][j][k-1])/angioDeltaZ;
								d2Fib_dz2=(vFibronectinConc[i][j][k-1]-vFibronectinConc[i][j][k])/angioDeltaZ/angioDeltaZ;
							}
						}

						else
						{
							if	(bBoneTissue[i][j][k+1]==TRUE && bBoneTissue[i][j][k-1]==TRUE)	//TAF, FN not defined at front and back nodes
							{
								dTAF_dz=d2TAF_dz2=dFib_dz=d2Fib_dz2=0.0;
							}

							else if	(bBoneTissue[i][j][k-1]==TRUE)	//TAF, FN not defined at back node
							{
								dTAF_dz=(vTAFConc[i][j][k+1]-vTAFConc[i][j][k])/angioDeltaZ;
								d2TAF_dz2=(vTAFConc[i][j][k+1]-vTAFConc[i][j][k])/angioDeltaZ/angioDeltaZ;
								dFib_dz=(vFibronectinConc[i][j][k+1]-vFibronectinConc[i][j][k])/angioDeltaZ;
								d2Fib_dz2=(vFibronectinConc[i][j][k+1]-vFibronectinConc[i][j][k])/angioDeltaZ/angioDeltaZ;
							}

							else if	(bBoneTissue[i][j][k+1]==TRUE)	//TAF, FN not defined at front node
							{
								dTAF_dz=(vTAFConc[i][j][k]-vTAFConc[i][j][k-1])/angioDeltaZ;
								d2TAF_dz2=(vTAFConc[i][j][k-1]-vTAFConc[i][j][k])/angioDeltaZ/angioDeltaZ;
								dFib_dz=(vFibronectinConc[i][j][k]-vFibronectinConc[i][j][k-1])/angioDeltaZ;
								d2Fib_dz2=(vFibronectinConc[i][j][k-1]-vFibronectinConc[i][j][k])/angioDeltaZ/angioDeltaZ;
							}

							else	//TAF, Fibronectin defined at front and back nodes
							{
								dTAF_dz=(vTAFConc[i][j][k+1]-vTAFConc[i][j][k-1])/angioDeltaZ/2.0;
								d2TAF_dz2=(vTAFConc[i][j][k+1]-2.0*vTAFConc[i][j][k]+vTAFConc[i][j][k-1])/angioDeltaZ/angioDeltaZ;
								dFib_dz=(vFibronectinConc[i][j][k+1]-vFibronectinConc[i][j][k-1])/angioDeltaZ/2.0;
								d2Fib_dz2=(vFibronectinConc[i][j][k+1]-2.0*vFibronectinConc[i][j][k]+vFibronectinConc[i][j][k-1])/angioDeltaZ/angioDeltaZ;
							}
						}	
					}//end if m_nz>1

					//---P0 = Probability to remain stationary (i,j,k)---

					probP0[i][j][k]=
	
						1.0-angioDeltaT*(
												2.0*m_diffCoeff*( (1.0/angioDeltaX/angioDeltaX)+(1.0/angioDeltaY/angioDeltaY)+(1.0/angioDeltaZ/angioDeltaZ*coeffZ) )
											-	( (m_chi*m_alpha)/pow((1.0+m_alpha*vTAFConc[i][j][k]),2.0) )*( (dTAF_dx*dTAF_dx)+(dTAF_dy*dTAF_dy)+(dTAF_dz*dTAF_dz*coeffZ) )
											+	( m_chi/(1.0+m_alpha*vTAFConc[i][j][k]) )*( d2TAF_dx2+d2TAF_dy2+(d2TAF_dz2*coeffZ) )
											+	m_rho*( d2Fib_dx2+d2Fib_dy2+(d2Fib_dz2*coeffZ) )
										);

					//---------------------------------------------------
					//---------------------------------------------------

					//---P1 = Probability to move right (i+1,j,k)---

					if (i==m_nx || i==m_nx-1)  {probP1[i][j][k]= 0.0;}

					else if	(
								pFluid[LabX(i+1+1,j+1,k+1)-1]==66	//can't grow onto pFluid=66 bonds in hex network (Mike 09/09)
								||
                                bBoneTissue[i+1][j][k]==TRUE		//can't grow into bone tissue (Mike 01/13)
							)	
								
							{probP1[i][j][k]=0.0;}	

					else	{																	
								probP1[i][j][k]=
								
									angioDeltaT*(
														m_diffCoeff/angioDeltaX/angioDeltaX
													+	1.0/2.0/angioDeltaX*( ((m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*dTAF_dx)+(m_rho*dFib_dx) )
												);
							}

					//----------------------------------------------
					//----------------------------------------------

					//---P2 = Probability to move left (i-1,j,k)---

					if (i==0)    {probP2[i][j][k]= 0.0;}

					else if	(
								pFluid[LabX(i+1,j+1,k+1)-1]==66	//can't grow onto pFluid=66 bonds in hex network (Mike 09/09)
								||
								bBoneTissue[i-1][j][k]==TRUE	//can't grow into bone tissue (Mike 01/13)
							)
								
							{probP2[i][j][k]=0.0;}

					else	{
								probP2[i][j][k]=
								
									angioDeltaT*(
														m_diffCoeff/angioDeltaX/angioDeltaX
													-	1.0/2.0/angioDeltaX*( ((m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*dTAF_dx)+(m_rho*dFib_dx) )
												);
							}

					//---------------------------------------------
					//---------------------------------------------

					//---P3 = Probability to move down (i,j+1,k)---

					if (j==m_ny-1) {probP3[i][j][k]=0.0;}

					else if	(
								pFluid[LabY(i+1,j+1+1,k+1)-1]==66	//can't grow onto pFluid=66 bonds in hex network (Mike 09/09)
								||
								bBoneTissue[i][j+1][k]==TRUE		//can't grow into bone tissue (Mike 01/13)
							)
							
							{probP3[i][j][k]=0.0;}	
																			
					else	{
								probP3[i][j][k]=
								
									angioDeltaT*(
														m_diffCoeff/angioDeltaY/angioDeltaY
													+	1.0/2.0/angioDeltaY*( ((m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*dTAF_dy)+(m_rho*dFib_dy) )
												);

							}

					//---------------------------------------------
					//---------------------------------------------

					//---P4 = Probability to move up (i,j-1,k)---

//					probP4[i][j][k]=0.0;

//					if	(b_venousIncluded || b_UU_wound_Model) //let upward migration if venule present or if central wound with lower PVs
//					{									
						if (j==0)    {probP4[i][j][k]=0.0;}

						else if	(
									pFluid[LabY(i+1,j+1,k+1)-1]==66	//can't grow onto pFluid=66 bonds in hex network (Mike 09/09)
									||
									bBoneTissue[i][j-1][k]==TRUE	//can't grow into bone tissue (Mike 01/13)
								)
						
								{probP4[i][j][k]=0.0;}	
																				
						else	{
									probP4[i][j][k]=
								
									angioDeltaT*(
														m_diffCoeff/angioDeltaY/angioDeltaY
													-	1.0/2.0/angioDeltaY*( ((m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*dTAF_dy)+(m_rho*dFib_dy) )
												);

								}
//					}
					//-------------------------------------------
					//-------------------------------------------
		
					//---P5 = Probability to move forwards (i,j,k+1)---

					if (k==m_nz-1 || coeffZ==0) {probP5[i][j][k]=0.0;}

					else if	(
								pFluid[LabZ(i+1,j+1,k+1+1)-1]==66	//can't grow onto pFluid=66 bonds in hex network (Mike 09/09)
								||
								bBoneTissue[i][j][k+1]==TRUE		//can't grow into bone tissue (Mike 01/13)
							)
					
							{probP5[i][j][k]=0.0;}	
																			
					else	{
								probP5[i][j][k]=
								
									angioDeltaT*(
														m_diffCoeff/angioDeltaZ/angioDeltaZ
													+	1.0/2.0/angioDeltaZ*( ((m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*dTAF_dz)+(m_rho*dFib_dz) )
												);

							}

					//-------------------------------------------------
					//-------------------------------------------------

					//---P6 = Probability to move backwards (i,j,k-1)---
	
					if (k==0 || coeffZ==0)    {probP6[i][j][k]=0.0;}

					else if	(
								pFluid[LabZ(i+1,j+1,k+1)-1]==66		//can't grow onto pFluid=66 bonds in hex network (Mike 09/09)
								||
								bBoneTissue[i][j][k-1]==TRUE		//can't grow into bone tissue (Mike 01/13)
							)
					
							{probP6[i][j][k]=0.0;}

					else	{
								probP6[i][j][k]=
								
									angioDeltaT*(
														m_diffCoeff/angioDeltaZ/angioDeltaZ
													-	1.0/2.0/angioDeltaZ*( ((m_chi/(1.0+m_alpha*vTAFConc[i][j][k]))*dTAF_dz)+(m_rho*dFib_dz) )
												);

							}
					//--------------------------------------------------
					//--------------------------------------------------
//outfileDebugBone << i << "\t" << j << endl;
//outfileDebugBone << vTAFConc[i][j][k] << "\t" << vTAFConc[i-1][j][k] << "\t" << vTAFConc[i+1][j][k] << "\t" << vTAFConc[i][j-1][k] << "\t" << vTAFConc[i][j+1][k] << endl;
//outfileDebugBone << vFibronectinConc[i][j][k] << "\t" << vFibronectinConc[i-1][j][k] << "\t" << vFibronectinConc[i+1][j][k] << "\t" << vFibronectinConc[i][j-1][k] << "\t" << vFibronectinConc[i][j+1][k] << endl;
//outfileDebugBone << dTAF_dx << "\t" << d2TAF_dx2 << "\t" << dTAF_dy << "\t" << d2TAF_dy2 << endl;
//outfileDebugBone << dFib_dx << "\t" << d2Fib_dx2 << "\t" << dFib_dy << "\t" << d2Fib_dy2 << endl;
//outfileDebugBone << probP0[i][j][k] << "\t" << probP1[i][j][k] << "\t" << probP2[i][j][k] << "\t" << probP3[i][j][k] << "\t" << probP4[i][j][k] << endl;
//outfileDebugBone << endl;
				}	//end vSproutTips
	}}}
//-----------------------------------------------
//-----------------------------------------------

//---Negative probs set to zero------------------
//---Contribution added to opposite direction----

	double add1,add2,add3,add4,add5,add6;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				add1=0.0;
				add2=0.0;
				add3=0.0;
				add4=0.0;
				add5=0.0;
				add6=0.0;

				if (probP0[i][j][k]<0.0)	{probP0[i][j][k]=0.0;}
				if (probP1[i][j][k]<0.0)	{add1=fabs(probP1[i][j][k]);	probP1[i][j][k]=0.0;}
				if (probP2[i][j][k]<0.0)	{add2=fabs(probP2[i][j][k]);	probP2[i][j][k]=0.0;}
				if (probP3[i][j][k]<0.0)	{add3=fabs(probP3[i][j][k]);	probP3[i][j][k]=0.0;}
				if (probP4[i][j][k]<0.0)	{add4=fabs(probP4[i][j][k]);	probP4[i][j][k]=0.0;}
				if (probP5[i][j][k]<0.0)	{add5=fabs(probP5[i][j][k]);	probP5[i][j][k]=0.0;}
				if (probP6[i][j][k]<0.0)	{add6=fabs(probP6[i][j][k]);	probP6[i][j][k]=0.0;}

				if (i<m_nx-1)	//---Previous zero probs must remain zero---
				{
					if	(
							pFluid[LabX(i+1+1,j+1,k+1)-1]!=66
							&&
							bBoneTissue[i+1][j][k]==FALSE
						)	
				
						{probP1[i][j][k]=probP1[i][j][k]+add2;}
				}

				if (i>0)	//---Previous zero probs must remain zero---
				{
					if	(
							pFluid[LabX(i+1,j+1,k+1)-1]!=66
							&&
							bBoneTissue[i-1][j][k]==FALSE
						)
				
						{probP2[i][j][k]=probP2[i][j][k]+add1;}
				}

				if (j<m_ny-1)	//---Previous zero probs must remain zero---
				{
					if	(
							pFluid[LabY(i+1,j+1+1,k+1)-1]!=66
							&&
							bBoneTissue[i][j+1][k]==FALSE
						)	
				
						{probP3[i][j][k]=probP3[i][j][k]+add4;}
				}

				if (j>0)	//---Previous zero probs must remain zero---
				{
					if	(
							pFluid[LabY(i+1,j+1,k+1)-1]!=66
							&&
							bBoneTissue[i][j-1][k]==FALSE
						)
				
						{probP4[i][j][k]=probP4[i][j][k]+add3;}
				}

//-----------------------------------------------

				if	(m_nz>1)
				{
					if	(k<m_nz-1)	//---Previous zero probs must remain zero---
					{
						if	(
								pFluid[LabZ(i+1,j+1,k+1+1)-1]!=66
								&&
								bBoneTissue[i][j][k+1]==FALSE
							)
							
							{probP5[i][j][k]=probP5[i][j][k]+add6;}
					}

					if (k>0)	//---Previous zero probs must remain zero---
					{
						if	(
								pFluid[LabZ(i+1,j+1,k+1)-1]!=66
								&&
								bBoneTissue[i][j][k-1]==FALSE
							)
				
							{probP6[i][j][k]=probP6[i][j][k]+add5;}
					}
				}
//if (i==4 && j==81) {outfileDebugBone << probP0[i][j][k] << "\t" << probP1[i][j][k] << "\t" << probP2[i][j][k] << "\t" << probP3[i][j][k] << "\t" << probP4[i][j][k] << endl;}
//-----------------------------------------------				
/*				//---All previous zero probs must remain zero---
				if	(i!=0 && i!=m_nx-1 && i!=m_nx && j!=0 && j!=m_ny-1)
				{outfileDebugBone<<i<<"\t"<<j<<endl;
					if	(
							pFluid[LabX(i+1+1,j+1,k+1)-1]!=66
							&&
							bBoneTissue[i+1][j][k]==FALSE
						)	
				
						{probP1[i][j][k]=probP1[i][j][k]+add2;}

					if	(
							pFluid[LabX(i+1,j+1,k+1)-1]!=66
							&&
							bBoneTissue[i-1][j][k]==FALSE
						)
				
						{probP2[i][j][k]=probP2[i][j][k]+add1;}

					if	(
							pFluid[LabY(i+1,j+1+1,k+1)-1]!=66
							&&
							bBoneTissue[i][j+1][k]==FALSE
						)	
				
						{probP3[i][j][k]=probP3[i][j][k]+add4;}

					if	(
							pFluid[LabY(i+1,j+1,k+1)-1]!=66
							&&
							bBoneTissue[i][j-1][k]==FALSE
						)
				
						{probP4[i][j][k]=probP4[i][j][k]+add3;}
				}

//-----------------------------------------------

				if	(m_nz>1)
				{
					if	(k!=0 && k!=m_nz-1)
					{
						if	(
								pFluid[LabZ(i+1,j+1,k+1+1)-1]!=66
								&&
								bBoneTissue[i][j][k+1]==FALSE
							)
							
							{probP5[i][j][k]=probP5[i][j][k]+add6;}

						if	(
								pFluid[LabZ(i+1,j+1,k+1)-1]!=66
								&&
								bBoneTissue[i][j][k-1]==FALSE
							)
				
							{probP6[i][j][k]=probP6[i][j][k]+add5;}
					}
				}
*/
	}}}
//-----------------------------------------------
//-----------------------------------------------

//---Prob sprout grows on itself is null---------

	for (int k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true)			{probP2[i-1][j-1][k-1]=0.0;}
				if (pSprout[nby-1]==1 && poleSprout[nby-1]==true)			{probP4[i-1][j-1][k-1]=0.0;}
				if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true)			{probP6[i-1][j-1][k-1]=0.0;}
				if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1)	{probP1[i-2][j-1][k-1]=0.0;}
				if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1)	{probP3[i-1][j-2][k-1]=0.0;}
				if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1)	{probP5[i-1][j-1][k-2]=0.0;}

//if (i==5 && j==82) {outfileDebugBone << probP0[i-1][j-1][k-1] << "\t" << probP1[i-1][j-1][k-1] << "\t" << probP2[i-1][j-1][k-1] << "\t" << probP3[i-1][j-1][k-1] << "\t" << probP4[i-1][j-1][k-1] << endl;}
			}

			int i=m_nx+1;
			int nbx=LabX(i,j,k);

			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true)	{probP2[i-1][j-1][k-1]=0.0;}
			if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false)	{probP1[i-2][j-1][k-1]=0.0;}
	}}
//-----------------------------------------------
//-----------------------------------------------



//---Normalisation of probs----------------------
//outfileDebugBone << angiotime << endl;
	double probTot;

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				probTot=0.0;
				probTot=fabs(probP0[i][j][k])
					    +fabs(probP1[i][j][k])+fabs(probP2[i][j][k])
						+fabs(probP3[i][j][k])+fabs(probP4[i][j][k])
				        +fabs(probP5[i][j][k])+fabs(probP6[i][j][k]);  

				if (probTot!=0.0)
				{
					probP0[i][j][k]=fabs(probP0[i][j][k])/probTot;
					probP1[i][j][k]=fabs(probP1[i][j][k])/probTot;
					probP2[i][j][k]=fabs(probP2[i][j][k])/probTot;
					probP3[i][j][k]=fabs(probP3[i][j][k])/probTot;
					probP4[i][j][k]=fabs(probP4[i][j][k])/probTot;
					probP5[i][j][k]=fabs(probP5[i][j][k])/probTot;
					probP6[i][j][k]=fabs(probP6[i][j][k])/probTot;
				}

				else	//Added by Mike 09/13 for bone modelling - cases can arise where ALL
				{		//probs are zero (set P0=1 to prevent numerical error OR kill sprout)
					if (vSproutsTips[i][j][k]==1)
					{
						//probP0[i][j][k]=1.0;

//-----------------------------------------------

						if (pSprout[LabX(i+1,j+1,k+1)-1]==1)
						{
							pSprout[LabX(i+1,j+1,k+1)-1]=0;
							pAgeOfSprout[LabX(i+1,j+1,k+1)-1]=0.0;
						}

						if (i!=m_nx)
						{
							if (pSprout[LabY(i+1,j+1,k+1)-1]==1)
							{
								pSprout[LabY(i+1,j+1,k+1)-1]=0;
								pAgeOfSprout[LabY(i+1,j+1,k+1)-1]=0.0;
							}

							if (pSprout[LabZ(i+1,j+1,k+1)-1]==1)
							{
								pSprout[LabZ(i+1,j+1,k+1)-1]=0;
								pAgeOfSprout[LabZ(i+1,j+1,k+1)-1]=0.0;
							}
						}

						vSproutsTips[i][j][k]=0;
					}
				}

if	(vSproutsTips[i][j][k]==1)
{
//	outfileDebugBone << i << "\t" << j << endl;
	//outfileDebugBone << vTAFConc[i][j][k] << "\t" << vTAFConc[i-1][j][k] << "\t" << vTAFConc[i+1][j][k] << "\t" << vTAFConc[i][j-1][k] << "\t" << vTAFConc[i][j+1][k] << endl;
	//outfileDebugBone << vFibronectinConc[i][j][k] << "\t" << vFibronectinConc[i-1][j][k] << "\t" << vFibronectinConc[i+1][j][k] << "\t" << vFibronectinConc[i][j-1][k] << "\t" << vFibronectinConc[i][j+1][k] << endl;
	//outfileDebugBone << dTAF_dx << "\t" << d2TAF_dx2 << "\t" << dTAF_dy << "\t" << d2TAF_dy2 << endl;
	//outfileDebugBone << dFib_dx << "\t" << d2Fib_dx2 << "\t" << dFib_dy << "\t" << d2Fib_dy2 << endl;
//	outfileDebugBone << probP0[i][j][k] << "\t" << probP1[i][j][k] << "\t" << probP2[i][j][k] << "\t" << probP3[i][j][k] << "\t" << probP4[i][j][k] << endl;
//	outfileDebugBone << endl;
}
	}}}
//-----------------------------------------------
//-----------------------------------------------


//---DEBUGGING-----------------------------------
/*	outfileProb << angiotime << endl;

	for (k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
				{
					outfileProb << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
					outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
					outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
					outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
					outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
					outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
					outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
					outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
				}

				if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1) 
				{
					outfileProb << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
					outfileProb << "P0" << "\t" << probP0[i-2][j-1][k-1] << endl;
					outfileProb << "P1" << "\t" << probP1[i-2][j-1][k-1] << endl;
					outfileProb << "P2" << "\t" << probP2[i-2][j-1][k-1] << endl;
					outfileProb << "P3" << "\t" << probP3[i-2][j-1][k-1] << endl;
					outfileProb << "P4" << "\t" << probP4[i-2][j-1][k-1] << endl;
					outfileProb << "P5" << "\t" << probP5[i-2][j-1][k-1] << endl;
					outfileProb << "P6" << "\t" << probP6[i-2][j-1][k-1] << endl;
				}

				if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
				{
					outfileProb << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
					outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
					outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
					outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
					outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
					outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
					outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
					outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
				}

				if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1) 
				{
					outfileProb << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
					outfileProb << "P0" << "\t" << probP0[i-1][j-2][k-1] << endl;
					outfileProb << "P1" << "\t" << probP1[i-1][j-2][k-1] << endl;
					outfileProb << "P2" << "\t" << probP2[i-1][j-2][k-1] << endl;
					outfileProb << "P3" << "\t" << probP3[i-1][j-2][k-1] << endl;
					outfileProb << "P4" << "\t" << probP4[i-1][j-2][k-1] << endl;
					outfileProb << "P5" << "\t" << probP5[i-1][j-2][k-1] << endl;
					outfileProb << "P6" << "\t" << probP6[i-1][j-2][k-1] << endl;
				}

				if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) 
				{
					outfileProb << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
					outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-1] << endl;
					outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-1] << endl;
					outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-1] << endl;
					outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-1] << endl;
					outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-1] << endl;
					outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-1] << endl;
					outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-1] << endl;
				}

				if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1) 
				{
					outfileProb << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
					outfileProb << "P0" << "\t" << probP0[i-1][j-1][k-2] << endl;
					outfileProb << "P1" << "\t" << probP1[i-1][j-1][k-2] << endl;
					outfileProb << "P2" << "\t" << probP2[i-1][j-1][k-2] << endl;
					outfileProb << "P3" << "\t" << probP3[i-1][j-1][k-2] << endl;
					outfileProb << "P4" << "\t" << probP4[i-1][j-1][k-2] << endl;
					outfileProb << "P5" << "\t" << probP5[i-1][j-1][k-2] << endl;
					outfileProb << "P6" << "\t" << probP6[i-1][j-1][k-2] << endl;
				}
	}}}

	outfileProb << endl;
*/
//-----------------------------------------------
//-----------------------------------------------

	
//---Calculation of prob ranges------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{	
				R0inf[i][j][k]=0.0;
				R0sup[i][j][k]=probP0[i][j][k];
				R1inf[i][j][k]=R0sup[i][j][k];
				R1sup[i][j][k]=R0sup[i][j][k]+probP1[i][j][k];
				R2inf[i][j][k]=R1sup[i][j][k];
				R2sup[i][j][k]=R1sup[i][j][k]+probP2[i][j][k];
				R3inf[i][j][k]=R2sup[i][j][k];
				R3sup[i][j][k]=R2sup[i][j][k]+probP3[i][j][k];
				R4inf[i][j][k]=R3sup[i][j][k];
				R4sup[i][j][k]=R3sup[i][j][k]+probP4[i][j][k];
				R5inf[i][j][k]=R4sup[i][j][k];
				R5sup[i][j][k]=R4sup[i][j][k]+probP5[i][j][k];
				R6inf[i][j][k]=R5sup[i][j][k];
				R6sup[i][j][k]=R5sup[i][j][k]+probP6[i][j][k];
	}}}
//-----------------------------------------------
//-----------------------------------------------

//---DEBUGGING-----------------------------------
/*	outfileGrowth << angiotime << endl;

	for (k=1;k<=m_nz;k++) 
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{
				int nbx=LabX(i,j,k);
				int nby=LabY(i,j,k);
				int nbz=LabZ(i,j,k);

				if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==true) 
				{
					outfileGrowth << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
					outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;	
					outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
				}

				if (pSprout[nbx-1]==1 && poleSprout[nbx-1]==false && i>1) 
				{
					outfileGrowth << "x-bond" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;
					outfileGrowth << "R0" << "\t" << R0inf[i-2][j-1][k-1] << "\t" << R0sup[i-2][j-1][k-1] <<endl;
					outfileGrowth << "R1" << "\t" << R1inf[i-2][j-1][k-1] << "\t" << R1sup[i-2][j-1][k-1] <<endl;	
					outfileGrowth << "R2" << "\t" << R2inf[i-2][j-1][k-1] << "\t" << R2sup[i-2][j-1][k-1] <<endl;
					outfileGrowth << "R3" << "\t" << R3inf[i-2][j-1][k-1] << "\t" << R3sup[i-2][j-1][k-1] <<endl;
					outfileGrowth << "R4" << "\t" << R4inf[i-2][j-1][k-1] << "\t" << R4sup[i-2][j-1][k-1] <<endl;
				}

				if (pSprout[nby-1]==1 && poleSprout[nby-1]==true) 
				{
					outfileGrowth << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
					outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
				}

				if (pSprout[nby-1]==1 && poleSprout[nby-1]==false && j>1) 
				{
					outfileGrowth << "y-bond" << "\t" << poleSprout[nby-1] << "\t" << i << "\t" << j << endl;
					outfileGrowth << "R0" << "\t" << R0inf[i-1][j-2][k-1] << "\t" << R0sup[i-1][j-2][k-1] <<endl;
					outfileGrowth << "R1" << "\t" << R1inf[i-1][j-2][k-1] << "\t" << R1sup[i-1][j-2][k-1] <<endl;
					outfileGrowth << "R2" << "\t" << R2inf[i-1][j-2][k-1] << "\t" << R2sup[i-1][j-2][k-1] <<endl;
					outfileGrowth << "R3" << "\t" << R3inf[i-1][j-2][k-1] << "\t" << R3sup[i-1][j-2][k-1] <<endl;
					outfileGrowth << "R4" << "\t" << R4inf[i-1][j-2][k-1] << "\t" << R4sup[i-1][j-2][k-1] <<endl;
				}

				if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==true) 
				{
					outfileGrowth << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
					outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-1] << "\t" << R0sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-1] << "\t" << R1sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-1] << "\t" << R2sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-1] << "\t" << R3sup[i-1][j-1][k-1] <<endl;
					outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-1] << "\t" << R4sup[i-1][j-1][k-1] <<endl;
				}

				if (pSprout[nbz-1]==1 && poleSprout[nbz-1]==false && k>1) 
				{
					outfileGrowth << "z-bond" << "\t" << poleSprout[nbz-1] << "\t" << i << "\t" << j << endl;
					outfileGrowth << "R0" << "\t" << R0inf[i-1][j-1][k-2] << "\t" << R0sup[i-1][j-1][k-2] <<endl;
					outfileGrowth << "R1" << "\t" << R1inf[i-1][j-1][k-2] << "\t" << R1sup[i-1][j-1][k-2] <<endl;
					outfileGrowth << "R2" << "\t" << R2inf[i-1][j-1][k-2] << "\t" << R2sup[i-1][j-1][k-2] <<endl;
					outfileGrowth << "R3" << "\t" << R3inf[i-1][j-1][k-2] << "\t" << R3sup[i-1][j-1][k-2] <<endl;
					outfileGrowth << "R4" << "\t" << R4inf[i-1][j-1][k-2] << "\t" << R4sup[i-1][j-1][k-2] <<endl;
				}
	}}}

	outfileGrowth << endl;
*/
//-----------------------------------------------
//-----------------------------------------------
}
//*********************************************************

//==========================================
void CAngioNetDlg::GrowVasculatureMDF2(void)
//==========================================
{
//---Decide sprout directions--------------------
//---Governed by prob ranges [R_inf, R_sup)------

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond]; 
	
	for	(int nn=1;nn<=Nbond;nn++)	{pOldSprout[nn-1]=0;}
	for (int nn=1;nn<=Nbond;nn++)		{pOldSprout[nn-1]=pSprout[nn-1];}

	//---Get total number of sprouts---
	int nTotSprouts=0;
	for (int nn=1;nn<=Nbond;nn++)
	{	 
		if (pOldSprout[nn-1]!=0)	{nTotSprouts+=1;}
	}

	//outfileGrowVasc << angiotime << "\t" << "nTotSprouts=" << nTotSprouts << endl;
	//outfileGrowVasc << angiotime << endl;
	//---------------------------------
	//---------------------------------

    double throwDice,throwDice2;
	int nbx,nby,nbz;
	int move,moveRight,moveLeft,moveDown,moveUp,moveFront,moveBack;

	double AnastThreshold=0.98;	//defines % of tip-vessel deaths upon anastomosis


//---DEBUGGING-----------------------------------
/*	outfileSprouts << angiotime << endl;

	for (int k=1;k<=m_nz;k++) 
	{	for (int j=2;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{   
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pOldSprout[nbx-1]!=0)	{outfileSprouts << "x-bond" << "\t" << i << "\t" << j << endl;}
				if (pOldSprout[nby-1]!=0)	{outfileSprouts << "y-bond" << "\t" << i << "\t" << j << endl;}
				if (pOldSprout[nbz-1]!=0)	{outfileSprouts << "z-bond" << "\t" << i << "\t" << j << endl;}

				//if (pFluid[nbx-1]==10)	{outfileSprouts << "x-bond" << "\t" << i << "\t" << j << endl;}
				//if (pFluid[nby-1]==10)	{outfileSprouts << "y-bond" << "\t" << i << "\t" << j << endl;}
				//if (pFluid[nbz-1]==10)	{outfileSprouts << "z-bond" << "\t" << i << "\t" << j << endl;}
	}}}

	outfileSprouts << endl;*/
//-----------------------------------------------
//-----------------------------------------------


	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{   
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);
	
				//---x-bond---

				if (pOldSprout[nbx-1]!=0) 
				{//outfileDebugBone<<"x-bond"<<"\t"<<i<<"\t"<<j<<"\t"<<poleSprout[nbx-1]<<endl;
//outfileDebugBone<<R0inf[i-1][j-1][k-1]<<"\t"<<R0sup[i-1][j-1][k-1]<<"\t"<<R1inf[i-1][j-1][k-1]<<"\t"<<R1sup[i-1][j-1][k-1]<<endl;
//outfileDebugBone<<R2inf[i-1][j-1][k-1]<<"\t"<<R2sup[i-1][j-1][k-1]<<"\t"<<R3inf[i-1][j-1][k-1]<<"\t"<<R3sup[i-1][j-1][k-1]<<endl;
//outfileDebugBone<<R4inf[i-1][j-1][k-1]<<"\t"<<R4sup[i-1][j-1][k-1]<<endl;
					if (poleSprout[nbx-1]==true)
					{	//if(angiotime>8.5 && i==84 && j==87){outfileDebugBone << "x true" << endl;}		
						moveRight=LabX(i+1,j,k);   
						moveLeft=LabX(i,j,k);
						if	(j==m_ny)	{moveDown=0;}	else	{moveDown=LabY(i,j+1,k);}
						moveUp=LabY(i,j,k);
						if	(k==m_nz)	{moveFront=0;}	else	{moveFront=LabZ(i,j,k+1);}
						moveBack=LabZ(i,j,k);

						throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1
						//outfileGrowVasc << angiotime << "\t" << throwDice << endl;
						

						if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
						//outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
						//outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}
						//outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
						//outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack;}
						//outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

//						outfileDebugBone<<throwDice<<"\t"<<move<<endl;

						if (move!=0) 
						{
							if (pFluid[move-1]!=10)	
							{						
								pSprout[nbx-1]=0;	
								pSprout[move-1]=1;
								pFluid[move-1]=10;
								pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
								pPericyteDensity[move-1]=PericyteDensityInit;

								if		(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
								else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

								if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
								else														{poleSprout[move-1]=true;}
							}

							else
							{
								throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
								//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

								if (throwDice2<AnastThreshold)
								//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
								{
									pSprout[nbx-1]=0;
									pAgeOfSprout[nbx-1]=0.0;

									//outfileGrowVasc << "kill-sprout-x" << endl;
									//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
								}
							}
						}	//end if move!=0
					}//end if poleSprout[nbx-1]==true

					if (poleSprout[nbx-1]==false)
					{	//if(angiotime>8.5 && i==84 && j==87){outfileDebugBone << "x false" << endl;}
						if	(i==1)	
						{
							moveLeft=moveDown=moveUp=moveFront=moveBack=0;
							moveRight=LabX(i,j,k);
						}
						
						else
						{
							moveRight=LabX(i,j,k);   
							moveLeft=LabX(i-1,j,k);
							if	(j==m_ny)	{moveDown=0;}	else	{moveDown=LabY(i-1,j+1,k);}
							moveUp=LabY(i-1,j,k);
							if	(k==m_nz)	{moveFront=0;}	else	{moveFront=LabZ(i-1,j,k+1);}
							moveBack=LabZ(i-1,j,k);
						}

						throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1
						//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

						if (throwDice>=R0inf[i-2][j-1][k-1] && throwDice<R0sup[i-2][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "x-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R1inf[i-2][j-1][k-1] && throwDice<R1sup[i-2][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "x-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R2inf[i-2][j-1][k-1] && throwDice<R2sup[i-2][j-1][k-1]) {move=moveLeft;}
						//outfileGrowVasc << "x-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R3inf[i-2][j-1][k-1] && throwDice<R3sup[i-2][j-1][k-1]) {move=moveDown;}
						//outfileGrowVasc << "x-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R4inf[i-2][j-1][k-1] && throwDice<R4sup[i-2][j-1][k-1]) {move=moveUp;}
						//outfileGrowVasc << "x-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R5inf[i-2][j-1][k-1] && throwDice<R5sup[i-2][j-1][k-1]) {move=moveFront;}
						//outfileGrowVasc << "x-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R6inf[i-2][j-1][k-1] && throwDice<R6sup[i-2][j-1][k-1]) {move=moveBack;}
						//outfileGrowVasc << "x-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
//if(angiotime>8.5 && i==84 && j==87){outfileDebugBone << R0inf[i-2][j-1][k-1] << "\t" << R0sup[i-2][j-1][k-1] << "\t" << R1inf[i-2][j-1][k-1] << "\t" << R1sup[i-2][j-1][k-1] << "\t" << R2inf[i-2][j-1][k-1] << "\t" << R2sup[i-2][j-1][k-1] << "\t" << R3inf[i-2][j-1][k-1] << "\t" << R3sup[i-2][j-1][k-1] << "\t" << R4inf[i-2][j-1][k-1] << "\t" << R4sup[i-2][j-1][k-1] << "\t" << move << endl;}
						if (move!=0) 
						{
							if (pFluid[move-1]!=10)	
							{						
								pSprout[nbx-1]=0;	
								pSprout[move-1]=1;
								pFluid[move-1]=10;
								pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
								pPericyteDensity[move-1]=PericyteDensityInit;

								if		(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
								else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

								if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
								else														{poleSprout[move-1]=true;}
					
							}

							else
							{	
								throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
								//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

								if (throwDice2<AnastThreshold)
								//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
								{
									pSprout[nbx-1]=0;
									pAgeOfSprout[nbx-1]=0.0;

									//outfileGrowVasc << "kill-sprout-x" << endl;
									//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
								}
							}
						}//end if move!=0
					}//end if poleSprout[nbx-1]==false
				}//end if pOldSprout[nbx-1]!=0
				//------------
				//------------

				//---y-bond---

				if (pOldSprout[nby-1]!=0) 
				{//outfileDebugBone<<"y-bond"<<"\t"<<i<<"\t"<<j<<"\t"<<pOldSprout[nby-1]<<endl;	//if(angiotime>8.5 && i==84 && j==87){outfileDebugBone << "y true" << endl;}
//outfileDebugBone<<R0inf[i-1][j-1][k-1]<<"\t"<<R0sup[i-1][j-1][k-1]<<"\t"<<R1inf[i-1][j-1][k-1]<<"\t"<<R1sup[i-1][j-1][k-1]<<endl;
//outfileDebugBone<<R2inf[i-1][j-1][k-1]<<"\t"<<R2sup[i-1][j-1][k-1]<<"\t"<<R3inf[i-1][j-1][k-1]<<"\t"<<R3sup[i-1][j-1][k-1]<<endl;
//outfileDebugBone<<R4inf[i-1][j-1][k-1]<<"\t"<<R4sup[i-1][j-1][k-1]<<endl;
					if (poleSprout[nby-1]==true)
					{	
						moveRight=LabX(i+1,j,k);   
						moveLeft=LabX(i,j,k);
						if	(j==m_ny)	{moveDown=0;}	else	{moveDown=LabY(i,j+1,k);}
						moveUp=LabY(i,j,k);
						if	(k==m_nz)	{moveFront=0;}	else	{moveFront=LabZ(i,j,k+1);}
						moveBack=LabZ(i,j,k);

						throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1
						//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

						if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "y-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
						//outfileGrowVasc << "y-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;}
						//outfileGrowVasc << "y-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
						//outfileGrowVasc << "y-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "y-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
						//outfileGrowVasc << "y-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack;}
						//outfileGrowVasc << "y-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

//						outfileDebugBone<<throwDice<<"\t"<<move<<endl;

						if (move!=0) 
						{
							if (pFluid[move-1]!=10)
							{					
								pSprout[nby-1]=0;	
								pSprout[move-1]=1;
								pFluid[move-1]=10;
								pAgeOfSprout[move-1]=pAgeOfSprout[nby-1];
								pPericyteDensity[move-1]=PericyteDensityInit;
					
								if		(pArterialVenousID[nby-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
								else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

								if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
								else														{poleSprout[move-1]=true;}
							}

							else
							{
								throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
								//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

								if (throwDice2<AnastThreshold)
								//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
								{
									pSprout[nby-1]=0;
									pAgeOfSprout[nby-1]=0.0;

									//outfileGrowVasc << "kill-sprout-y" << endl;
									//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
								}
							}
						}//end if move!=0
					}//end if poleSprout[nby-1]==true

					if (poleSprout[nby-1]==false)
					{	//if(angiotime>8.5 && i==84 && j==87){outfileDebugBone << "y false" << endl;}
						if	(j==1)	
						{
							moveLeft=moveRight=moveUp=moveFront=moveBack=0;
							moveDown=LabY(i,j,k);
						}
						
						else
						{
							moveRight=LabX(i+1,j-1,k);   
							moveLeft=LabX(i,j-1,k);
							moveDown=LabY(i,j,k);
							moveUp=LabY(i,j-1,k);
							if	(k==m_nz)	{moveFront=0;}	else	{moveFront=LabZ(i,j-1,k+1);}
							moveBack=LabZ(i,j-1,k);
						}
						
						throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1
						//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

						if (throwDice>=R0inf[i-1][j-2][k-1] && throwDice<R0sup[i-1][j-2][k-1]) {move=0;}
						//outfileGrowVasc << "y-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R1inf[i-1][j-2][k-1] && throwDice<R1sup[i-1][j-2][k-1]) {move=moveRight;}
						//outfileGrowVasc << "y-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R2inf[i-1][j-2][k-1] && throwDice<R2sup[i-1][j-2][k-1]) {move=moveLeft;}
						//outfileGrowVasc << "y-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R3inf[i-1][j-2][k-1] && throwDice<R3sup[i-1][j-2][k-1]) {move=0;}
						//outfileGrowVasc << "y-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R4inf[i-1][j-2][k-1] && throwDice<R4sup[i-1][j-2][k-1]) {move=moveUp;}
						//outfileGrowVasc << "y-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;} 
						if (throwDice>=R5inf[i-1][j-2][k-1] && throwDice<R5sup[i-1][j-2][k-1]) {move=moveFront;}
						//outfileGrowVasc << "y-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R6inf[i-1][j-2][k-1] && throwDice<R6sup[i-1][j-2][k-1]) {move=moveBack;}
						//outfileGrowVasc << "y-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

						if (move!=0) 
						{
							if (pFluid[move-1]!=10)	
							{						
								pSprout[nby-1]=0;	
								pSprout[move-1]=1;
								pFluid[move-1]=10;
								pAgeOfSprout[move-1]=pAgeOfSprout[nby-1];
								pPericyteDensity[move-1]=PericyteDensityInit;
					
								if		(pArterialVenousID[nby-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
								else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

								if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
								else														{poleSprout[move-1]=true;}
					
							}

							else
							{
								throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
								//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

								if (throwDice2<AnastThreshold)
								//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
								{
									pSprout[nby-1]=0;
									pAgeOfSprout[nby-1]=0.0;

									//outfileGrowVasc << "kill-sprout-y" << endl;
									//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
								}
							}
						}//end if move!=0
					}//end if poleSprout[nby-1]==false
				}//end if pOldSprout[nby-1]!=0
				//------------
				//------------

				//---z-bond---

				if (pOldSprout[nbz-1]!=0) 
				{
					if (poleSprout[nbz-1]==true)
					{
						moveRight=LabX(i+1,j,k);   
						moveLeft=LabX(i,j,k);
						if	(j==m_ny)	{moveDown=0;}	else	{moveDown=LabY(i,j+1,k);}
						moveUp=LabY(i,j,k);
						if	(k==m_nz)	{moveFront=0;}	else	{moveFront=LabZ(i,j,k+1);}
						moveBack=LabZ(i,j,k);

						throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1
						//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

						if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
						//outfileGrowVasc << "z-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
						//outfileGrowVasc << "z-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=moveLeft;}
						//outfileGrowVasc << "z-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
						//outfileGrowVasc << "z-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}  
						//outfileGrowVasc << "z-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
						//outfileGrowVasc << "z-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=0;} 
						//outfileGrowVasc << "z-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

						if (move!=0) 
						{
							if (pFluid[move-1]!=10)	 
							{						
								pSprout[nbz-1]=0;	
								pSprout[move-1]=1;
								pFluid[move-1]=10;
								pAgeOfSprout[move-1]=pAgeOfSprout[nbz-1];
								pPericyteDensity[move-1]=PericyteDensityInit;
					
								if		(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
								else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

								if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
								else														{poleSprout[move-1]=true;}
							}
				
							else
							{
								throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
								//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

								if (throwDice2<AnastThreshold)
								//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
								{
									pSprout[nbz-1]=0;
									pAgeOfSprout[nbz-1]=0.0;

									//outfileGrowVasc << "kill-sprout-z" << endl;
									//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
								}
							}
						}//end if move!=0
					}//end if poleSprout[nbz-1]==true

					if (poleSprout[nbz-1]==false)
					{
						if	(k==1)	
						{
							moveLeft=moveRight=moveUp=moveDown=moveBack=0;
							moveFront=LabZ(i,j,k);
						}
						
						else
						{
							moveRight=LabX(i+1,j,k-1);   
							moveLeft=LabX(i,j,k-1);
							if	(j==m_ny)	{moveDown=0;}	else	{moveDown=LabY(i,j+1,k-1);}
							moveUp=LabY(i,j,k-1);
							moveFront=LabZ(i,j,k);
							moveBack=LabZ(i,j,k-1);
						}
						
						throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1
						//outfileGrowVasc << angiotime << "\t" << throwDice << endl;

						if (throwDice>=R0inf[i-1][j-1][k-2] && throwDice<R0sup[i-1][j-1][k-2]) {move=0;}
						//outfileGrowVasc << "z-bond-stationary" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R1inf[i-1][j-1][k-2] && throwDice<R1sup[i-1][j-1][k-2]) {move=moveRight;}
						//outfileGrowVasc << "z-bond-right" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R2inf[i-1][j-1][k-2] && throwDice<R2sup[i-1][j-1][k-2]) {move=moveLeft;}
						//outfileGrowVasc << "z-bond-left" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R3inf[i-1][j-1][k-2] && throwDice<R3sup[i-1][j-1][k-2]) {move=moveDown;}
						//outfileGrowVasc << "z-bond-down" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R4inf[i-1][j-1][k-2] && throwDice<R4sup[i-1][j-1][k-2]) {move=moveUp;}   
						//outfileGrowVasc << "z-bond-up" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R5inf[i-1][j-1][k-2] && throwDice<R5sup[i-1][j-1][k-2]) {move=0;}
						//outfileGrowVasc << "z-bond-front" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}
						if (throwDice>=R6inf[i-1][j-1][k-2] && throwDice<R6sup[i-1][j-1][k-2]) {move=moveBack;}
						//outfileGrowVasc << "z-bond-back" << "\t" << poleSprout[nbx-1] << "\t" << i << "\t" << j << endl;}

						if (move!=0) 
						{
							if (pFluid[move-1]!=10)	 
							{						
								pSprout[nbz-1]=0;	
								pSprout[move-1]=1;
								pFluid[move-1]=10;
								pAgeOfSprout[move-1]=pAgeOfSprout[nbz-1];
								pPericyteDensity[move-1]=PericyteDensityInit;
					
								if		(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
								else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

								if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
								else														{poleSprout[move-1]=true;}
							}
				
							else
							{
								throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
								//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

								if (throwDice2<AnastThreshold)
								//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
								{
									pSprout[nbz-1]=0;
									pAgeOfSprout[nbz-1]=0.0;

									//outfileGrowVasc << "kill-sprout-z" << endl;
									//outfileGrowVasc << move << "\t" << i << "\t" << j << endl;
								}
							}
						}//end if move!=0
					}//end if poleSprout[nbz-1]==false
				}//end if pOldSprout[nbz-1]!=0
				//------------
				//------------
//if	(angiotime>=8.5)	{outfileDebugBone << i << "\t" << j << endl;}
			}//end i loop

			//---Dangling x-bond---

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pOldSprout[nbx-1]!=0) 
			{
				if (poleSprout[nbx-1]==true)
				{
					moveRight=moveDown=moveUp=moveFront=moveBack=0;   
					moveLeft=LabX(i,j,k);
					
					throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1

					if (throwDice>=R0inf[i-1][j-1][k-1] && throwDice<R0sup[i-1][j-1][k-1]) {move=0;}
					if (throwDice>=R1inf[i-1][j-1][k-1] && throwDice<R1sup[i-1][j-1][k-1]) {move=moveRight;}
					if (throwDice>=R2inf[i-1][j-1][k-1] && throwDice<R2sup[i-1][j-1][k-1]) {move=0;}
					if (throwDice>=R3inf[i-1][j-1][k-1] && throwDice<R3sup[i-1][j-1][k-1]) {move=moveDown;}
					if (throwDice>=R4inf[i-1][j-1][k-1] && throwDice<R4sup[i-1][j-1][k-1]) {move=moveUp;}
					if (throwDice>=R5inf[i-1][j-1][k-1] && throwDice<R5sup[i-1][j-1][k-1]) {move=moveFront;}
					if (throwDice>=R6inf[i-1][j-1][k-1] && throwDice<R6sup[i-1][j-1][k-1]) {move=moveBack; }

					if (move!=0) 
					{
						if (pFluid[move-1]!=10)	
						{						
							pSprout[nbx-1]=0;	
							pSprout[move-1]=1;
							pFluid[move-1]=10;
							pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
							pPericyteDensity[move-1]=PericyteDensityInit;
					
							if		(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
							else 									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

							if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
							else														{poleSprout[move-1]=true;}
						}
				
						else
						{
							throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
							//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

							if (throwDice2<AnastThreshold)
							//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
							{
								pSprout[nbx-1]=0;
								pAgeOfSprout[nbx-1]=0.0;
							}
						}
					}//end if move!=0
				}//end if poleSprout[nbx-1]==true

				if (poleSprout[nbx-1]==false)
				{
					moveRight=LabX(i,j,k);   
					moveLeft=LabX(i-1,j,k);
					if	(j==m_ny)	{moveDown=0;}	else	{moveDown=LabY(i-1,j+1,k);}
					moveUp=LabY(i-1,j,k);
					if	(k==m_nz)	{moveFront=0;}	else	{moveFront=LabZ(i-1,j,k+1);}
					moveBack=LabZ(i-1,j,k);

					throwDice=float(rand())/float(RAND_MAX+0.1); // random number between 0 and 1

					if (throwDice>=R0inf[i-2][j-1][k-1] && throwDice<R0sup[i-2][j-1][k-1]) {move=0;}
					if (throwDice>=R1inf[i-2][j-1][k-1] && throwDice<R1sup[i-2][j-1][k-1]) {move=0;}
					if (throwDice>=R2inf[i-2][j-1][k-1] && throwDice<R2sup[i-2][j-1][k-1]) {move=moveLeft;}
					if (throwDice>=R3inf[i-2][j-1][k-1] && throwDice<R3sup[i-2][j-1][k-1]) {move=moveDown;}
					if (throwDice>=R4inf[i-2][j-1][k-1] && throwDice<R4sup[i-2][j-1][k-1]) {move=moveUp;}
					if (throwDice>=R5inf[i-2][j-1][k-1] && throwDice<R5sup[i-2][j-1][k-1]) {move=moveFront;}
					if (throwDice>=R6inf[i-2][j-1][k-1] && throwDice<R6sup[i-2][j-1][k-1]) {move=moveBack; }

					if (move!=0) 
					{
						if (pFluid[move-1]!=10)	
						{						
							pSprout[nbx-1]=0;	
							pSprout[move-1]=1;
							pFluid[move-1]=10;
							pAgeOfSprout[move-1]=pAgeOfSprout[nbx-1];
							pPericyteDensity[move-1]=PericyteDensityInit;
					
							if		(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[move-1]=1;} //grown from an arterial vessel
							else									{pArterialVenousID[move-1]=-1;}//grown from a venous vessel

							if		(move==moveLeft || move==moveUp || move==moveBack)	{poleSprout[move-1]=false;}
							else														{poleSprout[move-1]=true;}
						}
				
						else
						{	
							throwDice2=float(rand())/float(RAND_MAX); // random number between 0 and 1
							//outfileGrowVasc << angiotime << "\t" << throwDice2 << endl;

							if (throwDice2<AnastThreshold)
							//if (throwDice<AnastThreshold) //use throwdice so random number sequence not disturbed
							{
								pSprout[nbx-1]=0;
								pAgeOfSprout[nbx-1]=0.0;
							}
						}
					}//end if move!=0
				}//end if poleSprout[nbx-1]==true
			}//end if pOldSprout[nbx-1]!=0
			//---------------------
			//---------------------

	}}//end j and k loops
//-----------------------------------------------
//-----------------------------------------------

//---Sprouts reaching boundaries are killed------

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx;i++)
			{   
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pSprout[nbx-1]!=0 && i==1)
				{
					pSprout[nbx-1]=0;
					pFluid[nbx-1]=0;
					pPericyteDensity[nbx-1]=0.0;
					pAgeOfSprout[nbx-1]=0.0;
					pArterialVenousID[nbx-1]=0;
				}

/*				if (pSprout[nbx-1]!=0 && i==m_nx)
				{ 
					pSprout[nbx-1]=0;
					pFluid[nbx-1]=0;
					pPericyteDensity[nbx-1]=0.0;
					pAgeOfSprout[nbx-1]=0.0;
					pArterialVenousID[nbx-1]=0;
				}
*/
				if (pSprout[nby-1]!=0 && j==1)	//(pSprout[nby-1]!=0 && poleSprout[nby-1]==false && j==2)
				{
					pSprout[nby-1]=0;
					pFluid[nby-1]=0;
					pPericyteDensity[nby-1]=0.0;
					pAgeOfSprout[nby-1]=0.0;
					pArterialVenousID[nby-1]=0;
				}

				if (pSprout[nby-1]!=0 && j==m_ny)
				{
					pSprout[nby-1]=0;
					pFluid[nby-1]=0;				//comment out to make sure tracer reaches tumour
					pPericyteDensity[nby-1]=0.0;
					pAgeOfSprout[nby-1]=0.0;
					pArterialVenousID[nby-1]=0;
				}

				if (pSprout[nbz-1]!=0 && k==1)
				{
					pSprout[nbz-1]=0;
					pFluid[nbz-1]=0;
					pPericyteDensity[nbz-1]=0.0;
					pAgeOfSprout[nbz-1]=0.0;
					pArterialVenousID[nbz-1]=0;
				}

				if (pSprout[nbz-1]!=0 && k==m_nz)
				{
					pSprout[nbz-1]=0;
					pFluid[nbz-1]=0;
					pPericyteDensity[nbz-1]=0.0;
					pAgeOfSprout[nbz-1]=0.0;
					pArterialVenousID[nbz-1]=0;
				}

			}//end i-loop

			int i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pSprout[nbx-1]!=0)
			{
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pAgeOfSprout[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
			}
	}}//end j,k-loops
//-----------------------------------------------
//-----------------------------------------------

	delete [] pOldSprout;

	//outfileGrowVasc << endl;
}

//*********************************************************

//===============================================
void CAngioNetDlg::BranchSproutsTAFWSS2(void)
//===============================================
{
	runningWSSMAX=2.0;//1.0;//0.2;//(Pa) //reference WSS for shear-induced branching	

	double thresholdAgeInf=2.66;//(4 days)	//lower threshold for shear-induced vessel branching
	double thresholdAgeSup=5.33; //(8 days)	//upper threshold for shear-induced vessel branching
	double thresholdAge=0.5;//0.1;//0.2;//0.25;// //lower threshold for TAF-induced sprout branching (changed by Mike 10/08 for wound model)

	double carryingCapacity=0.0;
	double branchFraction=1.001;//0.5;// (no pericyte effect on branching)

//-----------------------------------------------

	int* pOldSprout=NULL;
	pOldSprout=new int[Nbond];

	for(int nn=1;nn<=Nbond;nn++) {pOldSprout[nn-1]=pSprout[nn-1];}

//-----------------------------------------------
	
	double probBranch,randDice;
	int i,j,k,nbx,nby,nbz,randBranchDirection;
	bool bKillOldSprout;

	bool bWSS=FALSE;//TRUE;// Wall shear Stress included or not?
	bool bMaintainDirection=FALSE;//TRUE;// One branch maintains original sprout direction or not?

//-----------------------------------------------

	for	(k=1;k<=m_nz;k++)
	{	for	(j=1;j<=m_ny;j++)
		{	for	(i=1;i<=m_nx;i++)
			{	
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

//---xBonds--------------------------------------

				probBranch=0.0;
				bKillOldSprout=FALSE;

				if	(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)	//sprout older than critical age
				{
					if	(b_UU_wound_Model==false)	//Used for tumour angio work
					{
/*						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)		{probBranch=0.1;}//0.0;}//
						else if	(vTAFConc[i-1][j-1][k-1]>0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)		{probBranch=0.4;}//0.2;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)		{probBranch=0.6;}//0.3;}//
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)		{probBranch=0.8;}//0.4;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)			{probBranch=1.0;}
*/
						if		(vTAFConc[i-1][j-1][k-1]<=0.2)		{probBranch=0.15;}//0.0;}//
						else if	(vTAFConc[i-1][j-1][k-1]>0.2 &&
									vTAFConc[i-1][j-1][k-1]<=0.4)		{probBranch=0.225;}//0.2;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.4 &&
									vTAFConc[i-1][j-1][k-1]<=0.6)		{probBranch=0.3;}//0.3;}//
						else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
									vTAFConc[i-1][j-1][k-1]<=0.8)		{probBranch=0.375;}//0.4;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.8)			{probBranch=0.45;}
					}

					if	(b_UU_wound_Model==true)	//Used for thesis wound sims
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)		{probBranch=0.009;}
						else if	(vTAFConc[i-1][j-1][k-1]>0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)		{probBranch=0.01;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)	{probBranch=0.011;}
						else if (vTAFConc[i-1][j-1][k-1]>0.98*runningTAFConcMAX)		{probBranch=0.012;}
					}
				}			

//-----------------------------------------------
	
				if	(bWSS && pOldSprout[nbx-1]==0)	//WSS and not a sprout
				{		
					if		(XTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)      
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.0;}		
					}	

					else if	(XTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.02;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.03;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.04;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.1;}		
					}	
				
					else if (XTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX) 
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.04;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.06;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.08;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.2;}			
					}

					else if (XTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && XTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX) {probBranch=0.06;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.09;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.12;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.3;}			
					}

					else if (XTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX) {probBranch=0.08;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.12;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.16;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.4;}			
					}

					if	(j==1)	{probBranch=0.0;} 
					if	((b_UU_wound_Model || b_venousIncluded) && j==m_ny-1)	{probBranch=0.0;}
				}//end if WSS

//-----------------------------------------------
				
				if	(  
						(bWSS && pFluid[nbx-1]==10 && pAgeOfVessel[nbx-1]<=thresholdAgeSup && pAgeOfVessel[nbx-1]>=thresholdAgeInf)
						||
						(pOldSprout[nbx-1]!=0 && pAgeOfSprout[nbx-1]>thresholdAge)
						//pPericyteDensity[nbx-1]<=branchFraction*carryingCapacity
					)
				{
					carryingCapacity=2.0*XBR[i-1][j-1][k-1]*angioDeltaX/pow(RadiusPericyte,2);

					if	(bMaintainDirection)
					{
						if	(m_nz==1)	{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
						else			{randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

						randDice=float(rand())/float(RAND_MAX); //(0,1)

						if	(randDice<probBranch && poleSprout[nbx-1]==true)
						{	//NB: poleSprout variable isn't really defined for non-sprout (i.e. vessel) segments.
							//This section will be done anyway and may give a directional bias for branching.
							//All vessels initialised to poleSprout=TRUE in InitialiseVariables.

							if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
							{																
								pFluid[LabX(i+1,j,k)-1]=10;
								pSprout[LabX(i+1,j,k)-1]=1;
								pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
								if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
								else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

								poleSprout[LabX(i+1,j,k)-1]=true;
								pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

								bKillOldSprout=TRUE;
							}
						
							switch(randBranchDirection)
							{
								case 1:	if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
								break;

								case 2: if	(
												(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
												||
												(j==1 && pFluid[LabY(i,j,k)-1]==0)
											)
										{															
											pFluid[LabY(i,j,k)-1]=10;
											pSprout[LabY(i,j,k)-1]=1;
											pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabY(i,j,k)-1]=false;
											pAgeOfSprout[LabY(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
								break;
									
								case 3: if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
								break;

								case 4: if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
								break;
							}//end randDirection

							if	(bKillOldSprout==TRUE)	//old sprout only killed if at least 1 vessel added
							{
								pAgeOfSprout[nbx-1]=0.0;
								pSprout[nbx-1]=0;
							}

						}//end if branch

//-----------------------------------------------

						if	(randDice<probBranch && poleSprout[nbx-1]==false)
						{
							if	(i!=1)
							{
								if	(
										(i!=2 && pFluid[LabX(i-1,j,k)-1]==0 && bBoneTissue[i-2-1][j-1][k-1]==FALSE)
										||
										(i==2 && pFluid[LabX(i-1,j,k)-1]==0)
									)	
								{																
									pFluid[LabX(i-1,j,k)-1]=10;
									pSprout[LabX(i-1,j,k)-1]=1;
									pPericyteDensity[LabX(i-1,j,k)-1]=PericyteDensityInit;
							
									if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i-1,j,k)-1]=1;} //grown from arterial vessel
									else								{pArterialVenousID[LabX(i-1,j,k)-1]=-1;}//grown from venous vessel

									poleSprout[LabX(i-1,j,k)-1]=false;
									pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

									bKillOldSprout=TRUE;
								}

								switch(randBranchDirection)
								{
									case 1: if	(j!=m_ny)
											{
												if	(pFluid[LabY(i-1,j+1,k)-1]==0 && bBoneTissue[i-1-1][j+1-1][k-1]==FALSE)	
												{	
													pFluid[LabY(i-1,j+1,k)-1]=10;									
													pSprout[LabY(i-1,j+1,k)-1]=1;
													pPericyteDensity[LabY(i-1,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i-1,j+1,k)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i-1,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
									break;

									case 2: if	(
													(j!=1 && pFluid[LabY(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabY(i-1,j,k)-1]=10;
												pSprout[LabY(i-1,j,k)-1]=1;
												pPericyteDensity[LabY(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i-1,j,k)-1]=false;
												pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;
									
									case 3: if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i-1,j,k+1)-1]==0 && bBoneTissue[i-1-1][j-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i-1,j,k+1)-1]=10;
													pSprout[LabZ(i-1,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i-1,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i-1,j,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i-1,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
									break;

									case 4: if	(
													(k!=1 && pFluid[LabZ(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabZ(i-1,j,k)-1]=10;
												pSprout[LabZ(i-1,j,k)-1]=1;
												pPericyteDensity[LabZ(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i-1,j,k)-1]=false;
												pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;
								}//end randDirection

								if	(bKillOldSprout==TRUE)
								{
									pAgeOfSprout[nbx-1]=0.0;
									pSprout[nbx-1]=0;
								}

							}//end i!=1
						}//end if branch
					}//end if MaintainDirection

//-----------------------------------------------

					else
					{
						if	(m_nz==1)	{randBranchDirection=1+int(3*float(rand())/float(RAND_MAX));} 
						else			{randBranchDirection=1+int(10*float(rand())/float(RAND_MAX));} 

						randDice=float(rand())/float(RAND_MAX); //(0,1)

						if	(randDice<probBranch && poleSprout[nbx-1]==true)
						{	//NB: poleSprout variable isn't really defined for non-sprout (i.e. vessel) segments.
							//This section will be done anyway and may give a directional bias for branching.
							//All vessels initialised to poleSprout=TRUE in InitialiseVariables.

							switch(randBranchDirection)
							{
								case 1: if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 2: if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(
												(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
												||
												(j==1 && pFluid[LabY(i,j,k)-1]==0)
											)
										{															
											pFluid[LabY(i,j,k)-1]=10;
											pSprout[LabY(i,j,k)-1]=1;
											pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabY(i,j,k)-1]=false;
											pAgeOfSprout[LabY(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;
									
								case 3: if	(
												(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
												||
												(j==1 && pFluid[LabY(i,j,k)-1]==0)
											)
										{															
											pFluid[LabY(i,j,k)-1]=10;
											pSprout[LabY(i,j,k)-1]=1;
											pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabY(i,j,k)-1]=false;
											pAgeOfSprout[LabY(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 4:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 5:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 6:	if	(
												(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
												||
												(j==1 && pFluid[LabY(i,j,k)-1]==0)
											)
										{															
											pFluid[LabY(i,j,k)-1]=10;
											pSprout[LabY(i,j,k)-1]=1;
											pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabY(i,j,k)-1]=false;
											pAgeOfSprout[LabY(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 7:	if	(
												(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
												||
												(j==1 && pFluid[LabY(i,j,k)-1]==0)
											)
										{															
											pFluid[LabY(i,j,k)-1]=10;
											pSprout[LabY(i,j,k)-1]=1;
											pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabY(i,j,k)-1]=false;
											pAgeOfSprout[LabY(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}

								break;

								case 8:	if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
							
										if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 9:	if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
							
										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;

								case 10:if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
							
										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nbx-1]=0.0;
											pSprout[nbx-1]=0;
										}
								break;
							}//end randDirection	
						}//end if branch

//-----------------------------------------------

						if	(randDice<probBranch && poleSprout[nbx-1]==false)
						{
							if	(i!=1)
							{
								switch(randBranchDirection)
								{
									case 1: if	(
													(i!=2 && pFluid[LabX(i-1,j,k)-1]==0 && bBoneTissue[i-2-1][j-1][k-1]==FALSE)
													||
													(i==2 && pFluid[LabX(i-1,j,k)-1]==0)
												)	
											{																
												pFluid[LabX(i-1,j,k)-1]=10;
												pSprout[LabX(i-1,j,k)-1]=1;
												pPericyteDensity[LabX(i-1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i-1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i-1,j,k)-1]=false;
												pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(j!=m_ny)
											{
												if	(pFluid[LabY(i-1,j+1,k)-1]==0 && bBoneTissue[i-1-1][j+1-1][k-1]==FALSE)	
												{	
													pFluid[LabY(i-1,j+1,k)-1]=10;									
													pSprout[LabY(i-1,j+1,k)-1]=1;
													pPericyteDensity[LabY(i-1,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i-1,j+1,k)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i-1,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 2: if	(
													(i!=2 && pFluid[LabX(i-1,j,k)-1]==0 && bBoneTissue[i-2-1][j-1][k-1]==FALSE)
													||
													(i==2 && pFluid[LabX(i-1,j,k)-1]==0)
												)	
											{																
												pFluid[LabX(i-1,j,k)-1]=10;
												pSprout[LabX(i-1,j,k)-1]=1;
												pPericyteDensity[LabX(i-1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i-1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i-1,j,k)-1]=false;
												pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(
													(j!=1 && pFluid[LabY(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabY(i-1,j,k)-1]=10;
												pSprout[LabY(i-1,j,k)-1]=1;
												pPericyteDensity[LabY(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i-1,j,k)-1]=false;
												pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;
									
									case 3: if	(j!=m_ny)
											{
												if	(pFluid[LabY(i-1,j+1,k)-1]==0 && bBoneTissue[i-1-1][j+1-1][k-1]==FALSE)	
												{	
													pFluid[LabY(i-1,j+1,k)-1]=10;									
													pSprout[LabY(i-1,j+1,k)-1]=1;
													pPericyteDensity[LabY(i-1,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i-1,j+1,k)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i-1,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
							
											if	(
													(j!=1 && pFluid[LabY(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabY(i-1,j,k)-1]=10;
												pSprout[LabY(i-1,j,k)-1]=1;
												pPericyteDensity[LabY(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i-1,j,k)-1]=false;
												pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 4:	if	(
													(i!=2 && pFluid[LabX(i-1,j,k)-1]==0 && bBoneTissue[i-2-1][j-1][k-1]==FALSE)
													||
													(i==2 && pFluid[LabX(i-1,j,k)-1]==0)
												)	
											{																
												pFluid[LabX(i-1,j,k)-1]=10;
												pSprout[LabX(i-1,j,k)-1]=1;
												pPericyteDensity[LabX(i-1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i-1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i-1,j,k)-1]=false;
												pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i-1,j,k+1)-1]==0 && bBoneTissue[i-1-1][j-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i-1,j,k+1)-1]=10;
													pSprout[LabZ(i-1,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i-1,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i-1,j,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i-1,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 5:	if	(
													(i!=2 && pFluid[LabX(i-1,j,k)-1]==0 && bBoneTissue[i-2-1][j-1][k-1]==FALSE)
													||
													(i==2 && pFluid[LabX(i-1,j,k)-1]==0)
												)	
											{																
												pFluid[LabX(i-1,j,k)-1]=10;
												pSprout[LabX(i-1,j,k)-1]=1;
												pPericyteDensity[LabX(i-1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabX(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i-1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i-1,j,k)-1]=false;
												pAgeOfSprout[LabX(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(
													(k!=1 && pFluid[LabZ(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabZ(i-1,j,k)-1]=10;
												pSprout[LabZ(i-1,j,k)-1]=1;
												pPericyteDensity[LabZ(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i-1,j,k)-1]=false;
												pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 6:	if	(j!=m_ny)
											{
												if	(pFluid[LabY(i-1,j+1,k)-1]==0 && bBoneTissue[i-1-1][j+1-1][k-1]==FALSE)	
												{	
													pFluid[LabY(i-1,j+1,k)-1]=10;									
													pSprout[LabY(i-1,j+1,k)-1]=1;
													pPericyteDensity[LabY(i-1,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i-1,j+1,k)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i-1,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i-1,j,k+1)-1]==0 && bBoneTissue[i-1-1][j-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i-1,j,k+1)-1]=10;
													pSprout[LabZ(i-1,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i-1,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i-1,j,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i-1,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 7:	if	(j!=m_ny)
											{
												if	(pFluid[LabY(i-1,j+1,k)-1]==0 && bBoneTissue[i-1-1][j+1-1][k-1]==FALSE)	
												{	
													pFluid[LabY(i-1,j+1,k)-1]=10;									
													pSprout[LabY(i-1,j+1,k)-1]=1;
													pPericyteDensity[LabY(i-1,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i-1,j+1,k)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i-1,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i-1,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(
													(k!=1 && pFluid[LabZ(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabZ(i-1,j,k)-1]=10;
												pSprout[LabZ(i-1,j,k)-1]=1;
												pPericyteDensity[LabZ(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i-1,j,k)-1]=false;
												pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 8:	if	(
													(j!=1 && pFluid[LabY(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabY(i-1,j,k)-1]=10;
												pSprout[LabY(i-1,j,k)-1]=1;
												pPericyteDensity[LabY(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i-1,j,k)-1]=false;
												pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i-1,j,k+1)-1]==0 && bBoneTissue[i-1-1][j-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i-1,j,k+1)-1]=10;
													pSprout[LabZ(i-1,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i-1,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i-1,j,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i-1,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 9:	if	(
													(j!=1 && pFluid[LabY(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabY(i-1,j,k)-1]=10;
												pSprout[LabY(i-1,j,k)-1]=1;
												pPericyteDensity[LabY(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabY(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i-1,j,k)-1]=false;
												pAgeOfSprout[LabY(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(
													(k!=1 && pFluid[LabZ(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabZ(i-1,j,k)-1]=10;
												pSprout[LabZ(i-1,j,k)-1]=1;
												pPericyteDensity[LabZ(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i-1,j,k)-1]=false;
												pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;

									case 10:if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i-1,j,k+1)-1]==0 && bBoneTissue[i-1-1][j-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i-1,j,k+1)-1]=10;
													pSprout[LabZ(i-1,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i-1,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i-1,j,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i-1,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i-1,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(
													(k!=1 && pFluid[LabZ(i-1,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i-1,j,k)-1]==0)
												)
											{
												pFluid[LabZ(i-1,j,k)-1]=10;
												pSprout[LabZ(i-1,j,k)-1]=1;
												pPericyteDensity[LabZ(i-1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbx-1]>0)	{pArterialVenousID[LabZ(i-1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i-1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i-1,j,k)-1]=false;
												pAgeOfSprout[LabZ(i-1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbx-1]=0.0;
												pSprout[nbx-1]=0;
											}
									break;
								}//end randBranch
							}//end if i!=1
						}//end if branch
					}//end if !MaintainDirection

//-----------------------------------------------

				}//end if can branch

//---yBonds--------------------------------------

				probBranch=0.0;
				bKillOldSprout=FALSE;

				if	(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
				{
					if	(b_UU_wound_Model==false)	//Used for tumour angio work
					{
/*						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)		{probBranch=0.1;}//0.0;}//
						else if	(vTAFConc[i-1][j-1][k-1]>0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)		{probBranch=0.4;}//0.2;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)		{probBranch=0.6;}//0.3;}//
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)		{probBranch=0.8;}//0.4;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)			{probBranch=1.0;}
*/
						if		(vTAFConc[i-1][j-1][k-1]<=0.2)		{probBranch=0.15;}//0.0;}//
						else if	(vTAFConc[i-1][j-1][k-1]>0.2 &&
									vTAFConc[i-1][j-1][k-1]<=0.4)		{probBranch=0.225;}//0.2;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.4 &&
									vTAFConc[i-1][j-1][k-1]<=0.6)		{probBranch=0.3;}//0.3;}//
						else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
									vTAFConc[i-1][j-1][k-1]<=0.8)		{probBranch=0.375;}//0.4;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.8)			{probBranch=0.45;}
					}

					if	(b_UU_wound_Model==true)	//Used for thesis wound sims
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)		{probBranch=0.009;}
						else if	(vTAFConc[i-1][j-1][k-1]>0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)		{probBranch=0.01;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)	{probBranch=0.011;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)		{probBranch=0.012;}
					}
				}
	
				if (bWSS && pOldSprout[nby-1]==0)
				{				
					if		(YTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)      
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.0;}		
					}	

					else if	(YTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && YTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.02;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.03;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.04;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.1;}		
					}	
				
					else if (YTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && YTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX) 
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.04;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.06;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.08;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.2;}			
					}

					else if (YTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && YTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX) {probBranch=0.06;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.09;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.12;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.3;}			
					}

					else if (YTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX) {probBranch=0.08;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.12;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.16;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.4;}			
					}
				}	//end if WSS

//-----------------------------------------------

				if	(  
						(bWSS && pFluid[nby-1]==10 && pAgeOfVessel[nby-1]<=thresholdAgeSup && pAgeOfVessel[nby-1]>=thresholdAgeInf)
						||
						(pOldSprout[nby-1]!=0 && pAgeOfSprout[nby-1]>thresholdAge)
						//pPericyteDensity[nby-1]<=branchFraction*carryingCapacity
					)
				{
					carryingCapacity=2.0*YBR[i-1][j-1][k-1]*angioDeltaY/pow(RadiusPericyte,2);

					if	(bMaintainDirection)
					{
						if	(m_nz==1)	{randBranchDirection=1+int(2*float(rand())/float(RAND_MAX));} 
						else			{randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));} 

						randDice=float(rand())/float(RAND_MAX); //(0,1)

						if	(randDice<probBranch && poleSprout[nby-1]==true)
						{
							if	(j!=m_ny)
							{
								if (pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
								{
									pFluid[LabY(i,j+1,k)-1]=10;
									pSprout[LabY(i,j+1,k)-1]=1;
									pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
							
									if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
									else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel
							
									poleSprout[LabY(i,j+1,k)-1]=true;
									pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

									bKillOldSprout=TRUE;
								}
							}
						
							switch(randBranchDirection)
							{
								case 1: if	(pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)
										{
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else 								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
								break;

								case 2: if	(
												(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
												||
												(i==1 && pFluid[LabX(i,j,k)-1]==0)
											)
										{
											pFluid[LabX(i,j,k)-1]=10;
											pSprout[LabX(i,j,k)-1]=1;
											pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i,j,k)-1]=false;
											pAgeOfSprout[LabX(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
								break;
									
								case 3: if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
									break;

								case 4: if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
								break;
							}//end randDirection

							if	(bKillOldSprout==TRUE)
							{
								pAgeOfSprout[nby-1]=0.0;
								pSprout[nby-1]=0;
							}

						}//end if branch

//-----------------------------------------------

						if	(randDice<probBranch && poleSprout[nby-1]==false)
						{
							if	(j!=1)
							{
								if	(
										(j!=2 && pFluid[LabY(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-2-1][k-1]==FALSE)
										||
										(j==2 && pFluid[LabY(i,j-1,k)-1]==0)
									)
								{
									pFluid[LabY(i,j-1,k)-1]=10;
									pSprout[LabY(i,j-1,k)-1]=1;
									pPericyteDensity[LabY(i,j-1,k)-1]=PericyteDensityInit;
							
									if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j-1,k)-1]=1;} //grown from arterial vessel
									else								{pArterialVenousID[LabY(i,j-1,k)-1]=-1;}//grown from venous vessel

									poleSprout[LabY(i,j-1,k)-1]=false;
									pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

									bKillOldSprout=TRUE;
								}
						
								switch(randBranchDirection)
								{
									case 1: if (pFluid[LabX(i+1,j-1,k)-1]==0 && bBoneTissue[i+1-1][j-1-1][k-1]==FALSE)
											{
												pFluid[LabX(i+1,j-1,k)-1]=10;
												pSprout[LabX(i+1,j-1,k)-1]=1;
												pPericyteDensity[LabX(i+1,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j-1,k)-1]=1;} //grown from arterial vessel
												else 								{pArterialVenousID[LabX(i+1,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i+1,j-1,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;

									case 2: if (pFluid[LabX(i,j-1,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
											{
												pFluid[LabX(i,j-1,k)-1]=10;
												pSprout[LabX(i,j-1,k)-1]=1;
												pPericyteDensity[LabX(i,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i,j-1,k)-1]=false;
												pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;
									
									case 3: if	(k!=m_nz)
											{
												if (pFluid[LabZ(i,j-1,k+1)-1]==0 && bBoneTissue[i-1][j-1-1][k+1-1]==FALSE)
												{
													pFluid[LabZ(i,j-1,k+1)-1]=10;
													pSprout[LabZ(i,j-1,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j-1,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j-1,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i,j-1,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
									break;

									case 4: if	(
													(k!=1 && pFluid[LabZ(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i,j-1,k)-1]==0)
												)
											{
												pFluid[LabZ(i,j-1,k)-1]=10;
												pSprout[LabZ(i,j-1,k)-1]=1;
												pPericyteDensity[LabZ(i,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j-1,k)-1]=false;
												pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;
								}//end randDirection

								if	(bKillOldSprout==TRUE)
								{
									pAgeOfSprout[nby-1]=0.0;
									pSprout[nby-1]=0;
								}

							}//end if j!=1
						}//end if branch
					}//end if MaintainDirection

//-----------------------------------------------

					else
					{
						if	(m_nz==1)	{randBranchDirection=1+int(3*float(rand())/float(RAND_MAX));} 
						else			{randBranchDirection=1+int(10*float(rand())/float(RAND_MAX));} 

						randDice=float(rand())/float(RAND_MAX); //(0,1)

						if	(randDice<probBranch && poleSprout[nby-1]==true)
						{	//NB: poleSprout variable isn't really defined for non-sprout (i.e. vessel) segments.
							//This section will be done anyway and may give a directional bias for branching.
							//All vessels initialised to poleSprout=TRUE in InitialiseVariables.
//if	(i==81 && j==27)	{outfileDebugBone << angiotime << "\t" << randBranchDirection << endl;}
							switch(randBranchDirection)
							{
								case 1: if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
							
										if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 2: if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
							
										if	(
												(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
												||
												(i==1 && pFluid[LabX(i,j,k)-1]==0)
											)
										{															
											pFluid[LabX(i,j,k)-1]=10;
											pSprout[LabX(i,j,k)-1]=1;
											pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabX(i,j,k)-1]=false;
											pAgeOfSprout[LabX(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;
									
								case 3: if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(
												(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
												||
												(i==1 && pFluid[LabX(i,j,k)-1]==0)
											)
										{															
											pFluid[LabX(i,j,k)-1]=10;
											pSprout[LabX(i,j,k)-1]=1;
											pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabX(i,j,k)-1]=false;
											pAgeOfSprout[LabX(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 4:	if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 5:	if	(j!=m_ny)
										{
											if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
											{
												pFluid[LabY(i,j+1,k)-1]=10;
												pSprout[LabY(i,j+1,k)-1]=1;
												pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j+1,k)-1]=true;
												pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 6:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 7:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
										{																
											pFluid[LabX(i+1,j,k)-1]=10;
											pSprout[LabX(i+1,j,k)-1]=1;
											pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

											poleSprout[LabX(i+1,j,k)-1]=true;
											pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}

								break;

								case 8:	if	(
												(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
												||
												(i==1 && pFluid[LabX(i,j,k)-1]==0)
											)
										{															
											pFluid[LabX(i,j,k)-1]=10;
											pSprout[LabX(i,j,k)-1]=1;
											pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabX(i,j,k)-1]=false;
											pAgeOfSprout[LabX(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 9:	if	(
												(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
												||
												(i==1 && pFluid[LabX(i,j,k)-1]==0)
											)
										{															
											pFluid[LabX(i,j,k)-1]=10;
											pSprout[LabX(i,j,k)-1]=1;
											pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabX(i,j,k)-1]=false;
											pAgeOfSprout[LabX(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}
							
										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;

								case 10:if	(k!=m_nz)
										{
											if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
											{																
												pFluid[LabZ(i,j,k+1)-1]=10;
												pSprout[LabZ(i,j,k+1)-1]=1;
												pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

												poleSprout[LabZ(i,j,k+1)-1]=true;
												pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

												bKillOldSprout=TRUE;
											}
										}
							
										if	(
												(k!=1 && pFluid[LabZ(i,j,k)-1]==0 && bBoneTissue[i-1][j-1][k-1-1]==FALSE)
												||
												(k==1 && pFluid[LabZ(i,j,k)-1]==0)
											)
										{
											pFluid[LabZ(i,j,k)-1]=10;
											pSprout[LabZ(i,j,k)-1]=1;
											pPericyteDensity[LabZ(i,j,k)-1]=PericyteDensityInit;
										
											if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j,k)-1]=1;} //grown from arterial vessel
											else								{pArterialVenousID[LabZ(i,j,k)-1]=-1;}//grown from venous vessel
										
											poleSprout[LabZ(i,j,k)-1]=false;
											pAgeOfSprout[LabZ(i,j,k)-1]=0.0;

											bKillOldSprout=TRUE;
										}

										if	(bKillOldSprout==TRUE)
										{
											pAgeOfSprout[nby-1]=0.0;
											pSprout[nby-1]=0;
										}
								break;
							}//end randDirection	
						}//end if branch

//-----------------------------------------------

						if	(randDice<probBranch && poleSprout[nby-1]==false)
						{
							if	(j!=1)
							{
								switch(randBranchDirection)
								{
									case 1: if	(
													(j!=2 && pFluid[LabY(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-2-1][k-1]==FALSE)
													||
													(j==2 && pFluid[LabY(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabY(i,j-1,k)-1]=10;
												pSprout[LabY(i,j-1,k)-1]=1;
												pPericyteDensity[LabY(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j-1,k)-1]=false;
												pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(pFluid[LabX(i+1,j-1,k)-1]==0 && bBoneTissue[i+1-1][j-1-1][k-1]==FALSE)	
											{	
												pFluid[LabX(i+1,j-1,k)-1]=10;									
												pSprout[LabX(i+1,j-1,k)-1]=1;
												pPericyteDensity[LabX(i+1,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i+1,j-1,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
											
											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 2: if	(
													(j!=2 && pFluid[LabY(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-2-1][k-1]==FALSE)
													||
													(j==2 && pFluid[LabY(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabY(i,j-1,k)-1]=10;
												pSprout[LabY(i,j-1,k)-1]=1;
												pPericyteDensity[LabY(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j-1,k)-1]=false;
												pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(
													(i!=1 && pFluid[LabX(i,j-1,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabX(i,j-1,k)-1]=10;
												pSprout[LabX(i,j-1,k)-1]=1;
												pPericyteDensity[LabX(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i,j-1,k)-1]=false;
												pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;
									
									case 3: if	(pFluid[LabX(i+1,j-1,k)-1]==0 && bBoneTissue[i+1-1][j-1-1][k-1]==FALSE)	
											{	
												pFluid[LabX(i+1,j-1,k)-1]=10;									
												pSprout[LabX(i+1,j-1,k)-1]=1;
												pPericyteDensity[LabX(i+1,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i+1,j-1,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(
													(i!=1 && pFluid[LabX(i,j-1,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabX(i,j-1,k)-1]=10;
												pSprout[LabX(i,j-1,k)-1]=1;
												pPericyteDensity[LabX(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i,j-1,k)-1]=false;
												pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 4:	if	(
													(j!=2 && pFluid[LabY(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-2-1][k-1]==FALSE)
													||
													(j==2 && pFluid[LabY(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabY(i,j-1,k)-1]=10;
												pSprout[LabY(i,j-1,k)-1]=1;
												pPericyteDensity[LabY(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j-1,k)-1]=false;
												pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j-1,k+1)-1]==0 && bBoneTissue[i-1][j-1-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i,j-1,k+1)-1]=10;
													pSprout[LabZ(i,j-1,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j-1,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j-1,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i,j-1,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 5:	if	(
													(j!=2 && pFluid[LabY(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-2-1][k-1]==FALSE)
													||
													(j==2 && pFluid[LabY(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabY(i,j-1,k)-1]=10;
												pSprout[LabY(i,j-1,k)-1]=1;
												pPericyteDensity[LabY(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabY(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabY(i,j-1,k)-1]=false;
												pAgeOfSprout[LabY(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(
													(k!=1 && pFluid[LabZ(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i,j-1,k)-1]==0)
												)
											{
												pFluid[LabZ(i,j-1,k)-1]=10;
												pSprout[LabZ(i,j-1,k)-1]=1;
												pPericyteDensity[LabZ(i,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i,j-1,k)-1]=false;
												pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 6:	if	(pFluid[LabX(i+1,j-1,k)-1]==0 && bBoneTissue[i+1-1][j-1-1][k-1]==FALSE)	
											{	
												pFluid[LabX(i+1,j-1,k)-1]=10;									
												pSprout[LabX(i+1,j-1,k)-1]=1;
												pPericyteDensity[LabX(i+1,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i+1,j-1,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j-1,k+1)-1]==0 && bBoneTissue[i-1][j-1-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i,j-1,k+1)-1]=10;
													pSprout[LabZ(i,j-1,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j-1,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j-1,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i,j-1,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 7:	if	(pFluid[LabX(i+1,j-1,k)-1]==0 && bBoneTissue[i+1-1][j-1-1][k-1]==FALSE)	
											{	
												pFluid[LabX(i+1,j-1,k)-1]=10;									
												pSprout[LabX(i+1,j-1,k)-1]=1;
												pPericyteDensity[LabX(i+1,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i+1,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i+1,j-1,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(
													(k!=1 && pFluid[LabZ(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i,j-1,k)-1]==0)
												)
											{
												pFluid[LabZ(i,j-1,k)-1]=10;
												pSprout[LabZ(i,j-1,k)-1]=1;
												pPericyteDensity[LabZ(i,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i,j-1,k)-1]=false;
												pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 8:	if	(
													(i!=1 && pFluid[LabX(i,j-1,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabX(i,j-1,k)-1]=10;
												pSprout[LabX(i,j-1,k)-1]=1;
												pPericyteDensity[LabX(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i,j-1,k)-1]=false;
												pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j-1,k+1)-1]==0 && bBoneTissue[i-1][j-1-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i,j-1,k+1)-1]=10;
													pSprout[LabZ(i,j-1,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j-1,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j-1,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i,j-1,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 9:	if	(
													(i!=1 && pFluid[LabX(i,j-1,k)-1]==0 && bBoneTissue[i-1-1][j-1-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j-1,k)-1]==0)
												)	
											{																
												pFluid[LabX(i,j-1,k)-1]=10;
												pSprout[LabX(i,j-1,k)-1]=1;
												pPericyteDensity[LabX(i,j-1,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabX(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j-1,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i,j-1,k)-1]=false;
												pAgeOfSprout[LabX(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(
													(k!=1 && pFluid[LabZ(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i,j-1,k)-1]==0)
												)
											{
												pFluid[LabZ(i,j-1,k)-1]=10;
												pSprout[LabZ(i,j-1,k)-1]=1;
												pPericyteDensity[LabZ(i,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i,j-1,k)-1]=false;
												pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;

									case 10:if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j-1,k+1)-1]==0 && bBoneTissue[i-1][j-1-1][k+1-1]==FALSE)	
												{
													pFluid[LabZ(i,j-1,k+1)-1]=10;
													pSprout[LabZ(i,j-1,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j-1,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j-1,k+1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabZ(i,j-1,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j-1,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(
													(k!=1 && pFluid[LabZ(i,j-1,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
													||
													(k==1 && pFluid[LabZ(i,j-1,k)-1]==0)
												)
											{
												pFluid[LabZ(i,j-1,k)-1]=10;
												pSprout[LabZ(i,j-1,k)-1]=1;
												pPericyteDensity[LabZ(i,j-1,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nby-1]>0)	{pArterialVenousID[LabZ(i,j-1,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabZ(i,j-1,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabZ(i,j-1,k)-1]=false;
												pAgeOfSprout[LabZ(i,j-1,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nby-1]=0.0;
												pSprout[nby-1]=0;
											}
									break;
								}//end randBranch
							}//end if j!=1
						}//end if branch
					}//end if !MaintainDirection

//-----------------------------------------------

				}//end if can branch

//-----------------------------------------------

//---zBonds--------------------------------------

				probBranch=0.0;
				bKillOldSprout=FALSE;

				if	(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
				{
					if	(b_UU_wound_Model==false)	//Used for tumour angio work
					{
/*						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)		{probBranch=0.1;}//0.0;}//
						else if	(vTAFConc[i-1][j-1][k-1]>0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)		{probBranch=0.4;}//0.2;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX)		{probBranch=0.6;}//0.3;}//
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)		{probBranch=0.8;}//0.4;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)			{probBranch=1.0;}
*/
						if		(vTAFConc[i-1][j-1][k-1]<=0.2)		{probBranch=0.15;}//0.0;}//
						else if	(vTAFConc[i-1][j-1][k-1]>0.2 &&
									vTAFConc[i-1][j-1][k-1]<=0.4)		{probBranch=0.225;}//0.2;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.4 &&
									vTAFConc[i-1][j-1][k-1]<=0.6)		{probBranch=0.3;}//0.3;}//
						else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
									vTAFConc[i-1][j-1][k-1]<=0.8)		{probBranch=0.375;}//0.4;}//
						else if (vTAFConc[i-1][j-1][k-1]>0.8)			{probBranch=0.45;}
					}

					if	(b_UU_wound_Model==true)	//Used for thesis wound sims
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)		{probBranch=0.009;}
						else if	(vTAFConc[i-1][j-1][k-1]>0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX)		{probBranch=0.01;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.98*runningTAFConcMAX)	{probBranch=0.011;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.98*runningTAFConcMAX)		{probBranch=0.012;}
					}
				}
	
				if (bWSS && pOldSprout[nbz-1]==0)
				{				
					if		(ZTauW[i-1][j-1][k-1]<=0.2*runningWSSMAX)      
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.0;}		
					}	

					else if	(ZTauW[i-1][j-1][k-1]>0.2*runningWSSMAX && ZTauW[i-1][j-1][k-1]<=0.4*runningWSSMAX)      
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.02;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.03;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.04;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.1;}		
					}	
				
					else if (ZTauW[i-1][j-1][k-1]>0.4*runningWSSMAX && ZTauW[i-1][j-1][k-1]<=0.6*runningWSSMAX) 
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0.0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX)	{probBranch=0.04;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.06;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.08;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.2;}			
					}

					else if (ZTauW[i-1][j-1][k-1]>0.6*runningWSSMAX && ZTauW[i-1][j-1][k-1]<=0.8*runningWSSMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX) {probBranch=0.06;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.09;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.12;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.3;}			
					}

					else if (ZTauW[i-1][j-1][k-1]>0.8*runningWSSMAX)
					{
						if		(vTAFConc[i-1][j-1][k-1]<=0.3*runningTAFConcMAX)	{probBranch=0;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.3*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.5*runningTAFConcMAX) {probBranch=0.08;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.5*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.7*runningTAFConcMAX) {probBranch=0.12;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.7*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {probBranch=0.16;}
						else if (vTAFConc[i-1][j-1][k-1]>0.8*runningTAFConcMAX)		{probBranch=0.4;}			
					}
				}	//end if WSS

//-----------------------------------------------

				if	(m_nz!=1)
				{
					randBranchDirection=1+int(4*float(rand())/float(RAND_MAX));

					if	(  
							(bWSS && pFluid[nbz-1]==10 && pAgeOfVessel[nbz-1]<=thresholdAgeSup && pAgeOfVessel[nbz-1]>=thresholdAgeInf)
							||
							(pOldSprout[nbz-1]!=0 && pAgeOfSprout[nbz-1]>thresholdAge)
							//pPericyteDensity[nbz-1]<=branchFraction*carryingCapacity
						)
					{
						carryingCapacity=2.0*ZBR[i-1][j-1][k-1]*angioDeltaZ/pow(RadiusPericyte,2);

						if	(bMaintainDirection)
						{
							randDice=float(rand())/float(RAND_MAX); //(0,1)

							if	(randDice<probBranch && poleSprout[nbz-1]==true)
							{
								if	(k!=m_nz)
								{
									if (pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)
									{
										pFluid[LabZ(i,j,k+1)-1]=10;
										pSprout[LabZ(i,j,k+1)-1]=1;
										pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;

										if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
										else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

										poleSprout[LabZ(i,j,k+1)-1]=true;
										pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

										bKillOldSprout=TRUE;
									}
								}
						
								switch(randBranchDirection)
								{
									case 1: if	(pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)
											{
												pFluid[LabX(i+1,j,k)-1]=10;
												pSprout[LabX(i+1,j,k)-1]=1;
												pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i+1,j,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;

									case 2: if	(
													(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j,k)-1]==0)
												)
											{
												pFluid[LabX(i,j,k)-1]=10;
												pSprout[LabX(i,j,k)-1]=1;
												pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
											
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i,j,k)-1]=false;
												pAgeOfSprout[LabX(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;
									
									case 3: if	(j!=m_ny)
											{
												if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
												{
													pFluid[LabY(i,j+1,k)-1]=10;
													pSprout[LabY(i,j+1,k)-1]=1;
													pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
									break;

									case 4: if	(
													(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i,j,k)-1]==0)
												)
											{
												pFluid[LabY(i,j,k)-1]=10;
												pSprout[LabY(i,j,k)-1]=1;
												pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
												else 								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i,j,k)-1]=false;
												pAgeOfSprout[LabY(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
									break;
								}//end randDirection

								if	(bKillOldSprout==TRUE)
								{
									pAgeOfSprout[nbz-1]=0.0;
									pSprout[nbz-1]=0;
								}

							}//end if branch

//-----------------------------------------------

							if(randDice<probBranch && poleSprout[nbz-1]==false)
							{
								if	(k!=1)
								{
									if	(
											(k!=2 && pFluid[LabZ(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1][k-2-1]==FALSE)
											||
											(k==2 && pFluid[LabZ(i,j,k-1)-1]==0)
										)
									{
										pFluid[LabZ(i,j,k-1)-1]=10;
										pSprout[LabZ(i,j,k-1)-1]=1;
										pPericyteDensity[LabZ(i,j,k-1)-1]=PericyteDensityInit;
							
										if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k-1)-1]=1;} //grown from arterial vessel
										else								{pArterialVenousID[LabZ(i,j,k-1)-1]=-1;}//grown from venous vessel
							
										poleSprout[LabZ(i,j,k-1)-1]=false;
										pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

										bKillOldSprout=TRUE;
									}

									switch(randBranchDirection)
									{
										case 1: if	(pFluid[LabX(i+1,j,k-1)-1]==0 && bBoneTissue[i+1-1][j-1][k-1-1]==FALSE)
												{
													pFluid[LabX(i+1,j,k-1)-1]=10;
													pSprout[LabX(i+1,j,k-1)-1]=1;
													pPericyteDensity[LabX(i+1,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i+1,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabX(i+1,j,k-1)-1]=true;
													pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
										break;

										case 2: if	(
														(i!=1 && pFluid[LabX(i,j,k-1)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
														||
														(i==1 && pFluid[LabX(i,j,k-1)-1]==0)
													)
												{
													pFluid[LabX(i,j,k-1)-1]=10;
													pSprout[LabX(i,j,k-1)-1]=1;
													pPericyteDensity[LabX(i,j,k-1)-1]=PericyteDensityInit;
												
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k-1)-1]=1;} //grown from arterial vessel
													else 								{pArterialVenousID[LabX(i,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabX(i,j,k-1)-1]=false;
													pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
										break;
									
										case 3: if	(j!=m_ny)
												{
													if	(pFluid[LabY(i,j+1,k-1)-1]==0 && bBoneTissue[i-1][j+1-1][k-1-1]==FALSE)
													{
														pFluid[LabY(i,j+1,k-1)-1]=10;
														pSprout[LabY(i,j+1,k-1)-1]=1;
														pPericyteDensity[LabY(i,j+1,k-1)-1]=PericyteDensityInit;
										
														if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k-1)-1]=1;} //grown from arterial vessel
														else								{pArterialVenousID[LabY(i,j+1,k-1)-1]=-1;}//grown from venous vessel
										
														poleSprout[LabY(i,j+1,k-1)-1]=true;
														pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;

														bKillOldSprout=TRUE;
													}
												}
										break;

										case 4: if	(
														(j!=1 && pFluid[LabY(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
														||
														(j==1 && pFluid[LabY(i,j,k-1)-1]==0)
													)
												{
													pFluid[LabY(i,j,k-1)-1]=10;
													pSprout[LabY(i,j,k-1)-1]=1;
													pPericyteDensity[LabY(i,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i,j,k-1)-1]=false;
													pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
										break;
									}//end randDirection

									if	(bKillOldSprout==TRUE)
									{
										pAgeOfSprout[nbz-1]=0.0;
										pSprout[nbz-1]=0;
									}

								}//end if k!=1
							}//end if branch
						}//end if MaintainDirection

//-----------------------------------------------
				
						else
						{
							randDice=float(rand())/float(RAND_MAX); //(0,1)

							if	(randDice<probBranch && poleSprout[nbz-1]==true)
							{	//NB: poleSprout variable isn't really defined for non-sprout (i.e. vessel) segments.
								//This section will be done anyway and may give a directional bias for branching.
								//All vessels initialised to poleSprout=TRUE in InitialiseVariables.

								switch(randBranchDirection)
								{
									case 1: if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
												{																
													pFluid[LabZ(i,j,k+1)-1]=10;
													pSprout[LabZ(i,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
							
											if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
											{																
												pFluid[LabX(i+1,j,k)-1]=10;
												pSprout[LabX(i+1,j,k)-1]=1;
												pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i+1,j,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 2: if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
												{																
													pFluid[LabZ(i,j,k+1)-1]=10;
													pSprout[LabZ(i,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
							
											if	(
													(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j,k)-1]==0)
												)
											{															
												pFluid[LabX(i,j,k)-1]=10;
												pSprout[LabX(i,j,k)-1]=1;
												pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i,j,k)-1]=false;
												pAgeOfSprout[LabX(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;
									
									case 3: if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
												{																
													pFluid[LabZ(i,j,k+1)-1]=10;
													pSprout[LabZ(i,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
							
											if	(j!=m_ny)
											{
												if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
												{
													pFluid[LabY(i,j+1,k)-1]=10;
													pSprout[LabY(i,j+1,k)-1]=1;
													pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

													poleSprout[LabY(i,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 4:	if	(k!=m_nz)
											{
												if	(pFluid[LabZ(i,j,k+1)-1]==0 && bBoneTissue[i-1][j-1][k+1-1]==FALSE)	
												{																
													pFluid[LabZ(i,j,k+1)-1]=10;
													pSprout[LabZ(i,j,k+1)-1]=1;
													pPericyteDensity[LabZ(i,j,k+1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k+1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k+1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k+1)-1]=true;
													pAgeOfSprout[LabZ(i,j,k+1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(
													(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i,j,k)-1]==0)
												)
											{
												pFluid[LabY(i,j,k)-1]=10;
												pSprout[LabY(i,j,k)-1]=1;
												pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i,j,k)-1]=false;
												pAgeOfSprout[LabY(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 5:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
											{																
												pFluid[LabX(i+1,j,k)-1]=10;
												pSprout[LabX(i+1,j,k)-1]=1;
												pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i+1,j,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(
													(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j,k)-1]==0)
												)
											{															
												pFluid[LabX(i,j,k)-1]=10;
												pSprout[LabX(i,j,k)-1]=1;
												pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i,j,k)-1]=false;
												pAgeOfSprout[LabX(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 6:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
											{																
												pFluid[LabX(i+1,j,k)-1]=10;
												pSprout[LabX(i+1,j,k)-1]=1;
												pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel

												poleSprout[LabX(i+1,j,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(j!=m_ny)
											{
												if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
												{
													pFluid[LabY(i,j+1,k)-1]=10;
													pSprout[LabY(i,j+1,k)-1]=1;
													pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

													poleSprout[LabY(i,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 7:	if (pFluid[LabX(i+1,j,k)-1]==0 && bBoneTissue[i+1-1][j-1][k-1]==FALSE)	
											{																
												pFluid[LabX(i+1,j,k)-1]=10;
												pSprout[LabX(i+1,j,k)-1]=1;
												pPericyteDensity[LabX(i+1,j,k)-1]=PericyteDensityInit;
							
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i+1,j,k)-1]=-1;}//grown from venous vessel
	
												poleSprout[LabX(i+1,j,k)-1]=true;
												pAgeOfSprout[LabX(i+1,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(
													(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i,j,k)-1]==0)
												)
											{
												pFluid[LabY(i,j,k)-1]=10;
												pSprout[LabY(i,j,k)-1]=1;
												pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i,j,k)-1]=false;
												pAgeOfSprout[LabY(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}

									break;

									case 8:	if	(
													(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j,k)-1]==0)
												)
											{															
												pFluid[LabX(i,j,k)-1]=10;
												pSprout[LabX(i,j,k)-1]=1;
												pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i,j,k)-1]=false;
												pAgeOfSprout[LabX(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(j!=m_ny)
											{
												if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
												{
													pFluid[LabY(i,j+1,k)-1]=10;
													pSprout[LabY(i,j+1,k)-1]=1;
													pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

													poleSprout[LabY(i,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 9:	if	(
													(i!=1 && pFluid[LabX(i,j,k)-1]==0 && bBoneTissue[i-1-1][j-1][k-1]==FALSE)
													||
													(i==1 && pFluid[LabX(i,j,k)-1]==0)
												)
											{															
												pFluid[LabX(i,j,k)-1]=10;
												pSprout[LabX(i,j,k)-1]=1;
												pPericyteDensity[LabX(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabX(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabX(i,j,k)-1]=false;
												pAgeOfSprout[LabX(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}
							
											if	(
													(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i,j,k)-1]==0)
												)
											{
												pFluid[LabY(i,j,k)-1]=10;
												pSprout[LabY(i,j,k)-1]=1;
												pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i,j,k)-1]=false;
												pAgeOfSprout[LabY(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;

									case 10:if	(j!=m_ny)
											{
												if	(pFluid[LabY(i,j+1,k)-1]==0 && bBoneTissue[i-1][j+1-1][k-1]==FALSE)
												{
													pFluid[LabY(i,j+1,k)-1]=10;
													pSprout[LabY(i,j+1,k)-1]=1;
													pPericyteDensity[LabY(i,j+1,k)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j+1,k)-1]=-1;}//grown from venous vessel

													poleSprout[LabY(i,j+1,k)-1]=true;
													pAgeOfSprout[LabY(i,j+1,k)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											}
							
											if	(
													(j!=1 && pFluid[LabY(i,j,k)-1]==0 && bBoneTissue[i-1][j-1-1][k-1]==FALSE)
													||
													(j==1 && pFluid[LabY(i,j,k)-1]==0)
												)
											{
												pFluid[LabY(i,j,k)-1]=10;
												pSprout[LabY(i,j,k)-1]=1;
												pPericyteDensity[LabY(i,j,k)-1]=PericyteDensityInit;
										
												if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k)-1]=1;} //grown from arterial vessel
												else								{pArterialVenousID[LabY(i,j,k)-1]=-1;}//grown from venous vessel
										
												poleSprout[LabY(i,j,k)-1]=false;
												pAgeOfSprout[LabY(i,j,k)-1]=0.0;

												bKillOldSprout=TRUE;
											}

											if	(bKillOldSprout==TRUE)
											{
												pAgeOfSprout[nbz-1]=0.0;
												pSprout[nbz-1]=0;
											}
									break;
								}//end randDirection	
							}//end if branch

//-----------------------------------------------

							if	(randDice<probBranch && poleSprout[nby-1]==false)
							{
								if	(k!=1)
								{
									switch(randBranchDirection)
									{
										case 1: if	(
														(k!=2 && pFluid[LabZ(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1][k-2-1]==FALSE)
														||
														(k==2 && pFluid[LabZ(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabZ(i,j,k-1)-1]=10;
													pSprout[LabZ(i,j,k-1)-1]=1;
													pPericyteDensity[LabZ(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k-1)-1]=false;
													pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
							
												if	(pFluid[LabX(i+1,j,k-1)-1]==0 && bBoneTissue[i+1-1][j-1][k-1-1]==FALSE)	
												{	
													pFluid[LabX(i+1,j,k-1)-1]=10;									
													pSprout[LabX(i+1,j,k-1)-1]=1;
													pPericyteDensity[LabX(i+1,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i+1,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabX(i+1,j,k-1)-1]=true;
													pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
											
												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 2: if	(
														(k!=2 && pFluid[LabZ(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1][k-2-1]==FALSE)
														||
														(k==2 && pFluid[LabZ(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabZ(i,j,k-1)-1]=10;
													pSprout[LabZ(i,j,k-1)-1]=1;
													pPericyteDensity[LabZ(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k-1)-1]=false;
													pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
							
												if	(
														(i!=1 && pFluid[LabX(i,j,k-1)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
														||
														(i==1 && pFluid[LabX(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabX(i,j,k-1)-1]=10;
													pSprout[LabX(i,j,k-1)-1]=1;
													pPericyteDensity[LabX(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabX(i,j,k-1)-1]=false;
													pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;
									
										case 3: if	(
														(k!=2 && pFluid[LabZ(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1][k-2-1]==FALSE)
														||
														(k==2 && pFluid[LabZ(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabZ(i,j,k-1)-1]=10;
													pSprout[LabZ(i,j,k-1)-1]=1;
													pPericyteDensity[LabZ(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k-1)-1]=false;
													pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}
							
												if	(j!=m_ny)
												{
													if	(pFluid[LabY(i,j+1,k-1)-1]==0 && bBoneTissue[i-1][j+1-1][k-1-1]==FALSE)	
													{
														pFluid[LabY(i,j+1,k-1)-1]=10;
														pSprout[LabY(i,j+1,k-1)-1]=1;
														pPericyteDensity[LabY(i,j+1,k-1)-1]=PericyteDensityInit;
										
														if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k-1)-1]=1;} //grown from arterial vessel
														else								{pArterialVenousID[LabY(i,j+1,k-1)-1]=-1;}//grown from venous vessel
										
														poleSprout[LabY(i,j+1,k-1)-1]=true;
														pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;

														bKillOldSprout=TRUE;
													}
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 4:	if	(
														(k!=2 && pFluid[LabZ(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1][k-2-1]==FALSE)
														||
														(k==2 && pFluid[LabZ(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabZ(i,j,k-1)-1]=10;
													pSprout[LabZ(i,j,k-1)-1]=1;
													pPericyteDensity[LabZ(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabZ(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabZ(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabZ(i,j,k-1)-1]=false;
													pAgeOfSprout[LabZ(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(
														(j!=1 && pFluid[LabY(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
														||
														(j==1 && pFluid[LabY(i,j,k-1)-1]==0)
													)
												{
													pFluid[LabY(i,j,k-1)-1]=10;
													pSprout[LabY(i,j,k-1)-1]=1;
													pPericyteDensity[LabY(i,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i,j,k-1)-1]=false;
													pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 5:	if	(pFluid[LabX(i+1,j,k-1)-1]==0 && bBoneTissue[i+1-1][j-1][k-1-1]==FALSE)	
												{	
													pFluid[LabX(i+1,j,k-1)-1]=10;									
													pSprout[LabX(i+1,j,k-1)-1]=1;
													pPericyteDensity[LabX(i+1,j,k-1)-1]=PericyteDensityInit;
											
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i+1,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabX(i+1,j,k-1)-1]=true;
													pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(
														(i!=1 && pFluid[LabX(i,j,k-1)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
														||
														(i==1 && pFluid[LabX(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabX(i,j,k-1)-1]=10;
													pSprout[LabX(i,j,k-1)-1]=1;
													pPericyteDensity[LabX(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabX(i,j,k-1)-1]=false;
													pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 6:	if	(pFluid[LabX(i+1,j,k-1)-1]==0 && bBoneTissue[i+1-1][j-1][k-1-1]==FALSE)	
												{	
													pFluid[LabX(i+1,j,k-1)-1]=10;									
													pSprout[LabX(i+1,j,k-1)-1]=1;
													pPericyteDensity[LabX(i+1,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i+1,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabX(i+1,j,k-1)-1]=true;
													pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(j!=m_ny)
												{
													if	(pFluid[LabY(i,j+1,k-1)-1]==0 && bBoneTissue[i-1][j+1-1][k-1-1]==FALSE)	
													{
														pFluid[LabY(i,j+1,k-1)-1]=10;
														pSprout[LabY(i,j+1,k-1)-1]=1;
														pPericyteDensity[LabY(i,j+1,k-1)-1]=PericyteDensityInit;
										
														if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k-1)-1]=1;} //grown from arterial vessel
														else								{pArterialVenousID[LabY(i,j+1,k-1)-1]=-1;}//grown from venous vessel
										
														poleSprout[LabY(i,j+1,k-1)-1]=true;
														pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;

														bKillOldSprout=TRUE;
													}
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 7:	if	(pFluid[LabX(i+1,j,k-1)-1]==0 && bBoneTissue[i+1-1][j-1][k-1-1]==FALSE)	
												{	
													pFluid[LabX(i+1,j,k-1)-1]=10;									
													pSprout[LabX(i+1,j,k-1)-1]=1;
													pPericyteDensity[LabX(i+1,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i+1,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i+1,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabX(i+1,j,k-1)-1]=true;
													pAgeOfSprout[LabX(i+1,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(
														(j!=1 && pFluid[LabY(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
														||
														(j==1 && pFluid[LabY(i,j,k-1)-1]==0)
													)
												{
													pFluid[LabY(i,j,k-1)-1]=10;
													pSprout[LabY(i,j,k-1)-1]=1;
													pPericyteDensity[LabY(i,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i,j,k-1)-1]=false;
													pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 8:	if	(
														(i!=1 && pFluid[LabX(i,j,k-1)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
														||
														(i==1 && pFluid[LabX(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabX(i,j,k-1)-1]=10;
													pSprout[LabX(i,j,k-1)-1]=1;
													pPericyteDensity[LabX(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabX(i,j,k-1)-1]=false;
													pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(j!=m_ny)
												{
													if	(pFluid[LabY(i,j+1,k-1)-1]==0 && bBoneTissue[i-1][j+1-1][k-1-1]==FALSE)	
													{
														pFluid[LabY(i,j+1,k-1)-1]=10;
														pSprout[LabY(i,j+1,k-1)-1]=1;
														pPericyteDensity[LabY(i,j+1,k-1)-1]=PericyteDensityInit;
										
														if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k-1)-1]=1;} //grown from arterial vessel
														else								{pArterialVenousID[LabY(i,j+1,k-1)-1]=-1;}//grown from venous vessel
										
														poleSprout[LabY(i,j+1,k-1)-1]=true;
														pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;

														bKillOldSprout=TRUE;
													}
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 9:	if	(
														(i!=1 && pFluid[LabX(i,j,k-1)-1]==0 && bBoneTissue[i-1-1][j-1][k-1-1]==FALSE)
														||
														(i==1 && pFluid[LabX(i,j,k-1)-1]==0)
													)	
												{																
													pFluid[LabX(i,j,k-1)-1]=10;
													pSprout[LabX(i,j,k-1)-1]=1;
													pPericyteDensity[LabX(i,j,k-1)-1]=PericyteDensityInit;
							
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabX(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabX(i,j,k-1)-1]=-1;}//grown from venous vessel

													poleSprout[LabX(i,j,k-1)-1]=false;
													pAgeOfSprout[LabX(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(
														(j!=1 && pFluid[LabY(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
														||
														(j==1 && pFluid[LabY(i,j,k-1)-1]==0)
													)
												{
													pFluid[LabY(i,j,k-1)-1]=10;
													pSprout[LabY(i,j,k-1)-1]=1;
													pPericyteDensity[LabY(i,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i,j,k-1)-1]=false;
													pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;

										case 10:if	(j!=m_ny)
												{
													if	(pFluid[LabY(i,j+1,k-1)-1]==0 && bBoneTissue[i-1][j+1-1][k-1-1]==FALSE)	
													{
														pFluid[LabY(i,j+1,k-1)-1]=10;
														pSprout[LabY(i,j+1,k-1)-1]=1;
														pPericyteDensity[LabY(i,j+1,k-1)-1]=PericyteDensityInit;
										
														if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j+1,k-1)-1]=1;} //grown from arterial vessel
														else								{pArterialVenousID[LabY(i,j+1,k-1)-1]=-1;}//grown from venous vessel
										
														poleSprout[LabY(i,j+1,k-1)-1]=true;
														pAgeOfSprout[LabY(i,j+1,k-1)-1]=0.0;

														bKillOldSprout=TRUE;
													}
												}

												if	(
														(j!=1 && pFluid[LabY(i,j,k-1)-1]==0 && bBoneTissue[i-1][j-1-1][k-1-1]==FALSE)
														||
														(j==1 && pFluid[LabY(i,j,k-1)-1]==0)
													)
												{
													pFluid[LabY(i,j,k-1)-1]=10;
													pSprout[LabY(i,j,k-1)-1]=1;
													pPericyteDensity[LabY(i,j,k-1)-1]=PericyteDensityInit;
										
													if	(pArterialVenousID[nbz-1]>0)	{pArterialVenousID[LabY(i,j,k-1)-1]=1;} //grown from arterial vessel
													else								{pArterialVenousID[LabY(i,j,k-1)-1]=-1;}//grown from venous vessel
										
													poleSprout[LabY(i,j,k-1)-1]=false;
													pAgeOfSprout[LabY(i,j,k-1)-1]=0.0;

													bKillOldSprout=TRUE;
												}

												if	(bKillOldSprout==TRUE)
												{
													pAgeOfSprout[nbz-1]=0.0;
													pSprout[nbz-1]=0;
												}
										break;
									}//end randBranch
								}//end if k!=1
							}//end if branch
						}//end !MaintainDirection

//-----------------------------------------------

					}//end if can branch
				}//end if m_nz!=1

//-----------------------------------------------
				
			}
		}
	}

//-----------------------------------------------
		
//---Sprouts reaching boundaries are killed------

	for (k=1;k<=m_nz;k++)
	{	for (j=1;j<=m_ny;j++)
		{	for (i=1;i<=m_nx;i++)
			{   
				nbx=LabX(i,j,k);
				nby=LabY(i,j,k);
				nbz=LabZ(i,j,k);

				if (pSprout[nbx-1]!=0 && i==1)
				{
					pSprout[nbx-1]=0;
					pFluid[nbx-1]=0;
					pPericyteDensity[nbx-1]=0.0;
					pAgeOfSprout[nbx-1]=0.0;
					pArterialVenousID[nbx-1]=0;
				}

/*				if (pSprout[nbx-1]!=0 && i==m_nx)
				{ 
					pSprout[nbx-1]=0;
					pFluid[nbx-1]=0;
					pPericyteDensity[nbx-1]=0.0;
					pAgeOfSprout[nbx-1]=0.0;
					pArterialVenousID[nbx-1]=0;
				}
*/
				if (pSprout[nby-1]!=0 && j==1)	//(pSprout[nby-1]!=0 && poleSprout[nby-1]==false && j==2)
				{
					pSprout[nby-1]=0;
					pFluid[nby-1]=0;
					pPericyteDensity[nby-1]=0.0;
					pAgeOfSprout[nby-1]=0.0;
					pArterialVenousID[nby-1]=0;
				}

				if (pSprout[nby-1]!=0 && j==m_ny)
				{
					pSprout[nby-1]=0;
					pFluid[nby-1]=0;				//comment out to make sure tracer reaches tumour
					pPericyteDensity[nby-1]=0.0;
					pAgeOfSprout[nby-1]=0.0;
					pArterialVenousID[nby-1]=0;
				}

				if (pSprout[nbz-1]!=0 && k==1)
				{
					pSprout[nbz-1]=0;
					pFluid[nbz-1]=0;
					pPericyteDensity[nbz-1]=0.0;
					pAgeOfSprout[nbz-1]=0.0;
					pArterialVenousID[nbz-1]=0;
				}

				if (pSprout[nbz-1]!=0 && k==m_nz)
				{
					pSprout[nbz-1]=0;
					pFluid[nbz-1]=0;
					pPericyteDensity[nbz-1]=0.0;
					pAgeOfSprout[nbz-1]=0.0;
					pArterialVenousID[nbz-1]=0;
				}

			}//end i-loop

			i=m_nx+1;
			nbx=LabX(i,j,k);

			if (pSprout[nbx-1]!=0)
			{
				pSprout[nbx-1]=0;
				pFluid[nbx-1]=0;
				pPericyteDensity[nbx-1]=0.0;
				pAgeOfSprout[nbx-1]=0.0;
				pArterialVenousID[nbx-1]=0;
			}
	}}//end j,k-loops

//-----------------------------------------------
	
	delete [] pOldSprout;
	
}
//*********************************************************

//================================
void CAngioNetDlg::UpdateMDF2()
//================================
{
outfileDebugBone << angiotime << endl;
	// Print out some stuff
	// Get a device context first
	CClientDC graphicsDC(this);

	// Print the loop variable
	CString myString;
	int yval=200; // ?

	int iplus,iminus,jplus,jminus,kplus,kminus;

	double subAngioDeltaT;

	if (m_nz==1)	{subAngioDeltaT=angioDeltaT/2.0;} // for a 2D network
	else			{subAngioDeltaT=angioDeltaT/3.0;} // for a 3D network
 
	double nu=3.0*D_TAF_Scaling;	//rescales for new TAF diffusion coeff;//3.0;3.0 used in all pre-UU work	//decay constant
	double alpha=10.0e-6*D_TAF_Scaling;	//rescales for new TAF diffusion coeff;//10e-6;	//production rate
	double epsilon=0.01*D_TAF_Scaling;	//rescales for new TAF diffusion coeff;//0.01;0.01 used for all pre-UU work    //0.00035;	//Diffusion constant
	double epsilon_bone=epsilon/1.0e10;//
	double diffCoeff_left, diffCoeff_right, diffCoeff_up, diffCoeff_down, diffCoeff_back, diffCoeff_front;
	
	angioDeltaZ=angioDeltaY;

    double* coeffA;
	double* coeffB; 
	double* coeffC;
	double* coeffD;

//--------------------------------------------------------------
// calculation of variables in x-direction [t,t+subAngioDeltaT]
//--------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_nx+1];
	coeffB=new double[m_nx+1];
    coeffC=new double[m_nx+1];
	coeffD=new double[m_nx+1];
//outfileDebugBone << "got here" << endl;
	for (int k=0;k<=m_nz-1;k++)
	{	for (int j=0;j<=m_ny-1;j++)
		{
//-----------------------------------------------
//-----------------------------------------------
			for (int i=0;i<=m_nx;i++) 
			{
//outfileDebugBone << i << endl;
//---Impose zero-flux BCs---
				if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
				if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
				if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
				if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

				if (m_nz==1)	{kminus=k; kplus=k;}

				else 
				{
					if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
					if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
				}

//---Assign D for flux in each direction---
				if	(bBoneTissue[i][j][k]==FALSE)
				{
					if	(i!=0)
					{
						if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=epsilon_bone;}	else	{diffCoeff_left=epsilon;}
					}

					if	(i!=m_nx)
					{
						if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=epsilon_bone;}	else	{diffCoeff_right=epsilon;}
					}

					if	(j!=0)
					{
						if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=epsilon_bone;}	else	{diffCoeff_up=epsilon;}
					}

					if	(j!=m_ny-1)
					{
						if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=epsilon_bone;}	else	{diffCoeff_down=epsilon;}
					}

					if	(k!=0)
					{
						if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=epsilon_bone;}	else	{diffCoeff_back=epsilon;}
					}

					if	(k!=m_nz-1)
					{
						if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=epsilon_bone;}	else	{diffCoeff_front=epsilon;}
					}
				}

				else
				{
					diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=epsilon_bone;
				}
				
//---Match up D values for consistent BCs---
				if	(i==0)		{diffCoeff_left=diffCoeff_right;}
				if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
				if	(j==0)		{diffCoeff_up=diffCoeff_down;}
				if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
				if	(m_nz!=1)
				{
					if	(k==0)		{diffCoeff_back=diffCoeff_front;}
					if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
				}

				else
				{
					diffCoeff_back=diffCoeff_front=epsilon;
				}
				
//---Update MDF (x direction implicit)---
				coeffA[i]=-diffCoeff_left*subAngioDeltaT/angioDeltaX/angioDeltaX;
				coeffB[i]=1.0+(diffCoeff_left+diffCoeff_right)*subAngioDeltaT/angioDeltaX/angioDeltaX;
				coeffC[i]=-diffCoeff_right*subAngioDeltaT/angioDeltaX/angioDeltaX;

				coeffD[i]=	vOldMDFConc[i][j][k]
							+	subAngioDeltaT*	( 
														alpha*vSproutsTips[i][j][k]-nu*vOldMDFConc[i][j][k]
													+	(diffCoeff_up*vOldMDFConc[i][jminus][k]-(diffCoeff_up+diffCoeff_down)*vOldMDFConc[i][j][k]
															+diffCoeff_down*vOldMDFConc[i][jplus][k])/angioDeltaY/angioDeltaY
													+	(diffCoeff_back*vOldMDFConc[i][j][kminus]-(diffCoeff_back+diffCoeff_front)*vOldMDFConc[i][j][k]
															+diffCoeff_front*vOldMDFConc[i][j][kplus])/angioDeltaZ/angioDeltaZ
												);
			}//end loop i

//-----------------------------------------------
//-----------------------------------------------

			SolveTridiagMDFX(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);
	
	}}//end j, k loops
//outfileDebugBone << "got here" << endl;
//---Update old MDF values---
	OverWriteOldWithNewMDF();
	
	
//-------------------------------------------------------------------------------
// calculation of variables in y-direction [t+subAngioDeltaT,t+2*subAngioDeltaT]
//-------------------------------------------------------------------------------

	coeffA=coeffB=coeffC=coeffD=NULL;
	coeffA=new double[m_ny];
	coeffB=new double[m_ny];
    coeffC=new double[m_ny];
	coeffD=new double[m_ny];
 
	for (int k=0;k<=m_nz-1;k++)
	{   for ( int i=0;i<=m_nx;i++)
		{
//-----------------------------------------------
//-----------------------------------------------
			for (int j=0;j<=m_ny-1;j++) 
			{
//---Impose zero-flux BCs---
				if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
				if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
				if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
				if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

				if (m_nz==1)	{kminus=k; kplus=k;}

				else 
				{
					if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
					if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
				}

//---Assign D for flux in each direction---
				if	(bBoneTissue[i][j][k]==FALSE)
				{
					if	(i!=0)
					{
						if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=epsilon_bone;}	else	{diffCoeff_left=epsilon;}
					}

					if	(i!=m_nx)
					{
						if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=epsilon_bone;}	else	{diffCoeff_right=epsilon;}
					}

					if	(j!=0)
					{
						if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=epsilon_bone;}	else	{diffCoeff_up=epsilon;}
					}

					if	(j!=m_ny-1)
					{
						if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=epsilon_bone;}	else	{diffCoeff_down=epsilon;}
					}

					if	(k!=0)
					{
						if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=epsilon_bone;}	else	{diffCoeff_back=epsilon;}
					}

					if	(k!=m_nz-1)
					{
						if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=epsilon_bone;}	else	{diffCoeff_front=epsilon;}
					}
				}

				else
				{
					diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=epsilon_bone;
				}
				
//---Match up D values for consistent BCs---
				if	(i==0)		{diffCoeff_left=diffCoeff_right;}
				if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
				if	(j==0)		{diffCoeff_up=diffCoeff_down;}
				if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
				if	(m_nz!=1)
				{
					if	(k==0)		{diffCoeff_back=diffCoeff_front;}
					if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
				}

				else
				{
					diffCoeff_back=diffCoeff_front=epsilon;
				}

//---Update MDF (y direction implicit)---
				coeffA[j]=-diffCoeff_up*subAngioDeltaT/angioDeltaY/angioDeltaY;
				coeffB[j]=1.0+(diffCoeff_up+diffCoeff_down)*subAngioDeltaT/angioDeltaY/angioDeltaY;
				coeffC[j]=-diffCoeff_down*subAngioDeltaT/angioDeltaY/angioDeltaY;

				coeffD[j]=	vOldMDFConc[i][j][k]
							+	subAngioDeltaT*	( 
														alpha*vSproutsTips[i][j][k]-nu*vOldMDFConc[i][j][k]
													+	(diffCoeff_left*vOldMDFConc[iminus][j][k]-(diffCoeff_left+diffCoeff_right)*vOldMDFConc[i][j][k]
															+diffCoeff_right*vOldMDFConc[iplus][j][k])/angioDeltaX/angioDeltaX
													+	(diffCoeff_back*vOldMDFConc[i][j][kminus]-(diffCoeff_back+diffCoeff_front)*vOldMDFConc[i][j][k]
															+diffCoeff_front*vOldMDFConc[i][j][kplus])/angioDeltaZ/angioDeltaZ
												);

			} // end loop j

//-----------------------------------------------
//-----------------------------------------------

			SolveTridiagMDFY(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

	}}//end i, k loops
//outfileDebugBone << "got here" << endl; 
//---Update old MDF values---
	OverWriteOldWithNewMDF(); 
								

//----------------------------------------------------------------------------
// calculation of variables in z-direction [t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz not equal to 1 (i.e. 3D network)
//----------------------------------------------------------------------------

	if (m_nz!=1)
	{
		coeffA=coeffB=coeffC=coeffD=NULL;
		coeffA=new double[m_nz];
		coeffB=new double[m_nz];
		coeffC=new double[m_nz];
		coeffD=new double[m_nz];

		for (int i=0;i<=m_nx;i++)
		{   for (int j=0;j<=m_ny-1;j++)
			{
//-----------------------------------------------
//-----------------------------------------------
				for (int k=0;k<=m_nz-1;k++) 
				{	
//---Impose zero-flux BCs---
					if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
					if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
					if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
					if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}
					if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
					if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}

//---Assign D for flux in each direction---
					if	(bBoneTissue[i][j][k]==FALSE)
					{
						if	(i!=0)
						{
							if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=epsilon_bone;}	else	{diffCoeff_left=epsilon;}
						}

						if	(i!=m_nx)
						{
							if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=epsilon_bone;}	else	{diffCoeff_right=epsilon;}
						}

						if	(j!=0)
						{
							if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=epsilon_bone;}	else	{diffCoeff_up=epsilon;}
						}

						if	(j!=m_ny-1)
						{
							if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=epsilon_bone;}	else	{diffCoeff_down=epsilon;}
						}

						if	(k!=0)
						{
							if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=epsilon_bone;}	else	{diffCoeff_back=epsilon;}
						}

						if	(k!=m_nz-1)
						{
							if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=epsilon_bone;}	else	{diffCoeff_front=epsilon;}
						}
					}

					else
					{
						diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=epsilon_bone;
					}
				
//---Match up D values for consistent BCs---
					if	(i==0)		{diffCoeff_left=diffCoeff_right;}
					if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
					if	(j==0)		{diffCoeff_up=diffCoeff_down;}
					if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
					if	(k==0)		{diffCoeff_back=diffCoeff_front;}
					if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
				
//---Update MDF (z direction implicit)---
					coeffA[k]=-diffCoeff_back*subAngioDeltaT/angioDeltaZ/angioDeltaZ;
					coeffB[k]=1.0+(diffCoeff_back+diffCoeff_front)*subAngioDeltaT/angioDeltaZ/angioDeltaZ;
					coeffC[k]=-diffCoeff_front*subAngioDeltaT/angioDeltaZ/angioDeltaZ;

					coeffD[k]=	vOldMDFConc[i][j][k]
								+	subAngioDeltaT*	( 
															alpha*vSproutsTips[i][j][k]-nu*vOldMDFConc[i][j][k]
														+	(diffCoeff_left*vOldMDFConc[iminus][j][k]-(diffCoeff_left+diffCoeff_right)*vOldMDFConc[i][j][k]
																+diffCoeff_right*vOldMDFConc[iplus][j][k])/angioDeltaX/angioDeltaX
														+	(diffCoeff_up*vOldMDFConc[i][jminus][k]-(diffCoeff_up+diffCoeff_down)*vOldMDFConc[i][j][k]
																+diffCoeff_down*vOldMDFConc[i][jplus][k])/angioDeltaY/angioDeltaY
													);
				}//end loop k

//-----------------------------------------------
//-----------------------------------------------

				SolveTridiagMDFZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

		}}//end i, j loops

	}//end if m_nz!=1

//---Update old MDF values---
	  OverWriteOldWithNewMDF();

//outfileDebugBone << "got here" << endl;
//-----------------------------------------------
//-----------------------------------------------

//---Get new running MDFConc maximum---
	runningMDFConcMAX=0.0; //used for graphics

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
//				outfileDebugBone << i << "\t" << j << "\t" << vMDFConc[i][j][k] << endl;
				if (vMDFConc[i][j][k]>runningMDFConcMAX)
				{	
					runningMDFConcMAX=vMDFConc[i][j][k];
				}		
	}}}

//---Delete arrays---
	delete [] coeffA;
	delete [] coeffB;
	delete [] coeffC;
	delete [] coeffD;
//outfileDebugBone << "got here" << endl;	
//-----------------------------------------------
}
//*********************************************************

//==========================================
void CAngioNetDlg::SolveInitialTAFConc(void)
//==========================================
{
	double TAFChange=0.0;
	double TAFChangeMAX=1.0e20;

	double*** vStoredOldTAFConc=NULL;
	bool*** bTAFSource=NULL;

	vStoredOldTAFConc=new double** [m_nx+1]; //m_nx+1 tissue blocks
	bTAFSource=new bool** [m_nx+1]; //m_nx+1 tissue blocks

	for (int i=0;i<=m_nx;i++)
	{    
		vStoredOldTAFConc[i]=new double* [m_ny];
		bTAFSource[i]=new bool* [m_ny];
	}

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	 
			vStoredOldTAFConc[i][j]=new double [m_nz];
			bTAFSource[i][j]=new bool [m_nz];
		}
	}

//-----------------------------------------
	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
				vStoredOldTAFConc[i-1][j-1][k-1]=0.0;
				bTAFSource[i-1][j-1][k-1]=FALSE;
			}
		}
	}
//-----------------------------------------------
//	outfileDebugBone<<"got to clustering"<<endl;
//---Distribute TAF sources---
	BoneClustering(pIclusBone, 0);	//identify clusters of bone-free nodes to prevent TAF sources fully encased in bone
//	outfileDebugBone<<"got past clustering"<<endl;
	double throwDice;
	double SourceFraction=0.002;//0.01;//0.025;//0.05;//0.1;//0.4;//0.7;//1.0;//0.25;//0.5;//0.75;//
	double R_source=500.0;//200.0;//350.0;//1200.0;//	//microns

	for (int k=1;k<=m_nz;k++)
	{	for (int j=1;j<=m_ny;j++)
		{	for (int i=1;i<=m_nx+1;i++)
			{
//if (pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]!=1 && pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]!=1000000)	{outfileDebugBone<<i<<"\t"<<j<<"\t"<<pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]<<endl;}

				double r=20.0*sqrt(pow((double(i)-double(m_nx/2)),2.0)+pow((double(j)-double(m_ny/2)),2.0)+pow((double(k)-double(m_nz/2)),2.0));

				if (r<=R_source)
				{

//				if	(i>2 && j>=int(m_ny/5)+1 && i<m_nx-2 && j<int(4*m_ny/5)+1 && k>=int(m_nz/5)+1 && k<int(4*m_nz/5)+1)
//				{

					if	(bBoneTissue[i-1][j-1][k-1]==FALSE && pIclusBone[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]==1)
					{
						throwDice=float(rand())/float(RAND_MAX); // random number between 0 and 1

						if	(throwDice<SourceFraction)
						{
							bTAFSource[i-1][j-1][k-1]=TRUE;
//							outfileDebugBone<<"TAFSource"<<endl;
						}
					}
				}
			}
		}
	}
//-----------------------------------------------

	// Print out some stuff
	// Get a device context first
	CClientDC graphicsDC(this);

	// Print the loop variable
	CString myString;
	int yval=200; // ?

	int iplus,iminus,jplus,jminus,kplus,kminus;

	double TAF_DeltaT=0.00036;//0.005;//
	double subTAF_DeltaT;

	if (m_nz==1)	{subTAF_DeltaT=TAF_DeltaT/2.0;} //for 2D network
	else			{subTAF_DeltaT=TAF_DeltaT/3.0;} //for 3D network
 
	double nu=6.0;//0.1;//4.0e-6;//							//decay constant
	double alpha=6.3;//1.0;//1.0e-3;//1.0e-5;//5.0e-3;//					//production rate
	double epsilon=0.1;//0.04;//					//diffusion constant
	double epsilon_bone=epsilon/1.0e10;

	double diffCoeff_left, diffCoeff_right, diffCoeff_up, diffCoeff_down, diffCoeff_back, diffCoeff_front;
	
	angioDeltaZ=angioDeltaY;

	runningTAFConcMAX=1.0e-20;

	while (TAFChangeMAX/runningTAFConcMAX>5.0e-5)//1.0e-6
	{
outfileDebugBone<<TAFChangeMAX<<"\t"<<runningTAFConcMAX<<"\t"<<TAFChangeMAX/runningTAFConcMAX<<endl;

		TAFChangeMAX=0.0;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx+1;i++)
				{
					vStoredOldTAFConc[i-1][j-1][k-1]=vTAFConc[i-1][j-1][k-1];
				}
			}
		}
//--------------------------------------------------

		double* coeffA;
		double* coeffB; 
		double* coeffC;
		double* coeffD;

//--------------------------------------------------------------
// calculation of variables in x-direction [t,t+subAngioDeltaT]
//--------------------------------------------------------------

		coeffA=coeffB=coeffC=coeffD=NULL;
		coeffA=new double[m_nx+1];
		coeffB=new double[m_nx+1];
		coeffC=new double[m_nx+1];
		coeffD=new double[m_nx+1];

		for (int k=0;k<=m_nz-1;k++)
		{	for (int j=0;j<=m_ny-1;j++)
			{
//-----------------------------------------------
//-----------------------------------------------
				for (int i=0;i<=m_nx;i++) 
				{
//---Impose zero-flux BCs---
					if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
					if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
					if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
					if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

					if (m_nz==1)	{kminus=k; kplus=k;}

					else 
					{
						if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
						if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
					}

//---Assign D for flux in each direction---
					if	(bBoneTissue[i][j][k]==FALSE)
					{
						if	(i!=0)
						{
							if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=epsilon_bone;}	else	{diffCoeff_left=epsilon;}
						}

						if	(i!=m_nx)
						{
							if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=epsilon_bone;}	else	{diffCoeff_right=epsilon;}
						}

						if	(j!=0)
						{
							if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=epsilon_bone;}	else	{diffCoeff_up=epsilon;}
						}

						if	(j!=m_ny-1)
						{
							if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=epsilon_bone;}	else	{diffCoeff_down=epsilon;}
						}

						if	(k!=0)
						{
							if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=epsilon_bone;}	else	{diffCoeff_back=epsilon;}
						}

						if	(k!=m_nz-1)
						{
							if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=epsilon_bone;}	else	{diffCoeff_front=epsilon;}
						}
					}

					else
					{
						diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=epsilon_bone;
					}
				
//---Match up D values for consistent BCs---
					if	(i==0)		{diffCoeff_left=diffCoeff_right;}
					if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
					if	(j==0)		{diffCoeff_up=diffCoeff_down;}
					if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
					if	(m_nz!=1)
					{
						if	(k==0)		{diffCoeff_back=diffCoeff_front;}
						if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
					}

					else
					{
						diffCoeff_back=diffCoeff_front=epsilon;
					}
				
//---Update MDF (x direction implicit)---
					coeffA[i]=-diffCoeff_left*subTAF_DeltaT/angioDeltaX/angioDeltaX;
					coeffB[i]=1.0+(diffCoeff_left+diffCoeff_right)*subTAF_DeltaT/angioDeltaX/angioDeltaX;
					coeffC[i]=-diffCoeff_right*subTAF_DeltaT/angioDeltaX/angioDeltaX;

					coeffD[i]=	vOldTAFConc[i][j][k]
								+	subTAF_DeltaT*	( 
															alpha*bTAFSource[i][j][k]-nu*vOldTAFConc[i][j][k]
														+	(diffCoeff_up*vOldTAFConc[i][jminus][k]-(diffCoeff_up+diffCoeff_down)*vOldTAFConc[i][j][k]
																+diffCoeff_down*vOldTAFConc[i][jplus][k])/angioDeltaY/angioDeltaY
														+	(diffCoeff_back*vOldTAFConc[i][j][kminus]-(diffCoeff_back+diffCoeff_front)*vOldTAFConc[i][j][k]
																+diffCoeff_front*vOldTAFConc[i][j][kplus])/angioDeltaZ/angioDeltaZ
													);

/*if (j==m_ny/2)
{
outfileDebugBone<<i<<"\t"<<j<<"\t"<<k<<"\t"<<coeffA[i]<<"\t"<<coeffB[i]<<"\t"<<coeffC[i]<<"\t"<<vOldTAFConc[i][j][k]<<"\t"<<subTAF_DeltaT<<"\t"<<
	alpha*bTAFSource[i][j][k]<<"\t"<<-nu*vOldTAFConc[i][j][k]<<"\t"<<diffCoeff_up*vOldTAFConc[i][jminus][k]<<"\t"<<
		-(diffCoeff_up+diffCoeff_down)*vOldTAFConc[i][j][k]<<"\t"<<diffCoeff_down*vOldTAFConc[i][jplus][k]<<"\t"<<
			diffCoeff_back*vOldTAFConc[i][j][kminus]<<"\t"<<-(diffCoeff_back+diffCoeff_front)*vOldTAFConc[i][j][k]<<"\t"<<
				diffCoeff_front*vOldTAFConc[i][j][kplus]<<endl;
}*/
				}//end loop i

//-----------------------------------------------
//-----------------------------------------------

				SolveTridiagTAFX(m_nx,m_ny,m_nz,j,k,coeffA,coeffB,coeffC,coeffD);
	
		}}//end j, k loops

//---Update old TAF values---
		OverWriteOldWithNewTAF();
	
	
//-------------------------------------------------------------------------------
// calculation of variables in y-direction [t+subAngioDeltaT,t+2*subAngioDeltaT]
//-------------------------------------------------------------------------------

		coeffA=coeffB=coeffC=coeffD=NULL;
		coeffA=new double[m_ny];
		coeffB=new double[m_ny];
		coeffC=new double[m_ny];
		coeffD=new double[m_ny];
 
		for (int k=0;k<=m_nz-1;k++)
		{   for ( int i=0;i<=m_nx;i++)
			{
//-----------------------------------------------
//-----------------------------------------------
				for (int j=0;j<=m_ny-1;j++) 
				{
//---Impose zero-flux BCs---
					if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
					if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
					if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
					if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}

					if (m_nz==1)	{kminus=k; kplus=k;}

					else 
					{
						if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
						if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}
					}

//---Assign D for flux in each direction---
					if	(bBoneTissue[i][j][k]==FALSE)
					{
						if	(i!=0)
						{
							if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=epsilon_bone;}	else	{diffCoeff_left=epsilon;}
						}

						if	(i!=m_nx)
						{
							if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=epsilon_bone;}	else	{diffCoeff_right=epsilon;}
						}

						if	(j!=0)
						{
							if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=epsilon_bone;}	else	{diffCoeff_up=epsilon;}
						}

						if	(j!=m_ny-1)
						{
							if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=epsilon_bone;}	else	{diffCoeff_down=epsilon;}
						}

						if	(k!=0)
						{
							if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=epsilon_bone;}	else	{diffCoeff_back=epsilon;}
						}

						if	(k!=m_nz-1)
						{
							if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=epsilon_bone;}	else	{diffCoeff_front=epsilon;}
						}
					}

					else
					{
						diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=epsilon_bone;
					}
				
//---Match up D values for consistent BCs---
					if	(i==0)		{diffCoeff_left=diffCoeff_right;}
					if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
					if	(j==0)		{diffCoeff_up=diffCoeff_down;}
					if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
				
					if	(m_nz!=1)
					{
						if	(k==0)		{diffCoeff_back=diffCoeff_front;}
						if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
					}

					else
					{
						diffCoeff_back=diffCoeff_front=epsilon;
					}

//---Update MDF (y direction implicit)---
					coeffA[j]=-diffCoeff_up*subTAF_DeltaT/angioDeltaY/angioDeltaY;
					coeffB[j]=1.0+(diffCoeff_up+diffCoeff_down)*subTAF_DeltaT/angioDeltaY/angioDeltaY;
					coeffC[j]=-diffCoeff_down*subTAF_DeltaT/angioDeltaY/angioDeltaY;

					coeffD[j]=	vOldTAFConc[i][j][k]
								+	subTAF_DeltaT*	( 
															alpha*bTAFSource[i][j][k]-nu*vOldTAFConc[i][j][k]
														+	(diffCoeff_left*vOldTAFConc[iminus][j][k]-(diffCoeff_left+diffCoeff_right)*vOldTAFConc[i][j][k]
																+diffCoeff_right*vOldTAFConc[iplus][j][k])/angioDeltaX/angioDeltaX
														+	(diffCoeff_back*vOldTAFConc[i][j][kminus]-(diffCoeff_back+diffCoeff_front)*vOldTAFConc[i][j][k]
																+diffCoeff_front*vOldTAFConc[i][j][kplus])/angioDeltaZ/angioDeltaZ
													);
/*if(j==m_ny/2)
{
outfileDebugBone<<i<<"\t"<<j<<"\t"<<k<<"\t"<<coeffA[j]<<"\t"<<coeffB[j]<<"\t"<<coeffC[j]<<"\t"<<vOldTAFConc[i][j][k]<<"\t"<<subTAF_DeltaT<<"\t"<<
	alpha*bTAFSource[i][j][k]<<"\t"<<-nu*vOldTAFConc[i][j][k]<<"\t"<<diffCoeff_left*vOldTAFConc[iminus][j][k]<<"\t"<<
		-(diffCoeff_left+diffCoeff_right)*vOldTAFConc[i][j][k]<<"\t"<<diffCoeff_right*vOldTAFConc[iplus][j][k]<<"\t"<<
			diffCoeff_back*vOldTAFConc[i][j][kminus]<<"\t"<<-(diffCoeff_back+diffCoeff_front)*vOldTAFConc[i][j][k]<<"\t"<<
				diffCoeff_front*vOldTAFConc[i][j][kplus]<<endl;
}*/

				} // end loop j

//-----------------------------------------------
//-----------------------------------------------

				SolveTridiagTAFY(m_nx,m_ny,m_nz,i,k,coeffA,coeffB,coeffC,coeffD);

		}}//end i, k loops

//---Update old TAF values---
		OverWriteOldWithNewTAF(); 
								

//----------------------------------------------------------------------------
// calculation of variables in z-direction [t+2*subAngioDeltaT,t+angioDeltaT]
// only if m_nz not equal to 1 (i.e. 3D network)
//----------------------------------------------------------------------------

		if (m_nz!=1)
		{
			coeffA=coeffB=coeffC=coeffD=NULL;
			coeffA=new double[m_nz];
			coeffB=new double[m_nz];
			coeffC=new double[m_nz];
			coeffD=new double[m_nz];

			for (int i=0;i<=m_nx;i++)
			{   for (int j=0;j<=m_ny-1;j++)
				{
//-----------------------------------------------
//-----------------------------------------------
					for (int k=0;k<=m_nz-1;k++) 
					{	
//---Impose zero-flux BCs---
						if (i==0)		{iminus=i+1;}	else	{iminus=i-1;}
						if (i==m_nx)	{iplus=m_nx-1;}	else	{iplus=i+1;}
						if (j==0)		{jminus=j+1;}	else	{jminus=j-1;}
						if (j==m_ny-1)	{jplus=m_ny-2;} else	{jplus=j+1;}
						if (k==0)		{kminus=k+1;}	else	{kminus=k-1;}
						if (k==m_nz-1)	{kplus=m_nz-2;}	else	{kplus=k+1;}

//---Assign D for flux in each direction---
						if	(bBoneTissue[i][j][k]==FALSE)
						{
							if	(i!=0)
							{
								if	(bBoneTissue[iminus][j][k]==TRUE)	{diffCoeff_left=epsilon_bone;}	else	{diffCoeff_left=epsilon;}
							}

							if	(i!=m_nx)
							{
								if	(bBoneTissue[iplus][j][k]==TRUE)	{diffCoeff_right=epsilon_bone;}	else	{diffCoeff_right=epsilon;}
							}

							if	(j!=0)
							{
								if	(bBoneTissue[i][jminus][k]==TRUE)	{diffCoeff_up=epsilon_bone;}	else	{diffCoeff_up=epsilon;}
							}

							if	(j!=m_ny-1)
							{
								if	(bBoneTissue[i][jplus][k]==TRUE)	{diffCoeff_down=epsilon_bone;}	else	{diffCoeff_down=epsilon;}
							}

							if	(k!=0)
							{
								if	(bBoneTissue[i][j][kminus]==TRUE)	{diffCoeff_back=epsilon_bone;}	else	{diffCoeff_back=epsilon;}
							}

							if	(k!=m_nz-1)
							{
								if	(bBoneTissue[i][j][kplus]==TRUE)	{diffCoeff_front=epsilon_bone;}	else	{diffCoeff_front=epsilon;}
							}
						}

						else
						{
							diffCoeff_left=diffCoeff_right=diffCoeff_up=diffCoeff_down=diffCoeff_back=diffCoeff_front=epsilon_bone;
						}
				
//---Match up D values for consistent BCs---
						if	(i==0)		{diffCoeff_left=diffCoeff_right;}
						if	(i==m_nx)	{diffCoeff_right=diffCoeff_left;}
						if	(j==0)		{diffCoeff_up=diffCoeff_down;}
						if	(j==m_ny-1)	{diffCoeff_down=diffCoeff_up;}
						if	(k==0)		{diffCoeff_back=diffCoeff_front;}
						if	(k==m_nz-1)	{diffCoeff_front=diffCoeff_back;}
				
//---Update MDF (z direction implicit)---
						coeffA[k]=-diffCoeff_back*subTAF_DeltaT/angioDeltaZ/angioDeltaZ;
						coeffB[k]=1.0+(diffCoeff_back+diffCoeff_front)*subTAF_DeltaT/angioDeltaZ/angioDeltaZ;
						coeffC[k]=-diffCoeff_front*subTAF_DeltaT/angioDeltaZ/angioDeltaZ;

						coeffD[k]=	vOldTAFConc[i][j][k]
									+	subTAF_DeltaT*	( 
																alpha*bTAFSource[i][j][k]-nu*vOldTAFConc[i][j][k]
															+	(diffCoeff_left*vOldTAFConc[iminus][j][k]-(diffCoeff_left+diffCoeff_right)*vOldTAFConc[i][j][k]
																	+diffCoeff_right*vOldTAFConc[iplus][j][k])/angioDeltaX/angioDeltaX
															+	(diffCoeff_up*vOldTAFConc[i][jminus][k]-(diffCoeff_up+diffCoeff_down)*vOldTAFConc[i][j][k]
																	+diffCoeff_down*vOldTAFConc[i][jplus][k])/angioDeltaY/angioDeltaY
														);
/*if(j==m_ny/2)
{
outfileDebugBone<<i<<"\t"<<j<<"\t"<<k<<"\t"<<coeffA[k]<<"\t"<<coeffB[k]<<"\t"<<coeffC[k]<<"\t"<<vOldTAFConc[i][j][k]<<"\t"<<subTAF_DeltaT<<"\t"<<
	alpha*bTAFSource[i][j][k]<<"\t"<<-nu*vOldTAFConc[i][j][k]<<"\t"<<diffCoeff_left*vOldTAFConc[iminus][j][k]<<"\t"<<
		-(diffCoeff_left+diffCoeff_right)*vOldTAFConc[i][j][k]<<"\t"<<diffCoeff_right*vOldTAFConc[iplus][j][k]<<"\t"<<
			diffCoeff_up*vOldTAFConc[i][jminus][k]<<"\t"<<-(diffCoeff_up+diffCoeff_down)*vOldTAFConc[i][j][k]<<"\t"<<
				diffCoeff_down*vOldTAFConc[i][jplus][k]<<endl;
}*/
					}//end loop k

//-----------------------------------------------
//-----------------------------------------------

					SolveTridiagTAFZ(m_nx,m_ny,m_nz,i,j,coeffA,coeffB,coeffC,coeffD);

			}}//end i, j loops

		}//end if m_nz!=1

//---Update old MDF values---
		OverWriteOldWithNewTAF();

//-----------------------------------------------
//-----------------------------------------------

//---Delete arrays---
		delete [] coeffA;
		delete [] coeffB;
		delete [] coeffC;
		delete [] coeffD;

//-----------------------------------------------
int iMAX, jMAX, kMAX;

		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx+1;i++)
				{
					TAFChange=fabs(vStoredOldTAFConc[i-1][j-1][k-1]-vTAFConc[i-1][j-1][k-1]);

					if	(TAFChange>TAFChangeMAX)	{TAFChangeMAX=TAFChange;}

					if (vTAFConc[i-1][j-1][k-1]>runningTAFConcMAX)	{runningTAFConcMAX=vTAFConc[i-1][j-1][k-1];iMAX=i;jMAX=j;kMAX=k;}
				}
			}
		}
//outfileDebugBone<<"running TAF max = "<<runningTAFConcMAX<<"\t"<<"("<<iMAX<<", "<<jMAX<<", "<<kMAX<<")"<<endl;
		OnDrawIt3();
		ProcessMessageLoop();
		UpdateData();
//-----------------------------------------------
	}	//end while loop

//-----------------------------------------------
	for (int i=1;i<=m_nx+1;i++)
	{	for (int j=1;j<=m_ny;j++)
		{
			delete[] vStoredOldTAFConc[i-1][j-1];
			delete[] bTAFSource[i-1][j-1];
		}
	}

	for (int i=1;i<=m_nx+1;i++)
	{
		delete[] vStoredOldTAFConc[i-1];
		delete[] bTAFSource[i-1];
	}

	delete [] vStoredOldTAFConc;
	delete[] bTAFSource;

//-----------------------------------------------
//---Normalise TAF values---
	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{//outfileDebugBone<<i<<"\t"<<j<<"\t"<<vTAFConc[i][j][k]<<"\t"<<runningTAFConcMAX<<"\t"<<vTAFConc[i][j][k]/runningTAFConcMAX<<endl;
				vTAFConc[i][j][k]=vTAFConc[i][j][k]/runningTAFConcMAX;//*0.86744;
	}}}

	runningTAFConcMAX=1.0;//*0.86744;

//-----------------------------------------------

	for (int i=0;i<=m_nx;i++)
	{	for (int j=0;j<=m_ny-1;j++)
		{	for (int k=0;k<=m_nz-1;k++)
			{
				vOldTAFConc[i][j][k]=vTAFConc[i][j][k];
//				if(k==24&&i==24){outfileDebugBone<<vTAFConc[i][j][k]<<endl;}
	}}}
//-----------------------------------------------    
}
//*********************************************************

//=================================================================
void CAngioNetDlg::TAFConcGraphics2(int xMin, int xMax, int yMin,
									 int yMax, int networkWidth, 
									 double deltaX, double deltaY)
//=================================================================
 {
	//Get a device context first
	CClientDC graphicsDC(this);

	//---- MODIF A.S. -----------------------
	  CDC memDC;
	  CBitmap memBMP;
      memDC.CreateCompatibleDC(&graphicsDC);
	  memBMP.CreateCompatibleBitmap(&graphicsDC,xMax,yMax);
	  memDC.SelectObject(&memBMP);
	//---------------------------------------

//Define some colours
	COLORREF red=RGB(255,0,0),green=RGB(0,255,0),
			 colour=RGB(255,0,0),pink=RGB(255,200,200),
			 DarkBlue=RGB(0,0,255),LightBlue=RGB(175,175,255),
			 White=RGB(255,255,255),Black=RGB(0,0,0),Grey1=RGB(128,128,128);
	COLORREF choiceColour;

//Define the pens 
	CPen penRed(PS_SOLID,1,red);
	CPen penGrey1(PS_SOLID,1,Grey1);

//Select the pen into the DC (Device Context)
//	CPen *pOldPen=NULL;
//	pOldPen=memDC.SelectObject(&penRed);

//Print the loop variable
	CString myString;
	CString myString2;
	myString.Format("TIME %f",angiotime);
	myString2.Format("FLOW TIME %f",flowTime);
	//myString.Format("ITERATIONS %i",IterationNumber);
	memDC.TextOut(475,20,myString);//memDC.TextOut(520,24,myString);
	memDC.TextOut(275,20,myString2);
  
//Set a fixed viewing angle for now
	double dAngle=PI/4.0;

//Rescale picture to fit in same window of dimension networkWidth
	if (m_nz!=1)	{networkWidth=(int)(1.15*(networkWidth/max(1.0+cos(dAngle),1.0+sin(dAngle))));}

//If 3D plotting, then calculate offset for each layer
	int iOffset=0;
	if (m_nz!=1)	{iOffset=int(networkWidth/m_nz/1.5);}

//-----Draw Wound Margin if applicable-----------
	memDC.SelectObject(&penGrey1);
 	CBrush brGrey(RGB(50,50,50));

/*	if (b_UU_wound_Model)	//draw perimeter
	{
			memDC.SelectObject(&brGrey);

			memDC.Ellipse(
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)-i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)-i_UU_WoundRad*networkWidth/m_ny,
xMin+(int)deltaX+(int)(iCentre*networkWidth/m_nx)+i_UU_WoundRad*networkWidth/m_nx,
yMin+(int)deltaY+(int)(iCentre*networkWidth/m_ny)+i_UU_WoundRad*networkWidth/m_ny
						  );
	}
*/
//---------------------------------------
	int x1,x2,y1,y2;

//-------------------------
//  runningMDFConcMAX=1.0e-7;
//-------------------------

	if (m_nz==1)
	{
		//Draw the network
		for (int k=25;k<=25;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
			
					//memDC.SelectObject(&penBlack);
					choiceColour=Black;

/*					if		(vTAFConc[i-1][j-1][k-1]> 0.001*runningTAFConcMAX &&  
								vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX) {choiceColour=DarkBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&
								vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX) {choiceColour=LightBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&
								vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX) {choiceColour=White;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&
								vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {choiceColour=pink;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX) {choiceColour=red;}
*/
					if		(vTAFConc[i-1][j-1][k-1]> 0.001 &&  
								vTAFConc[i-1][j-1][k-1]<=0.2) {choiceColour=DarkBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.2 &&
								vTAFConc[i-1][j-1][k-1]<=0.4) {choiceColour=LightBlue;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.4 &&
								vTAFConc[i-1][j-1][k-1]<=0.6) {choiceColour=White;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
								vTAFConc[i-1][j-1][k-1]<=0.8) {choiceColour=pink;}
					else if (vTAFConc[i-1][j-1][k-1]> 0.8) {choiceColour=red;}
					
					x1=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)((XPOS[i][j][k]-1)*networkWidth/m_nx);
					y1=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)(YPOS[i][j][k]*networkWidth/m_ny);
					x2=(int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)(XPOS[i][j][k]*networkWidth/m_nx);
					y2=(int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)((YPOS[i][j][k]-1)*networkWidth/m_ny);

					memDC.FillSolidRect((int)x1,(int)y1,(int)( fabs(double(x1-x2)) ),(int)( fabs(double(y1-y2)+1) ),choiceColour);

//I've added the +1 just to stop black lines on graphics
	/*
	// draw colour segment in the x-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+((int)XPOS[i][j][k]-1)*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);

	// draw colour segment in the y-direction
	memDC.MoveTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+((int)YPOS[i][j][k]-1)*networkWidth/m_ny);
	memDC.LineTo((int)((k-1)*iOffset*cos(dAngle))+xMin+(int)deltaX+(int)XPOS[i][j][k]*networkWidth/m_nx,
					  (int)((k-1)*iOffset*sin(dAngle))+yMin+(int)deltaY+(int)YPOS[i][j][k]*networkWidth/m_ny);
	*/
		}}}
	}

	else
	{
		//Draw the network
		for (int k=1;k<=m_nz;k++)
		{	for (int j=1;j<=m_ny;j++)
			{	for (int i=1;i<=m_nx;i++)
				{
					if (vTAFConc[i-1][j-1][k-1]>0.001)//*runningTAFConcMAX)
					{
/*						if		(vTAFConc[i-1][j-1][k-1]> 0.001*runningTAFConcMAX &&  
									vTAFConc[i-1][j-1][k-1]<=0.2*runningTAFConcMAX) {choiceColour=DarkBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.2*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.4*runningTAFConcMAX) {choiceColour=LightBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.4*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.6*runningTAFConcMAX) {choiceColour=White;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.6*runningTAFConcMAX &&
									vTAFConc[i-1][j-1][k-1]<=0.8*runningTAFConcMAX) {choiceColour=pink;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.8*runningTAFConcMAX) {choiceColour=red;}
*/
						if		(vTAFConc[i-1][j-1][k-1]> 0.001 &&  
									vTAFConc[i-1][j-1][k-1]<=0.2) {choiceColour=DarkBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.2 &&
									vTAFConc[i-1][j-1][k-1]<=0.4) {choiceColour=LightBlue;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.4 &&
									vTAFConc[i-1][j-1][k-1]<=0.6) {choiceColour=White;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.6 &&
									vTAFConc[i-1][j-1][k-1]<=0.8) {choiceColour=pink;}
						else if (vTAFConc[i-1][j-1][k-1]> 0.8) {choiceColour=red;}

						CBrush brushChoiceColour(choiceColour);
						memDC.SelectObject(&brushChoiceColour);

//-----------------------------------------------

						CPoint cubePts[5];	

						//---Top Face------------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Side Face-----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)-0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)-0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();

//-----------------------------------------------

						//---Front Face----------
						cubePts[0].x=cubePts[4].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].x=xMin+int(deltaX)+int((double(i)+0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].x=xMin+int(deltaX)+int((double(i)-0.5)*double(networkWidth)/double(m_nx))+int((double(k)+0.5)*iOffset*sin(dAngle));

						cubePts[0].y=cubePts[4].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[1].y=yMin+int(deltaY)+int((double(j)-0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[2].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));
						cubePts[3].y=yMin+int(deltaY)+int((double(j)+0.5)*double(networkWidth)/double(m_ny))+int((double(k)+0.5)*iOffset*sin(dAngle));

						memDC.BeginPath();
						memDC.Polygon(cubePts,5);
						memDC.EndPath();
						memDC.FillPath();//memDC.StrokeAndFillPath();
					}
		}}}
	}


//---- draw the frame for 2D networks ------------
// A---B
// |   |
// D---C
 if (m_nz==1)
 {	
	memDC.SelectObject(&penGrey1);	

  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+networkWidth+networkWidth/m_nx,yMin+(int)deltaY+networkWidth);//(C)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(D)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
 }

 //---- draw the frame for 3D networks ------------
 if (m_nz!=1)
 {	
	memDC.SelectObject(&penGrey1);	

	//      A-------B
	//		|\		|\
	//		|  \    |  \
	//		|   C-------D
	//		A'  |   B'  |
    //		 \	|       |
    //		  \ |       |
	//			C'------D'

	//-------- AB ----------
  	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//-------- CD ----------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	//-------- AC ----------
	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(C)
	//-------- BD ----------
	memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY);//(B)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle)));//(D)
	//-------- A'B' --------
  	//memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- C'D' --------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- A'C' --------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- B'D' --------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
	//			 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
	//-------- AA' ---------
 	memDC.MoveTo(xMin+(int)deltaX,yMin+(int)deltaY);//(A)
	memDC.LineTo(xMin+(int)deltaX,yMin+(int)deltaY+networkWidth);//(A')
	//-------- BB' ---------
	//memDC.MoveTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY); //(B)
	//memDC.LineTo(xMin+(int)deltaX+networkWidth,yMin+(int)deltaY+networkWidth); //(B')
	//-------- CC' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(C)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle)),
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(C')
	//-------- DD' ---------
	memDC.MoveTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))); //(D)
	memDC.LineTo(xMin+(int)deltaX+(int)(m_nz*iOffset*sin(dAngle))+networkWidth,
				 yMin+(int)deltaY+(int)(m_nz*iOffset*cos(dAngle))+networkWidth); //(D')
 }
//----- MODIF A.S. ---------------------------------------		
   CClientDC graphics(this);    
   graphics.BitBlt(xMin,yMin,xMax,yMax,&memDC,xMin,yMin,SRCCOPY);
//--------------------------------------------------------

//Finally, restore old pen
//	memDC.SelectObject(pOldPen);
}

//*********************************************************

//=============================================================================
void CAngioNetDlg::BoneClustering(int *Iclus,bool bBoneLabel)
//=============================================================================
{
//----Initialisations-----------------
	int ntemp,newlabel,labtemp;
//---------------------------------------------------
	int* NP=NULL;
	NP=new int[(m_nx+1)*m_ny*m_nz];	//dynamic array of cluster labels
	
	for (int nn=1; nn<=(m_nx+1)*m_ny*m_nz; nn++)
	{
		Iclus[nn-1]=1000000;
		NP[nn-1]=1000000;
	}
//---------------------------------------------------
	int* Iwwork=NULL;
	Iwwork=new int[6];	//dynamic array of cluster labels
	int* Nwork=NULL;
	Nwork=new int[6];	//dynamic array of cluster labels
	
	for (int nn=1; nn<=6; nn++)
	{
		Iwwork[nn-1]=1000000;
		Nwork[nn-1]=1000000;
	}
//---------------------------------------------------
//-------------End Initialisations--------------------


//-----------------------------------------------------
	for (int nnnn=1; nnnn<=4; nnnn++)	//nnnn Loop *****
	{
//.....................................................
		ntemp=1;

		for (int k=1;k<=m_nz;k++)
		{
			for (int j=1;j<=m_ny;j++)
			{
				for (int i=1;i<=m_nx+1;i++)
				{
//----------------------------------------------
					if (bBoneTissue[i-1][j-1][k-1]==bBoneLabel)
					{
						NeighNode(i,j,k,Iclus,Iwwork,Nwork);
						newlabel=ntemp;
//----------------------------------------------
						for (int nn=1; nn<=6; nn++)
						{
							if  (Nwork[nn-1]!=1000000)
							{
								labtemp=min(NP[Nwork[nn-1]-1],ntemp);
								if (labtemp<newlabel) {newlabel=labtemp;}
							}
						}
//----------------------------------------------
						Iclus[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]=newlabel;
						NP[Iclus[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]-1]=newlabel;
//----------------------------------------------
						for (int nn=1; nn<=6; nn++)
						{
							if  (Nwork[nn-1]!=1000000)
							{
								NP[NP[Nwork[nn-1]-1]-1]=newlabel;
								NP[Nwork[nn-1]-1]=newlabel;
							}
						}
//----------------------------------------------				
						ntemp+=1;
//----------------------------------------------				
					}	//end if condition X

				}	//end i loop
			}	//end j loop
		}		//end k loop
//-----------------------------------------------

	}	//end nnnn loop *****
//--------------------------------------------------

//-----------------------------------------------
	int improp;

	for (improp=1; improp<=(m_nx+1)*m_ny*m_nz; improp++)
	{
		Improper(NP,improp);
	}
//-----------------------------------------------
	RelabelNode(Iclus,NP,bBoneLabel);
//-----------------------------------------------
	delete [] NP;
	delete [] Iwwork;
	delete [] Nwork;
//----------------------------------------------------

//----------output file for debugging-------------
	ofstream outfile4("clusters.txt");
	for (int k=1;k<=m_nz;k++)
	{
		for (int j=1;j<=m_ny;j++)
		{
			for (int i=1;i<=m_nx+1;i++)
			{
				outfile4<<"("<<i<<", "<<j<<", "<<k<<")"<<"\t"<<bBoneTissue[i-1][j-1][k-1]<<"\t"<<Iclus[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1] << endl;
			}
		}
	}
	
//----------------------------------------------------
}

//*********************************************************
//==================================================================================
void CAngioNetDlg::NeighNode(int i,int j,int k,int* pIclus,int* pIwork,int* pNwork)
//==================================================================================
{
	//-----2D case-------------------
	if (m_nz==1)	//2D
	{
		if (i==1)
		{
			if (j==1)	//top LH corner block
			{
				pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
				pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
				pIwork[3-1]=0;										//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}

			else if (j==m_ny)	//bottom LH corner block
			{
				pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
				pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=0;										//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}

			else	//other LH edge blocks
			{
				pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
				pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}
		}

//---------------------------------------

		if (i==m_nx+1)
		{
			if (j==1)	//top RH corner block
			{
				pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
				pIwork[2-1]=0;										//Iwork(2)
				pIwork[3-1]=0;										//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}

			else if (j==m_ny)	//bottom RH corner block
			{
				pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
				pIwork[2-1]=0;										//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=0;										//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}

			else	//other RH edge blocks
			{
				pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
				pIwork[2-1]=0;										//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}

		}
//---------------------------------------

		if (j==1 && i!=1 && i!=m_nx+1)	//top edge blocks (excluding corner blocks already done)
		{
			pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
			pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
			pIwork[3-1]=0;										//Iwork(3)
			pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
			pIwork[5-1]=0;										//Iwork(5)
			pIwork[6-1]=0;										//Iwork(6)
		}

//---------------------------------------

		if (j==m_ny && i!=1 && i!=m_nx+1)	//bottom edge blocks (excluding corner blocks already done)
		{
			pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
			pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
			pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
			pIwork[4-1]=0;										//Iwork(4)
			pIwork[5-1]=0;										//Iwork(5)
			pIwork[6-1]=0;										//Iwork(6)
		}

//---------------------------------------

		if (i!=1 && i!=m_nx+1 && j!=1 && j!=m_ny)		//internal blocks
		{
			pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
			pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
			pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
			pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
			pIwork[5-1]=0;										//Iwork(5)
			pIwork[6-1]=0;										//Iwork(6)
		}

//---------------------------------------

	}	//end 2D
//--------------------------------

//===============================

//-----3D case-------------------
	if (m_nz!=1)
	{

//------LH FACE----------------------------------

		if (i==1)
		{
			if (j==1)	
			{
				if (k==1) //farside, top LH corner block
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz) //nearside, top LH corner block
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else	//top LH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}

			else if (j==m_ny)
			{
				if (k==1) //farside, bottom LH corner block
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz) //nearside, bottom LH corner block
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else	//bottom LH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}

			else
			{
				if (k==1) //farside, LH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz) //nearside, LH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else	//LH face blocks (excluding edges already done)
				{
					pIwork[1-1]=0;										//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}
		}

//---END LH FACE---------------------------------

//---RH FACE-------------------------------------

		if (i==m_nx+1)
		{
			if (j==1)	
			{
				if (k==1) //farside, top RH corner block
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz) //nearside, top RH corner block
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else	//top RH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}

			else if (j==m_ny)
			{
				if (k==1) //farside, bottom RH corner block
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz) //nearside, bottom RH corner block
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else	//bottom RH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}

			else
			{
				if (k==1) //farside, RH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz) //nearside, RH edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else	//RH face blocks (excluding edges already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=0;										//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}
		}

//---END RH FACE---------------------------------

//---TOP FACE------------------------------------

		if (j==1)
		{
			if (i!=1 && i!=m_nx+1)
			{
				if (k==1)	//farside top edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz)	//nearside top edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else    //top face blocks (excluding edges already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=0;										//Iwork(3)
					pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}
		}

//---END TOP FACE--------------------------------

//---BOTTOM FACE------------------------------------

		if (j==m_ny)
		{
			if (i!=1 && i!=m_nx+1)
			{
				if (k==1)	//farside bottom edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=0;										//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}

				else if (k==m_nz)	//nearside bottom edge blocks (excluding corners already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=0;										//Iwork(6)
				}

				else    //bottom face blocks (excluding edges already done)
				{
					pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
					pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
					pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
					pIwork[4-1]=0;										//Iwork(4)
					pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
					pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
				}
			}
		}

//---END BOTTOM FACE-----------------------------

		if (i!=1 && i!=m_nx+1 && j!=1 && j!=m_ny)
		{

//---FARSIDE FACE--------------------------------

			if (k==1)	//farside face blocks (excluding edges already done)
			{
				pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
				pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=0;										//Iwork(5)
				pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
			}

//---END FARSIDE FACE----------------------------

//---NEARSIDE FACE-------------------------------

			else if (k==m_nz)	//nearside face blocks (excluding edges already done)
			{
				pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
				pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
				pIwork[6-1]=0;										//Iwork(6)
			}

//---END NEARSIDE FACE---------------------------

//---INTERNAL BLOCKS-----------------------------

			else
			{
				pIwork[1-1]=i-1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(1) [FORTRAN]
				pIwork[2-1]=i+1+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(2)
				pIwork[3-1]=i+(j-1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(3)
				pIwork[4-1]=i+(j+1-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny;	//Iwork(4)
				pIwork[5-1]=i+(j-1)*(m_nx+1)+(k-1-1)*(m_nx+1)*m_ny;	//Iwork(5)
				pIwork[6-1]=i+(j-1)*(m_nx+1)+(k+1-1)*(m_nx+1)*m_ny;	//Iwork(6)
			}

//---END INTERNAL BLOCKS-------------------------

		}

	}	//end 3D

//-----------------------------------------------
//-----------------------------------------------

//Clusters connected to each node--
	if  (pIwork[1-1]!=0)	{pNwork[1-1]=pIclus[pIwork[1-1]-1];}			//Nwork(1)=Iclus(Iwork(1))
	else					{pNwork[1-1]=1000000;}

	if(pIwork[2-1]!=0)		{pNwork[2-1]=pIclus[pIwork[2-1]-1];}			//Nwork(2)=
	else					{pNwork[2-1]=1000000;}

	if(pIwork[3-1]!=0)		{pNwork[3-1]=pIclus[pIwork[3-1]-1];}			//Nwork(3)=
	else					{pNwork[3-1]=1000000;}

	if(pIwork[4-1]!=0)		{pNwork[4-1]=pIclus[pIwork[4-1]-1];}			//Nwork(4)=
	else					{pNwork[4-1]=1000000;}

	if(pIwork[5-1]!=0)		{pNwork[5-1]=pIclus[pIwork[5-1]-1];}			//Nwork(5)=
	else					{pNwork[5-1]=1000000;}

	if(pIwork[6-1]!=0)		{pNwork[6-1]=pIclus[pIwork[6-1]-1];}			//Nwork(6)=
	else					{pNwork[6-1]=1000000;}	
	
//-----------------------------------------------
}

//*********************************************************
//=======================================================================================
void CAngioNetDlg::RelabelNode(int *Iclus, int *NP, bool bBoneLabel)
//=======================================================================================
{
	int Nb;

	for (int k=1;k<=m_nz;k++)
	{
		for (int j=1;j<=m_ny;j++)
		{
			for (int i=1;i<=m_nx+1;i++)
			{
				if (bBoneTissue[i-1][j-1][k-1]==bBoneLabel)
				{
					Nb=Iclus[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1];
					Nb=NP[Nb-1];
					Iclus[i+(j-1)*(m_nx+1)+(k-1)*(m_nx+1)*m_ny-1]=Nb;
				}
			}
		}
	}
//------------------------
}

//*********************************************************
//===============================================
void CAngioNetDlg::PutInArterioles_Bone(void)
//===============================================
{//Populate domain with parallel PVs on outer x-y and x-z faces of scaffold

	int i,j,k,nbx;

	double yPV_Spacing_Top=120.0;		//microns
	double yPV_Spacing_Bottom=120.0;	//microns
	double zPV_Spacing_Back=120.0;		//microns
	double zPV_Spacing_Front=120.0;		//microns

	num_yPVs_Top=int(double(m_nz)/(yPV_Spacing_Top/bondLength/1.0e6));
	num_yPVs_Bottom=int(double(m_nz)/(yPV_Spacing_Bottom/bondLength/1.0e6));
	num_zPVs_Back=int(double(m_ny)/(zPV_Spacing_Back/bondLength/1.0e6));
	num_zPVs_Front=int(double(m_ny)/(zPV_Spacing_Front/bondLength/1.0e6));


//---Insert Top PVs---
	j=1;

	for (int nCount=1;nCount<=num_yPVs_Top;nCount++)
	{	for (i=1;i<=m_nx+1;i++)
		{
			double kvalue=double(nCount*m_nz)/double(num_yPVs_Top+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}
	}

//-----------------------------------------------

//---Insert Bottom PVs---
	j=m_ny-1;

	for (int nCount=1;nCount<=num_yPVs_Bottom;nCount++)
	{	for (i=1;i<=m_nx+1;i++)
		{
			double kvalue=double(nCount*m_nz)/double(num_yPVs_Bottom+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}
	}

//-----------------------------------------------

//---Insert Back PVs---
	k=1;

	for (int nCount=1;nCount<=num_zPVs_Back;nCount++)
	{	for (i=1;i<=m_nx+1;i++)
		{
			double jvalue=double(nCount*m_ny)/double(num_zPVs_Back+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}
	}

//-----------------------------------------------

//---Insert Front PVs---
	k=m_nz-1;

	for (int nCount=1;nCount<=num_zPVs_Front;nCount++)
	{	for (i=1;i<=m_nx+1;i++)
		{
			double jvalue=double(nCount*m_ny)/double(num_zPVs_Front+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}
	}

//-----------------------------------------------

//---Insert Inlet & Outlet PV Sprouts---

//---Inlets---
	i=1;

	for (int nCount_y=2;nCount_y<=num_yPVs_Top-1;nCount_y++)
	{	for (int nCount_z=2;nCount_z<=num_zPVs_Back-1;nCount_z++)
		{
			double jvalue=double(nCount_z*m_ny)/double(num_zPVs_Back+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			double kvalue=double(nCount_y*m_nz)/double(num_yPVs_Top+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}
	}

	i=2;

	for (int nCount_y=2;nCount_y<=num_yPVs_Top-1;nCount_y++)
	{	for (int nCount_z=2;nCount_z<=num_zPVs_Back-1;nCount_z++)
		{
			double jvalue=double(nCount_z*m_ny)/double(num_zPVs_Back+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			double kvalue=double(nCount_y*m_nz)/double(num_yPVs_Top+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
			pSprout[nbx-1]=1;
			poleSprout[nbx-1]=true;
		}
	}

//---Outlets---
	i=m_nx+1;

	for (int nCount_y=2;nCount_y<=num_yPVs_Top-1;nCount_y++)
	{	for (int nCount_z=2;nCount_z<=num_zPVs_Back-1;nCount_z++)
		{
			double jvalue=double(nCount_z*m_ny)/double(num_zPVs_Back+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			double kvalue=double(nCount_y*m_nz)/double(num_yPVs_Top+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
		}
	}

	i=m_nx;

	for (int nCount_y=2;nCount_y<=num_yPVs_Top-1;nCount_y++)
	{	for (int nCount_z=2;nCount_z<=num_zPVs_Back-1;nCount_z++)
		{
			double jvalue=double(nCount_z*m_ny)/double(num_zPVs_Back+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			double kvalue=double(nCount_y*m_nz)/double(num_yPVs_Top+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			nbx=LabX(i,j,k);
			pFluid[nbx-1]=10;
			pPericyteDensity[nbx-1]=1.0;
			pArterialVenousID[nbx-1]=1;
			XBR[i-1][j-1][k-1]=3.0e-6;
			pSprout[nbx-1]=1;
			poleSprout[nbx-1]=false;
		}
	}

}

//*********************************************************
//====================================================
void CAngioNetDlg::AssignInitialSprouts_Bone(void)
//====================================================
{
//---No sprouts initially---
//	for (int nn=1;nn<=Nbond;nn++) {pSprout[nn-1]=0;}

//---Now assign sprout tips---
	TAF_Trigger=-1.0;//0.4*TAFConcMAX;//0.34;	// changed by Mike 10/08

	int first_sprout_pos=5;//10;//	//ideal position for first sprout (equal to delX for original set-up)
	int delX=7;//20;//5;			//(changed by Mike 10/08) spacing of sprouts in no. of bonds

	int nSprout_per_PV=((m_nx-first_sprout_pos)/delX)+1;	//no. of potential sprouts per parent vessel

//---Put in sprouts on Top PVs---
	int k;
	int j=2;

	for (int nCount=1;nCount<=num_yPVs_Top;nCount++)
	{	for (int nSproutCount=1; nSproutCount<=nSprout_per_PV; nSproutCount++)
		{
			double kvalue=double(nCount*m_nz)/double(num_yPVs_Top+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

			if	(vTAFConc[icoord-1][j-1][k-1]>TAF_Trigger)
			{
				pFluid[LabY(icoord,j,k)-1]=10;
				pSprout[LabY(icoord,j,k)-1]=1;
				poleSprout[LabY(icoord,j,k)-1]=true;
				pPericyteDensity[LabY(icoord,j,k)-1]=PericyteDensityInit;
				pArterialVenousID[LabY(icoord,j,k)-1]=1;
				YBR[icoord-1][j-1][k-1]=3.0e-6;
			}
		}	//end for nSproutCount
	}
//-----------------------------------------------

//---Put in sprouts on Bottom PVs---
	j=m_ny-1;

	for (int nCount=1;nCount<=num_yPVs_Bottom;nCount++)
	{	for (int nSproutCount=1; nSproutCount<=nSprout_per_PV; nSproutCount++)
		{
			double kvalue=double(nCount*m_nz)/double(num_yPVs_Bottom+1);

			if ((kvalue-floor(kvalue))<0.5)	{k=int(floor(kvalue));}	else {k=int(ceil(kvalue));}

			int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

			if	(vTAFConc[icoord-1][j-1][k-1]>TAF_Trigger)
			{
				pFluid[LabY(icoord,j,k)-1]=10;
				pSprout[LabY(icoord,j,k)-1]=1;
				poleSprout[LabY(icoord,j,k)-1]=false;
				pPericyteDensity[LabY(icoord,j,k)-1]=PericyteDensityInit;
				pArterialVenousID[LabY(icoord,j,k)-1]=1;
				YBR[icoord-1][j-1][k-1]=3.0e-6;
			}
		}	//end for nSproutCount
	}
//-----------------------------------------------

//---Put in sprouts on Back PVs---
	k=2;
	
	for (int nCount=1;nCount<=num_zPVs_Back;nCount++)
	{	for (int nSproutCount=1; nSproutCount<=nSprout_per_PV; nSproutCount++)
		{
			double jvalue=double(nCount*m_ny)/double(num_zPVs_Back+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

			if	(vTAFConc[icoord-1][j-1][k-1]>TAF_Trigger)
			{
				pFluid[LabZ(icoord,j,k)-1]=10;
				pSprout[LabZ(icoord,j,k)-1]=1;
				poleSprout[LabZ(icoord,j,k)-1]=true;
				pPericyteDensity[LabZ(icoord,j,k)-1]=PericyteDensityInit;
				pArterialVenousID[LabZ(icoord,j,k)-1]=1;
				ZBR[icoord-1][j-1][k-1]=3.0e-6;
			}
		}	//end for nSproutCount
	}
//-----------------------------------------------

//---Put in sprouts on Front PVs---
	k=m_nz-1;
	
	for (int nCount=1;nCount<=num_zPVs_Front;nCount++)
	{	for (int nSproutCount=1; nSproutCount<=nSprout_per_PV; nSproutCount++)
		{
			double jvalue=double(nCount*m_ny)/double(num_zPVs_Front+1);

			if ((jvalue-floor(jvalue))<0.5)	{j=int(floor(jvalue));}	else {j=int(ceil(jvalue));}

			int icoord=first_sprout_pos+(nSproutCount-1)*delX;	//step along vessel

			if	(vTAFConc[icoord-1][j-1][k-1]>TAF_Trigger)
			{
				pFluid[LabZ(icoord,j,k)-1]=10;
				pSprout[LabZ(icoord,j,k)-1]=1;
				poleSprout[LabZ(icoord,j,k)-1]=false;
				pPericyteDensity[LabZ(icoord,j,k)-1]=PericyteDensityInit;
				pArterialVenousID[LabZ(icoord,j,k)-1]=1;
				ZBR[icoord-1][j-1][k-1]=3.0e-6;
			}
		}	//end for nSproutCount
	}
//-----------------------------------------------

}

